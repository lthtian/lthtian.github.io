<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective C++ 条款8 析构函数的异常管理</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 : 别让异常逃离析构函数"></a>条款08 : 别让异常逃离析构函数</h2><blockquote><p>日常编程中，常见异常通常由以下原因引发：</p><ol><li><strong>资源管理不当</strong>（如内存泄漏, 文件操作, 连接或断开连接失败）。</li><li><strong>边界和合法性检查不足</strong>（如数组越界、除以零）。</li><li><strong>并发编程问题</strong>（如死锁、数据竞争）。</li><li><strong>类型不匹配或错误的操作</strong>。</li></ol></blockquote><p>本条款主要讨论的是析构函数的异常管理, 为什么会不希望异常逃离析构函数, 因为<strong>析构函数是一个必须执行且有可能失败的函数</strong>, 因为内存泄漏, 文件操作, 连接或断开连接失败等资源管理行为的错误都是很难避免的, 而且由于<strong>析构函数是递归式调用并且可能一次性销毁大量结构</strong>, 同时产生大量异常的概率就提高了, 书中指出, <strong>如果同时存在多个异常, 程序不是结束执行就是导致不明确行为</strong>, 因此对于析构函数的异常管理在所难免.</p><hr><p>书中举出了一个数据库连接的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;  <span class="hljs-comment">// 数据库连接类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回创建出来的静态数据库连接.                                     </span><br>  ...                                      <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 调用此函数关闭与数据库的连接, 这里有抛出异常的隐患         </span><br>&#125;;         <br></code></pre></td></tr></table></figure><p>我们经常会设计一个资源管理类来控制数据库的连接 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;                          <span class="hljs-comment">// 数据库连接管理类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>   db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 调用析构函数时断开数据库连接</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  DBConnection db;   <span class="hljs-comment">// RAII风格, 由DBConn管理DBConnection, 离开作用域自动触发DBConn的析构函数断开连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以写出以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ...<br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// 直接建立DBConnection对象并交由DBConn对象dbc管理</span><br>    ... <span class="hljs-comment">// 进行数据库的CURD, 离开作用域自动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了上面例子的基础, 我们来思考一下如何避免异常抛出吧.</p><p>站在<code>DBConn析构函数</code>的角度, 书中给出了两个一般的方法 : </p><ol><li><p>如果close()抛出异常就利用abort()结束程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>   std::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 直接结束程序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接吞下该异常.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>      <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>      <span class="hljs-comment">// 不做处理, 直接吞下</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两个方法其实都是保底方法, 一个是草率结束进程, 一个是吞掉异常防止扩散, 但其实<code>DBConn析构函数</code>也就能做这么多了.</p><hr><p>现在的问题是<strong>没有办法对”导致close抛出异常”的情况做出反应</strong>, 问题核心在<code>close()</code>函数被<code>DBConn析构函数</code>掌握, 只能其自己管理, 上一层无法干预. 那么由此我们可以将close()函数的使用权上交, 也就是让上一层用户有权决定处理<code>close()</code>报错的方式. </p><p>较佳策略是<strong>重新设计DBConn接口, 使客户有机会对可能出现的问题作出反应</strong>. </p><p>具体做法如下 : </p><ol><li><code>DBConn</code>自己也提供一个close接口, 内部封装上<code>DBConnection</code>的<code>close()</code>.</li><li><code>DBConn</code>自己对<code>DBConnection</code>的<code>close()</code>是否已经触发进行追踪管理, 如果到最后客户都没有自行close成功, 由<code>DBConn析构函数</code>自行完成close的任务.</li></ol><p>我们来看书中给出的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 提供给上层用户的close函数</span></span><br><span class="hljs-function">  </span>&#123;                                       <br>    db.<span class="hljs-built_in">close</span>();<br>    closed = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>      <span class="hljs-comment">// 如果到最后都没有触发close, 就会回到析构函数调用close的老路</span><br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>   <span class="hljs-keyword">try</span> &#123;                                           <br>     db.<span class="hljs-built_in">close</span>();                           <br>   &#125;<br>   <span class="hljs-built_in">catch</span> (...) &#123;                                    <br>     <span class="hljs-comment">// 记录日志, 记录对close的调用失败  </span><br>     ...                                   <span class="hljs-comment">// 直接结束 或 吞下异常</span><br>   &#125;<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  DBConnection db;<br>  <span class="hljs-type">bool</span> closed;<span class="hljs-comment">// 用布尔变量closed来对close()进行追踪管理</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是客户便可做出如下操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 客户自己在认为合适的地方调用close()结束连接, 并用try-catch语句尝试捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能会抛出异常，如果关闭失败</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 客户端捕获从 close() 抛出的异常</span><br>        <span class="hljs-comment">// ... 出现异常时的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只考虑数据库断开连接的场景, 我们可行的具体操作可以是重试关闭或执行数据库回滚, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!success &amp;&amp; attempts &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;正在尝试断开数据库连接, 次数 :  &quot;</span> &lt;&lt; ++attempts &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;已经尝试三次断开数据库连接, 但都出现异常, 断开失败&quot;</span> &lt;&lt; std::endl;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;进行补偿操作, 回滚数据库&quot;</span> &lt;&lt; std::endl;<br>        dbConn.<span class="hljs-built_in">rollback</span>(); <span class="hljs-comment">// 内部调用数据库的回滚函数</span><br>&#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来捋一下流程, 先是客户需要考虑何时调用<code>close()</code>并写出应对异常的代码, 实际运行时如果没有异常就万事大吉, 有异常就触发客户的处理逻辑, 最后析构函数检查客户是否真的成功调用了<code>close()</code>, 如果还是没有调用, 就自己调用, 自己调用如果还出错, 就直接结束程序或吞掉异常.</p><p>至此我们将调用<code>close()</code>的责任从<code>DBConn析构函数</code>的手上移交到了使用<code>DBConn对象</code>的客户手上, 可以更好地避免异常逃离析构函数. 有人可能这样会加大客户的操作负担, 但是根据我们先前的分析, 只有客户才能有办法对”导致close抛出异常”的情况做出反应, 这样做是给客户提供一个根据实际情况回避异常的机会, 至于是否需要就看客户自己了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>析构函数绝对不要吐出异常. 如果分析出一个析构函数有抛出异常的风险, 应当先把异常捕捉下来, 看是否结束程序或吞下异常.</li><li>给客户提供自己处理异常的机会, 让客户可以根据实际情况对异常做出反应.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款7 virtual析构函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 : 为多态基类声明virtual析构函数"></a>条款07 : 为多态基类声明virtual析构函数</h2><blockquote><p>说到多态, 我们应当非常了解其运行时绑定的机制, 简单来说就是我们可以在任何时候根据用户的需求将基类绑定为不同的派生类, 用相同的操作实现不同的效果, 这其中virtual函数起到了至关重要的作用, 每一个含有虚函数的类都会维护一个虚表, 以此实现基类到派生类的动态绑定. </p></blockquote><p>这里书中提到了一个重要又经常发生的问题 : <strong>如果<code>drived class(派生类)</code>对象经由一个<code>base class(基类)</code>指针被删除, 而该base class带着一个non-virtual析构函数, 那么结果是未定义的</strong>.</p><p>这里的结果未定义, 一般情况下是只会调用<code>base class</code>自己的析构函数, 销毁的是该对象的<code>base class</code>部分, 而<code>drived class</code>部分却没有被销毁, 就造成了诡异的”局部销毁”现象.</p><p>而解决这个问题的方法就是 : <strong>给 base class 一个 virtual析构函数</strong>.</p><p>先回忆一下有关派生类析构函数的知识 : <strong>派生类的析构函数会默认先调用上一层的析构函数</strong>. 也就是说是从当前派生类的析构函数开始, 递归式调用上一层的析构函数, 直到到达最深层的基类. </p><p>再思考上面的话, 当<code>base class</code>指针动态绑定<code>drived class</code>对象时, 如果我们想删除这个对象时, 正确的结果应该是调用动态绑定的<code>drived class</code>的析构函数, 这样才能正确地全部销毁, 而想这样调用就只能依赖于虚函数来实现, 也就是我们需要把base class的析构函数设置为virtual, 删除时就会根据虚表找到当前动态类型绑定的析构函数.</p><p>以下是书中的给出的样例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TimeKeeper</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>  ...<br>&#125;;<br>TimeKeeper *ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br>...<br><span class="hljs-keyword">delete</span> ptk;                         <span class="hljs-comment">// 现在, 行为正确</span><br></code></pre></td></tr></table></figure><p>书中告诉我们 : </p><ul><li><strong>virtual 函数的目的是允许 derived class 的实现得以客制化</strong>.</li><li><strong>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数</strong>.</li></ul><hr><p>当然, 无端地将所有的 classes 的析构函数声明为 virtual, 就像从未声明他们为 virtual 一样, 都是错误的.</p><p>如果 class 不含 virtual 函数, 通常表示它并不意图被用作一个 base class, 也就完全不需要声明virtual析构函数.</p><p>我们知道使用虚函数是要带来额外的花销的, 包括维护虚表, 虚指针表等一系列繁杂的动作, 会带来时间成本和空间成本, 而且书中还提到由于对象大小的增加会影响其可移植性.</p><p>所以请记住一个心得 : <strong>只有当 class 内含至少一个 virtual 函数, 才为他声明 virtual析构函数</strong>.</p><hr><p><strong>请不要企图继承我们神圣的STL容器</strong>, 正因为考虑到上面虚函数有关时间, 空间, 可移植性的问题, STL容器并没有考虑被继承的情况, 它们的析构函数都是 non-virtual 的!</p><hr><p>这里书中提到了一个构建抽象类的小窍门 : </p><p>我们一般不希望抽象类被实体化, 它只提供一些接口 : </p><ol><li>被声明为<code>纯虚函数</code>的接口所有派生类必须重写.</li><li>被声明为<code>虚函数</code>的接口提供默认行为同时也允许派生类重写.</li><li>被声明为<code>普通函数</code>的接口可以被所有派生类继承, 使用.</li></ol><p>我们在设计一个抽象类时, 也许并不希望有什么类是必须重写的, 就是不希望有纯虚函数, 只需要提供虚函数和普通函数即可, 然而一个类想要不被实体化, <strong>必须存在一个纯虚函数</strong>, 那么哪里找一个纯虚函数呢? </p><p><strong>如果你拿不定主意, 选析构函数就好了!</strong> 毕竟抽象类一定有多态的需求, 只要有多态的需求, 析构函数就必须是 virtual 的, 已经是虚函数了, 变成纯虚函数也没什么问题, 而且当我们的派生类没有新增动态资源时, 就算我们不手动重写析构函数也没关系! 因为编译器会自动帮我们生成! 这样既满足了必须有一个纯虚函数的要求, 又不需要我们顾及纯虚函数必须重写的问题, 多么完美 !</p><p>不过有一个小细节必须要注意, 所有派生类析构函数最后都会调用到最底层基类的析构函数, 所以我们<strong>需要对纯虚析构函数进行定义</strong>!</p><p>纯虚析构函数真的能定义吗? 答案是能的, 虽然大多数情况下纯虚函数都不用定义, 但是真要定义还是可以的.</p><p>以下是书中的示例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br>AWOV::~<span class="hljs-built_in">AWOV</span>()  <span class="hljs-comment">// 纯虚函数的定义</span><br>&#123;<br>    <span class="hljs-comment">// delete ...</span><br>&#125;                    <br></code></pre></td></tr></table></figure><hr><p>再次重申, 本章的主要观点  <strong>给 base class 一个 virtual析构函数</strong> 只适用于多态用途, 这种<code>base class</code>的设计目的就是为了<strong>用来通过 <code>base class</code> 接口处理 <code>drived class</code> 对象</strong>.</p><p>我们也应当知道很多 class 的设计就不是为了作为 base class 来使用, 也并非所有的 base class 的设计目的是为了多态用途, 就像我们上一个条款的<code>Uncopyable</code>类, 它被作为基类就不是为了多态, 而是为了赋予派生类不可拷贝的属性, 就不需要使用基类接口, 使用也只是使用派生类, 使用 virtual析构函数就没必要了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>请为多态性质的<code>base class</code>设置 virtual析构函数, 反之请不要.</li><li>不要试图继承<code>STL</code>容器.</li><li>想设计抽象类又不知道纯虚函数选谁时, 选析构函数当纯虚函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款5-6 默认成员函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE%205%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE%205%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05 了解C++默默编写并调用哪些函数"></a>条款05 了解C++默默编写并调用哪些函数</h2><blockquote><p>编译器会默认为class创建default构造函数, 析构函数, copy构造函数, 赋值操作符重载, 这算是我们C++语言基础学习中的重中之重, 这里就不再过多阐释.</p></blockquote><p>书中提出一点 : 如果我们在实际使用中确实没有使用到某些默认成员函数, 编译器很大可能也不会自动创建对应的默认函数(例如copy构造函数, 赋值操作符重载).</p><hr><p>书中还提出了三种编译器拒绝自动生成赋值操作符重载的情景 : </p><ol><li>内含<code>reference(引用)</code>成员变量的类.</li><li>内含<code>const</code>成员变量的类</li><li>基类将赋值操作符重载声明为private的派生类</li></ol><p>原因都是显而易见的, <code>reference</code>不可改指不同对象, <code>const</code>不可被更改, 派生类基于基类.</p><hr><p>这里额外提一个小点, 就是默认生成的拷贝函数和辅助操作符重载默认都是浅拷贝, 就是只把类类对象的所有值进行复制, 如果有指针, 不会深入拷贝指针指向的内容, 只是单纯把指针本身拷贝.</p><h2 id="条款6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝"></a>条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝</h2><blockquote><p>虽然大多情况下一个类对象应当有外置的构造&#x2F;析构&#x2F;拷贝接口, 但是总会有一些独一无二的东西应当是不可复制的, 就想天下没有第二个你一样, 如果为你自己设计一个类, 你肯定也不希望有一个自动生成的拷贝函数可以拷贝出无数个你吧.</p></blockquote><p>因此, 若不想使用编译器自动生成的函数, 就该明确拒绝.</p><p>所以怎么拒绝呢?</p><ol><li>将该函数写入private中, 并且故意不实现它.</li><li>将该函数后加上<code>= delete</code>.</li></ol><p>假定我们要写一个房产买卖的类<code>HomeForSale</code>, 众所周知每一套房产都是独一无二的.</p><p>我们来看看怎么实现 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员函数</span><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;); <br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;); <span class="hljs-comment">// 这样拷贝函数无法在外部使用就相当于禁用</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 直接声明禁用, 其实在哪声明都可以</span><br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>   ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="设计一个专门为了阻止copying动作的base-class"><a href="#设计一个专门为了阻止copying动作的base-class" class="headerlink" title="设计一个专门为了阻止copying动作的base class"></a>设计一个专门为了阻止copying动作的base class</h4><p>针对某些对象独一无二的情况, 我们可以设计一个专门为了阻止copying动作的base class, 让所有有此需求的类继承自该类, 就可以完全不用在专门处理阻止copying动作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:              <span class="hljs-comment">// 允许构造和析构</span><br>  <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                            <br>  ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                           <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);   <span class="hljs-comment">// 阻止copying</span><br>  Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;     <br>  ...    <span class="hljs-comment">// 自此HomeForSale不需要再进行任何动作就可以实现阻止copying</span><br>&#125;;  <br></code></pre></td></tr></table></figure><p>ed : 也许有人觉得这样子反而多写的, 但在日常情况下<code>Uncopyable</code>完全可以是我们提前备好的, ctrl + v当然方便很多. 再说到为什么是<code>private继承</code>, 在后面的条款中我们会明白, <code>private继承</code>意味着<code>has-a(有一个)</code>的关系, 就是说, 派生类有着基类的部分性质, 而不等于基类, 符合此处<code>HomeForSale</code>和<code>Uncopyable</code>的关系.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住:"></a>请记住:</h3><ul><li>编译器会默认为class创建<code>default构造函数</code>, <code>析构函数</code>, <code>copy构造函数</code>, <code>赋值操作符重载</code>.</li><li>拒绝编译器自动生成的函数, 可以将其写在将该函数写入private中, 并且故意不实现它, 或者直接加上<code>= delete</code></li><li>可以写一些通用类如<code>Uncopyable</code>, 将功能和实现解耦.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款4 初始化</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="headerlink" title="条款04 确定对象被使用前已先被初始化"></a>条款04 确定对象被使用前已先被初始化</h2><blockquote><p>本条讨论如何安全高效地实现初始化, 当然也有一些条件奇葩的初始化值得我们去讨论</p></blockquote><h3 id="普通变量初始化"><a href="#普通变量初始化" class="headerlink" title="普通变量初始化"></a>普通变量初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>cont <span class="hljs-type">char</span> text[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>cin &gt;&gt; d;    <span class="hljs-comment">// 这种也叫初始化</span><br></code></pre></td></tr></table></figure><h3 id="类内变量初始化"><a href="#类内变量初始化" class="headerlink" title="类内变量初始化"></a>类内变量初始化</h3><p>类内变量的初始化一般就是三种, <code>类内设置初始值</code>, <code>缺省值</code> , <code>初始值列表</code>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name = <span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age = <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-type">const</span> string&amp; sex = <span class="hljs-string">&quot;女&quot;</span>) <span class="hljs-comment">// 设置缺省值 (次之)</span><br>    :_name(name.<span class="hljs-built_in">c_str</span>())<br>        ,_age(age)<br>        ,_sex(sex.<span class="hljs-built_in">c_str</span>())<span class="hljs-comment">// 初始化列表 (优先)</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span> : <br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>    <span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">char</span> _sex[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;男&quot;</span>;  <span class="hljs-comment">// 类内设置初始值 (最次)</span><br>&#125;<br><br>Stu s1;  <span class="hljs-comment">// 小红 17 女</span><br><span class="hljs-function">Stu <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;男&quot;</span>)</span></span>;    <span class="hljs-comment">// 张三 35 男 </span><br></code></pre></td></tr></table></figure><p>这里虽然看起来三种方式都可以, 但是只推荐全部使用初始值列表, 当有特别想要设置的默认值时设置缺省值.</p><h3 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3><h4 id="优势描述"><a href="#优势描述" class="headerlink" title="优势描述 :"></a>优势描述 :</h4><p>为了描述初始值列表的优势, 请先阅读以下另一版本的构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age, <span class="hljs-type">const</span> string&amp; sex)<br>&#123;<br>_name = name.<span class="hljs-built_in">c_str</span>();<br>    _age = age;<br>    _sex = sex.<span class="hljs-built_in">c_str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这样子写构造函数其实和我们写初始值列表的最终结果是一样的, 而且相对直观.</p><p><strong>但是</strong>, 该版本在底层每个变量其实是先进行了一次default的构造, 再进行了一次copy操作, 其本质是<code>初始化 + 赋值</code>.</p><p>而<code>初始值列表</code>在底层只进行了一次copy构造, 比前者高效得多, 本质就是<code>初始化</code>.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项 :"></a>注意事项 :</h4><ul><li>最好在初始值列表中初始化所有的成员变量, 这样起码不会忘记没有初始化的变量.</li><li>C++中成员变量的初始化顺序是按照类中声明的次序, 而非初始值列表中的顺序! (如果有继承关系, 基类一定早于派生类初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : _b(b), _a(a) <span class="hljs-comment">// 尽管在初始化列表中是_b在前, 但是依旧是先初始化_a</span><br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a; <span class="hljs-comment">// _a 在 _b 之前声明</span><br>    <span class="hljs-type">int</span> _b; <span class="hljs-comment">// _b 在 _a 之后声明</span><br>&#125;;<br><span class="hljs-comment">// ----------------------------------------------------------//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Purple</span>&#123; <span class="hljs-comment">// 紫色需要类型为红色和蓝色的变量</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Purple</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red) ,<span class="hljs-built_in">b</span>(blue)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;<br>    Blue b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-comment">// Color类存储三种颜色, 并且可以用红蓝配出紫</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Color</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red)<br>        :<span class="hljs-built_in">b</span>(blue)<br>        :<span class="hljs-built_in">purper</span>(r, b)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;           <span class="hljs-comment">//purple p;</span><br>    Blue b; <span class="hljs-comment">//Red r;</span><br>    Purple p; <span class="hljs-comment">//Blue b; 假如是注释中的情况, 将无法编译通过, 因为p需要r,b都初始化完才能初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同编译单元内定义non-local-static对象-的初始化次序"><a href="#不同编译单元内定义non-local-static对象-的初始化次序" class="headerlink" title="[ 不同编译单元内定义non-local static对象 ] 的初始化次序"></a>[ 不同编译单元内定义non-local static对象 ] 的初始化次序</h3><p>初看第一眼根本就不知道是什么东西(再看也不知道), 所以先介绍一下定义:</p><ul><li><p>编译单元 : 可以简单理解为一个单独的<code>.cpp</code>文件或<code>.h</code>文件等, 就是有一定的隔离性.</p></li><li><p><code>local static</code>(局部静态变量) : 生命周期为整个程序, <strong>在局部第一次调用时初始化</strong>, 之后都是用这个.</p></li><li><p><code>non-local static</code>(全局静态变量) : 生命周期也为整个程序, <strong>程序启动时初始化</strong>, 之后都是用这个.(例如全局变量)</p></li></ul><p><code>local static</code>和<code>non-local static</code>的区别简单来看就在于初始化的时机.</p><hr><p>再举一个例子, 如果我在<code>a.h</code>中定义了<code>class A</code>, 在<code>b.h</code>中定义了<code>class B</code>, 又在<code>c.cpp</code>中要求使用类型为A和类型为B的<code>non-local static</code>变量, 那么这两个变量的初始化次序是怎样的?</p><p>答案是<strong>无法判断</strong>, 你看上面的定义, <code>non-local static</code>对象都是在程序启动时初始化, C++根本没有手段判断应该先初始化哪个,所以这就是没有定义的行为!</p><hr><p>说了这么多, 那这样会带来什么隐患呢? </p><p>如果两个编译单元中的类有依赖关系的话, 初始化次序的不确定性就会导致问题!</p><p>假如说B类static变量中使用到了A类static变量的话, 如果在<code>c.cpp</code>中先初始化了B类static变量, 可是A类static变量还没初始化, 那么就只有报错一条路了. </p><hr><p>可能看到这里有人不太理解这种情况有什么应用场景, 那么我在这里引入一个定义 :</p><ul><li>内置型对象 : 这个对象本身并没有太大意义, 目的是为了引出类中的各种功能性函数, 一般是non-local static的.</li></ul><p><strong>进一步解释</strong> : 有些类中会有许多应用实际场景的方法函数, 如果需要使用这些函数, 就需要客户构造一个类对象,再用这个对象使用函数, 那么我们就干脆在类的头文件中声明一个类对象, 要求使用这个头文件的客户必须记得生成一个对应对象, 而这个对象一般是non-local static的. </p><p>假如有一个钟表类, 内部需要用到一个计时器的类, 于是使用了计时器类的内置对象, 当用户创建一个non-local static类型的钟表类对象时, 你无法确定计时器类的内置对象和钟表类对象哪个先初始化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    ....<br>&#125;;<br><span class="hljs-keyword">extern</span> TimeKeeper tk;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(tk.<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里用tk获取当前时间来初始化time</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <span class="hljs-comment">// 如果用户设置一个全局变量的Clock类对象clock, 此时无法确定clock和tk的初始化次序!</span><br>...<br></code></pre></td></tr></table></figure><h4 id="解决方法-以local-static对象替换non-local-static对象"><a href="#解决方法-以local-static对象替换non-local-static对象" class="headerlink" title="解决方法 : 以local static对象替换non-local static对象"></a>解决方法 : 以local static对象替换non-local static对象</h4><p>这个解决方法用到了设计模式中最经典的<code>单例模式</code>的设计思想 : 延迟初始化.</p><p>思路简单来说就是, 既然给出一个non-local static对象有风险的话, 我就不给这个non-local static对象了, 我直接使用一个函数, 当客户有使用内置型对象相应需求的时候, 当真正客户调用这个函数时, 才会使用函数内部的代码自己生成一个local static对象供自己使用, 这样初始化次序就有了保障.</p><p>更通俗易懂地描述一下, 就是虽然不好直接使用内置型对象, 但是可以把函数返回值当成内置型对象来使用,  因为在函数内生成的对象时是local static对象, 没有初始化次序的问题.</p><p>看一看接下来的代码吧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>        <span class="hljs-keyword">return</span> timekeeper;<br>    &#125;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(<span class="hljs-built_in">tk</span>().<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里只是简单地将tk换成了tk(), 从调用对象改为调用函数而已</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <br><span class="hljs-comment">// 设置一个全局变量的Clock类对象clock, 此时一定是clock开始初始化, 当初始化时调用到tk()再进行timekeeper的初始化</span><br>...<br></code></pre></td></tr></table></figure><h4 id="多线程情况下的安全性"><a href="#多线程情况下的安全性" class="headerlink" title="多线程情况下的安全性 :"></a>多线程情况下的安全性 :</h4><p>书中指明, <code>内涵static对象</code>在多线程情况下会带有线程安全的问题, 等待某事发生都会有麻烦.</p><p>如果同时调用tk(), 没办法保证只有一个timekeeper生成, 除非用锁, 但那样花销太大得不偿失.</p><p>所以我们可以在线程的单线程启动阶段<code>手工调用</code>所有的初始化函数(例如tk()), 这样在多线程来临前就可以确保初始化完毕.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>对内置型对象进行手工初始化, C++本身并不会保证正确初始化他们.</li><li>最好使用初始化列表, 并且排序要和类内的声明顺序一致.</li><li>如果有跨编译单元的初始化次序问题, 请以local static对象替换non-local static对象.</li></ul><p>刚开始写博客, 如有错误感谢指正!</p><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款3 const</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 : 尽可能使用const"></a>条款03 : 尽可能使用const</h2><blockquote><p><code>const</code>(不可被改动), 是一种非常有效且多样的语义约束, 有了这项约束, 我们可以借用编译器之手规范我们的代码, 以免带来意想不到的错误, 毕竟任何的改动都会伴随着一定的风险, 如果可以提前规避, 我们何乐而不为呢? </p></blockquote><p><code>const</code>在实际表现上是多才多艺的, 他可以修饰对象, 对象指针, 甚至成员函数, 接下来逐一介绍 :</p><h3 id="const-修饰变量"><a href="#const-修饰变量" class="headerlink" title="const 修饰变量"></a>const 修饰变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>; <span class="hljs-comment">// 这样子定义的N又被称为常变量, 其实也就是常量了(因为不可被改动)</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 众所周知, arr数组名是一个指针</span><br><span class="hljs-type">char</span>* a = arr;<span class="hljs-comment">// a指针可修改, 指针指向的内容可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = arr;<span class="hljs-comment">// b指针不可修改, 指针指向的内容可修改</span><br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> c = arr;<span class="hljs-comment">// c指针可修改, 指针指向的内容不可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> d = arr;<span class="hljs-comment">// d指针不可修改, 指针指向的内容不可修改</span><br></code></pre></td></tr></table></figure><p>谈到指针就不可避免的就会想到<code> 迭代器</code>, 毕竟<code>迭代器</code>就是指针的封装嘛.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//看看下面两种迭代器的定义, 就可以对应上面指针的情况</span><br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-comment">// 迭代器本身是const的, 也就是说本身不可修改, 相当于指针在*前加const</span><br><span class="hljs-comment">// 此时无法进行 ++iter 等操作</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citer = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 语言自带的const_iterator本身就是为了对迭代器指向的内容设置只读, 本身可以进行运算操作, 相当于在*后加const </span><br></code></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><blockquote><p>先明确<code>const</code>成员函数的意义 : 告知编译器这个函数内部的对象不应被改动.</p><p>不是说明函数本身不可改动!!!</p></blockquote><ul><li>那么对成员函数声明<code>const</code>的意义何在?</li></ul><ol><li><strong>使这个函数接口更容易被理解</strong>, 一个函数是否可以改变类内变量的具体数值会很大程度上影响我们对这个函数的定位判断.</li><li><strong>使操作<code>const</code>对象成为可能</strong>, 首先我们要明晰<code>const</code>对象是什么, 就是类定义出的<code>const</code>对象(例如 const Stu stu(小明, 18);), 当我们声明一个类对象为<code>const</code>时, 这个对象对象只能调用<code>const</code>成员函数, 调用的任何<code>non-const</code>成员函数都无法通过编译的, 因此如果你所设计的类有需求<code>const</code>的情景时, 请设计<code>const</code>成员函数.</li></ol><hr><ul><li>这里书中给出了一个事实 : <strong>两个成员函数如果只是常量性不同(const &#x2F; non-const), 也可以被重载.</strong></li></ul><p>​这其实就告诉我们如果想要适配<code>const</code>版本的话, <strong>non-const版本和const版本各写一个就好了</strong>, 编译器会根据对象是否为<code>const</code>来选择使用哪个函数, 样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <span class="hljs-comment">// 1</span><br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <span class="hljs-comment">// 2</span><br> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;<br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数2</span><br>cout &lt;&lt; ctb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数1</span><br></code></pre></td></tr></table></figure><hr><ul><li>接下来需要介绍两种对<code> 成员函数为const</code>时应有行为的流派概念:</li></ul><h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const :"></a>bitwise const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, 应当<strong>不改变对象中的任何变量</strong>, 也就是物理上没有1bit被改变.</p><h4 id="logical-const"><a href="#logical-const" class="headerlink" title="logical const :"></a>logical const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, <strong>可以改变对象中的某些变量</strong>, <strong>但是不能对对象的主要逻辑产生影响</strong>, 也就是说对象在逻辑上没有被改变, 改变的部分只是起辅助优化作用, 例如修改日志, 对计算结果进行缓存, 记录当前容器大小等, 这些工作对主逻辑并没有任何影响, 却可以大大提高主逻辑的工作效率.</p><hr><ul><li>那么C++实际上是怎么定义<code>const</code>成员函数的行为的呢?</li></ul><p>​C++在<strong>一般情况下的定义按照<code>bitwise const</code>的规则进行</strong>, 也就是说一个<code>const</code>成员函数无法改变对象中任何变量.</p><p>​但是这其中有一个C++本身不好决断的情况需要了解 :</p><p>​还记得上面代码中定义的[]重载函数吗 ? const char&amp; operator[](const std::size_t position) const </p><p>​假如我把返回值改为char&amp; : char&amp; operator[](const std::size_t position) const</p><p>​那么这样就会产生一个奇怪的情况 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc = &amp;<span class="hljs-built_in">cbt</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 返回的指针没有const</span><br>*pc = <span class="hljs-string">&#x27;j&#x27;</span>;<span class="hljs-comment">// &quot;hello&quot;被变成了&quot;jello&quot;!!!</span><br></code></pre></td></tr></table></figure><p>​通过以上的情况我们可以发现, C++虽然确保在<code>const</code>成员函数内部不会改变任何对象, 但是并不会检查返回对象所指向的内容是否是不可改变的, C++可能认为在函数外的行为是程序员的自由吧, 所以我们应当注意这一点.</p><hr><ul><li>那么问题又来了, 既然<code>logical const</code>也有其道理所在, C++是如何解决的呢?</li></ul><p>​C++引入了一个与<code>const</code>相关的摆动场 : <strong>mutable(可变的).</strong></p><p>​<code>mutable</code> 的主要用途是在 <code>const</code> 成员函数中允许对特定成员变量的修改, 这样<code>logical const</code>的诉求就可以满足了。</p><p>​请阅读以下代码 : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">text</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br>        <br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">updateLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!lengthIsValid)<br>&#123;<br><span class="hljs-comment">// 以下两句就是因为mutable得以通过</span><br>length = pText.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 重新更新text的长度</span><br>lengthIsValid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 定义当前length可用</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>string pText;<br><br><span class="hljs-comment">// mutable 关键字可以使某个成员变量在const成员函数被修改</span><br><span class="hljs-comment">// 作用是在不改变内部变量的基础逻辑的情况下, 可以引入少量变量可以被改变, 丰富逻辑</span><br><span class="hljs-comment">// 保证函数的安全, 使用mutable意味着在const成员函数中只能改变mutable变量, 其他变量不会被改变</span><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>​以上代码将<code>lenth</code>和<code>lengthIsValid</code>赋予<code>mutable</code>特性, 使其在<code>const</code>成员函数中可以改变, 从而可以用非常小的代价更新<code>text</code>的长度, 方便其他需要使用text长度的函数, 这两个变量均对<code>text</code>存储字符串的主逻辑没有影响.</p><hr><p>​最后还有一个比较有价值的观点 : 我们知道要适配<code>const</code>版本需要写两个类似的函数, 一个处理<code>const</code>对象, 一个处理<code>non-const</code>对象, 但是我们也应当发现这两个函数其实非常相似, 那么这就带来了一些问题:</p><ol><li><strong>代码重复</strong>, 这会带来阅读性降低, 维护成本提高的负面作用.</li><li>我们在以后的条款学习中会知道, 编译器一般会把成员函数替换为<code>inline</code>函数, 这在一般情况下肯定是更高效的, 但是<code>inline</code>函数中的代码越多, 会带来一系列如代码膨胀之类的问题, 这点我们应当避免.</li></ol><ul><li>书中提出了这样的解决方案 : <strong>令<code>non-const</code>版本调用<code>const</code>版本</strong>.</li></ul><p>​这样子做的前提是两个版本的内容一定相等, 或者说<code>non-const</code>版本不能修改对象内的变量, 毕竟如果修改了那和<code>const</code>版本就一定不一样了, 我们来改写上面[]重载的两个版本.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br>&#123; <br>    <span class="hljs-comment">//我们假定[]重载在返回下标引用之前还要做许多工作, 代码量巨大</span><br>    <span class="hljs-comment">// ...边界检验</span><br>    <span class="hljs-comment">// ...将数据访问的行为加入日志</span><br>    <span class="hljs-comment">// ...检验指向内容数据的完整性</span><br>    <span class="hljs-keyword">return</span> text[position]; <br>&#125;<br><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br>&#123; <br>    <span class="hljs-comment">// 这段代码实现了两次类型转换, 目的是调用const版本的operator[]函数并返回non-const的char&amp;</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> text&amp;&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>    <span class="hljs-comment">/* 我们把这段代码拆分开来解读</span><br><span class="hljs-comment">    return const_cast&lt;char&amp;&gt;(    // 3. 将[]返回结果由const版本通过const_cast转换为non-const版本</span><br><span class="hljs-comment">        static_cast&lt;const text&amp;&gt;(*this)  // 1. 先将this指针通过static_cast转换为const text&amp;</span><br><span class="hljs-comment">        [pos] // 2. const text&amp;类型调用[]重载, 自然使用的是const版本的[]重载</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​经过以上的操作, 无论<code>const</code>版本需要多少行代码, <code>non-const</code>版本都只需要一行代码即可, 相当实用.</p><p>​另外如果在<code>non-const</code>版本虽然和<code>const</code>版本十分相似, 但是还是想要修改一部分的数据, 也可以在调用完重载版本后不返回, 再进行一些修改操作再返回.</p><ul><li>小问题 : 为什么不用<code>const</code>版本调用<code>non-const</code>版本?  因为<code>non-const</code>版本不会限制修改行为, 无法监督<code>const</code>实现.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h2><ul><li>将某些东西声明为<code>const</code>可以帮助编译器检查出错误语法, <code>const</code>可被施加于任何对象, 函数参数, 函数返回值, 成员函数</li><li>C++在<code>const</code>成员函数定义上默认支持<code>bitwise const</code>流派, 但是也通过关键字<code>mutable</code>变相支持了<code>logical const</code>流派</li><li>当<code>non-const</code>版本和<code>const</code>版本等价实质时, 可以用<code>non-const</code>版本调用<code>const</code>版本</li></ul><p>作者 : 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款1-2</title>
    <link href="/2024/11/29/Effective%20C++%20%E6%9D%A1%E6%AC%BE1-2/"/>
    <url>/2024/11/29/Effective%20C++%20%E6%9D%A1%E6%AC%BE1-2/</url>
    
    <content type="html"><![CDATA[<h3 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01 : 视C++为一个语言联邦"></a>条款01 : 视C++为一个语言联邦</h3><blockquote><p>不像Java对各种资源都进行了整合内聚, C++更像是由四种次语言组合而成的语言联邦, 每种次语言都有自己的规约, 也都有不同的用武之地, 每个都可以给C++这门语言带来独特的优势.</p><ul><li><h4 id="C-C-的基础-包含指针-内置数据类型等基础思想"><a href="#C-C-的基础-包含指针-内置数据类型等基础思想" class="headerlink" title="C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想."></a>C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想.</h4></li></ul></blockquote><ul><li><h4 id="Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态"><a href="#Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态" class="headerlink" title="Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态."></a>Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态.</h4></li><li><h4 id="Template-C-泛型编程"><a href="#Template-C-泛型编程" class="headerlink" title="Template C++  :  泛型编程."></a>Template C++  :  泛型编程.</h4></li><li><h4 id="STL-一套template的程序库-包含各种数据结构与算法"><a href="#STL-一套template的程序库-包含各种数据结构与算法" class="headerlink" title="STL  :  一套template的程序库, 包含各种数据结构与算法."></a>STL  :  一套template的程序库, 包含各种数据结构与算法.</h4><p>  这四个方向我们都应熟识掌握, 但是可以给自己这样一个印象 : C++并不是一个一体的语言, 编程时的思想规范应当随你使用C++的对应部分而改变.</p></li></ul><hr><h3 id="条款02-尽量以cnost-enum-inline-替换-define"><a href="#条款02-尽量以cnost-enum-inline-替换-define" class="headerlink" title="条款02 : 尽量以cnost, enum, inline 替换 #define"></a>条款02 : 尽量以cnost, enum, inline 替换 #define</h3><blockquote><p>由 ‘#’ 引出的语句一般与C的预处理机制相关, 我们很需要预处理机制中的 #include 和 #ifdef, 前者保证库的引入, 后者可以针对不同的环境进行条件编译, 而 #define 却在语言的发展下显得有些与时代脱节了, 现在我们应当有心减少 #define 的使用.</p></blockquote><p>以下列举 #define 所带来的一些问题:</p><ol><li>书写代码时很难自动显示错误</li><li>编译错误时显示的信息并不直观</li><li>#define并不重视作用域, 面向全局生效, 这与我们应当坚持的封装思想相悖</li></ol><p>简而言之, 就是#define可能带来一些不可预料的行为并且无法保证类型安全, 而如今我们由足够多的方法可以安全有效地替代#define的功能, 比如const和enum可以替代#define在常量定义上功能, inline又可以替代#define在宏函数上的功能.</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100 <span class="hljs-comment">// 这个步骤在预处理阶段实现</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-comment">// 这个步骤在编译阶段实现</span><br></code></pre></td></tr></table></figure><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里我们想定义三元色的对应数值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED = 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN = 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE = 3</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED = <span class="hljs-number">1</span>, <br>    GREEN = <span class="hljs-number">2</span>,<br>    BLUE = <span class="hljs-number">3</span><br>&#125;<span class="hljs-comment">// 使用enum枚举类型在增强代码的可读性的同时也提升了可维护性</span><br><br><span class="hljs-comment">//-----------------------------------------------------//</span><br><span class="hljs-keyword">enum</span> Action&#123;<br>    RUN = <span class="hljs-number">0x0001</span>,    <span class="hljs-comment">// 第一位</span><br>    JUMP = <span class="hljs-number">0x0002</span>, <span class="hljs-comment">// 第二位</span><br>    SAY = <span class="hljs-number">0x0004</span>, <span class="hljs-comment">// 第三位</span><br>    SLEEP = <span class="hljs-number">0x0008</span> <span class="hljs-comment">// 第四位</span><br>&#125;<span class="hljs-comment">// 使用enum还可以实现比特级别的状态判断</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">CheckAction</span>(<span class="hljs-type">int</span> action);   <span class="hljs-comment">// 假设我们有这样一个检查运动状态的函数, 那么我们就可以只接受一个int就可以判断复数的状态</span><br><span class="hljs-built_in">CheckAction</span>(RUN | JUMP | SAY);<span class="hljs-comment">// 这里的状态就 跑 + 跳 + 说话</span><br></code></pre></td></tr></table></figure><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入我们想实现的MAX(a, b), 我们可以通过以下实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b)  (a) &gt; (b) ? (a) : (b)</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MAX</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用模板 + inline就可以完全代替宏函数的作用, 首先inline的书写模式更加自然, 另外还保证了类型安全, 规避了#define的危险性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/29/hello-world/"/>
    <url>/2024/11/29/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
