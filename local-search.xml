<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective C++ 条款34 接口继承和实现继承</title>
    <link href="/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34 : 区分接口继承和实现继承"></a>条款34 : 区分接口继承和实现继承</h2><blockquote><p>作为class的设计者, 我们有时希望派生类只继承成员函数的接口, 有时又希望同时继承接口和实现, 有时又希望能够重写所继承的实现,  因此我们的选择是多样的, 这里大有可以探讨的地方, 本条款将带我们区分不同的继承方法, 并对其做出建议</p></blockquote><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><p>首先让我们明晰各种继承方式的区别, 大体有三种继承方式 : </p><ul><li><p>接口继承 : <strong>pure virtual函数</strong>实现, 强制派生类<strong>继承接口</strong>.</p><p>这种方式的通过强制继承接口确保必需功能的实现.</p></li><li><p>接口 + 缺省实现继承 : <strong>virtual函数</strong>实现, 派生类可以选择重写, <strong>继承基类提供的接口和缺省实现</strong>.</p><p>这种方式可以灵活选择是继承缺省版本还是重写.</p></li><li><p>接口 + 强制实现继承 : <strong>non-virtual函数</strong>实现, 派生类<strong>继承接口和唯一实现</strong>.</p><p>这种方式就是给整个继承体系增加了一个固定的工具函数, 该函数不可重写.</p></li></ul><p>简单来说就是继承会继承接口, 但是否继承一份实现是看具体情况而定的.</p><hr><h3 id="纯虚函数也可以被定义"><a href="#纯虚函数也可以被定义" class="headerlink" title="纯虚函数也可以被定义"></a>纯虚函数也可以被定义</h3><p>在前面的条款中应该有提过纯虚函数定义的问题, 这里再着重研究一下 : </p><ul><li><strong>纯虚函数可以被定义</strong>, 但调用它的唯一途径是调用时<strong>明确指出其class名称</strong>.</li></ul><p>就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;...&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shape::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;draw&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Shape* ps = <span class="hljs-keyword">new</span> Rectangle;<br>ps-&gt;Shape::<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 这样便可以调用纯虚函数</span><br></code></pre></td></tr></table></figure><p>有了该定义, 便可以为上述的第二种继承方式提供<strong>更平常更安全的缺省实现</strong>.</p><hr><h3 id="“使用纯虚函数并定义”来替换普通虚函数的使用"><a href="#“使用纯虚函数并定义”来替换普通虚函数的使用" class="headerlink" title="“使用纯虚函数并定义”来替换普通虚函数的使用"></a>“使用纯虚函数并定义”来替换普通虚函数的使用</h3><p>先来引入前提, <strong>普通虚函数的重写并没有强制性, 并且在没有重写的情况下会自动继承缺省版本</strong>, 这点在实际应用中被认为是有风险的. 因为自动使用某些功能总是有可能超出使用者的预期的, 有些时候往往可能只是我们忘记重写, 本身并不希望使用缺省, 但实际却还是调用到了缺省, 这很有可能<strong>和我们想要实现的目的不一致, 但是在语法上是正确的, 我们不一定会意识到我们的错误</strong>. 书中举出了一个飞机公司的例子, 一开始有两种型号的飞机A和B, 新加入一个型号的飞机C,  其默认的飞行方式和AB都不同, 如果我们忘记重写fly函数, 自动调用的缺省函数可能不会符合我们的预期 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airport</span> &#123; ... &#125;;                     <span class="hljs-comment">// represents airports</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// fly的缺省行为</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br>  ...                                   <span class="hljs-comment">// 忘记重写C的fly, 调用的缺省行为也可能不符合我们的预期</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>理解起来并没有那么麻烦, 就是使用<code>virtual</code>函数并没有强制性检查, 程序员的疏忽可能导致错误.</p><p>于是我们提出了一个新的方式替代<code>virtual</code>函数(第二种继承方案) : </p><ul><li><strong>使用pure virtual函数并定义,  在想要使用缺省版本时显示指定缺省版本</strong>.</li></ul><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数声明fly</span><br>  ...<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span>     </span><br><span class="hljs-function"></span>&#123;                                                  <br>  <span class="hljs-comment">// 用纯虚函数的定义当作缺省版本</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;   <span class="hljs-comment">// 在想要调用缺省版本时显示调用</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 这里强制我们重写fly, 不想调用缺省版本就只能老实重写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们可以用更安全地方式实现普通<code>virtual</code>函数的作用, <strong>利用纯虚函数必须重写的机制来让我必须在缺省和重写中做出选择, 而没有”忘了”这种选项</strong>.</p><hr><h3 id="继承方式的选择"><a href="#继承方式的选择" class="headerlink" title="继承方式的选择"></a>继承方式的选择</h3><p>具体选择还是依靠我们的需求来决定, 每种继承方式应用的场景我们都应明晰, 最后做出明智的判断, 最后作者还给出了几点提醒: </p><ul><li>除非你的<code>class</code>没有多态用途, 不要将所有函数声明为<code>non-virtual</code>.</li><li>除非你要写接口类, 不要将所有函数声明为<code>virtual</code>, 这是不想思考的体现.</li><li><code>virtual</code>函数是有成本的, 但是考虑到80-20法则(程序有80%的时间花费在20%的代码身上), 有80%的<code>virtual</code>函数不会对效率产生冲击, 这需要我们合理考量.</li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p><code>pure virtual</code>函数只确保接口继承, 但是也可以进行定义.</p></li><li><p><code>virtual</code>函数在接口继承的同时可以选择是否继承实现, 可以用”使用纯虚函数并定义”的方式来替换以提高安全性.</p></li><li><p><code>non-virtual</code>函数在接口继承的同时继承一份强制性实现.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款33 继承, 重载与作用域</title>
    <link href="/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33 : 避免遮掩继承而来的名称"></a>条款33 : 避免遮掩继承而来的名称</h2><blockquote><p>本条款并非和继承有关, 而是在讨论由继承引发的作用域问题, 其有可能破坏条款32所确定的法则, 因此我们在其之后介绍本条款。</p></blockquote><p>我们知道在不同作用域下如果有相同名称的事物, 无论其功能或类型, 都是局部优先的. 继承的父子类也是类似, 不管是不是虚函数, 亦或是纯虚函数都完全没有关系, 都遵守相同名称局部优先的原则, 我们来看看一下的代码 :  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析代码我们可以发现, 派生类的函数都将覆盖基类相同名称的函数, 但没有什么原则上的问题.</p><p>但是如果加入重载, 事情就变得有些复杂了, 我们来看看接下来的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// mf1的重载</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;  <span class="hljs-comment">// mf3的重载</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们经过测试发现, 派生类调用<code>mf1</code>将只能调用到<code>Derived</code>中的<code>mf1()</code>, <code>mf3</code>也是如此, 而基类中的重载版本将无法再获取(除非用<code>Base::</code>). 以下我们将会介绍两种应用于不同情况下的解决办法.</p><hr><h3 id="using声明式"><a href="#using声明式" class="headerlink" title="using声明式"></a>using声明式</h3><p>让我们回顾条款32 : “<strong>public意味is-a</strong>“ , 也就是说派生类可以干出所有<code>Base</code>可以干的事, 但是在这种情况下, 基类可以使用<code>mf1(int)</code>, 而派生类却不可, 这便是打破了这个规则. 因此我们可以再在派生类重写对应的重载, 亦或是直接接受父类的重载版本, 就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::mf1;       <br>  <span class="hljs-keyword">using</span> Base::mf3;      <span class="hljs-comment">// 所有Base中的mf1和mf2在Derived中都可见</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如此便可<strong>避免遮掩继承而来的名称</strong>.</p><hr><h3 id="转交函数"><a href="#转交函数" class="headerlink" title="转交函数"></a>转交函数</h3><p><code>public</code>继承可以通过<code>using</code>暴露所有基类的名称及其对应的重载版本, 但当然也会有<code>private</code>继承(具体细节在条款39中讲解)有类似的需求, 但<code>private</code>继承不一定需要继承所有基类的重载版本, 可能只是某个被遮掩的版本, 于是我们可以通过<strong>转交函数</strong>, 来缩小获取的范围, 让我们看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>  ...                                   <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">private</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123; Base::<span class="hljs-built_in">mf1</span>(); &#125;                     <span class="hljs-comment">// 转交给基类, 选取其中的无参数版本</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>mf1</code>就只会有基类无参数版本的<code>mf1</code>对应的功能, 而使用不到带<code>int</code>的重载版本.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>派生类中的名称会遮掩基类中的名称.</li><li><code>public</code>继承必须接受所有基类中所有被遮掩的名称, 故用<code>using</code>声明式.</li><li><code>private</code>继承中可能有需要基类中被遮掩物的需求, 可以用转交函数声明调用基类函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款32 public继承</title>
    <link href="/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款32-确定你的public继承塑膜出-is-a-关系"><a href="#条款32-确定你的public继承塑膜出-is-a-关系" class="headerlink" title="条款32 : 确定你的public继承塑膜出 is-a 关系"></a>条款32 : 确定你的public继承塑膜出 is-a 关系</h2><blockquote><p>从本条款开始我们将步入面向对象编程这一重要领域进行讨论, 首先我们将会围绕public继承, 分析public继承的意义与目的, 再举出两个错误的public继承典例.</p></blockquote><h3 id="public继承意味”is-a”-是一种-的关系"><a href="#public继承意味”is-a”-是一种-的关系" class="headerlink" title="public继承意味”is-a”(是一种)的关系"></a>public继承意味”is-a”(是一种)的关系</h3><p>这便是C++面向对象编程的最重要的一个规则, 请把这个规则牢牢记在心中吧, 相信很多人以及对这种认知有所耳闻, 我甚至在学java的多态时都听到过这个概念, 可见此思想影响之深远.</p><p>如果你令B公开继承自A, 那么代表着<strong>B是一种A</strong>,  进而代表着<strong>所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生</strong>. 反之则不然, 需要B的场景并不能用A替代.</p><p>这种规则表面上很容易理解, 但是我们应当多去站在语法和程序本身的角度去理解, 因为我们在生活中的直觉可能会误导我们, 它并不一定是富有逻辑性而且缜密, 这会让我们想当然地去认为xxx是一种xxx.</p><p>让我们通过两个例子来揭露这种错误.</p><hr><h3 id="鸟会飞"><a href="#鸟会飞" class="headerlink" title="鸟会飞?"></a>鸟会飞?</h3><p>直觉来看, 鸟应该是会飞的, 但是当我们想到鸵鸟和企鹅, 事情就开始不对劲了, 我们先来看第一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;                  <span class="hljs-comment">// 鸟会飞</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>:<span class="hljs-keyword">public</span> Bird &#123;            <span class="hljs-comment">// 企鹅是鸟</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们可以看出, 企鹅确实是鸟, 但企鹅确实不会飞, 它本就不应该继承fly()函数, 于是我们就会有下一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>  ...                                      <span class="hljs-comment">// 不在声明fly()函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span>: <span class="hljs-keyword">public</span> Bird &#123;<span class="hljs-comment">// 一个新的派生类, 用来做所有飞鸟的基类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>: <span class="hljs-keyword">public</span> Bird &#123;<br>  ...                                       <span class="hljs-comment">// 这里就继承不到fly()了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>至此逻辑就合理了,  这也在告诫我们应当仔细分析设置在类中的每个成员函数是否合理.</p><hr><h3 id="进一步梳理"><a href="#进一步梳理" class="headerlink" title="进一步梳理"></a>进一步梳理</h3><p>上一个例子因为鸟是否会飞的需求而产生了不同的设计, 但是书中想告诉我们, <strong>世界上并不存在一个”适用于所有软件”的完美设计</strong>, 因为时间在流逝, 需求在变化, 我们的设计一定要符合需求, 假如我们整个体系就是针对飞鸟来建立的, 完全不会与企鹅鸵鸟相关, 那么最开始的设计完全是可行的. 简单来说, <strong>我们要明确需求, 根据需求分析各种不同的情况, 做出符合当前需求的继承设计</strong>, 当然也可以有一定的前瞻性, 但不要与当下的需求相悖.</p><hr><h3 id="正方形是一种矩形"><a href="#正方形是一种矩形" class="headerlink" title="正方形是一种矩形?"></a>正方形是一种矩形?</h3><p>这相比于上一例中由于常识产生的错误不同, 这就是数理方面的真理, 但从最终结果上并不适合<code>public</code>继承, 我们来看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> newHeight)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> newWidth)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// return current values</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addWidth</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 调用这个函数会使这个width增加10, 并且height不加</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> oldHeight = <span class="hljs-built_in">height</span>();<br>  <span class="hljs-built_in">setWidth</span>(<span class="hljs-built_in">width</span>() + <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">height</span>() == oldHeight);          <span class="hljs-comment">// 检察height是否变化</span><br>&#125; <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-keyword">public</span> Rectangle &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>当我们用<code>Square</code>写出如下代码就会发生问题 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Square s;<br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());           <span class="hljs-comment">// 看正方形的性质是否保持</span><br>s.<span class="hljs-built_in">addWidth</span>();   <span class="hljs-comment">// 调用addWidth</span><br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());   <span class="hljs-comment">// 看正方形的性质是否保持</span><br></code></pre></td></tr></table></figure><p>最后一条<code>assert</code>将会触发, 原因很容易理解, <code>addWidth</code>只增加了宽度, 这打破的正方形的性质.</p><p>进一步分析, <code>addWidth()</code>这个函数本身是完全合理的, 因为一个矩形就是可以只增加宽度而不增加长度, 错的是自顾自<code>public</code>继承自它的<code>Square</code>, 因为它假定了正方形是一种矩形, 尽管这在公理上确实是成立的,  但是我们要求的是<strong>正方形可以做出所有矩形可以做出的行为</strong>, 这仿佛就不行了, 因为矩形可以只增加宽度而正方形不可以.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p><code>is-a(是一种)</code>并非是唯一存在于继承中关系, 我们还会再条款38和条款39讨论另外两个常见的关系, <code>has-a(有一个)</code>和<code>is-implemented-in-terms-of(根据某物实现出)</code>, 而我们上文正方形和矩形的关系便可以用<code>has-a</code>来解释. 在学完另外两种关系之后, 我们便应当好好了解这些关系之间的差异, 在继承中做到正确的选择.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>public</code>继承意味”<code>is-a</code>“(是一种)的关系, 若B继承自A, 所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生.</li><li>不要太相信直觉, 当你认为某些事物有 “<code>is-a</code>“的关系, 不妨再看看是否符合上一条的后半句.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(3)</title>
    <link href="/2024/12/11/2024-12-11-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/"/>
    <url>/2024/12/11/2024-12-11-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>只要紧紧跟随你的天赋, 它每时每刻都将让你看到全新的景色.</p></li><li><p>从事商业需要极具自信, 认真, 机警, 敢于冒险和不知疲倦的精神.</p></li><li><p>当了解某个人的真实性格以后, 我自认为是不可能去改变它的, 无论是让它变得更好还是更坏.</p></li><li><p>我既可以因为看戏而感动, 但我也可以对和我有重要关系的实际事件无动于衷.</p></li><li><p>我们活得太拥挤, 因袭彼此的生活方式, 相互之间磕磕绊绊, 我想我们因此失去了彼此之间的尊重. 对所有热忱的交往来说, 次数再少肯定也是足够的.</p></li><li><p>每个人清醒过来之后都应该了解自己所处的位置, 只有到了失去这个世界之后, 我们才能开始找到我们自己, 才能发现我们所处的位置, 以及我们与万事万物的联系是多么紧密.</p></li><li><p>别让谋生变成苦差事, 而是让它成为娱乐活动. 尽情地享受大地吧, 但别去占有它. 世人往往缺少冒险精神和信仰, 所以他们忙于买卖经营, 过着奴隶般的日子.</p></li><li><p>人们每天只去离家不远的田野和街道, 到了夜里就乖乖回去, 他们到底生命渐渐失去了活力, 因为缺乏新鲜的空气.</p></li><li><p>我既热爱善良的人性, 也热爱野蛮的兽性.</p></li><li><p>打猎是我受过最好的教育, 尽管起初他们只能是玩玩而已, 最后未必能够成为厉害的猎人, 这样他们将来反而不会在这片或其他旷野上滥杀无辜, 不会以同类为渔猎的对象.</p></li><li><p>几乎所有的成虫吃的东西都比幼虫少得多, 饕餮者都是处于幼虫时期的人, 有些民族整个都处在这种阶段, 那些民族的人没有理想和创造力, 有的是出卖了他们的便便大腹.</p></li><li><p>只要坚持茹素, 你将会欢快地迎接白天和黑夜的到来, 生活将如鲜花和芳草般散发着香气, 并且变得更加乐观和高尚, 而且更有仙气—那就是你的成功.</p></li><li><p>也许最让人震惊, 最为真切的事实从来不曾在人与人之间交流过.</p></li><li><p>我认为白水是唯一适合智者的饮料, 酒并非高贵的液体, 一杯咖啡能够冲走清晨的希望, 一杯热茶可以破坏夜晚的美梦.</p></li><li><p>能够污秽人的, 不是吃进嘴里的食物, 而是不知餍足的食欲. 应该受到谴责的不是食物的事务或品质, 而是对口腹之欲的痴迷; 加入你吃东西不是为了维持我们的生命, 也不是为了激发我们的灵感, 而是为了喂饱控制我们的馋虫, 那么你应该感到惭愧.</p></li><li><p>许多烦人的噪音传到远处之后, 人们居然将其当成音乐来倾听, 着对我们低贱的生活来说, 真实莫大的讽刺.</p></li><li><p>饕餮, 贪杯, 好色或嗜睡其实是一回事, 它们无非都是肉体的欲求, 只要看到有人犯了其中之一, 我们便知道他是耽于声色犬马之徒, 污秽与纯洁是不能并存的.</p></li><li><p>智慧和纯洁出自勤奋, 无知与堕落源于懒惰. 对学生来说, 堕落就是思考的懒惰.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款31 编译依存性</title>
    <link href="/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/"/>
    <url>/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款31-将文件间的编译依存关系降至最低"><a href="#条款31-将文件间的编译依存关系降至最低" class="headerlink" title="条款31 : 将文件间的编译依存关系降至最低"></a>条款31 : 将文件间的编译依存关系降至最低</h2><blockquote><p>本条款将带我们认识文件编译依存的问题, 以及解决问题的两个有效手段.</p></blockquote><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>问题的根源来自C++并没有把**”将接口从实现中分离”**这事做得很好, 简单来说, 由于C++本身机制与定位的原因, 为了达到更大的效率和可扩展性, C++引入<code>inline</code>和<code>template</code>等特性, 这些特性无不需要在头文件中发挥作用, 也就代表原本只应该存放声明的头文件会加入太多的实现细目, 也就是所谓的”没有把将接口从实现中分离这事做得很好”.</p><p>这带来的问题是既然<strong>很多定义在头文件里</strong>, 一旦我们要修改这些定义, 那么所有使用了这个头文件的所有客户(头文件)就都需要重新编译, 一环嵌一环, 最后需要的<strong>编译成本就非常高</strong>了, 这在书中被称作**”连串编译依存关系”**.</p><hr><h3 id="进一步解析"><a href="#进一步解析" class="headerlink" title="进一步解析"></a>进一步解析</h3><p><code>inline</code>和<code>template</code>无可厚非, 这是为了效率我们必须要让步的地方, 但是许多<strong>成员变量</strong>也会定义在类的定义式中, 这就有我们处理的余地了, 看看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span> <span class="hljs-comment">// 必须包含下方相关类的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>         <span class="hljs-type">const</span> Address&amp; addr);<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>      std::string theName;        <span class="hljs-comment">// 名称定义</span><br>      Date theBirthDate;          <span class="hljs-comment">// 生日定义</span><br>      Address theAddress;         <span class="hljs-comment">// 地址定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个人的抽象类型, 里面有三种不同类型的成员变量, 我们可以设想到的是, 只要<code>Date</code>和<code>Address</code>的内部定义发生变化, 就一定会连串导致<code>Person</code>重新编译, 然后使用<code>Person</code>的客户也需要重新编译.</p><p>部分语言的解决方式是直接在底层处理成指针, 这样到哪里都是原生指针的大小, 就无需通过引入头文件知道其大小, 于是可能处理成如下定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string* theName;        <br>Date* theBirthDate;   <br>Address* theAddress;<br></code></pre></td></tr></table></figure><p>这样就不需要引入头文件了,  只需要声明有这么一个类就行了, 当然string还是声明头文件吧, 因为标准库的编译一般不会成为编译瓶颈.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>             </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                          <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <br></code></pre></td></tr></table></figure><p>但我们的C++并没有在底层实现这种机制, 也是因为效率和一些设计理念的问题, 但没关系, 我们可以自己仿照这种做法来实现, 这就请我们回忆起条款29中提到的<strong>pimpl idiom</strong>手法(指针指向实现), 我们将在本条款继续深入其使用, <strong>设置接口类和实现类, 做到接口和实现分离</strong>, 以下是接口类的代码, 实现类将在后文补充 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>我们会实现一个<code>PersonImpl</code>封装上文的三个定义, 并且实现对<code>Person</code>中成员函数的定义,  因此<code>Person</code>中就只有这三个类型的声明而无定义了, 就算这三个类发生修改, 也无需重新编译Person, 于此通过接口与实现分离, 降低了编译依存关系.</p><p>额外说一下, <code>shared_ptr</code>并不需要被管理类的头文件, 也是声明即可, 就像正常的指针一样.</p><hr><h3 id="思想内核"><a href="#思想内核" class="headerlink" title="思想内核"></a>思想内核</h3><p><strong>编译依存性最小化</strong>的本质在于<strong>以”声明的依存性”替换”定义的依存性”</strong>, 现实中让头文件<strong>尽可能自我满足</strong>, 万一做不到, 则让它与其它文件内<strong>声明式</strong>相依.</p><p>于是我们可以衍生出三个设计策略 : </p><ul><li>如果可以用<strong>指针或引用</strong>就不要直接用类定义. <strong>类定义需要引入头文件, 但是指针或引用不需要, 只要声明类型即可</strong>.</li><li>如果能够, 尽量<strong>以class声明式替换class定义式</strong>. <strong>当你声明一个函数而用到某个class时, 你并不需要改class的定义</strong>, 纵使函数以<code>by value</code>的方式传递该类型的参数, 就像上面的<code>Person</code>构造一样.</li><li><strong>为接口类和实现类(也就是声明和定义)提供不同的头文件</strong>, 原因很容易理解, 本来分开的目的就是为了在实现类修改时无需接口类再次编译进而扩散影响,  放在一个头文件中到最后还不是一块编译吗?</li></ul><p>这里还需要解释为什么上面的策略都是无需定义, 只要声明就可以了?</p><p>我们可以想开一点, 就是在接口类中真的有没有无所谓, 只要通过声明认为它有就行, 真正用它的是实现类, <strong>一旦任何人调用那些函数, 调用之前定义式一旦得先曝光才行</strong>(就是你调用函数前肯定会传入对应的参数嘛), 所以我们是<strong>将”提供定义式”的义务从接口类头文件转到了”内含该函数调用”的客户文件中</strong>, 这样就可以<strong>将”非必要类型定义”与客户端之间的编译依存性去掉</strong>.</p><p>接下来将会根据思想内核提供两种实现编译依存性最小化的最终方案 : </p><hr><h3 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h3><p>本方案以上文的<strong>pimpl idiom</strong>手法为核心, <code>Handle classes</code>意为使用句柄的类, 这个句柄就是<strong>pimpl idiom</strong>手法的指针, <code>Person</code>类还是和上文一致, <code>PersonImpl</code>类<strong>应当和Person有着完全相同的成员函数, 并且有原本Person预想拥有的成员变量</strong>,  可以理解为<code>PersonImpl</code>才是真正的<code>Person</code>类, 以后所有的修改将在<code>PersonImpl</code>中进行.</p><p>一般来说我们要实现三个文件, 一个<code>Person.h</code>存放供客户使用的接口类, 一个<code>PersonImpl.h</code>存放对应接口类的实现类, 一个<code>Person.cpp</code>实现<code>Person</code>中函数声明的对应定义.  有点麻烦, 可以看代码理解, 接下来将给出两个分别封装接口类和实现类的头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h  存放接口类, 和上文一致</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// PersonImpl.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n) ,_birthDate(b) ,_address(a)<br>    &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp  在该文件实现接口类和实现类的真正关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PersonImpl.h&quot;</span></span><br><br><span class="hljs-comment">// 完成对接口类中声明函数的定义</span><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_shared</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure><p>宏观来说<code>Person</code>更像是一个外壳, 和<code>PersonImpl</code>有藕断丝连的关系, 而<code>PersonImpl</code>才拥有我们的核心代码, 不过对<code>PersonImpl</code>的修改并不需要<code>Person</code>所在头文件重新编译, 因为它和<code>PersonImpl</code>的关系都是声明来的, 在定义上没有任何关联.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span>  <span class="hljs-comment">// 只需包含接口类即可</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, date, addr)</span></span>;<br>cout &lt;&lt; p.<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>本方案核心在于<strong>继承</strong>, 像是<code>java</code>有专属的接口类, <code>C++</code>也可以模拟类似的<strong>抽象基类作为接口类, 而派生类作为实现类</strong>, 也可以达到和上个方案相似的效果, 但是唯一的问题是<strong>客户怎么使用接口类</strong>? 接口类既然是抽象基类, 就绝不可能生成对象, 但是<strong>抽象基类可以有指针和引用</strong>, 由此可以<strong>利用多态机制通过基类指针调用到派生的实现类</strong>, 所以我们虽然写不了构造函数, 但是可以写一个<strong>factory</strong>(工厂)函数来调用派生类的构造函数进而返回派生类的指针, 代码还是三个部分, 我们来逐一阅读 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-comment">// virtual析构函数见条款7</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 工厂函数为create, 通过提供的参数构造不同的派生类</span><br><span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Person&gt;    </span><br><span class="hljs-function"><span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RealPerson.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPerson</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealPerson</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n), _birthDate(b), _address(a)<br>    &#123;&#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RealPerson</span>() &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RealPerson.h&quot;</span></span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function">std::shared_ptr&lt;Person&gt;</span><br><span class="hljs-function"><span class="hljs-title">Person2::create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;RealPerson&gt;(std::<span class="hljs-built_in">make_shared</span>&lt;RealPerson&gt;(name, birthday, addr));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里重点理解<code>create</code>工厂函数, 它的最终目的一定是传出一个派生类的智能指针, 尽管传出指针的静态类型是<code>std::shared_ptr&lt;Person&gt;</code>, 但也会依靠多态机制绑定到正确的派生类类型. 至于是什么派生类可以通过参数值, 读取数据库数据, 环境变量等各种因素影响, 这里是因为只写了<code>RealPerson</code>一个派生类所以就直接返回了, 实际情况可以写更多的判断类型返回不同的派生类指针, 比如男人女人伪人之类的.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;Person&gt; <span class="hljs-title">pp</span><span class="hljs-params">(Person::create(<span class="hljs-string">&quot;李四&quot;</span>, date, addr))</span></span>;<br><br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="两种方案的异同"><a href="#两种方案的异同" class="headerlink" title="两种方案的异同"></a>两种方案的异同</h3><p><code>Handle classes</code>利用<strong>pimpl idiom</strong>手法, 构造出来的是一个实打实的对象, 因此可以通过各种方式调用内部功能, 使用较为简单.</p><p><code>Interface classes</code>利用<strong>继承和多态</strong>, 构造出来的只能说一个指向派生类对象的指针, 因此只可通过指针调用内部功能, 需要额外调用工厂函数, 但是吃到了多态的便利性, 可以有更大的可扩展性.</p><p>二者都实现了声明与定义的分离, 使头文件相依于声明式而非定义式, 解除了接口和实现之间的耦合关系, 从而降低了文件间的编译依存性.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>C++由于专注于运行时效率的提升, 引入<code>inline</code>等各种方式来促成该目的, 再加上<code>template</code>, 这其实给编译带来了过大的负担, 也就是说其实是牺牲了编译时而成全了运行时, 放在现实中其实就是牺牲了程序员的时间成本而成全了客户, 这无可厚非, 但若是因此影响了开发效率就顾此失彼了, 因此我们才要优化编译时间, 才要降低编译依存性, 尽管这可能增加些微的运行时成本, 但这仍是必要的.</p><p>另外我们也应权衡<code>inline</code>, <code>template</code>和以上两种方案的使用, 就让它们出现在最应该出现的地方吧.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>支持”编译依存性最小化”的一般构想是 : 相依于声明式, 不要相依于定义式. 基于此构想的两个手段是<code>Handle classes</code>和<code>Interface classes</code>.</li><li>头文件应该以”完全且仅有声明式”的形式存在, 除非要使用<code>inline</code>或<code>template</code>, 而且就算使用<code>template</code>, 也可以在头文件中实现<code>template</code>的声明, 将定义置入非头文件中,</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>编译依存性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款30 inline</title>
    <link href="/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/"/>
    <url>/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/</url>
    
    <content type="html"><![CDATA[<h2 id="条款30-透彻了解inlining的里里外外"><a href="#条款30-透彻了解inlining的里里外外" class="headerlink" title="条款30 : 透彻了解inlining的里里外外"></a>条款30 : 透彻了解inlining的里里外外</h2><blockquote><p>inline 函数, 多么棒的点子! 本条款将带我们透彻了解inlining的里里外外, 与往常的形式不同, 我会以知识点集的形式把书中对inline的描述列举处理, 可更简单明了的认识inline.</p></blockquote><h2 id="inline的优劣"><a href="#inline的优劣" class="headerlink" title="inline的优劣"></a>inline的优劣</h2><ul><li><code>inline</code>函数, 看起来像函数, 动作像函数, 却比宏好得多, 调用它们<strong>不用蒙受函数调用所带来的额外开销</strong>.</li><li>编译器会对<code>inline</code>函数执行语境相关最优化, 会<strong>提升编译效率</strong>.</li><li>如果内存有限, 过度<code>inlining</code>会造成程序<strong>体积太大</strong>.</li><li><code>inline</code>会带来<strong>代码膨胀</strong>, 进而导致额外的<strong>换页</strong>行为, 降低高速缓存装置的<strong>击中率</strong>.</li><li><strong>如果inline函数的本体很小</strong>, 编译器针对”函数本体”产出的码可能比针对”函数调用”产出的码更小, 反而会促成与上一条相反的情况, 可以导致较小的目标码和较高的高速缓存装置击中率.</li><li><code>inline</code>函数无法随程序库的升级而升级, 简单说如果程序库中有一个<code>inline</code>函数, 如果决定改变该函数, 那么程序库中所有用到该函数的程序就必须重新编译. 如果是<code>non-inline</code>函数,客户端只需要重新连接就好了, 没有那么大的编译负担, 如果是动态库就更没有了.</li></ul><hr><h2 id="inline的特性"><a href="#inline的特性" class="headerlink" title="inline的特性"></a>inline的特性</h2><ul><li><p><strong>inline不是一个强制命令, 它只是对编译器的一个申请!</strong> 编译器可以加以忽略, 大部分编译器将拒绝太过复杂的函数(含循环, 递归, 长度过长)进行<code>inlining</code>. 简而言之, <strong>一个表面看似inline的函数是否真的是inline, 取决于你的建置环境, 主要取决于编译器</strong>.</p></li><li><p><code>inline</code>可以明确提出, 也可以<strong>隐喻提出</strong>.</p></li><li><p>隐喻提出的方式是<strong>将函数定义在class定义式中</strong>. 这便是为什么很多<code>class</code>会将实现简短的函数直接在<code>class</code>定义式中将声明定义一并给出, 其实就是在方便的前提下还隐喻地使用了<code>inline</code>函数, 以达到”没有声明任何<code>inline</code>却处处都是<code>inline</code>“的效果. </p></li><li><p>隐喻<code>inline</code>函数通常是<strong>成员函数</strong>, 也可以是<code>friend</code>函数.</p></li><li><p>所有<code>virtual</code>函数与调用<code>virtual</code>的函数都无法<code>inlining</code>. <code>virtual</code>代表着等待运行时判定, 而<code>inline</code>代表编译时提前替换, 这两种行为是绝对冲突的.</p></li></ul><hr><h2 id="inline的使用"><a href="#inline的使用" class="headerlink" title="inline的使用"></a>inline的使用</h2><ul><li><code>inline</code>函数通常<strong>一定被置于头文件内</strong>, 因为大多数建置环境都在编译过程中进行<code>inline</code>.</li><li><code>templates</code>(泛型类&#x2F;函数)通常也被置于头文件内, 很多程序员认为泛型函数一定都是<code>inline</code>, 但这是错误的, <strong>template的实例化与inline无关</strong>, 不应该这样考量, 还是应该依照代码长度,内容以及环境做具体考量.</li><li><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>, 因为就算它们是空白的, 也有可能在底层被编译器施加很多额外的代码, 例如基类的构造与析构, 这导致它们的实际代码量远比我们看见的要多得多, 令它们<code>inlining</code>很有可能会发生代码膨胀.</li><li>一开始先不要将任何函数声明成<code>inline</code>, 除非你非常笃定它就是<code>inline</code>的典型案例, 当你开始关心效率时, 再分析是否可以<code>inlining</code>.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h2><ul><li>请将大多数的<code>inlining</code>限制在<strong>小型, 被频繁调用</strong>的函数身上.</li><li>通过将函数定义在<code>class</code>定义式中实现隐喻<code>inline</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款29 异常安全性</title>
    <link href="/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款29-为”异常安全”而努力是值得的"><a href="#条款29-为”异常安全”而努力是值得的" class="headerlink" title="条款29 : 为”异常安全”而努力是值得的"></a>条款29 : 为”异常安全”而努力是值得的</h2><blockquote><p>异常安全性是我们每个程序员都要考量的内容, 我们有必要知道我们写出的每个函数保证了怎样的异常安全, 因为一个函数是否会抛出异常不仅会影响我们是否使用该函数的决策, 也会影响部分的编译器优化策略, 让我们通过本条款来充分认识异常安全性.</p></blockquote><p>先了解本条款的例子, 假设有个<code>class</code>用来表现夹带背景图案的GUI界面, 这个<code>class</code>用于多线程环境, 所以它有个互斥器作为并发控制之用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span>;           <span class="hljs-comment">// 用来改变背景图片的成员函数</span><br><br><span class="hljs-keyword">private</span>:<br><br>  Mutex mutex;                    <span class="hljs-comment">// 互斥器</span><br><br>  Image *bgImage;                 <span class="hljs-comment">// 当前的背景图像</span><br>  <span class="hljs-type">int</span> imageChanges;               <span class="hljs-comment">// 背景图像被改变的次数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">lock</span>(&amp;mutex);                      <span class="hljs-comment">// 上锁</span><br><br>  <span class="hljs-keyword">delete</span> bgImage;                    <span class="hljs-comment">// 释放原背景</span><br>  ++imageChanges;                    <span class="hljs-comment">// 更新计数</span><br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);       <span class="hljs-comment">// 修改新背景</span><br><br>  <span class="hljs-built_in">unlock</span>(&amp;mutex);                    <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从异常安全性的角度来看, <code>changeBackground</code>非常糟糕, 它并没有满足”异常安全”的两个必要条件 : </p><ul><li><p><strong>不泄漏任何资源</strong>. </p><p>资源泄漏包括内存&#x2F;文件句柄&#x2F;<code>socket</code>连接&#x2F;锁等泄漏, 这里我们知道<code>new Image(imgSrc)</code>是一定可能有<code>bad_alloc</code>的异常的, 当异常发生, <code>unlock(&amp;mutex)</code>语句将不会执行, 锁并没有得到释放, 也就是说发生了泄漏.</p></li><li><p><strong>不允许数据败坏</strong>.</p><p>数据败坏即数据与预期的有效状态不符, 比如野指针. 这里当<code>new Image(imgSrc)</code>处发生异常, <code>bgImage</code>的原资源已经释放却没有获得新资源, 它的行为是未定义的, 并且<code>imageChanges</code>也增加了一次本不存在的计数, 这都是数据败坏.</p></li></ul><hr><h3 id="利用资源管理类解决资源泄漏"><a href="#利用资源管理类解决资源泄漏" class="headerlink" title="利用资源管理类解决资源泄漏"></a>利用资源管理类解决资源泄漏</h3><p>当我们深谙条款13”<strong>以对象管理资源</strong>“的道理后, 资源泄漏将不再是问题! 资源管理类可以确保资源及时且自动地释放, 并且还减少了我们的代码量, 于是我们就可以用条款14中<code>RAII</code>风格的<code>Lock</code>类来解决本条款的锁泄漏 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                <span class="hljs-comment">// 自动管理锁的释放</span><br>  <span class="hljs-keyword">delete</span> bgImage;<br>  ++imageChanges;<br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);    <span class="hljs-comment">// 一旦触发异常离开函数作用域就会自动触发Lock的析构函数释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>绝大多数异常引发的资源泄漏都可以用资源管理类来解决.</p><hr><h3 id="三种异常安全保证"><a href="#三种异常安全保证" class="headerlink" title="三种异常安全保证"></a>三种异常安全保证</h3><p>这将是本条款的重点, 一个异常安全的函数在避免资源泄漏之后, 为了防止数据败坏, 我们还必须拥有下面三个保证之一, 越往后保证强度越大.</p><ul><li><p><strong>基本承诺</strong> : 异常抛出后, 没有数据泄漏, 没有数据败坏, 所有事物仍然保持有效, 但是不支持完全回滚, 我们不确定数据在该函数中修改成什么样了, 即使这种状态合法, 其实就是符合<strong>两个必要条件但是不做任何处理</strong>. 我们看以下的例子理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i = <span class="hljs-number">10</span>; i ++ )<br>        data.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 如果此处抛出异常，vector 自动管理内存，无泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该例子符合基本承诺, 这个函数向<code>data</code>中插入1到10, 插入动作会抛出异常, 但是<code>vector</code>会自动管理内存, 不会有泄漏与数据败坏, 但是加入我们在插入<code>i = 5</code>时出现异常, 那么异常抛出将不会执行之后的语句, 也就是说这次插入的结果是<code>data</code>尾插了1,2,3,4, 然而出现异常后客户并不会知道内部到底插入了多少, 虽然该状态合法.</p></li><li><p><strong>强烈保证</strong> : 如果异常被抛出, 对象状态不会改变, 与调用该函数前状态一致. 就是说, 没有异常就是完全成功, 抛出异常对象状态会发生<strong>回滚</strong>, 回滚至调用前状态. </p></li><li><p><strong>不抛掷保证</strong> : 承诺绝不抛出异常. 这种函数不可能涉及任何动态内存的分配, 一般只是对<strong>内置类型</strong>进行操作, 如算术类型, 指针, 引用等.并且这种函数我们一般会在其函数定义后添加<code>noexcept</code>关键字, 这代表你向编译器声明这个函数绝不会抛出异常, 编译器就会删去对这个函数的异常处理工作, 实现效率的提升.</p></li></ul><hr><h3 id="实现强烈保证"><a href="#实现强烈保证" class="headerlink" title="实现强烈保证"></a>实现强烈保证</h3><p>我们一般都是由下至上选择安全保证, 不抛掷保证只适用于对内置类型的操作, 比较典型的就是移动构造和移动赋值.</p><p>所以大多数情况下我们更愿意实现强烈保证, 我们来看看将<code>changeBackground</code>修改为强烈保证的步骤 : </p><ol><li>将<code>bgImage</code>这个成员变量用智能指针代替, 这个只是为了实现两个条件中的避免资源泄漏.</li><li>重新改变语句顺序, <strong>不要为了表示某事件的发生而改变对象状态, 除非那件事真的发生了</strong>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br>  ...<br>  std::shared_ptr&lt;Image&gt; bgImage; <span class="hljs-comment">// 改用智能指针</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>  bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));  <span class="hljs-comment">// 以 new Image(imgSrc) 的结果设定为bfImage的内部指针</span><br>     <span class="hljs-comment">// 无需delete原资源, reset内部会帮我们自动调用delete</span><br>  ++imageChanges;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析上述代码, 我们可以很惊喜地发现, 如果<code>new Image(imgSrc)</code>失败, 对象状态将不发生任何改变, <code>reset</code>和<code>++imageChanges</code>都不会触发,  也就是说失败即回滚, 成功即完全, 再加上不会资源泄漏与数据败坏, 其符合强烈保证!</p><hr><h3 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h3><p>上文我们通过<strong>调整语序</strong>来实现了强烈保证, 这确实是最基础的一种解决方法, 其内核在于”<strong>在所有可能抛出异常的动作成功结束前不要改变对象状态</strong>“, 但是这种做法比较费脑, 并且不一定适合某些场景. 然而有一个<strong>一般化的设计</strong>很典型地会导致强烈保证, 这个策略被称为<code>copy and swap</code>.</p><p>使用方法很简单, <strong>为你打算修改的对象做出一个副本, 在那个副本上做任何的修改, 待所有改变成功后再交换原对象和副本</strong>(注意这个做法的前提建立在<code>swap</code>是<code>noexcept</code>的, 这也是为什么条款25一直强调<code>swap</code>不抛异常的重要性). 其内核在于”<strong>修改对象数据的副本, 然后在一个不抛异常的函数中将数据和原件置换</strong>“.</p><p>在看代码之前, 有一个手法很适合实现上述操作, 叫做<strong>pimpl idiom</strong>(pointer to implementation idiom)(指针指向实现), 这个手法在于将所有需要隐藏的成员变量和成员函数包入一个<strong>实现类</strong>, 外部构造一个<strong>接口类</strong>, 该接口类存放该实现类的指针(一般是智能指针)与外放接口. 条款31将详细描述该手法的优势, 在本条款就是将<strong>所有”隶属对象的数据”从原对象放进另一个对象内, 然后赋值原对象一个指针, 指向该对象</strong>, <strong>这样我们copy and swap的对象就仅限于存放数据的对象, 而一切操作都在原对象中进行</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMImpl</span> &#123;                               <span class="hljs-comment">// 实现类</span><br>  std::shared_ptr&lt;Image&gt; bgImage;        <br>  <span class="hljs-type">int</span> imageChanges;                           <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;  <span class="hljs-comment">// 接口类</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  Mutex mutex;<br>  std::shared_ptr&lt;PMImpl&gt; pImpl;  <span class="hljs-comment">// 一个智能指针指向实现类</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;                            <span class="hljs-comment">// 见条款25</span><br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                        <span class="hljs-comment">// 锁的copy and swap是没有意义的</span><br>  <span class="hljs-function">std::shared_ptr&lt;PMImpl&gt; <span class="hljs-title">pNew</span><span class="hljs-params">(<span class="hljs-keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="hljs-comment">// 复制副本</span><br><br>  pNew-&gt;bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));     <span class="hljs-comment">// 对副本进行所有修改</span><br>  ++pNew-&gt;imageChanges;<br><br>  <span class="hljs-built_in">swap</span>(pImpl, pNew);    <span class="hljs-comment">// 只有前面不抛异常才会到这里, 直接进行交换, 内置类型的交换一定不会有异常</span><br>&#125;                                     <br></code></pre></td></tr></table></figure><p>以上便通过<code>copy and swap</code>实现了强烈保证.</p><hr><h3 id="实现强烈保证的最终策略"><a href="#实现强烈保证的最终策略" class="headerlink" title="实现强烈保证的最终策略"></a>实现强烈保证的最终策略</h3><p><code>copy and swap</code>策略是<strong>对对象状态做出”全有或全无”改变</strong>的一个很好办法, 但是它<strong>不等于一个函数有强烈保证</strong>.</p><p>分析起来比较麻烦, 简单说就是<code>copy and swap</code><strong>只确定了内存相关操作的强烈保证, 使对象的局部状态有了一致性</strong>, 即”全有或全无”, 然而有时候对象其实是会对”<strong>非局部性数据</strong>“产生影响的, 例如数据库连接, 网络连接, 锁等, 这些东西不会只因为内存数据的有无而生效或失效, 连接还和连接的对象有关, 锁还和线程分配有关, 它们更偏向于全局状态, 这也是上面代码我没有将<code>Lock ml</code>存入<code>PMImpl</code>的原因.</p><p>再讲一个例子, 假设我在函数中创建的副本上对<strong>数据库</strong>进行了修改, 如果之后发生了异常, 如果我不做任何其他的操作, 那么这个数据库的修改是一直成立的, 并没有因为<code>copy and swap</code>而回滚, 这是完全可以理解的, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123; <span class="hljs-comment">// 修改局部数据与数据库</span><br>    <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData; <span class="hljs-comment">// copy 创建局部状态的副本</span><br><br>    <span class="hljs-comment">// 修改数据库（非局部数据）</span><br>    db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        localDataCopy.<span class="hljs-built_in">push_back</span>(i);   <span class="hljs-comment">// 如果此处发生异常, 前面的数据库修改无法恢复!</span><br>    &#125;<br>    <span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此, 我们可以总结出可以实现强烈保证的大体策略 :</p><ul><li><strong>如果函数有关内存数据的修改, 使用<code>copy and swap</code>策略.</strong></li><li><strong>如果函数有关非局部数据的修改, 自己根据非局部数据的性质进行对应的异常回滚操作.</strong></li></ul><p>例如上文的数据库, 我们就可以利用其<strong>事务</strong>的特性实现异常回滚 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData;<br>    db.<span class="hljs-built_in">beginTransaction</span>(); <span class="hljs-comment">// 开启数据库事务</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 修改数据库数据</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            localDataCopy.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 此刻发生任何异常都会被捕获, 在catch语句中触发回滚</span><br>        &#125;<br><br>        db.<span class="hljs-built_in">commitTransaction</span>(); <span class="hljs-comment">// 所有修改成功后，提交事务</span><br>        std::<span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        db.<span class="hljs-built_in">rollbackTransaction</span>();  <span class="hljs-comment">// 发生异常时，回滚事务</span><br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<code>modifyDataAndDatabase</code>函数也就拥有了强烈保证, 这部分的最终策略是我求证后自创的, 书中没有详细指出如有问题或补充欢迎指出.</p><hr><h3 id="关于嵌套函数的问题"><a href="#关于嵌套函数的问题" class="headerlink" title="关于嵌套函数的问题"></a>关于嵌套函数的问题</h3><p>书中指出, 嵌套函数会确实影响函数本身的异常安全性, 道理也很容易理解, 一个没有强烈保证的函数被嵌入一个函数, 那么这个函数也一定没有强烈保证. 然而<strong>所有嵌套函数都是强烈保证的就能使本函数有强烈保证了吗, 未必!</strong> 让我们看下面的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    ...                <span class="hljs-comment">// 创建副本</span><br>    <span class="hljs-built_in">f1</span>();              <span class="hljs-comment">// 调用 f1 当成调用 modifyDataAndDatabase(localData);</span><br>    <span class="hljs-built_in">f2</span>();              <span class="hljs-comment">// 调用 f2</span><br>    ...                <span class="hljs-comment">// 将修改后的副本交换到原状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们把<code>f1</code>当成上文的<code>modifyDataAndDatabase</code>, 仔细想想有什么问题.</p><p>大佬可能一眼就看出来了, 虽然<code>f1</code>的本身有强烈保证, 但是如果<code>f2</code>抛出了异常, <code>f1</code>中对<code>localData</code>的修改固然可以因为<code>copy and swap</code>回滚, 但是数据库的修改不能呀, 我们在<code>f1</code>中的数据库回滚操作无法延申到<code>f2</code>中! 所以无法实现完全的回滚, 这个函数是没有强烈保证的!</p><p>这种问题书中叫做”<strong>连带影响</strong>“, 即当一个函数对”非局部性数据”有影响时, 其被嵌套在其他函数内部时, 就算本身有强烈保证, 也会因为外部可能的异常连带产生错误. </p><p>这个问题提醒我们一个函数如果想有强烈保证, 不要嵌套影响”非局部数据”的函数, 非要嵌套也要确定其后没有任何异常产生的可能性.</p><hr><h3 id="异常安全性就像怀孕"><a href="#异常安全性就像怀孕" class="headerlink" title="异常安全性就像怀孕 . . ."></a>异常安全性就像怀孕 . . .</h3><p>作者提出, 一位女士若非怀孕, 就是没怀孕, 不可能说她”部分怀孕”; 同理, 一个系统内如果有一个函数不具备异常安全性, 整个系统就不具备异常安全性, 很不幸, C++由于对C的继承, 其很多传统代码其实是不具备异常安全性的, 不过我们应当尽力让我们的代码具备异常安全性, 同时也<strong>应当将自己对函数的安全性定义写成文档, 为我们的客户和后期维护者使用</strong>.</p><hr><h3 id="书中作者难得发出感叹-由此摘录"><a href="#书中作者难得发出感叹-由此摘录" class="headerlink" title="书中作者难得发出感叹, 由此摘录:"></a>书中作者难得发出感叹, 由此摘录:</h3><p>四十年前, 满载goto的代码被视为一种美好实践, 而今我们却致力于写出结构化控制流.</p><p>二十年前, 全局数据被视为一种美好实践, 而今我们却致力于数据的封装.</p><p>十年前, 撰写”未将异常考虑在内”的函数被视为一种美好实践, 而今我们却致力于写出”异常安全码”.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>“以对象管理资源”可以阻止资源泄漏, 调整语序和三种异常保证可能可以阻止数据败坏.</li><li>“基本承诺”诚可贵, “强烈保证”价更高, 若为”不抛掷”, 二者皆可抛.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>异常安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(2)</title>
    <link href="/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%952/"/>
    <url>/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%952/</url>
    
    <content type="html"><![CDATA[<ul><li><p>假如我们醒来并没有过上比睡前更崇高的生活, 那么白天也就没什么好期待的了.</p></li><li><p>人要是不相信在喧嚣的白日之前, 有者更神圣,更绚丽的时刻, 那么他对生活肯定已经感到绝望, 而他所走的人生之路肯定是江河日下, 越来越黑暗的.</p></li><li><p>只要我清醒着, 心中有光明, 那就是早晨.</p></li><li><p>我们必须学会再次苏醒, 并保持着清醒的状态, 但要借助的不是某些生硬的措施, 而是对黎明的无限期待, 这是在我们睡得最熟时也会也会有的期待.</p></li><li><p>狗屁新闻!最重要的是去了解那些永不过时的东西!</p></li><li><p>大人没能过上有价值的生活, 却自认为更聪明, 因为他们更有经验, 可惜他们的经验其实就是失败.</p></li><li><p>只有持续不断地渗入和浸泡在周围的现实之中, 我们才能理解一切圣洁而高贵的东西.</p></li><li><p>让我们把自己安顿下来, 好好地工作, 用力去踩踏脚下的烂泥, 那由成见,偏见,传统,谎言和表象搅成的烂泥, 直到我们的脚触及更坚硬的底部和安稳的岩石, 也就是我们说的现实, 有了这个立足点, 我们得以在将来的世代能够知道, 谎言和表象的洪水曾经积聚得有多深.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款28 避免返回handles指向对象内部成分</title>
    <link href="/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/"/>
    <url>/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款28-避免返回handles指向对象内部成分"><a href="#条款28-避免返回handles指向对象内部成分" class="headerlink" title="条款28 : 避免返回handles指向对象内部成分"></a>条款28 : 避免返回handles指向对象内部成分</h2><p>让我们先来明确本条款中的两个概念 : </p><ul><li>handle : 即句柄, 号码牌, 可以理解为各种<strong>指针, 引用, 迭代器</strong>.</li><li>内部成分 : <strong>private成员变量和成员函数</strong>.</li></ul><p>有了上面两个概念, 就可以比较直观地理解本条款了, 不过在通读完本条款后, 本条款虽说是<strong>避免返回handles指向对象内部成分</strong>, 但是其实内容着重在解释<strong>在必须返回handles指向对象内部成分的情况下, 会带来什么样的风险</strong>, 以此告诫我们注意. </p><hr><h3 id="降低对象封装性"><a href="#降低对象封装性" class="headerlink" title="降低对象封装性"></a>降低对象封装性</h3><p>书中指出, <strong>返回handles指向对象内部成分</strong>, 随之而来的便是**”降低对象封装性”的风险**, 如果不是有意设计, 我们<strong>不应令public成员函数返回一个handle指向private的成员变量</strong>, 这会使后者的<strong>实际访问级别变为public</strong>, 这是完全可以理解的.</p><p>书中描述了GUI中常有的矩形, 它一般会用左上点和右下点表示 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;                      <span class="hljs-comment">// 坐标点</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>  ...<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RectData</span> &#123;                    <span class="hljs-comment">// 矩形资源类</span><br>  Point ulhc;                        <span class="hljs-comment">// 左上点</span><br>  Point lrhc;                        <span class="hljs-comment">// 右下点</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<span class="hljs-comment">// 资源管理类 见条款13</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  std::shared_ptr&lt;RectData&gt; pData;    <span class="hljs-comment">// 存入智能指针进行管理    </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>客户一般会要求使用矩形的位置信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们用两个函数分别返回左上点和右下点, 这个操作很正常, 但是这给了客户捣乱的方式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Point <span class="hljs-title">coord1</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Point <span class="hljs-title">coord2</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(coord1, coord2)</span></span>;    <br><br>rec.<span class="hljs-built_in">upperLeft</span>().<span class="hljs-built_in">setX</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">// rec的左上点实际被修改为了(50, 0)!</span><br></code></pre></td></tr></table></figure><p>这种情况在条款3中也实际发生过, 就是<strong>通过const成员函数的返回值修改了类的内部数据</strong>, 原因条款3中已经解释过了, 解决方式也很简单, 给返回值也加一个<code>const</code>就好了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>重新整理思路, 封装性在于<strong>数据隐藏</strong>, 在于<strong>限制外部对内部的访问与修改</strong>. 以上函数做到了<strong>访问权的让渡与修改权的禁止</strong>, 访问权让渡是因为有必要的客户需求, 修改权禁止是应为客户没有权限修改内部, 以此在提供必要功能的前提下使对象达到了最好的封装性.</p><hr><h3 id="空悬句柄-dangling-handles"><a href="#空悬句柄-dangling-handles" class="headerlink" title="空悬句柄(dangling handles)"></a>空悬句柄(dangling handles)</h3><p>空悬句柄和C中的野指针很相似, 书中给出了某个函数返回GUI对象的外框(矩形)的例子 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUIObject</span> &#123; ... &#125;; <br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">boundingBox</span><span class="hljs-params">(<span class="hljs-type">const</span> GUIObject&amp; obj)</span></span>;  <span class="hljs-comment">// 返回一个矩形    </span><br><br>GUIObject *pgo;   <br>...                                  <br><span class="hljs-type">const</span> Point *pUpperLeft = &amp;(<span class="hljs-built_in">boundingBox</span>(*pgo).<span class="hljs-built_in">upperLeft</span>());  <span class="hljs-comment">// 这里pUpperLeft是一个空悬句柄                   </span><br></code></pre></td></tr></table></figure><p>我们来解释最后一句代码 : </p><ol><li><code>boundingBox(*pgo)</code> 利用<code>pgo</code>调用<code>boundingBox</code>函数</li><li><code>boundingBox</code>函数返回一个临时矩形对象(这是一个匿名对象, 以下简称<code>temp</code>)</li><li><code>temp</code>调用<code>upperLeft()</code>得到该临时对象的左上点</li><li>取出右上点的地址赋值给<code>pUpperLeft</code></li></ol><p>最后的结果就是<code>pUpperLeft</code>获得了一个来自临时对象的指针, 当控制域离开该行, 这个指针将成为一个野指针, 则称<code>pUpperLeft</code>是一个空悬句柄, 它指向了一个不存在的对象.</p><p>因此书中告诉我们, <strong>返回handles指向对象内部成分总是危险的</strong>, 不管这个<code>handle</code>是否为<code>const</code> 唯一造成危险的事实就是, <strong>有个handle被传出去了</strong>, 因此就有可能出现<strong>handle比其所指对象更长寿</strong>的风险, 这才是问题的核心.</p><p>然而指出这个风险不是说就不应该返回<code>handles</code>, 我们总会有许多需求需要访问内部成分, 这种风险避无可避, 而是在告诫我们时常注意空悬句柄问题, <strong>不要让我们的指针&#x2F;引用&#x2F;迭代器因为比其所指对象更长寿而失效</strong>.</p><p>我们可以再通过一个例子来加深理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) v.<span class="hljs-built_in">erase</span>(it);<br>    ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是非常经典<strong>迭代器失效</strong>问题, 这个例子在遍历<code>v</code>, 将<code>v</code>中等于3的元素删除, 这段代码看似合理, 但是结合我们上面的理解, 在触发<code>erase</code>后, <code>it</code>迭代器指向的对象其实已经被销毁了, 这时<code>++it</code>就变为了未定义的操作, 在<code>vs</code>中甚至会直接报错, 如果我们可以提前发现这个问题, 就可以做出以下改进 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) it = v.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">else</span> ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用<code>erase</code>的返回值对<code>it</code>重新赋值, 使其免于失效.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能避免返回<code>handles</code>指向对象内部成分, 这可以提升对象封装性, 避免<code>dangling handles</code>出现.</li><li>避无可避时谨慎释出内部成分的访问权与修改权, 修改权可用<code>const</code>禁止, 注意<code>dangling handles</code>问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款27 类型转换</title>
    <link href="/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="条款27-尽量少做转型动作"><a href="#条款27-尽量少做转型动作" class="headerlink" title="条款27 : 尽量少做转型动作"></a>条款27 : 尽量少做转型动作</h2><blockquote><p>优良的C++代码很少使用转型, 但是要完全摆脱它们又太过不切实际, 我们应当保证”类型错误”绝无可能发生. 本条款在了解各种转型动作的前提下, 指出了一些有风险的转型操作及其解决方法.</p></blockquote><p>我们先来回顾一下类型转换 : </p><h4 id="旧式C风格转型"><a href="#旧式C风格转型" class="headerlink" title="旧式C风格转型"></a>旧式C风格转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(T)expression;<br><span class="hljs-built_in">T</span>(experssion);<br></code></pre></td></tr></table></figure><h4 id="新式转型"><a href="#新式转型" class="headerlink" title="新式转型"></a>新式转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure><ul><li>static_cast : 强制隐式转换, 适合除常量性移除之外的大部分转换场景.</li><li>const_cast : 唯一可以常量性移除的转换, 而且能且仅能移除常量性.</li><li>dynamic_cast : “安全向下转型”, 可以理解为一个有安全类型检查的可以将基类转为派生类的<code>static_cast</code>.</li><li>reinterpret_cast : 低级转型, 现在很少用了.</li></ul><hr><p>书中提出第一个观点 : 除非你确定转型没有任何风险, 并且旧式转型很方便, 应当<strong>始终理智使用新式转型</strong>, 以下为原因 : </p><ol><li>新式转型<strong>很容易在代码中被识别出来</strong>, 有助于编译器或其他工具识别.</li><li>新式转型<strong>细化了转型动作的目标</strong>, 使得编译器更容易诊断出错误的运用.</li></ol><hr><h4 id="避免做出”对象在C-中如何布局”的假设"><a href="#避免做出”对象在C-中如何布局”的假设" class="headerlink" title="避免做出”对象在C++中如何布局”的假设"></a>避免做出”对象在C++中如何布局”的假设</h4><p>书中提醒我们, <strong>类型转换并不仅仅是“告诉编译器类型的变化”</strong>, 它是会实际产生额外代码的, 而且有可能对当前对象布局做出调整, 例如将基类指针从原本的指向的基类, 改为指向派生类, 我们也许会认为前者和后者的指针地址是一样的, 实际也确实大多数情况都是一样的(包括我测试的), 但是书中说对象布局方式会依照编译器的不同而不同, 确实会发生前后者指针不一样的情况出现, 而且在出现多重继承是这种情况会更多. 所以作者告诫我们, <strong>“由于知道对象如何布局”而设计的转型, 在某些平台行得通, 在其他平台并不一定</strong>.</p><hr><h4 id="避免用类型转换写出似是而非的代码"><a href="#避免用类型转换写出似是而非的代码" class="headerlink" title="避免用类型转换写出似是而非的代码"></a>避免用类型转换写出似是而非的代码</h4><p>在写GUI时会有定义很多的窗口类, 这种应用框架一般会坚持派生类的重写会先调用父类版本, 于是就有了以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;                                <span class="hljs-comment">// base class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123; ... &#125;             <span class="hljs-comment">// 基类窗口重置尺寸</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;          <span class="hljs-comment">// derived class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;                   <span class="hljs-comment">// 派生类重写</span><br>    <span class="hljs-built_in">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();    <span class="hljs-comment">// 先调用父类版本的onResize()</span><br>    ...                                    <br>  &#125;                                          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们起初看可能还像一回事, 但是实际漏洞百出,  <code>static_cast&lt;Window&gt;(*this)</code>这个表达式返回的其实是一个**”<em>this对象值base class成分”的临时拷贝</em>*! <code>static_cast</code>在底层转换类型后进行切分, 然后把切分出来的部分拷贝返回. 也就是说真正调用基类<code>onResize()</code>的是这个临时对象, 而不是当前对象的基类部分, 想要真正使当前对象调用基类<code>onResize()</code>, 应以如下写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;<br>    Window::<span class="hljs-built_in">onResize</span>();                    <span class="hljs-comment">// 这样调用</span><br>    ...                                   <br>  &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="谨慎使用dynamic-cast"><a href="#谨慎使用dynamic-cast" class="headerlink" title="谨慎使用dynamic_cast"></a>谨慎使用dynamic_cast</h4><p>我们之所以需要<code>dynamic_cast</code>, 通常是因为我们手持一个<strong>静态类型是base而动态类型是derived的指针或引用</strong>时, <strong>想要使用只有derived中有的一个普通函数</strong>, 因为其不是虚函数, 所以我们现在无权使用它, 只能依靠<code>dynamic_cast</code>来进行较为安全的转换.</p><p>假设我们的<code>SpecialWindow</code>有一个单独的闪烁功能, 有一个<code>vector</code>中存放了大量的<code>Window</code>, 我们希望遍历该<code>vector</code>, 如果其动态类型是<code>SpecialWindow</code>就调用其闪烁功能, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 特有的blink功能</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;Window&gt; &gt; VPW;  <span class="hljs-comment">// 存放Window智能指针的数组</span><br>VPW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>();  ++iter) &#123;<br>  <span class="hljs-comment">// dynamic_cast转换成功说明是SpecialWindow类型, psw不为空, 判true, 调用blink</span><br>  <span class="hljs-comment">// 转换失败说明不是, psw为nullptr, 判false</span><br>  <span class="hljs-keyword">if</span> (SpecialWindow *psw = <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="hljs-built_in">get</span>()))<br>     psw-&gt;<span class="hljs-built_in">blink</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面算是对<code>dynamic_cast</code>的日常用法做了一个介绍, 但是作者告诉你使用<code>dynamic_cast</code>在很多情况并不必要, <strong>能不使用dynamic_cast就尽量不使用</strong>, 原因在于<code>dynamic_cast</code>为了实现安全性检测和其他一些目的, 效率十分低下, 相比于它的其他几个兄弟效率不只低了一点半点, 除非有<strong>必须是多态情况下用基类使用派生类普通函数的场景</strong>, 我们可以<strong>做出一些让步</strong>来提升我们的效率, 书中给出了两种方法 : </p><ol><li><p><strong>放弃多态需求</strong>, 确保容器内只有需求派生类的指针.具体来说就是<code>VPW</code>内只存<code>shared_ptr&lt;SpecialWindow&gt;</code>, 让<code>blink</code>的调用普遍化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW; <span class="hljs-comment">// 只存派生类智能指针</span><br>VPSW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>(); <span class="hljs-comment">// 直接调用</span><br></code></pre></td></tr></table></figure></li><li><p><strong>将普通函数转为virtual函数</strong>, <strong>略微增加写代码的成本</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 这里什么都不做, 其目的只是为了让SpecialWindow通过多态调用有效果的blink()</span><br>  ...<br>&#125;;                                            <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123; ... &#125;;                 <br>  ...                                          <br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;                                    <br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>();<br>     iter != winPtrs.<span class="hljs-built_in">end</span>();<br>     ++iter)                                  <br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>();  <span class="hljs-comment">// 正常的多态用法</span><br></code></pre></td></tr></table></figure></li></ol><p>最后总结下来就是, <strong>在出现dynamic_cast需求场景时, 如果代码对效率没有太多需求, 直接使用dynamic_cast, 反之则思考是否能做出上面所说的两种让步, 如果前两种让步的代价实在太高再使用dynamic_cast</strong>.</p><p>书中还指出了一种应当杜绝的写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow1</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow2</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow3</span> &#123; ... &#125;;<br>...                    <br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;<br>...<br><br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>&#123;<br>  <span class="hljs-keyword">if</span> (SpecialWindow1 *psw1 =<br>       <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow2 *psw2 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow3 *psw3 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子的代码, 不仅效率低, 而且可维护性差, 最好将这种需求<strong>改写成某种virtual函数</strong>来实现, 不要去依赖<code>dynamic_cast</code>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>尽量避免转型</strong>, 尤其在注重效率的程序中避免<code>dynamic_cast</code>.</li><li>转型并非什么都没做, 会产生实际的花销.</li><li>如果转型是必要的, <strong>可以把转型过程放在一个函数中</strong>, 让客户调用该函数以实现转型, 而不需要将转型写入他们的代码.</li><li>最好使用<code>C++</code>风格的新式转型.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款26 尽可能延后变量定义式的出现时间</title>
    <link href="/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/"/>
    <url>/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款26-尽可能延后变量定义式的出现时间"><a href="#条款26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款26 : 尽可能延后变量定义式的出现时间"></a>条款26 : 尽可能延后变量定义式的出现时间</h2><p>只要你定义了一个变量, 并且其类型带有构造函数或析构函数, 那么当程序控制流到达变量定义式时, 你便得承担构造成本; 当变量离开作用域时, 你便得承担析构成本. 本条款希望我们避免<strong>定义变量但最终并未使用</strong>的情况, 不要白白浪费构造和析构的成本.</p><p>先来看看什么情况下会出现定义变量但最终并未使用 : </p><p>这是一个密码加密的函数, 由于密码本身不能修改, 所以要定义并返回一个<code>encryted</code>来表示<strong>加密后的密码</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  string encrypted;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  ...                        <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到, 当密码的长度小于最小值时, 我们的函数无法提供对应的服务, 所以要抛出一个<code>logic_error</code>异常, 然后就离开该函数了, 也就是说先前构造的<code>encrypted</code>确实没有发挥任何作用.</p><p>没错, <code>encrypted</code>并非完全未被使用, 但是仍然会有未被使用的情况存在, 为了不无端付出构造和析构的成本, 我们应将其<strong>定义式往后移</strong>, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  string encrypted;<br>  ...                     <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设还有一个<code>encrypt</code>函数, 里面通过复杂的算法将<code>password</code>加密, 那么我们应当把<code>password</code>赋值给<code>encrypted</code>, 再把<code>encrypted</code>传进去, 进而使函数修改<code>encrypted</code>实现加密 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  string encrypted;         <br>  encrypted = password;  <span class="hljs-comment">// 赋值             </span><br><br>  <span class="hljs-built_in">encrypt</span>(encrypted);<span class="hljs-comment">// 传入</span><br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就又有可以提升效率的地方了, 这里的行为是<code>defalut</code>构造 + 赋值, 但是我们在条款4就讨论过 : “<strong>通过default构造函数构造出一个对象然后对它赋值比直接在构造是指定初值效率差</strong>“, 就和<code>vector</code>中<code>emplace_back</code>比<code>push_back</code>效率高一个道理, 于是我们可以有以下的改良操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...                                   <br>  <span class="hljs-function">string <span class="hljs-title">encrypted</span><span class="hljs-params">(password)</span></span>;     <br>  <span class="hljs-built_in">encrypt</span>(encrypted);<br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们再回顾本条款的内容 : <strong>尽可能延后变量定义式的出现时间</strong>.</p><p>我们可以理解到”尽可能延后”的真正意义, 在于<strong>我们不应当只延后变量的定义, 直到非得使用该变量的前一刻为止, 甚至应该尝试延后这份定义直到能够给它初值实参为止</strong>. 这样不只能<strong>避免构造非必要对象</strong>, 还能<strong>避免无意义的defalut构造行为</strong>. 更深一层说, 以”具明显意义值初值”将变量初始化, 还可以附带说明变量的目的, <strong>提高代码的可读性</strong>.</p><hr><p>还有一个小问题, 循环怎么办? 我们在循环外定义只需要定义一次, 在循环内需要定义n次, 延后不是代价更大吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  w = 取决于某个i的值;       <span class="hljs-function">Widget <span class="hljs-title">w</span><span class="hljs-params">(取决于某个i的值)</span></span>;<br>  ...                                  ...<br>&#125;                                    &#125;<br></code></pre></td></tr></table></figure><p>我们分析两种写法的成本 : </p><ul><li>循环外 : 1构造 + 1析构 + n赋值</li><li>循环内 : n构造 + n析构</li></ul><p>确实就实际而言, 循环外的做法大体比较高效, 但这建立在: </p><ol><li>你知道赋值比”构造 + 析构”的成本低的情况下.</li><li>你的这部分代码对效率高度敏感.</li></ol><p>否则你应该使用循环内的做法.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能延后变量定义式的出现. 这样有助于<strong>避免浪费, 提升效率, 提高代码可读性</strong>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款25 考虑写出一个不抛异常的swap函数</title>
    <link href="/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款25-考虑写出一个不抛异常的swap函数"><a href="#条款25-考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25 : 考虑写出一个不抛异常的swap函数"></a>条款25 : 考虑写出一个不抛异常的swap函数</h2><blockquote><p>swap 是一个有趣的函数, 原本它只是STL的一部分, 而后成为了异常安全性编程中的脊柱, 有关异常安全性我在条款11中介绍过, 在之后的条款29中也将着重着墨. 由于swap相当有用, 适当的实现非常重要, 好的swap设计可以带来非凡的效率提升.</p></blockquote><p>swap顾名思义, 意为将两对象的值彼此赋予对方, 在现代标准库中的实现是这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        T temp = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// 使用移动拷贝会大大提高效率且不抛出异常</span><br>        a = std::<span class="hljs-built_in">move</span>(b);<br>        b = std::<span class="hljs-built_in">move</span>(temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出这只是简单的移动拷贝而已, 而我们经常会使用一个手法叫做<code>pimpl idiom</code>, 其”<strong>以指针指向一个对象, 内涵真正的数据</strong>“, 这种手法意在将数据管理和操作管理解耦, 可以进行更有效的设计, 而这种类调用标准库的<code>std::swap</code>往往是效率低下的, 书中给出的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetImpl</span> &#123;                          <span class="hljs-comment">// 保存Widget的数据</span><br><span class="hljs-keyword">public</span>:                                    <br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a, b, c;                            <br>  std::vector&lt;<span class="hljs-type">double</span>&gt; v;                  <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                              <span class="hljs-comment">// 日常使用的Widget</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; rhs);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  WidgetImpl *pImpl;                         <span class="hljs-comment">// 一个指针指向数据</span><br>&#125;;           <br></code></pre></td></tr></table></figure><p>如果我们调用标准库中的<code>std::swap</code>, 其消耗是<strong>三次移动拷贝并且还有可能多余地拷贝双方的底层资源</strong>, 有可能产生更大的花销, 所以我们希望自定义的<code>swap</code>可以只交换<code>pImpl</code>的指针即可.</p><p>现在我们现在需要重新拟定一下我们的目标, 其一<strong>确保我们的swap函数不抛异常</strong>, 这是为了其在异常安全性上的功能得以实现; 其二<strong>让其他人调用swap时都能取得我们提供的高效的版本</strong>.</p><hr><p>前者只需我们记得不做有异常风险的举动就行了, 但是在<code>C++11</code>已经推行的当下, 我们还应<strong>必须</strong>给我们的函数贴心地加上<code>noexpect</code>标识符, 用来对编译器保证该函数绝不会抛出异常, <strong>编译器也会回应你的保证, 删去针对该函数的异常处理, 使效率提高</strong>. </p><hr><p>现在开始分析后者, 这里我们要知道一个前提, 大多数用户调用<code>swap</code>其实都是以标准库中的形式来调用的, 也就是说不会通过对象调用<code>swap</code>成员函数, 而是都是<code>swap(lhs, rhs)</code>这样的形式, 现在先研究在<code>C++98</code>版本下如何解决 :</p><p>书中给出的步骤如下:</p><ol><li>像我们先前一样写一个完美的不抛异常的<code>swap</code>成员函数.</li><li>在该<code>class</code>的命名空间下写一个<code>non-member swap</code>函数, 并使它调用该<code>class</code>的成员函数.</li><li>最后如果你的<code>class</code>不是<code>class template</code>(模板类), 为你的<code>class</code>全特化<code>std::swap</code>.</li></ol><p>我们来解释为什么要写三个函数, 即<strong>member + non-member + std全特化</strong> :</p><p>简单来说就是使在客户调用<code>swap(a, b)</code>时, 如果这个函数在<code>WidgetStuff</code>命名空间中, 就会直接匹配<code>non-member</code>版本, 进而调用相同命名空间下的<code>member</code>版本, 不会因为参数不匹配而没有调用到<code>member</code>版本. 而当客户调用标准库<code>swap</code>时, 由于模板全特化, 也会自动调用<code>member</code>版本.这样就极大程度上使得调用到的版本都是我们的特化版本.</p><p>由上面上述构成的最终方案如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span>  </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 下面解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-keyword">template</span>&lt;&gt;                       <span class="hljs-comment">// 对于swap针对Widget类型的全特化</span><br>  <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)<br>  &#123;<br>    a.<span class="hljs-built_in">swap</span>(b);                 <br>  &#125;                                <br>&#125;<br></code></pre></td></tr></table></figure><p>这里要解释一下为什么<code>member</code>版本中要加<code>using std::swap;</code>而不是直接用<code>std::swap(pImpl, other.pImpl)</code>, 因为不必写死只用标准库, <code>pImpl</code>也有可能是有自定义<code>swap</code>函数的类对象, 这样子可以<strong>让编译器优先选择类的自定义swap</strong>, 并且通过<code>using std::swap;</code>暴露了标准库接口, <strong>在没有自定义的情况下最后也会选择标准库版本</strong>.</p><hr><p>以上是<code>C++98</code>版本的解决方法, 但在<code>C++11</code>已经引入的当下, 推出了一个新的机制<strong>参数依赖查找 (ADL, Argument-Dependent Lookup)</strong>, 这个机制简单来说就是在<code>C++98</code>时的函数查找机制都<strong>只是在当前作用域或using声明中查找</strong>,  <strong>而ADL可以通过参数的类型将该类型所在的命名空间纳入查找范围</strong>. 这对我们上述的解决办法有何助益? 答案是我们不需要执行第三步了, 也就是说可以放弃对<code>std::swap</code>的全特化了.</p><p>在C++98的情况下, 如果当前作用域中没有<code>non-member</code>版本, 就一定会回到使用标准库的情况, 所以对<code>std::swap</code>进行全特化是有必要的. 而<code>ADL</code>可以通过参数类型引入作用域, 只要<code>non-member</code>版本和<code>member</code>版本在同一命名空间下, 就一定可以调用成功, 就是说<strong>只要你认真实现了前两步, 就一定不会在发生调用标准库<code>swap</code>的情况</strong>, 我们对标准库swap的需求就已经降低到了只需要默认版本的程度, 不需要任何的特化, 所谓的特化已经成为”98往事”了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 上面已经解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意为了符合<code>C+11</code>版本, 我们新加了<code>noexcept</code>关键字, 添加的原因上文已经说明.</p><hr><p>这次我基于<code>C++11</code>的新增机制对书中条款的解读做出了比较大的变化, 让其更适应2024年的现在, 写了很多原本书中没有的内容, 可能会有自己考虑不周的地方, 欢迎评论指正!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>当std::swap对你的类型效率不高时, 提供swap的member版本和non-member版本, 确定这两个函数不抛出异常, 并且标明noexpect</strong>.</li><li>如果你的版本还在<code>C++98</code>, 可能还要考虑多提供对<code>std::swap</code>的全特化.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款24 类型转换与non-member函数</title>
    <link href="/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款24-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24: 若所有参数皆需类型转换, 请为此采用non-member函数"></a>条款24: 若所有参数皆需类型转换, 请为此采用non-member函数</h2><blockquote><p>虽然令classes支持隐式类型转换是一个坏主意, 但常常有许多意外出现, 有些类型之间的关联实在太强, 我们经常想把它们放在一起用,       例如支持int类型隐式转换为Rational(有理数), 当对便利性的需求非常强烈之后, 也许支持隐式类型转换也未必是坏事.</p></blockquote><p>书中给出了一个<code>Rational</code>类, 它可以由<code>int</code>类型隐式转化而来 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,        <span class="hljs-comment">// 这里没有加explicit</span><br>           <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);     <span class="hljs-comment">// 传入int类型可隐式转换为分母是1的Rational类型</span><br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 获取分子</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 获取分母  // 见条款22</span><br><br><span class="hljs-keyword">private</span>:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们一定希望<code>Rational</code>类型可以和int类型相乘, 所以我们来写一个成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                       <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了以上的函数, 我们看看能通过哪些代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * oneEighth;            <span class="hljs-comment">// fine</span><br>result = result * oneEighth;                      <span class="hljs-comment">// fine</span><br><br>result = oneHalf * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneHalf;                             <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个例子无法通过编译, 原因很容易理解, 让我们重写一下上述两个式子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result = oneHalf.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">2</span>);                    <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2.</span><span class="hljs-keyword">operator</span>*(oneHalf);                    <span class="hljs-comment">// 2还没隐式转换, 怎么可能使用operator*</span><br></code></pre></td></tr></table></figure><p>因此我们有了这样的推论 : <strong>只有当参数被列于参数列内, 这个参数才是隐式转换的合格参与者</strong>.</p><p>至于”被调用之成员函数所隶属的哪个对象”, 即<strong>this对象</strong>, 绝不是隐式转换的合格参与者.</p><p>为了支持这样的混合算术运算, 可行之道拨云见日 : </p><p><strong>让operator*成为一个non-member成员函数</strong>, 即可让编译器在每一个实参上执行隐式类型转换. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><span class="hljs-comment">//-----------------------//</span><br><span class="hljs-function">Rational <span class="hljs-title">oneFourth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>Rational result;<br>result = oneFourth * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneFourth;                           <span class="hljs-comment">// fine</span><br></code></pre></td></tr></table></figure><p>问题解决, 皆大欢喜. 有了以上的经验, 我们在看别人代码时, 就不会奇怪于为什么总是要把双目运算符的重载都放在类外作为<code>non-member</code>定义了, 说明他们也深谙上述的道理, 也许有时并没有隐式转换的需求大家还是这样写, 可能是因为习惯了.</p><hr><p>有人可能认为<code>operator*</code>可以作为友元与<code>Rational</code>类加强联系, 但完全没必要, 除非它要调用<code>Rational</code>的<code>private</code>数据, 不然这样只会降低其封装性(见条款23), 我们<strong>不应当只因函数不该成为member, 就自动让它成为friend</strong>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>如果你需要为某个函数的所有参数进行类型转换, 那么这个函数必须是个<code>non-member</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(1)</title>
    <link href="/2024/12/02/2024-12-2-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2024/12/02/2024-12-2-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>人只有想起自己的无知才能有长进, 但他如此忙碌于运用自己已有的知识, 又如何能想得起来呢?</p></li><li><p>受制于对自己的看法, 受制于他通过自己行动所赢得的名誉.</p></li><li><p>大家好像都选择了相同的生活模式, 好像这种模式是在他们清醒时做出的选择, 然而其实他们并不认为还有其他模式可选, 但聪敏而健康的人记得太阳每天都会升起.</p></li><li><p>所有的改变都是奇迹, 但这种奇迹时时刻刻都在发生.</p></li><li><p>在当前的境况中找到他们的勇气和灵感, 怀着恋人般的怜爱和热情, 珍惜着此时此刻的生活.</p></li><li><p>没有人会因为衣服上有补丁而显得卑贱.然而我敢说, 普遍而言, 人们追求衣服时髦或者至少干净并且没有补丁的心情, 远比追求良知完整无损的心情要迫切.</p></li><li><p>商品的价格就是你用来换它的那部分生命.</p></li><li><p>让群众热切地跟风的时尚其实都是奢靡浪费的人设定的.</p></li><li><p>最好的艺术作品应该表现人如何奋斗着将自己从这种境况中解放出来, 但我们的艺术却只致力于使某种境界变得舒适, 并让人忘记更高级的境界.</p></li><li><p>在用美丽的物品装饰房子之前, 我们必须清理墙壁, 清理我们的生活, 还必须有美丽的家务管理和美丽的生活方式做基础.</p></li><li><p>对于生活, 大学生不应抱着玩乐的态度, 也不应只是研究它, 而是自始至终真诚地去过好它.</p></li><li><p>我盼望每个人都能非常清醒地去发现和追求他自己的生活方式.</p></li><li><p>做好事, 做人们常说的好事, 绝不应成为我人生的主要目标, 而且基本上绝不应刻意为之.与其去做好事, 不如做个好人.</p></li><li><p>人世间最难闻的莫过于变了味的好事.</p></li><li><p>做好事几乎是人人都称赞的美德, 人们不仅称赞他, 还给予他过高的评价; 而高估他的, 正是我们的自私心.</p></li><li><p>我们应该散发出去的, 不是绝望, 而是勇气, 不是病态, 而是健全.</p></li><li><p>所有的健康和成功都对我有益处, 哪怕他可能显得遥不可及; 所有的疾病和失败只会让我感到悲伤和对我有坏处, 哪怕他能引起我的怜悯, 或者让我得到许多同情.</p></li><li><p>我们不要去做管理穷人的官员, 而是要努力成为对这个世界有贡献的人.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款22-23 封装性相关</title>
    <link href="/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款22-将成员变量声明为private"><a href="#条款22-将成员变量声明为private" class="headerlink" title="条款22 : 将成员变量声明为private"></a>条款22 : 将成员变量声明为private</h2><p>本条款中, 作者明确声明, 如果没有必要的原因, 务必将成员变量声明为<code>private</code>, 而非<code>public/protected</code>, 并苦口婆心地列举出了非常多使用<code>private</code>的优势, 让我们逐一阅览 : </p><ul><li><h4 id="保证了语法一致性"><a href="#保证了语法一致性" class="headerlink" title="保证了语法一致性"></a>保证了语法一致性</h4><p>当客户通过对象调用时, 如果将成员变量声明为<code>private</code>, 那么就省去了客户思考要不要加小括号的问题, 只要无脑加括号就行了.</p></li><li><h4 id="对成员变量的处理更加精确"><a href="#对成员变量的处理更加精确" class="headerlink" title="对成员变量的处理更加精确"></a>对成员变量的处理更加精确</h4><p>当你把成员变量声明为<code>public</code>时, 客户拥有对该变量的所有特权, 可读可写, 然而我们一定不希望这样, 如果我们把成员变量声明为<code>private</code>, 通过<code>public</code>函数, 我们希望客户读时就返回一个<code>const reference</code>, 希望写就让客户传入修改值, 在函数内部修改, 如果不希望读写就不暴露在外置接口中.</p></li><li><h4 id="保证了封装性"><a href="#保证了封装性" class="headerlink" title="保证了封装性"></a>保证了封装性</h4><p>书中提出 : <strong>Public意味不封装, 不封装意味不可改变</strong>, 因为成员变量很大程度上是会被广泛使用的, 会出现在无数客户代码中, 如此牵一发而动全身, 就算你以后想改, 可客户就不一定想改了. <code>protected</code>也是同理, <strong>protected成员变量就像public成员变量一样缺乏封装性</strong>, 虽然成员变量并不开放给客户, 但是如果你之下有无数的派生类, 带来的修改难度也是非同一般, 由此可以得出一个结论 : <strong>成员变量的封装性与”成员变量的内容改变所破坏的代码数量”成反比</strong>.</p><p>而当我们使用private成员变量, 我们的修改范围就仅仅只局限在类内, 非常易于事后的修改. <strong>就算外部可以通过函数访问该成员变量, 日后希望对这个变量进行替换或修改, 外部也全然不知. 也就是说, 把成员变量隐藏在函数接口背后, 可以为所有可能的实现提供弹性</strong>.</p><p>书中给出了一个速度收集器的类, 保存每次测量到的速度, 可以返回当前状态下的速度平均值, 雏型如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedDataCollection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; data;<br>  ...<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span></span>;          <span class="hljs-comment">// 将收集到的速度存入data中</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">averageSoFar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 通过某些算法求得平均值并返回</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来假定一个情景, 这个类使用于一个嵌入式模板内, 一开始我们的可使用内存很少, 也不是很要求高效, 于是我们在<code>averageSoFar()</code>中的策略就是遍历<code>data</code>, 求出总和再求平均值. </p><p>当我们技术不断提高, 可使用内存变大了, 对计算效率有了需求, 我们就可以多加一个<code>private</code>成员变量<code>sum</code>额外记录<code>data</code>的总和, 然后修改<code>averageSoFar()</code>中的处理逻辑, 让其直接用<code>sum</code>求平均值, 效率可以从<code>O(N)</code>提到<code>O(1)</code>. </p><p>然而不管我们修改了什么, 外部<code>averageSoFar()</code>的使用者都不会知道.</p><p>这种<strong>把成员变量隐藏在函数接口背后</strong>的方式, 除了以上行为, <strong>还可以使得成员变量被读写时轻松同时其他对象, 验证class的约束条件以及函数的前提和事后条件, 实现在多线程环境中执行同步控制</strong>.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>切记将成员变量声明为<code>private</code>. 这有助于一致性, 访问控制, 允许约束条件获得保证, 提升类的实现弹性.</li><li><code>protected</code>并不比<code>public</code>更具封装性.</li></ul><hr><h2 id="条款23-宁以non-memeber-non-friend替换member函数"><a href="#条款23-宁以non-memeber-non-friend替换member函数" class="headerlink" title="条款23 : 宁以non-memeber non-friend替换member函数"></a>条款23 : 宁以non-memeber non-friend替换member函数</h2><p>本条款告诉我们, 如果一个成员函数没有直接访问成员变量的需求, 那么推荐将其替换为<code>non-memeber</code>且<code>non-friend</code>的函数.</p><p>想理解本条款可以先对封装性有进一步的认知 : </p><p>书中提出, 封装的本质在于<strong>隐藏内部实现和暴露有限接口</strong>, 至于我们为什么推崇封装, 是因为它<strong>使我们能改变的事务只影响有限客户</strong>, 就是说大大降低了我们后期做出改变时的维护成本. </p><p><strong>一个类的封装性和它的数据, 也就是成员变量息息相关</strong>, 愈少的代码可以看到数据, 愈多的数据就可以被封装, 封装性也就越强. </p><p>然而我们通常情况下认为数据以及操作数据的那些函数应该被捆绑在一起, 这样子是在实现所谓的封装, 然而正如我们前面所说, <strong>愈多成员函数可以访问数据, 数据的封装性就越低</strong>.</p><p>成员函数是实现封装的必要手段, 但并不代表我们可以毫无顾虑地增加成员变量, 每有一个函数可以访问到内部数据, 我们的维护成本就会提高一些, 因为你不一定会记得哪个函数有没有在什么不起眼的地方调用了我们的底层数据. 当然如果你预想的成员函数必须调用成员变量, 那完全没有问题. </p><p>书中给出了一个用于管理网络浏览器的类, 其中有一些用来清理的函数, 有的用来清理高速缓冲区, 有的用来清理历史记录, 有的用来移除<code>cookie</code>, 让我们看看书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在大多数情况下是希望同时调用这三个函数的, 于是我们可以写一个统合函数<code>clearBrowser()</code>, 按照习惯我们可能就把它写为成员函数了, 但有了上面的认知, 我们可以直接把它写成一个<code>non-memeber non-friend</code>函数,  代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br>    <span class="hljs-comment">// void clearBrowser(WebBrowser&amp; wb); // 请放弃这种写法</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>  wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们知道<code>clearBrowser</code>内部不会以任何形式直接调用数据,  所以干脆直接把<code>clearBrowser</code>排除在外, 这不只是告诉未来的自己, 也是在告诉将要维护这份代码的其他人, 这个函数从机理上就不可能触及底层数据, 是绝对安全的, 封装性因此得到提升.</p><p>当然还是要把他俩放在<strong>同一个命名空间</strong>内, 不然就真互相找不到了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>书中还提出 : 像是这种<code>clearBrowser</code>不触及底层数据的伪成员函数, 我们一般称其为便利函数, <strong>将所有的便利函数放在多个头文件内但隶属于同一个命名空间, 可以使编写者轻松找到并扩展某些方向的便利函数</strong>, 示例如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<span class="hljs-comment">// 核心机能</span><br>     ...                                <br>&#125;<br><br><span class="hljs-comment">// header &quot;webbrowserclear.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>; <span class="hljs-comment">// 有关内存清理的便利函数</span><br>  ...                                   <br>&#125;   <br><br><span class="hljs-comment">// header &quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关书签日志的便利函数</span><br>&#125;                                       <br><br><span class="hljs-comment">// header &quot;webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关cookie的便利函数</span><br>&#125;                                      <br>...<br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>宁以<code>non-memeber non-friend</code>替换<code>member</code>函数, 如果这个函数没有访问底层数据的必要的话. 这样子可以增加封装性, 包裹弹性和可扩展性.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款21 必须返回对象时, 别妄想返回其reference</title>
    <link href="/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/"/>
    <url>/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    
    <content type="html"><![CDATA[<h2 id="条款21-必须返回对象时-别妄想返回其reference"><a href="#条款21-必须返回对象时-别妄想返回其reference" class="headerlink" title="条款21 : 必须返回对象时, 别妄想返回其reference"></a>条款21 : 必须返回对象时, 别妄想返回其reference</h2><blockquote><p>当程序员领悟了条款20所讲的pass-by-value的种种效率问题之后, 往往会变成十字军战士, 一心一意根除pass-by-value的存在, 然而这却会让他们犯下一些致命的错误, 通过本条款让我们来了解.</p></blockquote><p>阅读完本文章, 我更倾向于把本条款解释为 :</p><ul><li>必须返回<strong>新</strong>对象时, 别妄想返回其reference.</li></ul><p>这样子会更便于理解.</p><p>书中给出了一个有理数类, 用于计算一个有乘积的有理数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,<span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> n, d;  <span class="hljs-comment">// 有理数的分子和分母</span><br><br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们最初的设想, <code>operator*</code>是传值返回的, 这不由得引发我们顾虑, 我们确实是希望其返回一个新的代表<code>lhs</code>和<code>rhs</code>乘积的<code>Rational</code>对象, 但是传值返回的拷贝构造成本也许会很高, 因此有不同的程序员想出了三种不同返回策略, 但无一例外都是错误的, 让我们看书中逐一反驳.</p><hr><h4 id="返回一个pointer-reference指向一个-local-stack-对象"><a href="#返回一个pointer-reference指向一个-local-stack-对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个 local stack 对象"></a>返回一个pointer&#x2F;reference指向一个 local stack 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们的目的是避免调用构造函数, 这样不仅没有避免, 而且<code>result</code>还是一个<code>local</code>对象, 出了作用域就会被销毁, 返回的引用是一个悬挂引用! 我们首先应当知道的, 就是不要让函数返回一个函数内局部变量的<code>reference</code>, 也就是返回引用的生命周期一定要大.</p><hr><h4 id="返回一个reference指向一个heap-allocated对象"><a href="#返回一个reference指向一个heap-allocated对象" class="headerlink" title="返回一个reference指向一个heap-allocated对象"></a>返回一个reference指向一个heap-allocated对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>  <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其一还是会进行构造, 其二这会带来严重的内存泄露, 首先你必须记得在外部要执行delete, 其次当你进行连乘时, 例如<code>a * b * c</code> , 你永远无法获得<code>b*c</code>是new出来的指针, 也就是说必然内存泄露.</p><hr><h4 id="返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象"><a href="#返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象"></a>返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,    <span class="hljs-comment">// 有风险的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)    <br>&#123;<br>  <span class="hljs-type">static</span> Rational result; <br>  result = ...;            <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个原理上看来没有问题, 但是只要使用<code>static</code>对象就一定会伴随着多线程情况下的风险, 这样就显得有弊端了, 除非你可以保证这个代码不会在多线程情况下出问题或是通过锁保证了线程安全, 就像我们条款4中提到的初始化策略一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>    <span class="hljs-keyword">return</span> timekeeper;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会确保这个函数在多线程之前的单线程阶段就都调用过一次来实现初始化.</p><hr><p>看过以上的三种情况后, 最后还是直接返回对象吧!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说即使要承担构造和析构的成本, 也还是推荐直接传值返回, 但是要知道Effective C++已经是十几年前的老书了, 现在伴随着C++11的引入, 带来了<strong>移动语义</strong>的新机制, 这种机制对传值返回带来了极大的优化, 简单来说就是不会有多余的构造和析构了, <strong>编译器会直接在原本要析构的临时对象上直接构建要传出的新对象</strong>, 也就是说传值返回的效率得到了极大的提升, 而这也与本条款的要求不谋而合, 可见Effective C++的条款还是禁得住时间历练的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>绝对不要返回一个<code>pointer/reference</code>指向一个<code>local stack</code>对象, 返回一个<code>reference</code>指向一个<code>heap-allocated</code>对象, 返回一个<code>pointer/reference</code>指向一个<code>local static</code>对象而有可能同时需要多个这样的对象. </p></li><li><p>请优先考虑传值返回吧, 在C++11引入移动语义后它如有神助!</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款20 宁以pass-by-reference-to-const替换pass-by-value</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    
    <content type="html"><![CDATA[<h2 id="条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20 : 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20 : 宁以pass-by-reference-to-const替换pass-by-value</h2><blockquote><p>本条款将告诉我们函数传参时的最佳策略.</p></blockquote><p>我们都知道, <code>pass-by-value</code>(传值传参)是一个费时费力的过程, 它会直接复制一个原件的拷贝, 如果是自定义类就会调用一次拷贝构造来实现复制, 函数结束时还要额外调用一次析构函数, 我们会很有意愿去削减这方面的花销.</p><p>相信我们在别处的很多函数中都看见过<code>pass-by-reference-to-const</code>的存在, 在本书中也极力推荐这种写法, 足矣见得这种写法的高效与广泛, 就像下面这行函数定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><p>reference的底层一般是个指针, 也就是说我们只是用了一个传递指针的花销就实现了参数的传递, 再加上const, 这对我们传入引用的安全性给予了保证,  使得这个写法<strong>兼具了效率与安全</strong>, 是不可多得的好事.</p><p>另外书中还给出了一个好处 : <strong>避免对象切割问题</strong>.</p><p>我们都知道多态中的动态类型是依靠指针和引用来触发的, 简单来说就是也许某个指针或引用的静态类型是基类, 但是动态类型可以通过实际的赋值来改变, 实现动态类型的绑定, 这点可是一个普通的类对象做不到的. 当我们使用<code>pass-by-reference-to-const</code>, 其实也就符合了这种性质, 我们来看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<span class="hljs-comment">// 普通窗口</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 返回窗口名</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 窗口显示函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window &#123;<span class="hljs-comment">// 高级窗口! 它带滚动条!</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 对窗口重写</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面是一对父子类, 下面是分别用两种传值方法的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span>         <span class="hljs-comment">// pass-by-value</span></span><br><span class="hljs-function"></span>&#123;                             <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span>   <span class="hljs-comment">// pass-by-reference-to-const</span></span><br><span class="hljs-function"></span>&#123;                                           <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用以下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<br></code></pre></td></tr></table></figure><p>如果我们调用前者, 答案是只能调用基类的<code>display()</code>, 因为<strong>对象被切割了</strong>, <code>wwsb</code>被强行从派生类被切割成了基类, 这很正常, 传一个对象可没有什么多态的机制.</p><p>如果我们调用后者, 结果很成功, 调用的就是派生类的<code>display()</code>, 因为<code>w</code>虽然静态类型是<code>Window</code>, 但由于引用的对象<code>wwsb</code>类型是<code>WindowWithScrollBars</code>, 所以动态类型绑定为了派生类, 调用就正确了. 说的有些复杂了, 可以宏观理解为<code>pass-by-reference-to-const</code>是虚函数机制实现的必要手段.</p><hr><p>吹了那么久<code>pass-by-reference-to-const</code>, 那么就没有什么情况要用<code>pass-by-value</code>的吗?</p><p>答案是有的, 先看书中给出的最终结论 : <strong>内置类型, STL迭代器, 函数对象推荐用pass-by-value</strong>.</p><p>原因很简单, <code>pass-by-reference-to-const</code>说到底也就是一个指针的花销, <strong>一些内置类型的花销甚至比指针花销还小</strong>, 而<strong>STL迭代器和函数对象内部也就是一个或几个指针</strong>而已, 差不了多少, 当然也有一部分原因是习惯所致.</p><p>有人可能认为只包含小型对象的自定义类型也可以用<code>pass-by-value</code>, 这样的想法是有漏洞的.</p><p>书中给出了三个原因 : </p><ol><li>对象小不代表<strong>构造和析构函数的花销</strong>就不小, 如果你直接<code>pass-by-value</code>一个STL的<code>set</code>, 其内部对象也就是几个指针, 是所谓的”小对象”, 但是构造和析构的开销就不知道大多少倍了.</li><li><strong>某些编译器对待内置类型和自定义类型的态度截然不同</strong>, 编译器很乐意把内置类型对象放进缓存器, 但一个自定义类对象就不会有此般关怀.</li><li><strong>一个类创建完后是需要维护的</strong>, 你现在对象小, 不代表以后就不会根据客户需求加入额外的变量, 除非你在一开始就把框架定死了.</li></ol><p>因此书中才给出了我们上面的最终结论.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽量以pass-by-reference-to-const替换pass-by-value, 前者高效, 安全, 并且有效解决了切割问题.</li><li>以上规则不适用于内置类型, STL迭代器, 函数对象, 它们适合pass-by-value.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款19 设计class犹如设计type</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    
    <content type="html"><![CDATA[<h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19 : 设计class犹如设计type"></a>条款19 : 设计class犹如设计type</h2><blockquote><p>C++ 是面向对象编程语言, 当你定义了一个新class, 也就定义了一个新type. 然而设计一个优秀的class是一项艰巨的任务, 正如设计一个好的type是一项艰巨的任务. 本条款将依照一个好的类型应有的行为来指导我们class的设计, 并一一列举出来.</p></blockquote><p>当我们要设计一个<code>class</code>时, 让我们对自己提出这些问题吧 : </p><ul><li><p><strong>新type的对象应该如何创建和销毁?</strong></p><p>想想<code>class</code>的构造和析构是否可以默认生成 不能的话该怎样编写.</p><p>想想是否要是设计内存的分配函数和释放函数.</p></li><li><p><strong>对象的初始化和对象的赋值该有什么样的差别?</strong></p><p>想想在<code>class</code>构造时需要有什么特殊的步骤, 以及是否需要设置一个<code>init</code>函数辅助构造.</p><p>想想<code>copying</code>时的策略是怎样的. (见条款14)</p></li><li><p><strong>新type的对象如果被 pass-by-value(以值传参) , 意味着什么?</strong></p><p>记住copy构造函数用来定义一个<code>type</code>被 <code>pass-by-value</code> 应当产生的行为.</p></li><li><p><strong>什么是新type的”合法值”?</strong></p><p>想想class的成员变量在你的预期中是否有一个合法的范围, 想想该怎样约束.</p><p>想想是否要设置超出合法范围时触发的检查机制.</p></li><li><p><strong>新type需要配合某个继承图系吗?</strong></p><p>如果其继承自某些既有的<code>class</code>, 你就应当受到那些<code>class</code>设计的束缚, 好好分析那些<code>virtual</code>函数是否要重写, 哪些不用.</p><p>尤其看看析构函数是否为<code>virtual</code>. (见条款7)</p></li><li><p><strong>新type需要什么样的转换?</strong></p><p>想想你的<code>class</code>可以和其他<code>class</code>产生什么可能且合理的转换, 如果有可以考虑实施.</p><p>如果有就写一个类型转换函数或接受其他类型的构造函数, 没有请声明<code>explicit</code>.</p></li><li><p><strong>什么样的操作符和函数对此新type而言是合理的?</strong></p><p>这个属于你的设计私事, 但也必须考虑清楚.</p></li><li><p><strong>什么样的默认成员函数应该驳回?</strong></p><p>将需要驳回的成员函数设置为<code>private</code>或者直接<code>delete</code>掉. (见条款6)</p></li><li><p><strong>谁该取用新type的成员?</strong></p><p>想想哪些成员应设为<code>public</code>, 哪些应设为<code>protected</code>, 哪些应设为<code>private</code>. </p><p>想想哪些<code>classes/functions</code>应是<code>friends</code>. </p></li><li><p><strong>什么是新type的”未声明接口”?</strong></p><p>想想你的<code>class</code>不对外的底层函数可以提供什么样的服务, 是否进行资源运用, 是否需要应对多线程情况, 以此在实现中加上相应的约束条件.</p></li><li><p><strong>新type有多么一般化?</strong></p><p>想想你的<code>class</code>是否要接受泛型编程, 有没有使用泛型编程的必要.</p></li><li><p><strong>真的需要一个新type吗?</strong></p><p>想想真的要定义一个新的class吗? 在你定义<code>derived class</code>时, 如果只是单纯地想添加一些机能, 而不是出于多态考虑, 那么说不定单纯定义一个或多个 <code>non-member</code> 函数或 <code>templates</code>, 更能够达到目标. 就像是<code>STL</code>源码中的<code>priority_queue</code>, 为了使用堆机制其实并没再建立一个专属的堆类, 而是写了几个用于调整堆结构的函数, 再套在<code>vector</code>上就实现了堆的功能.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>class</code>的设计就是<code>type</code>的设计, 在设计一个<code>class</code>之前请确定思考过本条款所提出的所有问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款18 设计正确易用的接口</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款18-让接口容易被正确使用-不易被误用"><a href="#条款18-让接口容易被正确使用-不易被误用" class="headerlink" title="条款18 : 让接口容易被正确使用, 不易被误用."></a>条款18 : 让接口容易被正确使用, 不易被误用.</h2><blockquote><p>C++在接口之海漂浮, 一个好的接口很容易被正确使用, 不容易被误用.</p></blockquote><p>条款18其实是一个很宏观的条款, 让接口变得正确易用, 简单来说就是”<strong>促进正确使用</strong>“和”<strong>阻止误用</strong>“.</p><p>我们先从<strong>阻止误用</strong>的角度考虑, 对接口来说, 是否误用无非就是参数传递的类型对不对, 参数是否合法, 是否符合设计者的设想.</p><p>书中给出了一个日期类, 分别由年月日的成员变量, 我们先来看第一个给出的构造函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样设计在设计者看来很合理, 但是没有任何合法性检查只会带来无穷的隐患, 我们可以从中看出以下问题 : </p><ul><li>客户不一定知道是按月日年的顺序来输入, 如果是我们的日常习惯, 可能会输入年月日.</li></ul><p>如何使用户在编写过程中就知道自己写错了呢? </p><p>书中告诉我们的方法是 : <strong>导入新类型</strong>, 因为问题的根源是年月日的变量类型都是相同的<code>int</code>, 如果设定为不同的类型, 就可以确保输入的正确性了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span> &#123;            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span> &#123;                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>     <span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>         <span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">  :val(d) &#123;</span>&#125;              :<span class="hljs-built_in">val</span>(m) &#123;&#125;                    :<span class="hljs-built_in">val</span>(y)&#123;&#125;<br><br>  <span class="hljs-type">int</span> val;                <span class="hljs-type">int</span> val;                      <span class="hljs-type">int</span> val;<br>&#125;;                      &#125;;                            &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>...<br>&#125;;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>;                      <span class="hljs-comment">// 错误, 不是int!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Day(<span class="hljs-number">30</span>), Month(<span class="hljs-number">3</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 错误, 顺序错了!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 正确, 类型和顺序相对应</span><br></code></pre></td></tr></table></figure><p>当然还有一些数值我们可以提前限制, 比如一年肯定只有12个月, 我们就可以让用户不用直接通过构造传参, 而是用函数返回需求的<code>Month</code>对象, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125; <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125;  <br>  ...                                       <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125; <br>  ...                                      <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>;  <span class="hljs-comment">// 不让用户显式使用构造, 只能通过成员函数内部调用</span><br>&#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month::Mar(), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <span class="hljs-comment">// 这样我们就可以这样调用了</span><br></code></pre></td></tr></table></figure><p> 书中提出<strong>以函数替换对象</strong>也是一种预防客户输入错误的方式.</p><p>当然通过<strong>const限制类型操作</strong>也是一种方式, 这里就不再举例.</p><hr><p>讲完了阻止误用, 那么如何<strong>促进正确使用</strong>呢? </p><p>正确使用, 简单来说就是<strong>符合使用者的习惯</strong>, 使用者的习惯是什么呢? 当然是<strong>使用内置类型</strong>呀, 使用者当然希望可以像使用<code>int</code>一样使用其他自定义的类型.</p><p>因此书中提出: <strong>除非有好理由, 否则应该尽量令你的自定义类型的行为与内置类型一致.</strong></p><p>实际来说就是<strong>用好运算符重载, 有必要时考虑迭代器的设计模式</strong>.</p><hr><p>书中还提出了一个重要观点 : </p><ul><li><strong>任何接口如果要求用户必须记得做某些事情, 就是有者”不正确使用”的倾向.</strong></li></ul><blockquote><p>接下来的内容有关条款13和14, 没有看过的可以看我往期的博客.</p></blockquote><p>让我们回到条款13中提出的<code>createInvestment()</code>工厂函数, 他会返回一个资源的原始指针, 而我们应当用<code>shared_ptr</code>去封装该指针, 这就成了用户必须记得做的事情, 那么为了让该函数返回的内容更易用, 我们可以在直接返回一个智能指针, 函数声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Investment* createInvestment();</span><br><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><hr><p>函数内部实现并非本条款的重点, 但是书中也花了部分篇幅去讲解, 我也会跟着解释清楚, 先看内部的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br>    <br>  ...                                <span class="hljs-comment">// 中间部分实现工厂函数的内存分配步骤</span><br>      <br>  <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到<code>shared_ptr</code>构造的两个参数我们可能会有点懵, 我们来一个个分析 : </p><p>首先我们明确<code>stl</code>中<code>shared_ptr</code>构造的第一个参数是<strong>原始资源类型的指针</strong>, 第二个参数是<strong>删除器函数</strong>.</p><p>先讲第二个参数, 看过条款14的都知道, <code>getRidOfInvestmen</code>t应当是我们提供给<code>shared_ptr</code>在析构时使用的函数, 它存在的意义在于某些类型没有传统的析构, 而是一些特殊的释放函数, 需要我们手动调用, 我们把这些函数放在删除器中, 就可以化手动为自动, 我们这里是假定<code>Investment</code>是有这种需求的类型, 如果不是当然可以不写. 这种由设计者自己定制删除器的行为其实也是在减少客户不必要的释放步骤, 与本条款的理念相符合.</p><p>接下来是第一个参数, 我们应当传入一个原始资源类型的指针, 按道理来说应该是通过<code>new Investment()</code> 返回一个指针直接存进去, 但这里选择先不进行动态分配, 直接存入一个<code>nullptr</code>, 而且由于<code>shared_ptr</code>构造不允许隐式类型转换, 所以要把<code>nullptr</code>强转成<code>Investment*</code>类型, 也就是<code>static_cast&lt;Investment*&gt;(nullptr)</code>了, 因此<code>retVal</code>刚生成时并没有分配到资源, 是在接下来中间部分实现内存分配.</p><p>这里深入一下, 为什么工厂函数中要先构造指针再分配内存, 而不是先分配内存再给指针构造? 这里有两点原因 : </p><ol><li><p>可能需要<strong>通过不同的条件以不同的方式分配内存</strong>, 这是也是工厂函数存在的意义所在.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">(<span class="hljs-type">bool</span> isPremium)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br><br>    <span class="hljs-comment">// 根据条件选择不同的分配方式</span><br>    <span class="hljs-keyword">if</span> (isPremium) &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;PremiumInvestment&gt;();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;RegularInvestment&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析以上代码, 我们可以知道<code>Investment*</code>的静态类型是一个基类指针, 但是通过<code>isPremium</code>和多态机制, 我们可以根据传入的<code>isPremium</code>来选择其动态类型是派生类的<code>PremiumInvestment</code>还是<code>RegularInvestment</code>进而产生不同的内存分配策略, 而这起码要我们先有一个指针对象才行.</p></li><li><p><strong>分配内存是有可能出现异常的</strong>, 如果出现异常先前分配的内存就泄露了, 但如果提前构造指针, 再用<code>make_shared</code>函数获取内存, 就算发生异常也一定是安全的, 因为<strong>指针会调用析构把先前的内存释放</strong>.</p></li></ol><p>也许略微有些跑题, 但是我觉得能看透问题的本质才是最重要的, 因此多下了一些功夫.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>阻止误用的方法包括 : 导入新类型, 以函数替换对象, 利用const限制, 消除客户的资源管理责任, 不要让客户必须记得某些事情.</strong></li><li><strong>促进正确使用的方法包括 : 保证接口的一致性, 与内置类型行为兼容.</strong></li><li>可以通过设定定制的删除器减少客户手动调用释放函数的负担.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款16-17 new 和 delete</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/</url>
    
    <content type="html"><![CDATA[<h2 id="条款16-成对使用new和delete时要采用相同形式"><a href="#条款16-成对使用new和delete时要采用相同形式" class="headerlink" title="条款16 : 成对使用new和delete时要采用相同形式"></a>条款16 : 成对使用new和delete时要采用相同形式</h2><p>直接看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;                     <br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure><p>这个其实没什么好说的, 其实就是相对应就行.</p><hr><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 : 以独立语句将newed对象置入智能指针"></a>条款17 : 以独立语句将newed对象置入智能指针</h2><p>在条款15我们知道C风格API喜欢直接调用原始资源, 那么我们来看一个不用直接调用原始资源的API : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来在某动态分配的Widget上进行某些带有优先权的操作, 所以需要传入一个智能指针和一个优先度, 那么现在<strong>假定去求优先度其实是一个很复杂的过程</strong>, 我们需要额外封装一个函数来返回求得的优先度 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>那么我们设想的调用<code>processWidget</code>的方法可能是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>这里的<code>priority()</code>函数嵌套是没有问题的, 我们日常中也推荐多用这种手法, 但是前面的new就有问题了, 因为<code>shared_ptr</code>不支持隐式转换, 也就是无法通过<code>new</code>出一个<code>Widget*</code>再转换成<code>shared_ptr&lt;Widget&gt;</code>, 那么下面的修改是否合理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>一眼看上去非常合理, 但是还是有一些隐患在其中, 我们知道<code>priority()</code>是一个很复杂的过程, 既然复杂就有可能会抛出异常, 抛出异常本身并不可怕, 我们可以设置对应的处理逻辑, 但是在这样的调用发生异常就有额外的问题了.</p><p>问题核心在于<strong>C++在函数参数的调用上弹性很大, 并不确定实际的调用步骤</strong> , 真正的调用步骤由编译器选择效率最高的步骤.</p><p>我们先来看看按顺序会发生什么 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>shared_ptr</code>构造函数</li><li>调用<code>priority()</code></li></ul><p>虽然我们确定执行 <code>&quot;new Widget&quot;</code> 表达式一定在调用<code>shared_ptr</code>构造函数之前, 但是我们确实不确定<code>priority()</code>的调用时机 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>构造函数</li></ul><p>如果是这样的话, 在priority()调用过程中发生了异常, 就算之后异常得到了处理,<code> &quot;new Widget&quot;</code>得到的资源也很大可能是被泄露了.</p><p>这一切的问题来源于<strong>在”资源被创建”和”资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰</strong>.</p><p>解决方法很简单, 那就是标题 : <strong>坚持以独立语句将newed对象置入智能指针</strong>, 这样就可以杜绝一切异常干扰了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;  <br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <br></code></pre></td></tr></table></figure><p>于是以上操作就没有任何问题了!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>成对使用<code>new</code>和<code>delete</code>时要采用相同形式.</li><li>以独立语句将<code>newed</code>对象置入智能指针.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款15 在资源管理类中提供对原始资源的访问</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 : 在资源管理类中提供对原始资源的访问"></a>条款15 : 在资源管理类中提供对原始资源的访问</h2><blockquote><p>我们将资源存入资源管理类, 为的是可以免去资源管理的麻烦, 但同时我们也希望<strong>可以正常合理地通过资源管理类来使用资源, 就像直接使用资源一样</strong>, 为此我们一定需要在资源管理类中提供对原始资源的访问;</p></blockquote><p>我们先来解答一些疑问 : </p><ul><li><h4 id="为什么要对原始资源进行访问-为什么要获取原始资源的指针"><a href="#为什么要对原始资源进行访问-为什么要获取原始资源的指针" class="headerlink" title="为什么要对原始资源进行访问(为什么要获取原始资源的指针)?"></a>为什么要对原始资源进行访问(为什么要获取原始资源的指针)?</h4><p>有时候需要我们传递原始资源的指针, 因为很多<code>C API</code>都是要求传递原始指针才能运作.</p></li><li><h4 id="如何进行资源访问呢"><a href="#如何进行资源访问呢" class="headerlink" title="如何进行资源访问呢?"></a>如何进行资源访问呢?</h4><p><strong>显式转换</strong> 或 <strong>隐式转换</strong> .</p></li></ul><hr><p><strong>显示转换</strong> : 资源管理类直接提供一个返回原始资源的<code>get()</code>函数, <code>C++</code>提供的智能指针也提供相应的功能.</p><p>书中举了一个有关字体资源管理的例子, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>假设有一个<code>C API</code>可以通过接受字体资源和字体大小来改变字体 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这是函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeFont</span><span class="hljs-params">(FontHandle f, <span class="hljs-type">int</span> newSize)</span></span>;     <span class="hljs-comment">// C风格的API函数</span><br><span class="hljs-comment">// 以下是用户具体使用例子</span><br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br>...<br><span class="hljs-built_in">changeFont</span>(f.<span class="hljs-built_in">get</span>(), newFontSize);<span class="hljs-comment">// 使用f.get()</span><br></code></pre></td></tr></table></figure><hr><p><strong>隐式转换</strong> : <strong>提供operator-&gt;和operator*的重载</strong> 或 <strong>直接提供隐式转换函数</strong></p><p>前者支持将资源管理类指针隐式转换为底部原始指针, 以此可以直接调用资源函数或取出资源成员变量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br>    <br>    <span class="hljs-comment">// 重载 operator-&gt;，返回原始的 FontHandle 指针</span><br>    FontHandle* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">return</span> &amp;f;  <span class="hljs-comment">// 返回 FontHandle 的指针，允许访问 FontHandle 的成员</span><br>    &#125;<br><br>    <span class="hljs-comment">// 重载 operator*，返回对 FontHandle 的引用</span><br>    FontHandle&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">return</span> f;  <span class="hljs-comment">// 返回 FontHandle 的引用，允许访问 FontHandle 的成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们就可以完全将资源管理类当做一个指针看待, <strong>通过*取出原始资源, 通过-&gt;调用原始资源的成员</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(*f, newFontSize);  <span class="hljs-comment">// 假装f是一个指针, 通过解引用调出资源</span><br></code></pre></td></tr></table></figure><hr><p>后者在使用资源管理类时就会默认转换到底部原始指针 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125;        <span class="hljs-comment">// 隐式转换函数</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样直接写f就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(f, newFontSize);<br></code></pre></td></tr></table></figure><p>但是书中并不推荐这样使用, 因为这是一种<strong>完全把资源管理类作为原始资源</strong>的做法, 也就是说<strong>无法再使用有关任何资源管理类自己的操作</strong>, 当我们想进行资源管理类的拷贝赋值等操作时, 由于已经隐式转换为了资源, 这样做几乎不会有好下场, 当然你也可以保证完全不使用也不设计这类操作, 让它单独做好资源管理的本职工作, 也是完全可以使用这种方法的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>API</code> 往往要求访问原始资源, 所以<strong>每个资源管理类都应提供一个取得其原始资源的方法</strong>.</li><li>对于原始资源的访问, 显示转换一般比较<strong>安全</strong>, 但隐式转换对客户比较<strong>方便</strong>, 自己斟酌利弊.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款14 在资源管理类中小心 copying 行为</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="条款14-在资源管理类中小心-copying-行为"><a href="#条款14-在资源管理类中小心-copying-行为" class="headerlink" title="条款14 : 在资源管理类中小心 copying 行为"></a>条款14 : 在资源管理类中小心 copying 行为</h2><blockquote><p>本条款是在我们自己建立资源管理类时要注意的行为, 但是归根结底, 我们为什么要自己建立资源管理类呢 ? 为什么不用 shared_ptr ? 这是我们在本条款中需要首先解决迭代问题.</p></blockquote><p>书中提出, C++提供的智能指针是适配于<code>heap-based</code>资源上的, 其要求不管是自动生成还是手动完成, 该资源<strong>必须要有析构函数</strong>, 然而并非所有的资源都是<code>heap-based</code>的, 简单来说就是有些资源<strong>没有对应的析构函数</strong>, 而是选择了别的方式进行资源的释放, 非常典型的就是<strong>文件句柄</strong>, 其必须要调用<code>close()</code>函数释放, 你如果直接把其交给<code>shared_ptr</code>而不做其他动作, 可以确定的是<code>shared_ptr</code>并不会智能到把<code>close()</code>加到智能函数中, 文件句柄不会被释放, 这样的资源还有很多, 而且大部分都很关键, 比如<strong>锁, 数据库连接, 网络socket</strong>等. 因此我们需要自己建立自己的资源管理类(当然也有些其他的方式).</p><hr><h3 id="怎么建立自己的资源管理类"><a href="#怎么建立自己的资源管理类" class="headerlink" title="怎么建立自己的资源管理类?"></a>怎么建立自己的资源管理类?</h3><p>简单来说还是<strong>遵循RAII原则</strong>, 构造即初始化, 析构即释放资源, 这里的释放资源具体到文件就是调用<code>close()</code>, 具体到锁就是调用<code>unlock()</code>, 我们自己应当考量, 而我们一般称其为 <strong>RAII风格的XXX</strong> .</p><p>书中给出了一段代码, 用于实现<strong>RAII风格的锁</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以实现以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mutex m;                    <span class="hljs-comment">// 设置一个互斥器</span><br>...<br>&#123;                           <span class="hljs-comment">// 这是一块作用域, 可以是一个要求线程安全的函数内部</span><br><span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;m)</span></span>;            <span class="hljs-comment">// 直接用互斥器上锁</span><br>...                     <span class="hljs-comment">// 执行对锁有需求的行为</span><br>&#125;    <span class="hljs-comment">// 离开作用域自动调用析构, 析构中自动unlock</span><br></code></pre></td></tr></table></figure><hr><h3 id="言归正传-当一个RAII对象被复制-会发生什么事"><a href="#言归正传-当一个RAII对象被复制-会发生什么事" class="headerlink" title="言归正传, 当一个RAII对象被复制, 会发生什么事 ?"></a>言归正传, 当一个RAII对象被复制, 会发生什么事 ?</h3><p>以下是可能发生的复制策略 : </p><ul><li><p><strong>禁止复制</strong> : 很多时候我们并不希望资源管理类可以复制, 就像锁, 我们一定不希望多个锁对象控制同一个底层的互斥器, 这有违锁设计的初衷, 所以直接禁止就好了, 这时我们的<code>Uncopyable</code>类就有用了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;        <span class="hljs-comment">// 直接private继承自Uncopyable</span><br><span class="hljs-keyword">public</span>:                                    <br>...                                     <span class="hljs-comment">// 同上   </span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>对底层资源祭出”引用计数法”</strong> : 这个其实就是利用<code>shared_ptr</code>实现资源共享就好了.</p><p>需要注意的就是, <code>shared_ptr</code>还有一个和共享内存无关的性质—<strong>删除器</strong>, 这是一个函数, 可以传入<code>shared_ptr</code>构造函数的第二参数, 如果没有删除器会默认调用析构, 有删除器就调用删除器, 这其实就在一定程度上解决了智能指针只能针对<code>heap-based</code>资源的问题, 让没有析构函数的资源也可以通过调用删除器实现释放, 以下是书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span>       </span><br><span class="hljs-function">  : mutexPtr(pm, unlock)         // 初始化智能指针, 将unlock设置为删除器</span><br><span class="hljs-function">    lock(mutexPtr.get());</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* mtx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mtx) &#123;<br>        mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>        <br>    <span class="hljs-comment">// 不需要写析构函数了, 它可以被删除器替代</span><br>&#125;<br>   <br><span class="hljs-keyword">private</span>:<br>  std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;    <span class="hljs-comment">// 使用 shared_ptr</span><br>&#125;;                     <br></code></pre></td></tr></table></figure><p>请注意如果我们写的资源管理类不希望共享资源, <code>shared_ptr</code>可以共享就带来了隐患, 像是上面的锁, 其实更推荐禁止拷贝的做法, 这种做法只是告诉我们一种其他的做法而已.</p></li><li><p><strong>复制底层资源</strong> : 这其实就是我们常说的深拷贝.</p></li><li><p><strong>转移底部资源的拥有权</strong> : 为了保证资源的独占性, 我们可以选择这种策略.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>复制<code>RAII对象</code>必须一并复制他所管理的资源, 资源的<code>copying</code>行为决定<code>RAII对象</code>的<code>copying</code>行为.</li><li>普遍的<code>copying</code>行为是禁止复制或施行引用计数法.</li><li>文件句柄和锁这类资源可以选择<strong>禁止复制, 支持移动</strong>的策略</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款13 以对象管理资源</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 : 以对象管理资源"></a>条款13 : 以对象管理资源</h2><blockquote><p>所谓资源, 一旦用了它, 将来必须还给系统. 本条款及以后几项条款都致力于实现优秀的资源管理, 严守这些条款, 可以几乎消除资源管理问题.</p></blockquote><p>本条款主要提出<strong>以对象管理资源</strong>的思想, 以及对<code>std</code>内置的<code>auto_ptr</code>和<code>smart_prt</code>的使用策略做了分析.</p><p>书中塑模了一个投资行为, 让我们看看资源该如何处理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span> &#123; ... &#125;;  <span class="hljs-comment">// 一个投资类</span><br><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这是一个工厂函数, 返回一个动态分配的对象, 这里为了简化刻意不写参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Investment *pInv = <span class="hljs-built_in">createInvestment</span>();         <br>  ...                                            <br>  <span class="hljs-keyword">delete</span> pInv;                                  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有资源管理对象, 我们正常行为是请求指针使用后再<strong>手动删除</strong>.</p><p>书中提出了”以对象管理资源”的两个关键想法 : </p><ul><li><strong>获得资源后立即放进管理对象.</strong></li><li>**管理对象运用析构函数确保资源被释放, **这样便可倚赖 C++ 的”<strong>析构函数自动调用机制</strong>“确保资源被释放.</li></ul><p>这两个想法来源于一种资源管理观念 : </p><ul><li><strong>RAII (Resoure Acquisition Is Initialization)</strong> <strong>: 资源取得时机便是初始化时机 .</strong></li></ul><p>那么资源管理类该如何使用与实现呢 ? 不妨看看C++本身给我们提供的两个资源管理类(智能指针)吧. </p><hr><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;  <span class="hljs-comment">// 请求对象的同时直接存入auto_ptr中 </span><br>  ...                                                 <br>&#125;         <br></code></pre></td></tr></table></figure><p>这样我们可以一如既往地使用<code>pInv</code>, 当其离开作用域时, 会经由<code>auto_ptr</code>的析构函数自动删除<code>pInv</code>.</p><p><code>auto_ptr</code>的特性 : 受<code>auto_ptr</code>管理的资源必须绝对没有一个以上的<code>auto_ptr</code>同时指向它.</p><p>也就是说<code>auto_ptr</code>保证独占指向的资源, 如果发生拷贝也会转交使用权, 这种特性使得其在需求共享内存的场面起不到作用, 于是也就有了我们接下来的<code>shared_ptr</code>.</p><hr><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pInv1</span><span class="hljs-params">(createInvestment())</span></span>;<br>  ...    <br>    std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt;  <span class="hljs-title">pInv2</span><span class="hljs-params">(pInv1)</span></span>; <span class="hljs-comment">// 允许指向同一块内存</span><br>  pInv1 = pInv2; <span class="hljs-comment">// 允许赋值同时获得使用权</span><br>&#125;          <br></code></pre></td></tr></table></figure><p><code>share_ptr</code>是”<strong>引用计数型智能指针</strong>“, 其自己内部维护了一个计数器, 用于记录指向同一块资源的指针有多少, 当发生拷贝和赋值时都会使计数器 + 1, 当有指向其的指针离开作用域时都会使计数器 - 1, 当计数器为0时才自动触发真正的析构.</p><hr><p>请注意 : <code>auto_ptr</code>和<code>shared_ptr</code>的析构函数内部调用的都是 <code>delete</code>, 而非 <code>delete[]</code>, 虽然我们可以 <code>new []</code>, 但是这样new出来的指针就请不要存入智能指针了. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spi</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>])</span></span>; <span class="hljs-comment">// 这样是错误的!</span><br></code></pre></td></tr></table></figure><p>至于为什么没有<code>delete[]</code>版本的, 那是因为<code>vector</code>和<code>string</code>几乎总是可以取代动态分配而得的数组, 所以没必要.</p><hr><p>以上专门描述了<code>auto_ptr</code>和<code>shared_ptr</code>, 但是本条款并不专门针对它们, 而是在强调”<strong>以对象管理资源</strong>“的重要性, 有时候我们要使用的资源也许是这些<strong>预制式classes无法妥善管理</strong>的, 就需要我们有<strong>自己制作资源管理类</strong>的能力了, 至于其中要考虑的细节, 在接下来的条款14, 15中会提及.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>为防止资源泄露, 请使用<code>RAII</code>对象, 它们在构造函数中获得资源并在析构函数中释放资源. </li><li>优先使用<code>shared_ptr</code>, <code>auto_ptr</code>次之, 如果效果无法令你满意, 请自己制作资源管理类.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款10-12 拷贝与赋值</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="条款10-令-operator-返回一个-reference-to-this"><a href="#条款10-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10 : 令 operator&#x3D; 返回一个 reference to * this"></a>条款10 : 令 operator&#x3D; 返回一个 reference to * this</h2><blockquote><p>很多类都有重写operator&#x3D;函数的要求,  本质是 &#x3D; 左侧调用 operator&#x3D; 函数, 右侧作为参数传入, 将右侧参数赋值给左侧成员变量, 并且为了实现连锁赋值, 我们还应当使 operator&#x3D; 返回当前赋完值的对象.</p></blockquote><p>本条款的目的是<strong>实现连锁赋值</strong>, 接下来看看如何 令 operator&#x3D; 返回一个 reference to * this : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)     <span class="hljs-comment">// 返回一个引用, 符合右侧参数的类型</span><br>&#123;          <br>    <span class="hljs-comment">// 条款11, 12会告诉我们怎样实现中间的拷贝过程</span><br>    ...<br>    <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                        <span class="hljs-comment">// 返回=左侧的当前对象, 使其可以充当下一次operator=的右侧参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时这个协议不只适用于 &#x3D; , 也同样适用于 +&#x3D;, -&#x3D;, *&#x3D; 等运算符.</p><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>令赋值操作符重载返回一个 reference to * this</li></ul><hr><h2 id="条款11-在-operator-中处理”自我赋值”"><a href="#条款11-在-operator-中处理”自我赋值”" class="headerlink" title="条款11 : 在 operator&#x3D; 中处理”自我赋值”"></a>条款11 : 在 operator&#x3D; 中处理”自我赋值”</h2><blockquote><p>我们设置一个变量w, 令 w &#x3D; w , 这种自我赋值的做法虽然看上去很愚蠢, 但是合法, 这种程度的自由还是应该有的, 可是这在我们手动重载operator&#x3D; 时也会带来相应的麻烦, 有一些我们需要注意的点.</p></blockquote><p>正常来说, 如果我们的类中只有一些普通的本地变量, 其实不必考虑自我赋值的问题, 因为只要把正常情况下的 operator&#x3D; 函数写好(或者你也可以让编译器自动生成), 是没有什么问题的, 问题发生在<strong>需要动态管理内存</strong>时.</p><p>假如我们一个类中有一个成员变量是指针, 该指针指向一块动态分配的内存, 我们创建两个类对象 a 和 b , 其中的指针都指向不同的内存, 当使 a &#x3D; b, 从正常考量来说, b 赋值给 a 应当代表着 a 的指针将指向原先 b 所指向内存, 那么<strong>原先 a 所指向的内存就应当delete掉</strong>, 以完成最后的赋值操作. 书中举了一个指针指向bitmap的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  Bitmap *pb; <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)              <span class="hljs-comment">// 这是一个有隐患的赋值重载</span><br>&#123;<br>  <span class="hljs-keyword">delete</span> pb;                                      <span class="hljs-comment">// delete掉原来指向的动态内存</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);                       <span class="hljs-comment">// 再new一块用来拷贝rhs副本的空间, pb重新接手这块空间 </span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                   <span class="hljs-comment">// 见条款10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很合理, 但是带入自我赋值的情况, 你就会惊奇地发现, new Bitmap(*rhs.pb)用来拷贝的副本 rhs.pb 已经因为 delete pb 被释放了! 我们掉进了”<strong>在停止使用资源之前就意外释放了它</strong>“的陷阱! 虽然自我赋值是愚蠢的操作, 但我们程序员也不能让愚蠢的操作产生愚蠢的错误, 所以我们应当提前判断是否是自我赋值 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <span class="hljs-comment">// 判断是否是自我赋值, 是就直接返回</span><br>  <span class="hljs-keyword">delete</span> pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以对自我赋值的问题完全规避了! </p><hr><p>但是其实由于动态内存的存在, 还催生出了另一个问题, 就是其实new一个对象也会有产生异常的情况出现, 如果申请内存失败, pb就是折了孩子又赔兵, 原先的内存释放了, 新申请的还失败了, 这个问题就是<strong>异常安全性</strong>的问题了, 从原理上来说这和本条款重点针对的自我赋值毫无关联, 但是书中很高兴地告诉我们 : </p><ul><li><strong>让 operator&#x3D; 具备”异常安全性”往往会自动获得”自我赋值安全”的回报.</strong></li></ul><p>因此作者告诉我们可以把焦点放在实现异常安全性上, 对自我赋值问题倾向于不管理. 就是说虽然两个问题毫不相干, 但你解决一个问题却可以顺带解决另一个问题, 何乐而不为呢?</p><p>那么如何实现异常安全性呢? 异常安全性会在条款29着重讲解, 但不妨我们提前了解 : </p><p>简而言之就是 : <strong>不泄露任何资源, 不允许数据败坏, 强烈保证如果函数没有成功就回滚到函数被调用前的状态</strong>.</p><p>放在本例中, 就是<strong>如何确保new失败后pb可以依旧指向原先的内存, 而不是原先的内存被释放</strong>.</p><p>简单思考一下就可以写出如下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  Bitmap *pOrig = pb;               <span class="hljs-comment">// 用一个备份指针记住原先的pb指向的空间先不释放</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// 令左边pb指向右边pb所指向内存的副本</span><br>  <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// 如果new成功了再释放原先指向的空间</span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是异常安全性的问题就解决啦, 我们还可以发现, 确实自我复制安全的问题也被解决了, 因为pb不会被提前释放, 就算是对着自己再复制一遍也完全没有问题, 唯一的变化就是换了块内存而已.</p><p>书中还提出了一种理念相同, 但更推荐的编写方法 : <strong>copy and swap技术</strong>;</p><p>简而言之就是 : <strong>如果对某对象的操作有异常风险, 就直接先copy该对象的副本, 在该对象的副本上做出所有操作, 随后swap原件和副本</strong>.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; W);<br>  ...                       <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 大多数赋值重载最后用的都是这种方法</span><br>&#123;<br>  Widget <span class="hljs-built_in">temp</span>(rhs);             <span class="hljs-comment">// 使用重写的拷贝构造函数直接拷贝副本</span><br>  <span class="hljs-built_in">swap</span>(temp);                   <span class="hljs-comment">// 交换原件和副本</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里可能有些人似懂非懂, 前一个函数很明确要在拷贝目标内存成功后就释放原内存, 这个是怎么实现的呢?</p><p>这里的拷贝构造函数我们需要重写, 实现对 bitmap 的深拷贝, 拷贝完的对象就是 temp , 由于 temp 是一个临时对象, 离开这个函数的作用域就会析构掉, 此时我们交换原对象和目标对象, 那么最后析构掉的就是存在 temp 中的原对象, 而目标对象留在了我们的当前对象中.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>通过实现异常安全性顺便解决自我赋值的问题.</li><li>确保操作多个对象时, 其中多个对象实质上是同一个对象时, 其行为仍然正确.</li></ul><hr><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12 : 复制对象时勿忘其每一个成分"></a>条款12 : 复制对象时勿忘其每一个成分</h2><blockquote><p>copying函数 : 拷贝构造 和 赋值重载(operator&#x3D;) .</p><p>条款10&#x2F;11告诉了我们 operator&#x3D; 如何返回值 和 注意 operator&#x3D; 自我赋值, 本条款会告诉我们 copying函数 在赋值过程中应当注意些什么.</p></blockquote><p>书中提出, 如果我们决定自己实现 copying函数, 编译器会仿佛被冒犯似的, 以一种奇怪的方式回敬 : 当你的代码必然出错时也不会告诉你. </p><p>这也在警告我们, 复制对象时勿忘其每一个成分.</p><p>首先提出的观点是 : </p><ul><li><strong>如果你为class添加一个成员变量, 你必须同时修改copying函数</strong>.</li></ul><p>这点很好理解, 每个成员变量都必须和拷贝构造和赋值拷贝关联.</p><p>接下的观点就涉及继承层面了 : </p><ul><li><p><strong>只要为 derived class 撰写 copying函数, 必须很小心地复制其 base class 成分.</strong></p></li><li><p><strong>你应当让 derived class 的 copying函数 调用相应的 base class函数.</strong></p></li></ul><p>我们来看书中的代码来进一步了解这两句话 : </p><p>书中设定了一个<code>Customer顾客类</code>, 其派生类是<code>PriorityCustomer贵宾类</code>, 贵宾类中local int 变量 <code>priority</code>, 用来确定贵宾的优先度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logCall</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; funcName)</span></span>;  <span class="hljs-comment">// 用来产生一个日志通告</span><br><br><span class="hljs-comment">// Customer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<span class="hljs-comment">// 普通客户</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>  std::string name;<br>&#125;;<br><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>: <span class="hljs-built_in">name</span>(rhs.name)                                 <br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 赋值重载被触发&quot;</span>);<br>  name = rhs.name;                             <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                  <span class="hljs-comment">// 见条款10</span><br>&#125;<br><br><span class="hljs-comment">// PriorityCustomer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span>: <span class="hljs-keyword">public</span> Customer &#123;                  <span class="hljs-comment">// 贵宾客户</span><br><span class="hljs-keyword">public</span>:<br>   ...<br>   <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>   PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> priority;<br>&#125;;<br><br><span class="hljs-comment">// 重点看这个两个函数</span><br>PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br>  priority = rhs.priority;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似<code>PriorityCustomer</code>的构造函数好像复制了每一样东西, 但是其实它所<strong>继承的Customer部分并未进行复制</strong>, Customer部分中的name变量仍旧是未定义的, 当我们再仔细看看operator&#x3D;, 里面的问题是一样的.</p><p>接下来是改进后的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">Customer</span>(rhs)                   <span class="hljs-comment">// 调用 base class 的 copy构造函数</span><br>  , <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br><br>  Customer::<span class="hljs-keyword">operator</span>=(rhs);           <span class="hljs-comment">// 对 base class 成分进行赋值动作</span><br>  priority = rhs.priority;<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样代码就完美了! 再去回味前面提出的两句话, 其实就是在告诉我们<strong>显式且正确处理基类部分的拷贝和赋值</strong>的重要性.</p><p>我们要确保 : </p><ol><li>复制所有的 local 变量.</li><li>调用所有 <code>base classes</code> 内适当的 <code>copying函数</code>.</li></ol><hr><p>很多时候这两个<code>copying函数</code>往往有着近似的实现本体, 这可能会诱使我们用其中一个调用另外一个以实现代码复用的效果, 但是书中告诉我们这样做风险很大, 因为拷贝构造用来初始化新对象, 而赋值重载只能施行于已初始化的对象上, 二者的应用场景就不同, 不然也就不会分成两个默认成员函数了, 所以书中告诉我们 : </p><ul><li><p><strong>你不该令 copy assignment 操作符调用 copy构造函数 .</strong></p></li><li><p><strong>令 copy构造函数 调用 copy assignment 操作符同样无意义.</strong></p></li><li><p><strong>真正明智的做法是将相近代码封装进 init() 函数, 给二者调用.</strong></p></li></ul><hr><h3 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>copying函数</code>应当确保复制 “对象内的所有成员变量” 及 “所有<code>base class</code>成分”.</li><li>不要尝试<code>copying函数</code>相互调用, 应当封装一个共用函数实现代码复用.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款9 绝不在构造和析构函数过程中调用</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款09-绝不在构造和析构函数过程中调用virtual函数"><a href="#条款09-绝不在构造和析构函数过程中调用virtual函数" class="headerlink" title="条款09 : 绝不在构造和析构函数过程中调用virtual函数"></a>条款09 : 绝不在构造和析构函数过程中调用virtual函数</h2><p>开门见山阐释本条款的重点 : <strong>你不该在构造函数和析构函数中调用virtual函数</strong>.</p><p>书中给出了一个例子 : 假如我们要塑膜股市交易订单模型, 订单可以分成买入, 卖出等不同类型的订单, 当我们产生不同类型的订单, 也就是构造不同类型订单对象时, 我们也许会有记录订单日志的需求, 并我们希望订单根据不同的订单类型产生不同的订单日志.</p><p>于是我们可以抽象出以上需求的类构建过程, 一个订单基类, 派生出不同的订单派生类(如买入类, 卖出类), 基类的构造函数调用一个虚函数<code>logTransaction()</code>, 派生类重写出不同的<code>logTransaction()</code>, 就可以实现我们以上的需求.</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                               <span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span>:                                           <br>  <span class="hljs-built_in">Transaction</span>()<br>  &#123;                                                 <br>  ...<br>  <span class="hljs-built_in">logTransaction</span>();                        <span class="hljs-comment">// 订单构建时依据订单动态类型构建对应日志       </span><br>&#125;     <br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 要求派生类重写</span><br>  ...<br>&#125;;                       <br>                                            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;       <span class="hljs-comment">// 买入类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 提供重写版本日志</span><br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">// 卖出类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码看似很完美, 但是真正运行起来是无法实现的!</p><p>当我们创建一个<code>BuyTransaction</code>类对象<code>b</code>时, 并不会调用<code>BuyTransaction</code>重写的<code>logTransaction()</code>, 而是会调用基类<code>Transaction</code>的<code>logTransaction()</code>, 然而我们基类的<code>logTransaction()</code>设置为纯虚函数甚至都没有写, 就更别谈运行了. </p><p>为什么? 书中告诉我们, <strong>在base class构造期间, virtual函数不是virtual函数</strong>, 更细致的说就是<strong>base class构造期间virtual函数绝不会下降到derived class阶层</strong>. 原因很直观, <strong>base class 构造函数执行期间derived class的成员变量一定还未初始化</strong>, 如果此刻就可以通过virtual下降到派生类, 我们怎么确保这个虚函数不会调用派生类的成员变量呢? 太危险了, 所以C++不会让你走这条路.</p><p>而且不止是不能在构造析构函数内调用虚函数, 当然也不能调用包含了虚函数的普通函数, 这是显而易见的, 这就又回到了我们开头说的那句话 : <strong>绝不在构造和析构函数过程中调用virtual函数</strong>, 只要还在过程中, 就不要调用.</p><hr><p>那么我们最开始的需求还有其他实现的方式吗?</p><p>书中提出一种解决办法 : 将<code>logTransaction()</code>改为普通函数, 要求派生类构造函数传递必要的日志信息给基类的构造函数, 基类的构造函数再把接收到的日志信息传入<code>logTransaction()</code>, 这样就可以了!</p><p>我们可以宏观地理解一下, 有助于我们的思维进步. 其实派生类的构造函数是一个<code>自底向上</code>的过程, 一直递归调用到最顶层的基类, 当调用到最顶层后, 我们不好奢求基类再自顶向下调用派生类的重写函数, 不如在一开始自底向上时就把必要的信息传递至基类构造函数, 这样想就非常通顺了.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span>  <span class="hljs-comment">// 接收下层的日志信息</span></span><br><span class="hljs-function">  </span>&#123;<br>  ...<br>  <span class="hljs-built_in">logTransaction</span>(logInfo);<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 此时是普通函数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BuyTransaction</span>(<span class="hljs-type">const</span> std::string&amp; parameters)<br>: <span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>(parameters))             <span class="hljs-comment">// 将log信息传递给上层</span><br>  &#123; ... &#125;                                                 <br>   ...                                                  <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 这里利用一个辅助函数创建一个值传给base class构造函数往往比较方便美观可读</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; parameterss)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝不在构造和析构函数过程中调用<code>virtual</code>函数.</li><li>对象在<code>derived class构造函数</code>开始执行前不会成为一个<code>derived class对象</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款8 析构函数的异常管理</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 : 别让异常逃离析构函数"></a>条款08 : 别让异常逃离析构函数</h2><blockquote><p>日常编程中，常见异常通常由以下原因引发：</p><ol><li><strong>资源管理不当</strong>（如内存泄漏, 文件操作, 连接或断开连接失败）。</li><li><strong>边界和合法性检查不足</strong>（如数组越界、除以零）。</li><li><strong>并发编程问题</strong>（如死锁、数据竞争）。</li><li><strong>类型不匹配或错误的操作</strong>。</li></ol></blockquote><p>本条款主要讨论的是析构函数的异常管理, 为什么会不希望异常逃离析构函数, 因为<strong>析构函数是一个必须执行且有可能失败的函数</strong>, 因为内存泄漏, 文件操作, 连接或断开连接失败等资源管理行为的错误都是很难避免的, 而且由于<strong>析构函数是递归式调用并且可能一次性销毁大量结构</strong>, 同时产生大量异常的概率就提高了, 书中指出, <strong>如果同时存在多个异常, 程序不是结束执行就是导致不明确行为</strong>, 因此对于析构函数的异常管理在所难免.</p><hr><p>书中举出了一个数据库连接的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;  <span class="hljs-comment">// 数据库连接类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回创建出来的静态数据库连接.                                     </span><br>  ...                                      <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 调用此函数关闭与数据库的连接, 这里有抛出异常的隐患         </span><br>&#125;;         <br></code></pre></td></tr></table></figure><p>我们经常会设计一个资源管理类来控制数据库的连接 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;                          <span class="hljs-comment">// 数据库连接管理类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>   db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 调用析构函数时断开数据库连接</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  DBConnection db;   <span class="hljs-comment">// RAII风格, 由DBConn管理DBConnection, 离开作用域自动触发DBConn的析构函数断开连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以写出以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ...<br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// 直接建立DBConnection对象并交由DBConn对象dbc管理</span><br>    ... <span class="hljs-comment">// 进行数据库的CURD, 离开作用域自动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了上面例子的基础, 我们来思考一下如何避免异常抛出吧.</p><p>站在<code>DBConn析构函数</code>的角度, 书中给出了两个一般的方法 : </p><ol><li><p>如果close()抛出异常就利用abort()结束程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>   std::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 直接结束程序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接吞下该异常.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>      <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>      <span class="hljs-comment">// 不做处理, 直接吞下</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两个方法其实都是保底方法, 一个是草率结束进程, 一个是吞掉异常防止扩散, 但其实<code>DBConn析构函数</code>也就能做这么多了.</p><hr><p>现在的问题是<strong>没有办法对”导致close抛出异常”的情况做出反应</strong>, 问题核心在<code>close()</code>函数被<code>DBConn析构函数</code>掌握, 只能其自己管理, 上一层无法干预. 那么由此我们可以将close()函数的使用权上交, 也就是让上一层用户有权决定处理<code>close()</code>报错的方式. </p><p>较佳策略是<strong>重新设计DBConn接口, 使客户有机会对可能出现的问题作出反应</strong>. </p><p>具体做法如下 : </p><ol><li><code>DBConn</code>自己也提供一个close接口, 内部封装上<code>DBConnection</code>的<code>close()</code>.</li><li><code>DBConn</code>自己对<code>DBConnection</code>的<code>close()</code>是否已经触发进行追踪管理, 如果到最后客户都没有自行close成功, 由<code>DBConn析构函数</code>自行完成close的任务.</li></ol><p>我们来看书中给出的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 提供给上层用户的close函数</span></span><br><span class="hljs-function">  </span>&#123;                                       <br>    db.<span class="hljs-built_in">close</span>();<br>    closed = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>      <span class="hljs-comment">// 如果到最后都没有触发close, 就会回到析构函数调用close的老路</span><br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>   <span class="hljs-keyword">try</span> &#123;                                           <br>     db.<span class="hljs-built_in">close</span>();                           <br>   &#125;<br>   <span class="hljs-built_in">catch</span> (...) &#123;                                    <br>     <span class="hljs-comment">// 记录日志, 记录对close的调用失败  </span><br>     ...                                   <span class="hljs-comment">// 直接结束 或 吞下异常</span><br>   &#125;<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  DBConnection db;<br>  <span class="hljs-type">bool</span> closed;<span class="hljs-comment">// 用布尔变量closed来对close()进行追踪管理</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是客户便可做出如下操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 客户自己在认为合适的地方调用close()结束连接, 并用try-catch语句尝试捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能会抛出异常，如果关闭失败</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 客户端捕获从 close() 抛出的异常</span><br>        <span class="hljs-comment">// ... 出现异常时的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只考虑数据库断开连接的场景, 我们可行的具体操作可以是重试关闭或执行数据库回滚, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!success &amp;&amp; attempts &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;正在尝试断开数据库连接, 次数 :  &quot;</span> &lt;&lt; ++attempts &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;已经尝试三次断开数据库连接, 但都出现异常, 断开失败&quot;</span> &lt;&lt; std::endl;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;进行补偿操作, 回滚数据库&quot;</span> &lt;&lt; std::endl;<br>        dbConn.<span class="hljs-built_in">rollback</span>(); <span class="hljs-comment">// 内部调用数据库的回滚函数</span><br>&#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来捋一下流程, 先是客户需要考虑何时调用<code>close()</code>并写出应对异常的代码, 实际运行时如果没有异常就万事大吉, 有异常就触发客户的处理逻辑, 最后析构函数检查客户是否真的成功调用了<code>close()</code>, 如果还是没有调用, 就自己调用, 自己调用如果还出错, 就直接结束程序或吞掉异常.</p><p>至此我们将调用<code>close()</code>的责任从<code>DBConn析构函数</code>的手上移交到了使用<code>DBConn对象</code>的客户手上, 可以更好地避免异常逃离析构函数. 有人可能这样会加大客户的操作负担, 但是根据我们先前的分析, 只有客户才能有办法对”导致close抛出异常”的情况做出反应, 这样做是给客户提供一个根据实际情况回避异常的机会, 至于是否需要就看客户自己了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>析构函数绝对不要吐出异常. 如果分析出一个析构函数有抛出异常的风险, 应当先把异常捕捉下来, 看是否结束程序或吞下异常.</li><li>给客户提供自己处理异常的机会, 让客户可以根据实际情况对异常做出反应.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款7 virtual析构函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 : 为多态基类声明virtual析构函数"></a>条款07 : 为多态基类声明virtual析构函数</h2><blockquote><p>说到多态, 我们应当非常了解其运行时绑定的机制, 简单来说就是我们可以在任何时候根据用户的需求将基类绑定为不同的派生类, 用相同的操作实现不同的效果, 这其中virtual函数起到了至关重要的作用, 每一个含有虚函数的类都会维护一个虚表, 以此实现基类到派生类的动态绑定. </p></blockquote><p>这里书中提到了一个重要又经常发生的问题 : <strong>如果<code>drived class(派生类)</code>对象经由一个<code>base class(基类)</code>指针被删除, 而该base class带着一个non-virtual析构函数, 那么结果是未定义的</strong>.</p><p>这里的结果未定义, 一般情况下是只会调用<code>base class</code>自己的析构函数, 销毁的是该对象的<code>base class</code>部分, 而<code>drived class</code>部分却没有被销毁, 就造成了诡异的”局部销毁”现象.</p><p>而解决这个问题的方法就是 : <strong>给 base class 一个 virtual析构函数</strong>.</p><p>先回忆一下有关派生类析构函数的知识 : <strong>派生类的析构函数会默认先调用上一层的析构函数</strong>. 也就是说是从当前派生类的析构函数开始, 递归式调用上一层的析构函数, 直到到达最深层的基类. </p><p>再思考上面的话, 当<code>base class</code>指针动态绑定<code>drived class</code>对象时, 如果我们想删除这个对象时, 正确的结果应该是调用动态绑定的<code>drived class</code>的析构函数, 这样才能正确地全部销毁, 而想这样调用就只能依赖于虚函数来实现, 也就是我们需要把base class的析构函数设置为virtual, 删除时就会根据虚表找到当前动态类型绑定的析构函数.</p><p>以下是书中的给出的样例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TimeKeeper</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>  ...<br>&#125;;<br>TimeKeeper *ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br>...<br><span class="hljs-keyword">delete</span> ptk;                         <span class="hljs-comment">// 现在, 行为正确</span><br></code></pre></td></tr></table></figure><p>书中告诉我们 : </p><ul><li><strong>virtual 函数的目的是允许 derived class 的实现得以客制化</strong>.</li><li><strong>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数</strong>.</li></ul><hr><p>当然, 无端地将所有的 classes 的析构函数声明为 virtual, 就像从未声明他们为 virtual 一样, 都是错误的.</p><p>如果 class 不含 virtual 函数, 通常表示它并不意图被用作一个 base class, 也就完全不需要声明virtual析构函数.</p><p>我们知道使用虚函数是要带来额外的花销的, 包括维护虚表, 虚指针表等一系列繁杂的动作, 会带来时间成本和空间成本, 而且书中还提到由于对象大小的增加会影响其可移植性.</p><p>所以请记住一个心得 : <strong>只有当 class 内含至少一个 virtual 函数, 才为他声明 virtual析构函数</strong>.</p><hr><p><strong>请不要企图继承我们神圣的STL容器</strong>, 正因为考虑到上面虚函数有关时间, 空间, 可移植性的问题, STL容器并没有考虑被继承的情况, 它们的析构函数都是 non-virtual 的!</p><hr><p>这里书中提到了一个构建抽象类的小窍门 : </p><p>我们一般不希望抽象类被实体化, 它只提供一些接口 : </p><ol><li>被声明为<code>纯虚函数</code>的接口所有派生类必须重写.</li><li>被声明为<code>虚函数</code>的接口提供默认行为同时也允许派生类重写.</li><li>被声明为<code>普通函数</code>的接口可以被所有派生类继承, 使用.</li></ol><p>我们在设计一个抽象类时, 也许并不希望有什么类是必须重写的, 就是不希望有纯虚函数, 只需要提供虚函数和普通函数即可, 然而一个类想要不被实体化, <strong>必须存在一个纯虚函数</strong>, 那么哪里找一个纯虚函数呢? </p><p><strong>如果你拿不定主意, 选析构函数就好了!</strong> 毕竟抽象类一定有多态的需求, 只要有多态的需求, 析构函数就必须是 virtual 的, 已经是虚函数了, 变成纯虚函数也没什么问题, 而且当我们的派生类没有新增动态资源时, 就算我们不手动重写析构函数也没关系! 因为编译器会自动帮我们生成! 这样既满足了必须有一个纯虚函数的要求, 又不需要我们顾及纯虚函数必须重写的问题, 多么完美 !</p><p>不过有一个小细节必须要注意, 所有派生类析构函数最后都会调用到最底层基类的析构函数, 所以我们<strong>需要对纯虚析构函数进行定义</strong>!</p><p>纯虚析构函数真的能定义吗? 答案是能的, 虽然大多数情况下纯虚函数都不用定义, 但是真要定义还是可以的.</p><p>以下是书中的示例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br>AWOV::~<span class="hljs-built_in">AWOV</span>()  <span class="hljs-comment">// 纯虚函数的定义</span><br>&#123;<br>    <span class="hljs-comment">// delete ...</span><br>&#125;                    <br></code></pre></td></tr></table></figure><hr><p>再次重申, 本章的主要观点  <strong>给 base class 一个 virtual析构函数</strong> 只适用于多态用途, 这种<code>base class</code>的设计目的就是为了<strong>用来通过 <code>base class</code> 接口处理 <code>drived class</code> 对象</strong>.</p><p>我们也应当知道很多 class 的设计就不是为了作为 base class 来使用, 也并非所有的 base class 的设计目的是为了多态用途, 就像我们上一个条款的<code>Uncopyable</code>类, 它被作为基类就不是为了多态, 而是为了赋予派生类不可拷贝的属性, 就不需要使用基类接口, 使用也只是使用派生类, 使用 virtual析构函数就没必要了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>请为多态性质的<code>base class</code>设置 virtual析构函数, 反之请不要.</li><li>不要试图继承<code>STL</code>容器.</li><li>想设计抽象类又不知道纯虚函数选谁时, 选析构函数当纯虚函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款5-6 默认成员函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05 了解C++默默编写并调用哪些函数"></a>条款05 了解C++默默编写并调用哪些函数</h2><blockquote><p>编译器会默认为class创建default构造函数, 析构函数, copy构造函数, 赋值操作符重载, 这算是我们C++语言基础学习中的重中之重, 这里就不再过多阐释.</p></blockquote><p>书中提出一点 : 如果我们在实际使用中确实没有使用到某些默认成员函数, 编译器很大可能也不会自动创建对应的默认函数(例如copy构造函数, 赋值操作符重载).</p><hr><p>书中还提出了三种编译器拒绝自动生成赋值操作符重载的情景 : </p><ol><li>内含<code>reference(引用)</code>成员变量的类.</li><li>内含<code>const</code>成员变量的类</li><li>基类将赋值操作符重载声明为private的派生类</li></ol><p>原因都是显而易见的, <code>reference</code>不可改指不同对象, <code>const</code>不可被更改, 派生类基于基类.</p><hr><p>这里额外提一个小点, 就是默认生成的拷贝函数和辅助操作符重载默认都是浅拷贝, 就是只把类类对象的所有值进行复制, 如果有指针, 不会深入拷贝指针指向的内容, 只是单纯把指针本身拷贝.</p><h2 id="条款6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝"></a>条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝</h2><blockquote><p>虽然大多情况下一个类对象应当有外置的构造&#x2F;析构&#x2F;拷贝接口, 但是总会有一些独一无二的东西应当是不可复制的, 就想天下没有第二个你一样, 如果为你自己设计一个类, 你肯定也不希望有一个自动生成的拷贝函数可以拷贝出无数个你吧.</p></blockquote><p>因此, 若不想使用编译器自动生成的函数, 就该明确拒绝.</p><p>所以怎么拒绝呢?</p><ol><li>将该函数写入private中, 并且故意不实现它.</li><li>将该函数后加上<code>= delete</code>.</li></ol><p>假定我们要写一个房产买卖的类<code>HomeForSale</code>, 众所周知每一套房产都是独一无二的.</p><p>我们来看看怎么实现 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员函数</span><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;); <br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;); <span class="hljs-comment">// 这样拷贝函数无法在外部使用就相当于禁用</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 直接声明禁用, 其实在哪声明都可以</span><br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>   ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="设计一个专门为了阻止copying动作的base-class"><a href="#设计一个专门为了阻止copying动作的base-class" class="headerlink" title="设计一个专门为了阻止copying动作的base class"></a>设计一个专门为了阻止copying动作的base class</h4><p>针对某些对象独一无二的情况, 我们可以设计一个专门为了阻止copying动作的base class, 让所有有此需求的类继承自该类, 就可以完全不用在专门处理阻止copying动作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:              <span class="hljs-comment">// 允许构造和析构</span><br>  <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                            <br>  ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                           <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);   <span class="hljs-comment">// 阻止copying</span><br>  Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;     <br>  ...    <span class="hljs-comment">// 自此HomeForSale不需要再进行任何动作就可以实现阻止copying</span><br>&#125;;  <br></code></pre></td></tr></table></figure><p>ed : 也许有人觉得这样子反而多写的, 但在日常情况下<code>Uncopyable</code>完全可以是我们提前备好的, ctrl + v当然方便很多. 再说到为什么是<code>private继承</code>, 在后面的条款中我们会明白, <code>private继承</code>意味着<code>has-a(有一个)</code>的关系, 就是说, 派生类有着基类的部分性质, 而不等于基类, 符合此处<code>HomeForSale</code>和<code>Uncopyable</code>的关系.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住:"></a>请记住:</h3><ul><li>编译器会默认为class创建<code>default构造函数</code>, <code>析构函数</code>, <code>copy构造函数</code>, <code>赋值操作符重载</code>.</li><li>拒绝编译器自动生成的函数, 可以将其写在将该函数写入private中, 并且故意不实现它, 或者直接加上<code>= delete</code></li><li>可以写一些通用类如<code>Uncopyable</code>, 将功能和实现解耦.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款4 初始化</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="headerlink" title="条款04 确定对象被使用前已先被初始化"></a>条款04 确定对象被使用前已先被初始化</h2><blockquote><p>本条讨论如何安全高效地实现初始化, 当然也有一些条件奇葩的初始化值得我们去讨论</p></blockquote><h3 id="普通变量初始化"><a href="#普通变量初始化" class="headerlink" title="普通变量初始化"></a>普通变量初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>cont <span class="hljs-type">char</span> text[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>cin &gt;&gt; d;    <span class="hljs-comment">// 这种也叫初始化</span><br></code></pre></td></tr></table></figure><h3 id="类内变量初始化"><a href="#类内变量初始化" class="headerlink" title="类内变量初始化"></a>类内变量初始化</h3><p>类内变量的初始化一般就是三种, <code>类内设置初始值</code>, <code>缺省值</code> , <code>初始值列表</code>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name = <span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age = <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-type">const</span> string&amp; sex = <span class="hljs-string">&quot;女&quot;</span>) <span class="hljs-comment">// 设置缺省值 (次之)</span><br>    :_name(name.<span class="hljs-built_in">c_str</span>())<br>        ,_age(age)<br>        ,_sex(sex.<span class="hljs-built_in">c_str</span>())<span class="hljs-comment">// 初始化列表 (优先)</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span> : <br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>    <span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">char</span> _sex[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;男&quot;</span>;  <span class="hljs-comment">// 类内设置初始值 (最次)</span><br>&#125;<br><br>Stu s1;  <span class="hljs-comment">// 小红 17 女</span><br><span class="hljs-function">Stu <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;男&quot;</span>)</span></span>;    <span class="hljs-comment">// 张三 35 男 </span><br></code></pre></td></tr></table></figure><p>这里虽然看起来三种方式都可以, 但是只推荐全部使用初始值列表, 当有特别想要设置的默认值时设置缺省值.</p><h3 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3><h4 id="优势描述"><a href="#优势描述" class="headerlink" title="优势描述 :"></a>优势描述 :</h4><p>为了描述初始值列表的优势, 请先阅读以下另一版本的构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age, <span class="hljs-type">const</span> string&amp; sex)<br>&#123;<br>_name = name.<span class="hljs-built_in">c_str</span>();<br>    _age = age;<br>    _sex = sex.<span class="hljs-built_in">c_str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这样子写构造函数其实和我们写初始值列表的最终结果是一样的, 而且相对直观.</p><p><strong>但是</strong>, 该版本在底层每个变量其实是先进行了一次default的构造, 再进行了一次copy操作, 其本质是<code>初始化 + 赋值</code>.</p><p>而<code>初始值列表</code>在底层只进行了一次copy构造, 比前者高效得多, 本质就是<code>初始化</code>.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项 :"></a>注意事项 :</h4><ul><li>最好在初始值列表中初始化所有的成员变量, 这样起码不会忘记没有初始化的变量.</li><li>C++中成员变量的初始化顺序是按照类中声明的次序, 而非初始值列表中的顺序! (如果有继承关系, 基类一定早于派生类初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : _b(b), _a(a) <span class="hljs-comment">// 尽管在初始化列表中是_b在前, 但是依旧是先初始化_a</span><br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a; <span class="hljs-comment">// _a 在 _b 之前声明</span><br>    <span class="hljs-type">int</span> _b; <span class="hljs-comment">// _b 在 _a 之后声明</span><br>&#125;;<br><span class="hljs-comment">// ----------------------------------------------------------//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Purple</span>&#123; <span class="hljs-comment">// 紫色需要类型为红色和蓝色的变量</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Purple</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red) ,<span class="hljs-built_in">b</span>(blue)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;<br>    Blue b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-comment">// Color类存储三种颜色, 并且可以用红蓝配出紫</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Color</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red)<br>        :<span class="hljs-built_in">b</span>(blue)<br>        :<span class="hljs-built_in">purper</span>(r, b)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;           <span class="hljs-comment">//purple p;</span><br>    Blue b; <span class="hljs-comment">//Red r;</span><br>    Purple p; <span class="hljs-comment">//Blue b; 假如是注释中的情况, 将无法编译通过, 因为p需要r,b都初始化完才能初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同编译单元内定义non-local-static对象-的初始化次序"><a href="#不同编译单元内定义non-local-static对象-的初始化次序" class="headerlink" title="[ 不同编译单元内定义non-local static对象 ] 的初始化次序"></a>[ 不同编译单元内定义non-local static对象 ] 的初始化次序</h3><p>初看第一眼根本就不知道是什么东西(再看也不知道), 所以先介绍一下定义:</p><ul><li><p>编译单元 : 可以简单理解为一个单独的<code>.cpp</code>文件或<code>.h</code>文件等, 就是有一定的隔离性.</p></li><li><p><code>local static</code>(局部静态变量) : 生命周期为整个程序, <strong>在局部第一次调用时初始化</strong>, 之后都是用这个.</p></li><li><p><code>non-local static</code>(全局静态变量) : 生命周期也为整个程序, <strong>程序启动时初始化</strong>, 之后都是用这个.(例如全局变量)</p></li></ul><p><code>local static</code>和<code>non-local static</code>的区别简单来看就在于初始化的时机.</p><hr><p>再举一个例子, 如果我在<code>a.h</code>中定义了<code>class A</code>, 在<code>b.h</code>中定义了<code>class B</code>, 又在<code>c.cpp</code>中要求使用类型为A和类型为B的<code>non-local static</code>变量, 那么这两个变量的初始化次序是怎样的?</p><p>答案是<strong>无法判断</strong>, 你看上面的定义, <code>non-local static</code>对象都是在程序启动时初始化, C++根本没有手段判断应该先初始化哪个,所以这就是没有定义的行为!</p><hr><p>说了这么多, 那这样会带来什么隐患呢? </p><p>如果两个编译单元中的类有依赖关系的话, 初始化次序的不确定性就会导致问题!</p><p>假如说B类static变量中使用到了A类static变量的话, 如果在<code>c.cpp</code>中先初始化了B类static变量, 可是A类static变量还没初始化, 那么就只有报错一条路了. </p><hr><p>可能看到这里有人不太理解这种情况有什么应用场景, 那么我在这里引入一个定义 :</p><ul><li>内置型对象 : 这个对象本身并没有太大意义, 目的是为了引出类中的各种功能性函数, 一般是non-local static的.</li></ul><p><strong>进一步解释</strong> : 有些类中会有许多应用实际场景的方法函数, 如果需要使用这些函数, 就需要客户构造一个类对象,再用这个对象使用函数, 那么我们就干脆在类的头文件中声明一个类对象, 要求使用这个头文件的客户必须记得生成一个对应对象, 而这个对象一般是non-local static的. </p><p>假如有一个钟表类, 内部需要用到一个计时器的类, 于是使用了计时器类的内置对象, 当用户创建一个non-local static类型的钟表类对象时, 你无法确定计时器类的内置对象和钟表类对象哪个先初始化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    ....<br>&#125;;<br><span class="hljs-keyword">extern</span> TimeKeeper tk;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(tk.<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里用tk获取当前时间来初始化time</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <span class="hljs-comment">// 如果用户设置一个全局变量的Clock类对象clock, 此时无法确定clock和tk的初始化次序!</span><br>...<br></code></pre></td></tr></table></figure><h4 id="解决方法-以local-static对象替换non-local-static对象"><a href="#解决方法-以local-static对象替换non-local-static对象" class="headerlink" title="解决方法 : 以local static对象替换non-local static对象"></a>解决方法 : 以local static对象替换non-local static对象</h4><p>这个解决方法用到了设计模式中最经典的<code>单例模式</code>的设计思想 : 延迟初始化.</p><p>思路简单来说就是, 既然给出一个non-local static对象有风险的话, 我就不给这个non-local static对象了, 我直接使用一个函数, 当客户有使用内置型对象相应需求的时候, 当真正客户调用这个函数时, 才会使用函数内部的代码自己生成一个local static对象供自己使用, 这样初始化次序就有了保障.</p><p>更通俗易懂地描述一下, 就是虽然不好直接使用内置型对象, 但是可以把函数返回值当成内置型对象来使用,  因为在函数内生成的对象时是local static对象, 没有初始化次序的问题.</p><p>看一看接下来的代码吧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>        <span class="hljs-keyword">return</span> timekeeper;<br>    &#125;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(<span class="hljs-built_in">tk</span>().<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里只是简单地将tk换成了tk(), 从调用对象改为调用函数而已</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <br><span class="hljs-comment">// 设置一个全局变量的Clock类对象clock, 此时一定是clock开始初始化, 当初始化时调用到tk()再进行timekeeper的初始化</span><br>...<br></code></pre></td></tr></table></figure><h4 id="多线程情况下的安全性"><a href="#多线程情况下的安全性" class="headerlink" title="多线程情况下的安全性 :"></a>多线程情况下的安全性 :</h4><p>书中指明, <code>内涵static对象</code>在多线程情况下会带有线程安全的问题, 等待某事发生都会有麻烦.</p><p>如果同时调用tk(), 没办法保证只有一个timekeeper生成, 除非用锁, 但那样花销太大得不偿失.</p><p>所以我们可以在线程的单线程启动阶段<code>手工调用</code>所有的初始化函数(例如tk()), 这样在多线程来临前就可以确保初始化完毕.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>对内置型对象进行手工初始化, C++本身并不会保证正确初始化他们.</li><li>最好使用初始化列表, 并且排序要和类内的声明顺序一致.</li><li>如果有跨编译单元的初始化次序问题, 请以local static对象替换non-local static对象.</li></ul><p>刚开始写博客, 如有错误感谢指正!</p><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款3 const</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 : 尽可能使用const"></a>条款03 : 尽可能使用const</h2><blockquote><p><code>const</code>(不可被改动), 是一种非常有效且多样的语义约束, 有了这项约束, 我们可以借用编译器之手规范我们的代码, 以免带来意想不到的错误, 毕竟任何的改动都会伴随着一定的风险, 如果可以提前规避, 我们何乐而不为呢? </p></blockquote><p><code>const</code>在实际表现上是多才多艺的, 他可以修饰对象, 对象指针, 甚至成员函数, 接下来逐一介绍 :</p><h3 id="const-修饰变量"><a href="#const-修饰变量" class="headerlink" title="const 修饰变量"></a>const 修饰变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>; <span class="hljs-comment">// 这样子定义的N又被称为常变量, 其实也就是常量了(因为不可被改动)</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 众所周知, arr数组名是一个指针</span><br><span class="hljs-type">char</span>* a = arr;<span class="hljs-comment">// a指针可修改, 指针指向的内容可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = arr;<span class="hljs-comment">// b指针不可修改, 指针指向的内容可修改</span><br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> c = arr;<span class="hljs-comment">// c指针可修改, 指针指向的内容不可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> d = arr;<span class="hljs-comment">// d指针不可修改, 指针指向的内容不可修改</span><br></code></pre></td></tr></table></figure><p>谈到指针就不可避免的就会想到<code> 迭代器</code>, 毕竟<code>迭代器</code>就是指针的封装嘛.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//看看下面两种迭代器的定义, 就可以对应上面指针的情况</span><br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-comment">// 迭代器本身是const的, 也就是说本身不可修改, 相当于指针在*前加const</span><br><span class="hljs-comment">// 此时无法进行 ++iter 等操作</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citer = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 语言自带的const_iterator本身就是为了对迭代器指向的内容设置只读, 本身可以进行运算操作, 相当于在*后加const </span><br></code></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><blockquote><p>先明确<code>const</code>成员函数的意义 : 告知编译器这个函数内部的对象不应被改动.</p><p>不是说明函数本身不可改动!!!</p></blockquote><ul><li>那么对成员函数声明<code>const</code>的意义何在?</li></ul><ol><li><strong>使这个函数接口更容易被理解</strong>, 一个函数是否可以改变类内变量的具体数值会很大程度上影响我们对这个函数的定位判断.</li><li><strong>使操作<code>const</code>对象成为可能</strong>, 首先我们要明晰<code>const</code>对象是什么, 就是类定义出的<code>const</code>对象(例如 const Stu stu(小明, 18);), 当我们声明一个类对象为<code>const</code>时, 这个对象对象只能调用<code>const</code>成员函数, 调用的任何<code>non-const</code>成员函数都无法通过编译的, 因此如果你所设计的类有需求<code>const</code>的情景时, 请设计<code>const</code>成员函数.</li></ol><hr><ul><li>这里书中给出了一个事实 : <strong>两个成员函数如果只是常量性不同(const &#x2F; non-const), 也可以被重载.</strong></li></ul><p>​这其实就告诉我们如果想要适配<code>const</code>版本的话, <strong>non-const版本和const版本各写一个就好了</strong>, 编译器会根据对象是否为<code>const</code>来选择使用哪个函数, 样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <span class="hljs-comment">// 1</span><br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <span class="hljs-comment">// 2</span><br> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;<br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数2</span><br>cout &lt;&lt; ctb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数1</span><br></code></pre></td></tr></table></figure><hr><ul><li>接下来需要介绍两种对<code> 成员函数为const</code>时应有行为的流派概念:</li></ul><h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const :"></a>bitwise const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, 应当<strong>不改变对象中的任何变量</strong>, 也就是物理上没有1bit被改变.</p><h4 id="logical-const"><a href="#logical-const" class="headerlink" title="logical const :"></a>logical const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, <strong>可以改变对象中的某些变量</strong>, <strong>但是不能对对象的主要逻辑产生影响</strong>, 也就是说对象在逻辑上没有被改变, 改变的部分只是起辅助优化作用, 例如修改日志, 对计算结果进行缓存, 记录当前容器大小等, 这些工作对主逻辑并没有任何影响, 却可以大大提高主逻辑的工作效率.</p><hr><ul><li>那么C++实际上是怎么定义<code>const</code>成员函数的行为的呢?</li></ul><p>​C++在<strong>一般情况下的定义按照<code>bitwise const</code>的规则进行</strong>, 也就是说一个<code>const</code>成员函数无法改变对象中任何变量.</p><p>​但是这其中有一个C++本身不好决断的情况需要了解 :</p><p>​还记得上面代码中定义的[]重载函数吗 ? const char&amp; operator[](const std::size_t position) const </p><p>​假如我把返回值改为char&amp; : char&amp; operator[](const std::size_t position) const</p><p>​那么这样就会产生一个奇怪的情况 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc = &amp;<span class="hljs-built_in">cbt</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 返回的指针没有const</span><br>*pc = <span class="hljs-string">&#x27;j&#x27;</span>;<span class="hljs-comment">// &quot;hello&quot;被变成了&quot;jello&quot;!!!</span><br></code></pre></td></tr></table></figure><p>​通过以上的情况我们可以发现, C++虽然确保在<code>const</code>成员函数内部不会改变任何对象, 但是并不会检查返回对象所指向的内容是否是不可改变的, C++可能认为在函数外的行为是程序员的自由吧, 所以我们应当注意这一点.</p><hr><ul><li>那么问题又来了, 既然<code>logical const</code>也有其道理所在, C++是如何解决的呢?</li></ul><p>​C++引入了一个与<code>const</code>相关的摆动场 : <strong>mutable(可变的).</strong></p><p>​<code>mutable</code> 的主要用途是在 <code>const</code> 成员函数中允许对特定成员变量的修改, 这样<code>logical const</code>的诉求就可以满足了。</p><p>​请阅读以下代码 : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">text</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br>        <br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">updateLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!lengthIsValid)<br>&#123;<br><span class="hljs-comment">// 以下两句就是因为mutable得以通过</span><br>length = pText.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 重新更新text的长度</span><br>lengthIsValid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 定义当前length可用</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>string pText;<br><br><span class="hljs-comment">// mutable 关键字可以使某个成员变量在const成员函数被修改</span><br><span class="hljs-comment">// 作用是在不改变内部变量的基础逻辑的情况下, 可以引入少量变量可以被改变, 丰富逻辑</span><br><span class="hljs-comment">// 保证函数的安全, 使用mutable意味着在const成员函数中只能改变mutable变量, 其他变量不会被改变</span><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>​以上代码将<code>lenth</code>和<code>lengthIsValid</code>赋予<code>mutable</code>特性, 使其在<code>const</code>成员函数中可以改变, 从而可以用非常小的代价更新<code>text</code>的长度, 方便其他需要使用text长度的函数, 这两个变量均对<code>text</code>存储字符串的主逻辑没有影响.</p><hr><p>​最后还有一个比较有价值的观点 : 我们知道要适配<code>const</code>版本需要写两个类似的函数, 一个处理<code>const</code>对象, 一个处理<code>non-const</code>对象, 但是我们也应当发现这两个函数其实非常相似, 那么这就带来了一些问题:</p><ol><li><strong>代码重复</strong>, 这会带来阅读性降低, 维护成本提高的负面作用.</li><li>我们在以后的条款学习中会知道, 编译器一般会把成员函数替换为<code>inline</code>函数, 这在一般情况下肯定是更高效的, 但是<code>inline</code>函数中的代码越多, 会带来一系列如代码膨胀之类的问题, 这点我们应当避免.</li></ol><ul><li>书中提出了这样的解决方案 : <strong>令<code>non-const</code>版本调用<code>const</code>版本</strong>.</li></ul><p>​这样子做的前提是两个版本的内容一定相等, 或者说<code>non-const</code>版本不能修改对象内的变量, 毕竟如果修改了那和<code>const</code>版本就一定不一样了, 我们来改写上面[]重载的两个版本.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br>&#123; <br>    <span class="hljs-comment">//我们假定[]重载在返回下标引用之前还要做许多工作, 代码量巨大</span><br>    <span class="hljs-comment">// ...边界检验</span><br>    <span class="hljs-comment">// ...将数据访问的行为加入日志</span><br>    <span class="hljs-comment">// ...检验指向内容数据的完整性</span><br>    <span class="hljs-keyword">return</span> text[position]; <br>&#125;<br><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br>&#123; <br>    <span class="hljs-comment">// 这段代码实现了两次类型转换, 目的是调用const版本的operator[]函数并返回non-const的char&amp;</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> text&amp;&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>    <span class="hljs-comment">/* 我们把这段代码拆分开来解读</span><br><span class="hljs-comment">    return const_cast&lt;char&amp;&gt;(    // 3. 将[]返回结果由const版本通过const_cast转换为non-const版本</span><br><span class="hljs-comment">        static_cast&lt;const text&amp;&gt;(*this)  // 1. 先将this指针通过static_cast转换为const text&amp;</span><br><span class="hljs-comment">        [pos] // 2. const text&amp;类型调用[]重载, 自然使用的是const版本的[]重载</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​经过以上的操作, 无论<code>const</code>版本需要多少行代码, <code>non-const</code>版本都只需要一行代码即可, 相当实用.</p><p>​另外如果在<code>non-const</code>版本虽然和<code>const</code>版本十分相似, 但是还是想要修改一部分的数据, 也可以在调用完重载版本后不返回, 再进行一些修改操作再返回.</p><ul><li>小问题 : 为什么不用<code>const</code>版本调用<code>non-const</code>版本?  因为<code>non-const</code>版本不会限制修改行为, 无法监督<code>const</code>实现.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h2><ul><li>将某些东西声明为<code>const</code>可以帮助编译器检查出错误语法, <code>const</code>可被施加于任何对象, 函数参数, 函数返回值, 成员函数</li><li>C++在<code>const</code>成员函数定义上默认支持<code>bitwise const</code>流派, 但是也通过关键字<code>mutable</code>变相支持了<code>logical const</code>流派</li><li>当<code>non-const</code>版本和<code>const</code>版本等价实质时, 可以用<code>non-const</code>版本调用<code>const</code>版本</li></ul><p>作者 : 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款1-2</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/</url>
    
    <content type="html"><![CDATA[<h3 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01 : 视C++为一个语言联邦"></a>条款01 : 视C++为一个语言联邦</h3><blockquote><p>不像Java对各种资源都进行了整合内聚, C++更像是由四种次语言组合而成的语言联邦, 每种次语言都有自己的规约, 也都有不同的用武之地, 每个都可以给C++这门语言带来独特的优势.</p><ul><li><h4 id="C-C-的基础-包含指针-内置数据类型等基础思想"><a href="#C-C-的基础-包含指针-内置数据类型等基础思想" class="headerlink" title="C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想."></a>C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想.</h4></li></ul></blockquote><ul><li><h4 id="Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态"><a href="#Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态" class="headerlink" title="Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态."></a>Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态.</h4></li><li><h4 id="Template-C-泛型编程"><a href="#Template-C-泛型编程" class="headerlink" title="Template C++  :  泛型编程."></a>Template C++  :  泛型编程.</h4></li><li><h4 id="STL-一套template的程序库-包含各种数据结构与算法"><a href="#STL-一套template的程序库-包含各种数据结构与算法" class="headerlink" title="STL  :  一套template的程序库, 包含各种数据结构与算法."></a>STL  :  一套template的程序库, 包含各种数据结构与算法.</h4><p>  这四个方向我们都应熟识掌握, 但是可以给自己这样一个印象 : C++并不是一个一体的语言, 编程时的思想规范应当随你使用C++的对应部分而改变.</p></li></ul><hr><h3 id="条款02-尽量以cnost-enum-inline-替换-define"><a href="#条款02-尽量以cnost-enum-inline-替换-define" class="headerlink" title="条款02 : 尽量以cnost, enum, inline 替换 #define"></a>条款02 : 尽量以cnost, enum, inline 替换 #define</h3><blockquote><p>由 ‘#’ 引出的语句一般与C的预处理机制相关, 我们很需要预处理机制中的 #include 和 #ifdef, 前者保证库的引入, 后者可以针对不同的环境进行条件编译, 而 #define 却在语言的发展下显得有些与时代脱节了, 现在我们应当有心减少 #define 的使用.</p></blockquote><p>以下列举 #define 所带来的一些问题:</p><ol><li>书写代码时很难自动显示错误</li><li>编译错误时显示的信息并不直观</li><li>#define并不重视作用域, 面向全局生效, 这与我们应当坚持的封装思想相悖</li></ol><p>简而言之, 就是#define可能带来一些不可预料的行为并且无法保证类型安全, 而如今我们由足够多的方法可以安全有效地替代#define的功能, 比如const和enum可以替代#define在常量定义上功能, inline又可以替代#define在宏函数上的功能.</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100 <span class="hljs-comment">// 这个步骤在预处理阶段实现</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-comment">// 这个步骤在编译阶段实现</span><br></code></pre></td></tr></table></figure><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里我们想定义三元色的对应数值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED = 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN = 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE = 3</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED = <span class="hljs-number">1</span>, <br>    GREEN = <span class="hljs-number">2</span>,<br>    BLUE = <span class="hljs-number">3</span><br>&#125;<span class="hljs-comment">// 使用enum枚举类型在增强代码的可读性的同时也提升了可维护性</span><br><br><span class="hljs-comment">//-----------------------------------------------------//</span><br><span class="hljs-keyword">enum</span> Action&#123;<br>    RUN = <span class="hljs-number">0x0001</span>,    <span class="hljs-comment">// 第一位</span><br>    JUMP = <span class="hljs-number">0x0002</span>, <span class="hljs-comment">// 第二位</span><br>    SAY = <span class="hljs-number">0x0004</span>, <span class="hljs-comment">// 第三位</span><br>    SLEEP = <span class="hljs-number">0x0008</span> <span class="hljs-comment">// 第四位</span><br>&#125;<span class="hljs-comment">// 使用enum还可以实现比特级别的状态判断</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">CheckAction</span>(<span class="hljs-type">int</span> action);   <span class="hljs-comment">// 假设我们有这样一个检查运动状态的函数, 那么我们就可以只接受一个int就可以判断复数的状态</span><br><span class="hljs-built_in">CheckAction</span>(RUN | JUMP | SAY);<span class="hljs-comment">// 这里的状态就 跑 + 跳 + 说话</span><br></code></pre></td></tr></table></figure><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入我们想实现的MAX(a, b), 我们可以通过以下实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b)  (a) &gt; (b) ? (a) : (b)</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MAX</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用模板 + inline就可以完全代替宏函数的作用, 首先inline的书写模式更加自然, 另外还保证了类型安全, 规避了#define的危险性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
