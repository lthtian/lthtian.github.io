<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Effective C++ 条款24 类型转换与non-member函数</title>
    <link href="/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款24-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24: 若所有参数皆需类型转换, 请为此采用non-member函数"></a>条款24: 若所有参数皆需类型转换, 请为此采用non-member函数</h2><blockquote><p>虽然令classes支持隐式类型转换是一个坏主意, 但常常有许多意外出现, 有些类型之间的关联实在太强, 我们经常想把它们放在一起用,       例如支持int类型隐式转换为Rational(有理数), 当对便利性的需求非常强烈之后, 也许支持隐式类型转换也未必是坏事.</p></blockquote><p>书中给出了一个<code>Rational</code>类, 它可以由<code>int</code>类型隐式转化而来 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,        <span class="hljs-comment">// 这里没有加explicit</span><br>           <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);     <span class="hljs-comment">// 传入int类型可隐式转换为分母是1的Rational类型</span><br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 获取分子</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 获取分母  // 见条款22</span><br><br><span class="hljs-keyword">private</span>:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们一定希望<code>Rational</code>类型可以和int类型相乘, 所以我们来写一个成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                       <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了以上的函数, 我们看看能通过哪些代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * oneEighth;            <span class="hljs-comment">// fine</span><br>result = result * oneEighth;                      <span class="hljs-comment">// fine</span><br><br>result = oneHalf * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneHalf;                             <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个例子无法通过编译, 原因很容易理解, 让我们重写一下上述两个式子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result = oneHalf.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">2</span>);                    <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2.</span><span class="hljs-keyword">operator</span>*(oneHalf);                    <span class="hljs-comment">// 2还没隐式转换, 怎么可能使用operator*</span><br></code></pre></td></tr></table></figure><p>因此我们有了这样的推论 : <strong>只有当参数被列于参数列内, 这个参数才是隐式转换的合格参与者</strong>.</p><p>至于”被调用之成员函数所隶属的哪个对象”, 即<strong>this对象</strong>, 绝不是隐式转换的合格参与者.</p><p>为了支持这样的混合算术运算, 可行之道拨云见日 : </p><p><strong>让operator*成为一个non-member成员函数</strong>, 即可让编译器在每一个实参上执行隐式类型转换. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><span class="hljs-comment">//-----------------------//</span><br><span class="hljs-function">Rational <span class="hljs-title">oneFourth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>Rational result;<br>result = oneFourth * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneFourth;                           <span class="hljs-comment">// fine</span><br></code></pre></td></tr></table></figure><p>问题解决, 皆大欢喜. 有了以上的经验, 我们在看别人代码时, 就不会奇怪于为什么总是要把双目运算符的重载都放在类外作为<code>non-member</code>定义了, 说明他们也深谙上述的道理, 也许有时并没有隐式转换的需求大家还是这样写, 可能是因为习惯了.</p><hr><p>有人可能认为<code>operator*</code>可以作为友元与<code>Rational</code>类加强联系, 但完全没必要, 除非它要调用<code>Rational</code>的<code>private</code>数据, 不然这样只会降低其封装性(见条款23), 我们<strong>不应当只因函数不该成为member, 就自动让它成为friend</strong>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>如果你需要为某个函数的所有参数进行类型转换, 那么这个函数必须是个<code>non-member</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(1)</title>
    <link href="/2024/12/02/2024-12-2-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2024/12/02/2024-12-2-%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>人只有想起自己的无知才能有长进, 但他如此忙碌于运用自己已有的知识, 又如何能想得起来呢?</p></li><li><p>受制于对自己的看法, 受制于他通过自己行动所赢得的名誉.</p></li><li><p>大家好像都选择了相同的生活模式, 好像这种模式是在他们清醒时做出的选择, 然而其实他们并不认为还有其他模式可选, 但聪敏而健康的人记得太阳每天都会升起.</p></li><li><p>所有的改变都是奇迹, 但这种奇迹时时刻刻都在发生.</p></li><li><p>在当前的境况中找到他们的勇气和灵感, 怀着恋人般的怜爱和热情, 珍惜着此时此刻的生活.</p></li><li><p>没有人会因为衣服上有补丁而显得卑贱.然而我敢说, 普遍而言, 人们追求衣服时髦或者至少干净并且没有补丁的心情, 远比追求良知完整无损的心情要迫切.</p></li><li><p>商品的价格就是你用来换它的那部分生命.</p></li><li><p>让群众热切地跟风的时尚其实都是奢靡浪费的人设定的.</p></li><li><p>最好的艺术作品应该表现人如何奋斗着将自己从这种境况中解放出来, 但我们的艺术却只致力于使某种境界变得舒适, 并让人忘记更高级的境界.</p></li><li><p>在用美丽的物品装饰房子之前, 我们必须清理墙壁, 清理我们的生活, 还必须有美丽的家务管理和美丽的生活方式做基础.</p></li><li><p>对于生活, 大学生不应抱着玩乐的态度, 也不应只是研究它, 而是自始至终真诚地去过好它.</p></li><li><p>我盼望每个人都能非常清醒地去发现和追求他自己的生活方式.</p></li><li><p>做好事, 做人们常说的好事, 绝不应成为我人生的主要目标, 而且基本上绝不应刻意为之.与其去做好事, 不如做个好人.</p></li><li><p>人世间最难闻的莫过于变了味的好事.</p></li><li><p>做好事几乎是人人都称赞的美德, 人们不仅称赞他, 还给予他过高的评价; 而高估他的, 正是我们的自私心.</p></li><li><p>我们应该散发出去的, 不是绝望, 而是勇气, 不是病态, 而是健全.</p></li><li><p>所有的健康和成功都对我有益处, 哪怕他可能显得遥不可及; 所有的疾病和失败只会让我感到悲伤和对我有坏处, 哪怕他能引起我的怜悯, 或者让我得到许多同情.</p></li><li><p>我们不要去做管理穷人的官员, 而是要努力成为对这个世界有贡献的人.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款22-23 封装性相关</title>
    <link href="/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款22-将成员变量声明为private"><a href="#条款22-将成员变量声明为private" class="headerlink" title="条款22 : 将成员变量声明为private"></a>条款22 : 将成员变量声明为private</h2><p>本条款中, 作者明确声明, 如果没有必要的原因, 务必将成员变量声明为<code>private</code>, 而非<code>public/protected</code>, 并苦口婆心地列举出了非常多使用<code>private</code>的优势, 让我们逐一阅览 : </p><ul><li><h4 id="保证了语法一致性"><a href="#保证了语法一致性" class="headerlink" title="保证了语法一致性"></a>保证了语法一致性</h4><p>当客户通过对象调用时, 如果将成员变量声明为<code>private</code>, 那么就省去了客户思考要不要加小括号的问题, 只要无脑加括号就行了.</p></li><li><h4 id="对成员变量的处理更加精确"><a href="#对成员变量的处理更加精确" class="headerlink" title="对成员变量的处理更加精确"></a>对成员变量的处理更加精确</h4><p>当你把成员变量声明为<code>public</code>时, 客户拥有对该变量的所有特权, 可读可写, 然而我们一定不希望这样, 如果我们把成员变量声明为<code>private</code>, 通过<code>public</code>函数, 我们希望客户读时就返回一个<code>const reference</code>, 希望写就让客户传入修改值, 在函数内部修改, 如果不希望读写就不暴露在外置接口中.</p></li><li><h4 id="保证了封装性"><a href="#保证了封装性" class="headerlink" title="保证了封装性"></a>保证了封装性</h4><p>书中提出 : <strong>Public意味不封装, 不封装意味不可改变</strong>, 因为成员变量很大程度上是会被广泛使用的, 会出现在无数客户代码中, 如此牵一发而动全身, 就算你以后想改, 可客户就不一定想改了. <code>protected</code>也是同理, <strong>protected成员变量就像public成员变量一样缺乏封装性</strong>, 虽然成员变量并不开放给客户, 但是如果你之下有无数的派生类, 带来的修改难度也是非同一般, 由此可以得出一个结论 : <strong>成员变量的封装性与”成员变量的内容改变所破坏的代码数量”成反比</strong>.</p><p>而当我们使用private成员变量, 我们的修改范围就仅仅只局限在类内, 非常易于事后的修改. <strong>就算外部可以通过函数访问该成员变量, 日后希望对这个变量进行替换或修改, 外部也全然不知. 也就是说, 把成员变量隐藏在函数接口背后, 可以为所有可能的实现提供弹性</strong>.</p><p>书中给出了一个速度收集器的类, 保存每次测量到的速度, 可以返回当前状态下的速度平均值, 雏型如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedDataCollection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; data;<br>  ...<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span></span>;          <span class="hljs-comment">// 将收集到的速度存入data中</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">averageSoFar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 通过某些算法求得平均值并返回</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来假定一个情景, 这个类使用于一个嵌入式模板内, 一开始我们的可使用内存很少, 也不是很要求高效, 于是我们在<code>averageSoFar()</code>中的策略就是遍历<code>data</code>, 求出总和再求平均值. </p><p>当我们技术不断提高, 可使用内存变大了, 对计算效率有了需求, 我们就可以多加一个<code>private</code>成员变量<code>sum</code>额外记录<code>data</code>的总和, 然后修改<code>averageSoFar()</code>中的处理逻辑, 让其直接用<code>sum</code>求平均值, 效率可以从<code>O(N)</code>提到<code>O(1)</code>. </p><p>然而不管我们修改了什么, 外部<code>averageSoFar()</code>的使用者都不会知道.</p><p>这种<strong>把成员变量隐藏在函数接口背后</strong>的方式, 除了以上行为, <strong>还可以使得成员变量被读写时轻松同时其他对象, 验证class的约束条件以及函数的前提和事后条件, 实现在多线程环境中执行同步控制</strong>.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>切记将成员变量声明为<code>private</code>. 这有助于一致性, 访问控制, 允许约束条件获得保证, 提升类的实现弹性.</li><li><code>protected</code>并不比<code>public</code>更具封装性.</li></ul><hr><h2 id="条款23-宁以non-memeber-non-friend替换member函数"><a href="#条款23-宁以non-memeber-non-friend替换member函数" class="headerlink" title="条款23 : 宁以non-memeber non-friend替换member函数"></a>条款23 : 宁以non-memeber non-friend替换member函数</h2><p>本条款告诉我们, 如果一个成员函数没有直接访问成员变量的需求, 那么推荐将其替换为<code>non-memeber</code>且<code>non-friend</code>的函数.</p><p>想理解本条款可以先对封装性有进一步的认知 : </p><p>书中提出, 封装的本质在于<strong>隐藏内部实现和暴露有限接口</strong>, 至于我们为什么推崇封装, 是因为它<strong>使我们能改变的事务只影响有限客户</strong>, 就是说大大降低了我们后期做出改变时的维护成本. </p><p><strong>一个类的封装性和它的数据, 也就是成员变量息息相关</strong>, 愈少的代码可以看到数据, 愈多的数据就可以被封装, 封装性也就越强. </p><p>然而我们通常情况下认为数据以及操作数据的那些函数应该被捆绑在一起, 这样子是在实现所谓的封装, 然而正如我们前面所说, <strong>愈多成员函数可以访问数据, 数据的封装性就越低</strong>.</p><p>成员函数是实现封装的必要手段, 但并不代表我们可以毫无顾虑地增加成员变量, 每有一个函数可以访问到内部数据, 我们的维护成本就会提高一些, 因为你不一定会记得哪个函数有没有在什么不起眼的地方调用了我们的底层数据. 当然如果你预想的成员函数必须调用成员变量, 那完全没有问题. </p><p>书中给出了一个用于管理网络浏览器的类, 其中有一些用来清理的函数, 有的用来清理高速缓冲区, 有的用来清理历史记录, 有的用来移除<code>cookie</code>, 让我们看看书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在大多数情况下是希望同时调用这三个函数的, 于是我们可以写一个统合函数<code>clearBrowser()</code>, 按照习惯我们可能就把它写为成员函数了, 但有了上面的认知, 我们可以直接把它写成一个<code>non-memeber non-friend</code>函数,  代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br>    <span class="hljs-comment">// void clearBrowser(WebBrowser&amp; wb); // 请放弃这种写法</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>  wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们知道<code>clearBrowser</code>内部不会以任何形式直接调用数据,  所以干脆直接把<code>clearBrowser</code>排除在外, 这不只是告诉未来的自己, 也是在告诉将要维护这份代码的其他人, 这个函数从机理上就不可能触及底层数据, 是绝对安全的, 封装性因此得到提升.</p><p>当然还是要把他俩放在<strong>同一个命名空间</strong>内, 不然就真互相找不到了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>书中还提出 : 像是这种<code>clearBrowser</code>不触及底层数据的伪成员函数, 我们一般称其为便利函数, <strong>将所有的便利函数放在多个头文件内但隶属于同一个命名空间, 可以使编写者轻松找到并扩展某些方向的便利函数</strong>, 示例如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<span class="hljs-comment">// 核心机能</span><br>     ...                                <br>&#125;<br><br><span class="hljs-comment">// header &quot;webbrowserclear.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>; <span class="hljs-comment">// 有关内存清理的便利函数</span><br>  ...                                   <br>&#125;   <br><br><span class="hljs-comment">// header &quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关书签日志的便利函数</span><br>&#125;                                       <br><br><span class="hljs-comment">// header &quot;webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关cookie的便利函数</span><br>&#125;                                      <br>...<br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>宁以<code>non-memeber non-friend</code>替换<code>member</code>函数, 如果这个函数没有访问底层数据的必要的话. 这样子可以增加封装性, 包裹弹性和可扩展性.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款21 必须返回对象时, 别妄想返回其reference</title>
    <link href="/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/"/>
    <url>/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    
    <content type="html"><![CDATA[<h2 id="条款21-必须返回对象时-别妄想返回其reference"><a href="#条款21-必须返回对象时-别妄想返回其reference" class="headerlink" title="条款21 : 必须返回对象时, 别妄想返回其reference"></a>条款21 : 必须返回对象时, 别妄想返回其reference</h2><blockquote><p>当程序员领悟了条款20所讲的pass-by-value的种种效率问题之后, 往往会变成十字军战士, 一心一意根除pass-by-value的存在, 然而这却会让他们犯下一些致命的错误, 通过本条款让我们来了解.</p></blockquote><p>阅读完本文章, 我更倾向于把本条款解释为 :</p><ul><li>必须返回<strong>新</strong>对象时, 别妄想返回其reference.</li></ul><p>这样子会更便于理解.</p><p>书中给出了一个有理数类, 用于计算一个有乘积的有理数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,<span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> n, d;  <span class="hljs-comment">// 有理数的分子和分母</span><br><br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们最初的设想, <code>operator*</code>是传值返回的, 这不由得引发我们顾虑, 我们确实是希望其返回一个新的代表<code>lhs</code>和<code>rhs</code>乘积的<code>Rational</code>对象, 但是传值返回的拷贝构造成本也许会很高, 因此有不同的程序员想出了三种不同返回策略, 但无一例外都是错误的, 让我们看书中逐一反驳.</p><hr><h4 id="返回一个pointer-reference指向一个-local-stack-对象"><a href="#返回一个pointer-reference指向一个-local-stack-对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个 local stack 对象"></a>返回一个pointer&#x2F;reference指向一个 local stack 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们的目的是避免调用构造函数, 这样不仅没有避免, 而且<code>result</code>还是一个<code>local</code>对象, 出了作用域就会被销毁, 返回的引用是一个悬挂引用! 我们首先应当知道的, 就是不要让函数返回一个函数内局部变量的<code>reference</code>, 也就是返回引用的生命周期一定要大.</p><hr><h4 id="返回一个reference指向一个heap-allocated对象"><a href="#返回一个reference指向一个heap-allocated对象" class="headerlink" title="返回一个reference指向一个heap-allocated对象"></a>返回一个reference指向一个heap-allocated对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>  <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其一还是会进行构造, 其二这会带来严重的内存泄露, 首先你必须记得在外部要执行delete, 其次当你进行连乘时, 例如<code>a * b * c</code> , 你永远无法获得<code>b*c</code>是new出来的指针, 也就是说必然内存泄露.</p><hr><h4 id="返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象"><a href="#返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象"></a>返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,    <span class="hljs-comment">// 有风险的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)    <br>&#123;<br>  <span class="hljs-type">static</span> Rational result; <br>  result = ...;            <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个原理上看来没有问题, 但是只要使用<code>static</code>对象就一定会伴随着多线程情况下的风险, 这样就显得有弊端了, 除非你可以保证这个代码不会在多线程情况下出问题或是通过锁保证了线程安全, 就像我们条款4中提到的初始化策略一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>    <span class="hljs-keyword">return</span> timekeeper;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会确保这个函数在多线程之前的单线程阶段就都调用过一次来实现初始化.</p><hr><p>看过以上的三种情况后, 最后还是直接返回对象吧!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说即使要承担构造和析构的成本, 也还是推荐直接传值返回, 但是要知道Effective C++已经是十几年前的老书了, 现在伴随着C++11的引入, 带来了<strong>移动语义</strong>的新机制, 这种机制对传值返回带来了极大的优化, 简单来说就是不会有多余的构造和析构了, <strong>编译器会直接在原本要析构的临时对象上直接构建要传出的新对象</strong>, 也就是说传值返回的效率得到了极大的提升, 而这也与本条款的要求不谋而合, 可见Effective C++的条款还是禁得住时间历练的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>绝对不要返回一个<code>pointer/reference</code>指向一个<code>local stack</code>对象, 返回一个<code>reference</code>指向一个<code>heap-allocated</code>对象, 返回一个<code>pointer/reference</code>指向一个<code>local static</code>对象而有可能同时需要多个这样的对象. </p></li><li><p>请优先考虑传值返回吧, 在C++11引入移动语义后它如有神助!</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款20 宁以pass-by-reference-to-const替换pass-by-value</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    
    <content type="html"><![CDATA[<h2 id="条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20 : 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20 : 宁以pass-by-reference-to-const替换pass-by-value</h2><blockquote><p>本条款将告诉我们函数传参时的最佳策略.</p></blockquote><p>我们都知道, <code>pass-by-value</code>(传值传参)是一个费时费力的过程, 它会直接复制一个原件的拷贝, 如果是自定义类就会调用一次拷贝构造来实现复制, 函数结束时还要额外调用一次析构函数, 我们会很有意愿去削减这方面的花销.</p><p>相信我们在别处的很多函数中都看见过<code>pass-by-reference-to-const</code>的存在, 在本书中也极力推荐这种写法, 足矣见得这种写法的高效与广泛, 就像下面这行函数定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><p>reference的底层一般是个指针, 也就是说我们只是用了一个传递指针的花销就实现了参数的传递, 再加上const, 这对我们传入引用的安全性给予了保证,  使得这个写法<strong>兼具了效率与安全</strong>, 是不可多得的好事.</p><p>另外书中还给出了一个好处 : <strong>避免对象切割问题</strong>.</p><p>我们都知道多态中的动态类型是依靠指针和引用来触发的, 简单来说就是也许某个指针或引用的静态类型是基类, 但是动态类型可以通过实际的赋值来改变, 实现动态类型的绑定, 这点可是一个普通的类对象做不到的. 当我们使用<code>pass-by-reference-to-const</code>, 其实也就符合了这种性质, 我们来看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<span class="hljs-comment">// 普通窗口</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 返回窗口名</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 窗口显示函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window &#123;<span class="hljs-comment">// 高级窗口! 它带滚动条!</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 对窗口重写</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面是一对父子类, 下面是分别用两种传值方法的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span>         <span class="hljs-comment">// pass-by-value</span></span><br><span class="hljs-function"></span>&#123;                             <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span>   <span class="hljs-comment">// pass-by-reference-to-const</span></span><br><span class="hljs-function"></span>&#123;                                           <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用以下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<br></code></pre></td></tr></table></figure><p>如果我们调用前者, 答案是只能调用基类的<code>display()</code>, 因为<strong>对象被切割了</strong>, <code>wwsb</code>被强行从派生类被切割成了基类, 这很正常, 传一个对象可没有什么多态的机制.</p><p>如果我们调用后者, 结果很成功, 调用的就是派生类的<code>display()</code>, 因为<code>w</code>虽然静态类型是<code>Window</code>, 但由于引用的对象<code>wwsb</code>类型是<code>WindowWithScrollBars</code>, 所以动态类型绑定为了派生类, 调用就正确了. 说的有些复杂了, 可以宏观理解为<code>pass-by-reference-to-const</code>是虚函数机制实现的必要手段.</p><hr><p>吹了那么久<code>pass-by-reference-to-const</code>, 那么就没有什么情况要用<code>pass-by-value</code>的吗?</p><p>答案是有的, 先看书中给出的最终结论 : <strong>内置类型, STL迭代器, 函数对象推荐用pass-by-value</strong>.</p><p>原因很简单, <code>pass-by-reference-to-const</code>说到底也就是一个指针的花销, <strong>一些内置类型的花销甚至比指针花销还小</strong>, 而<strong>STL迭代器和函数对象内部也就是一个或几个指针</strong>而已, 差不了多少, 当然也有一部分原因是习惯所致.</p><p>有人可能认为只包含小型对象的自定义类型也可以用<code>pass-by-value</code>, 这样的想法是有漏洞的.</p><p>书中给出了三个原因 : </p><ol><li>对象小不代表<strong>构造和析构函数的花销</strong>就不小, 如果你直接<code>pass-by-value</code>一个STL的<code>set</code>, 其内部对象也就是几个指针, 是所谓的”小对象”, 但是构造和析构的开销就不知道大多少倍了.</li><li><strong>某些编译器对待内置类型和自定义类型的态度截然不同</strong>, 编译器很乐意把内置类型对象放进缓存器, 但一个自定义类对象就不会有此般关怀.</li><li><strong>一个类创建完后是需要维护的</strong>, 你现在对象小, 不代表以后就不会根据客户需求加入额外的变量, 除非你在一开始就把框架定死了.</li></ol><p>因此书中才给出了我们上面的最终结论.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽量以pass-by-reference-to-const替换pass-by-value, 前者高效, 安全, 并且有效解决了切割问题.</li><li>以上规则不适用于内置类型, STL迭代器, 函数对象, 它们适合pass-by-value.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款19 设计class犹如设计type</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    
    <content type="html"><![CDATA[<h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19 : 设计class犹如设计type"></a>条款19 : 设计class犹如设计type</h2><blockquote><p>C++ 是面向对象编程语言, 当你定义了一个新class, 也就定义了一个新type. 然而设计一个优秀的class是一项艰巨的任务, 正如设计一个好的type是一项艰巨的任务. 本条款将依照一个好的类型应有的行为来指导我们class的设计, 并一一列举出来.</p></blockquote><p>当我们要设计一个<code>class</code>时, 让我们对自己提出这些问题吧 : </p><ul><li><p><strong>新type的对象应该如何创建和销毁?</strong></p><p>想想<code>class</code>的构造和析构是否可以默认生成 不能的话该怎样编写.</p><p>想想是否要是设计内存的分配函数和释放函数.</p></li><li><p><strong>对象的初始化和对象的赋值该有什么样的差别?</strong></p><p>想想在<code>class</code>构造时需要有什么特殊的步骤, 以及是否需要设置一个<code>init</code>函数辅助构造.</p><p>想想<code>copying</code>时的策略是怎样的. (见条款14)</p></li><li><p><strong>新type的对象如果被 pass-by-value(以值传参) , 意味着什么?</strong></p><p>记住copy构造函数用来定义一个<code>type</code>被 <code>pass-by-value</code> 应当产生的行为.</p></li><li><p><strong>什么是新type的”合法值”?</strong></p><p>想想class的成员变量在你的预期中是否有一个合法的范围, 想想该怎样约束.</p><p>想想是否要设置超出合法范围时触发的检查机制.</p></li><li><p><strong>新type需要配合某个继承图系吗?</strong></p><p>如果其继承自某些既有的<code>class</code>, 你就应当受到那些<code>class</code>设计的束缚, 好好分析那些<code>virtual</code>函数是否要重写, 哪些不用.</p><p>尤其看看析构函数是否为<code>virtual</code>. (见条款7)</p></li><li><p><strong>新type需要什么样的转换?</strong></p><p>想想你的<code>class</code>可以和其他<code>class</code>产生什么可能且合理的转换, 如果有可以考虑实施.</p><p>如果有就写一个类型转换函数或接受其他类型的构造函数, 没有请声明<code>explicit</code>.</p></li><li><p><strong>什么样的操作符和函数对此新type而言是合理的?</strong></p><p>这个属于你的设计私事, 但也必须考虑清楚.</p></li><li><p><strong>什么样的默认成员函数应该驳回?</strong></p><p>将需要驳回的成员函数设置为<code>private</code>或者直接<code>delete</code>掉. (见条款6)</p></li><li><p><strong>谁该取用新type的成员?</strong></p><p>想想哪些成员应设为<code>public</code>, 哪些应设为<code>protected</code>, 哪些应设为<code>private</code>. </p><p>想想哪些<code>classes/functions</code>应是<code>friends</code>. </p></li><li><p><strong>什么是新type的”未声明接口”?</strong></p><p>想想你的<code>class</code>不对外的底层函数可以提供什么样的服务, 是否进行资源运用, 是否需要应对多线程情况, 以此在实现中加上相应的约束条件.</p></li><li><p><strong>新type有多么一般化?</strong></p><p>想想你的<code>class</code>是否要接受泛型编程, 有没有使用泛型编程的必要.</p></li><li><p><strong>真的需要一个新type吗?</strong></p><p>想想真的要定义一个新的class吗? 在你定义<code>derived class</code>时, 如果只是单纯地想添加一些机能, 而不是出于多态考虑, 那么说不定单纯定义一个或多个 <code>non-member</code> 函数或 <code>templates</code>, 更能够达到目标. 就像是<code>STL</code>源码中的<code>priority_queue</code>, 为了使用堆机制其实并没再建立一个专属的堆类, 而是写了几个用于调整堆结构的函数, 再套在<code>vector</code>上就实现了堆的功能.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>class</code>的设计就是<code>type</code>的设计, 在设计一个<code>class</code>之前请确定思考过本条款所提出的所有问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款18 设计正确易用的接口</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款18-让接口容易被正确使用-不易被误用"><a href="#条款18-让接口容易被正确使用-不易被误用" class="headerlink" title="条款18 : 让接口容易被正确使用, 不易被误用."></a>条款18 : 让接口容易被正确使用, 不易被误用.</h2><blockquote><p>C++在接口之海漂浮, 一个好的接口很容易被正确使用, 不容易被误用.</p></blockquote><p>条款18其实是一个很宏观的条款, 让接口变得正确易用, 简单来说就是”<strong>促进正确使用</strong>“和”<strong>阻止误用</strong>“.</p><p>我们先从<strong>阻止误用</strong>的角度考虑, 对接口来说, 是否误用无非就是参数传递的类型对不对, 参数是否合法, 是否符合设计者的设想.</p><p>书中给出了一个日期类, 分别由年月日的成员变量, 我们先来看第一个给出的构造函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样设计在设计者看来很合理, 但是没有任何合法性检查只会带来无穷的隐患, 我们可以从中看出以下问题 : </p><ul><li>客户不一定知道是按月日年的顺序来输入, 如果是我们的日常习惯, 可能会输入年月日.</li></ul><p>如何使用户在编写过程中就知道自己写错了呢? </p><p>书中告诉我们的方法是 : <strong>导入新类型</strong>, 因为问题的根源是年月日的变量类型都是相同的<code>int</code>, 如果设定为不同的类型, 就可以确保输入的正确性了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span> &#123;            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span> &#123;                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>     <span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>         <span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">  :val(d) &#123;</span>&#125;              :<span class="hljs-built_in">val</span>(m) &#123;&#125;                    :<span class="hljs-built_in">val</span>(y)&#123;&#125;<br><br>  <span class="hljs-type">int</span> val;                <span class="hljs-type">int</span> val;                      <span class="hljs-type">int</span> val;<br>&#125;;                      &#125;;                            &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>...<br>&#125;;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>;                      <span class="hljs-comment">// 错误, 不是int!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Day(<span class="hljs-number">30</span>), Month(<span class="hljs-number">3</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 错误, 顺序错了!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 正确, 类型和顺序相对应</span><br></code></pre></td></tr></table></figure><p>当然还有一些数值我们可以提前限制, 比如一年肯定只有12个月, 我们就可以让用户不用直接通过构造传参, 而是用函数返回需求的<code>Month</code>对象, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125; <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125;  <br>  ...                                       <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125; <br>  ...                                      <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>;  <span class="hljs-comment">// 不让用户显式使用构造, 只能通过成员函数内部调用</span><br>&#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month::Mar(), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <span class="hljs-comment">// 这样我们就可以这样调用了</span><br></code></pre></td></tr></table></figure><p> 书中提出<strong>以函数替换对象</strong>也是一种预防客户输入错误的方式.</p><p>当然通过<strong>const限制类型操作</strong>也是一种方式, 这里就不再举例.</p><hr><p>讲完了阻止误用, 那么如何<strong>促进正确使用</strong>呢? </p><p>正确使用, 简单来说就是<strong>符合使用者的习惯</strong>, 使用者的习惯是什么呢? 当然是<strong>使用内置类型</strong>呀, 使用者当然希望可以像使用<code>int</code>一样使用其他自定义的类型.</p><p>因此书中提出: <strong>除非有好理由, 否则应该尽量令你的自定义类型的行为与内置类型一致.</strong></p><p>实际来说就是<strong>用好运算符重载, 有必要时考虑迭代器的设计模式</strong>.</p><hr><p>书中还提出了一个重要观点 : </p><ul><li><strong>任何接口如果要求用户必须记得做某些事情, 就是有者”不正确使用”的倾向.</strong></li></ul><blockquote><p>接下来的内容有关条款13和14, 没有看过的可以看我往期的博客.</p></blockquote><p>让我们回到条款13中提出的<code>createInvestment()</code>工厂函数, 他会返回一个资源的原始指针, 而我们应当用<code>shared_ptr</code>去封装该指针, 这就成了用户必须记得做的事情, 那么为了让该函数返回的内容更易用, 我们可以在直接返回一个智能指针, 函数声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Investment* createInvestment();</span><br><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><hr><p>函数内部实现并非本条款的重点, 但是书中也花了部分篇幅去讲解, 我也会跟着解释清楚, 先看内部的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br>    <br>  ...                                <span class="hljs-comment">// 中间部分实现工厂函数的内存分配步骤</span><br>      <br>  <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到<code>shared_ptr</code>构造的两个参数我们可能会有点懵, 我们来一个个分析 : </p><p>首先我们明确<code>stl</code>中<code>shared_ptr</code>构造的第一个参数是<strong>原始资源类型的指针</strong>, 第二个参数是<strong>删除器函数</strong>.</p><p>先讲第二个参数, 看过条款14的都知道, <code>getRidOfInvestmen</code>t应当是我们提供给<code>shared_ptr</code>在析构时使用的函数, 它存在的意义在于某些类型没有传统的析构, 而是一些特殊的释放函数, 需要我们手动调用, 我们把这些函数放在删除器中, 就可以化手动为自动, 我们这里是假定<code>Investment</code>是有这种需求的类型, 如果不是当然可以不写. 这种由设计者自己定制删除器的行为其实也是在减少客户不必要的释放步骤, 与本条款的理念相符合.</p><p>接下来是第一个参数, 我们应当传入一个原始资源类型的指针, 按道理来说应该是通过<code>new Investment()</code> 返回一个指针直接存进去, 但这里选择先不进行动态分配, 直接存入一个<code>nullptr</code>, 而且由于<code>shared_ptr</code>构造不允许隐式类型转换, 所以要把<code>nullptr</code>强转成<code>Investment*</code>类型, 也就是<code>static_cast&lt;Investment*&gt;(nullptr)</code>了, 因此<code>retVal</code>刚生成时并没有分配到资源, 是在接下来中间部分实现内存分配.</p><p>这里深入一下, 为什么工厂函数中要先构造指针再分配内存, 而不是先分配内存再给指针构造? 这里有两点原因 : </p><ol><li><p>可能需要<strong>通过不同的条件以不同的方式分配内存</strong>, 这是也是工厂函数存在的意义所在.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">(<span class="hljs-type">bool</span> isPremium)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br><br>    <span class="hljs-comment">// 根据条件选择不同的分配方式</span><br>    <span class="hljs-keyword">if</span> (isPremium) &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;PremiumInvestment&gt;();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;RegularInvestment&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析以上代码, 我们可以知道<code>Investment*</code>的静态类型是一个基类指针, 但是通过<code>isPremium</code>和多态机制, 我们可以根据传入的<code>isPremium</code>来选择其动态类型是派生类的<code>PremiumInvestment</code>还是<code>RegularInvestment</code>进而产生不同的内存分配策略, 而这起码要我们先有一个指针对象才行.</p></li><li><p><strong>分配内存是有可能出现异常的</strong>, 如果出现异常先前分配的内存就泄露了, 但如果提前构造指针, 再用<code>make_shared</code>函数获取内存, 就算发生异常也一定是安全的, 因为<strong>指针会调用析构把先前的内存释放</strong>.</p></li></ol><p>也许略微有些跑题, 但是我觉得能看透问题的本质才是最重要的, 因此多下了一些功夫.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>阻止误用的方法包括 : 导入新类型, 以函数替换对象, 利用const限制, 消除客户的资源管理责任, 不要让客户必须记得某些事情.</strong></li><li><strong>促进正确使用的方法包括 : 保证接口的一致性, 与内置类型行为兼容.</strong></li><li>可以通过设定定制的删除器减少客户手动调用释放函数的负担.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款16-17 new 和 delete</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/</url>
    
    <content type="html"><![CDATA[<h2 id="条款16-成对使用new和delete时要采用相同形式"><a href="#条款16-成对使用new和delete时要采用相同形式" class="headerlink" title="条款16 : 成对使用new和delete时要采用相同形式"></a>条款16 : 成对使用new和delete时要采用相同形式</h2><p>直接看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;                     <br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure><p>这个其实没什么好说的, 其实就是相对应就行.</p><hr><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 : 以独立语句将newed对象置入智能指针"></a>条款17 : 以独立语句将newed对象置入智能指针</h2><p>在条款15我们知道C风格API喜欢直接调用原始资源, 那么我们来看一个不用直接调用原始资源的API : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来在某动态分配的Widget上进行某些带有优先权的操作, 所以需要传入一个智能指针和一个优先度, 那么现在<strong>假定去求优先度其实是一个很复杂的过程</strong>, 我们需要额外封装一个函数来返回求得的优先度 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>那么我们设想的调用<code>processWidget</code>的方法可能是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>这里的<code>priority()</code>函数嵌套是没有问题的, 我们日常中也推荐多用这种手法, 但是前面的new就有问题了, 因为<code>shared_ptr</code>不支持隐式转换, 也就是无法通过<code>new</code>出一个<code>Widget*</code>再转换成<code>shared_ptr&lt;Widget&gt;</code>, 那么下面的修改是否合理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>一眼看上去非常合理, 但是还是有一些隐患在其中, 我们知道<code>priority()</code>是一个很复杂的过程, 既然复杂就有可能会抛出异常, 抛出异常本身并不可怕, 我们可以设置对应的处理逻辑, 但是在这样的调用发生异常就有额外的问题了.</p><p>问题核心在于<strong>C++在函数参数的调用上弹性很大, 并不确定实际的调用步骤</strong> , 真正的调用步骤由编译器选择效率最高的步骤.</p><p>我们先来看看按顺序会发生什么 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>shared_ptr</code>构造函数</li><li>调用<code>priority()</code></li></ul><p>虽然我们确定执行 <code>&quot;new Widget&quot;</code> 表达式一定在调用<code>shared_ptr</code>构造函数之前, 但是我们确实不确定<code>priority()</code>的调用时机 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>构造函数</li></ul><p>如果是这样的话, 在priority()调用过程中发生了异常, 就算之后异常得到了处理,<code> &quot;new Widget&quot;</code>得到的资源也很大可能是被泄露了.</p><p>这一切的问题来源于<strong>在”资源被创建”和”资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰</strong>.</p><p>解决方法很简单, 那就是标题 : <strong>坚持以独立语句将newed对象置入智能指针</strong>, 这样就可以杜绝一切异常干扰了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;  <br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <br></code></pre></td></tr></table></figure><p>于是以上操作就没有任何问题了!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>成对使用<code>new</code>和<code>delete</code>时要采用相同形式.</li><li>以独立语句将<code>newed</code>对象置入智能指针.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款15 在资源管理类中提供对原始资源的访问</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 : 在资源管理类中提供对原始资源的访问"></a>条款15 : 在资源管理类中提供对原始资源的访问</h2><blockquote><p>我们将资源存入资源管理类, 为的是可以免去资源管理的麻烦, 但同时我们也希望<strong>可以正常合理地通过资源管理类来使用资源, 就像直接使用资源一样</strong>, 为此我们一定需要在资源管理类中提供对原始资源的访问;</p></blockquote><p>我们先来解答一些疑问 : </p><ul><li><h4 id="为什么要对原始资源进行访问-为什么要获取原始资源的指针"><a href="#为什么要对原始资源进行访问-为什么要获取原始资源的指针" class="headerlink" title="为什么要对原始资源进行访问(为什么要获取原始资源的指针)?"></a>为什么要对原始资源进行访问(为什么要获取原始资源的指针)?</h4><p>有时候需要我们传递原始资源的指针, 因为很多<code>C API</code>都是要求传递原始指针才能运作.</p></li><li><h4 id="如何进行资源访问呢"><a href="#如何进行资源访问呢" class="headerlink" title="如何进行资源访问呢?"></a>如何进行资源访问呢?</h4><p><strong>显式转换</strong> 或 <strong>隐式转换</strong> .</p></li></ul><hr><p><strong>显示转换</strong> : 资源管理类直接提供一个返回原始资源的<code>get()</code>函数, <code>C++</code>提供的智能指针也提供相应的功能.</p><p>书中举了一个有关字体资源管理的例子, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>假设有一个<code>C API</code>可以通过接受字体资源和字体大小来改变字体 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这是函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeFont</span><span class="hljs-params">(FontHandle f, <span class="hljs-type">int</span> newSize)</span></span>;     <span class="hljs-comment">// C风格的API函数</span><br><span class="hljs-comment">// 以下是用户具体使用例子</span><br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br>...<br><span class="hljs-built_in">changeFont</span>(f.<span class="hljs-built_in">get</span>(), newFontSize);<span class="hljs-comment">// 使用f.get()</span><br></code></pre></td></tr></table></figure><hr><p><strong>隐式转换</strong> : <strong>提供operator-&gt;和operator*的重载</strong> 或 <strong>直接提供隐式转换函数</strong></p><p>前者支持将资源管理类指针隐式转换为底部原始指针, 以此可以直接调用资源函数或取出资源成员变量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br>    <br>    <span class="hljs-comment">// 重载 operator-&gt;，返回原始的 FontHandle 指针</span><br>    FontHandle* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">return</span> &amp;f;  <span class="hljs-comment">// 返回 FontHandle 的指针，允许访问 FontHandle 的成员</span><br>    &#125;<br><br>    <span class="hljs-comment">// 重载 operator*，返回对 FontHandle 的引用</span><br>    FontHandle&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">return</span> f;  <span class="hljs-comment">// 返回 FontHandle 的引用，允许访问 FontHandle 的成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们就可以完全将资源管理类当做一个指针看待, <strong>通过*取出原始资源, 通过-&gt;调用原始资源的成员</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(*f, newFontSize);  <span class="hljs-comment">// 假装f是一个指针, 通过解引用调出资源</span><br></code></pre></td></tr></table></figure><hr><p>后者在使用资源管理类时就会默认转换到底部原始指针 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125;        <span class="hljs-comment">// 隐式转换函数</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样直接写f就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(f, newFontSize);<br></code></pre></td></tr></table></figure><p>但是书中并不推荐这样使用, 因为这是一种<strong>完全把资源管理类作为原始资源</strong>的做法, 也就是说<strong>无法再使用有关任何资源管理类自己的操作</strong>, 当我们想进行资源管理类的拷贝赋值等操作时, 由于已经隐式转换为了资源, 这样做几乎不会有好下场, 当然你也可以保证完全不使用也不设计这类操作, 让它单独做好资源管理的本职工作, 也是完全可以使用这种方法的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>API</code> 往往要求访问原始资源, 所以<strong>每个资源管理类都应提供一个取得其原始资源的方法</strong>.</li><li>对于原始资源的访问, 显示转换一般比较<strong>安全</strong>, 但隐式转换对客户比较<strong>方便</strong>, 自己斟酌利弊.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款14 在资源管理类中小心 copying 行为</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="条款14-在资源管理类中小心-copying-行为"><a href="#条款14-在资源管理类中小心-copying-行为" class="headerlink" title="条款14 : 在资源管理类中小心 copying 行为"></a>条款14 : 在资源管理类中小心 copying 行为</h2><blockquote><p>本条款是在我们自己建立资源管理类时要注意的行为, 但是归根结底, 我们为什么要自己建立资源管理类呢 ? 为什么不用 shared_ptr ? 这是我们在本条款中需要首先解决迭代问题.</p></blockquote><p>书中提出, C++提供的智能指针是适配于<code>heap-based</code>资源上的, 其要求不管是自动生成还是手动完成, 该资源<strong>必须要有析构函数</strong>, 然而并非所有的资源都是<code>heap-based</code>的, 简单来说就是有些资源<strong>没有对应的析构函数</strong>, 而是选择了别的方式进行资源的释放, 非常典型的就是<strong>文件句柄</strong>, 其必须要调用<code>close()</code>函数释放, 你如果直接把其交给<code>shared_ptr</code>而不做其他动作, 可以确定的是<code>shared_ptr</code>并不会智能到把<code>close()</code>加到智能函数中, 文件句柄不会被释放, 这样的资源还有很多, 而且大部分都很关键, 比如<strong>锁, 数据库连接, 网络socket</strong>等. 因此我们需要自己建立自己的资源管理类(当然也有些其他的方式).</p><hr><h3 id="怎么建立自己的资源管理类"><a href="#怎么建立自己的资源管理类" class="headerlink" title="怎么建立自己的资源管理类?"></a>怎么建立自己的资源管理类?</h3><p>简单来说还是<strong>遵循RAII原则</strong>, 构造即初始化, 析构即释放资源, 这里的释放资源具体到文件就是调用<code>close()</code>, 具体到锁就是调用<code>unlock()</code>, 我们自己应当考量, 而我们一般称其为 <strong>RAII风格的XXX</strong> .</p><p>书中给出了一段代码, 用于实现<strong>RAII风格的锁</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以实现以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mutex m;                    <span class="hljs-comment">// 设置一个互斥器</span><br>...<br>&#123;                           <span class="hljs-comment">// 这是一块作用域, 可以是一个要求线程安全的函数内部</span><br><span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;m)</span></span>;            <span class="hljs-comment">// 直接用互斥器上锁</span><br>...                     <span class="hljs-comment">// 执行对锁有需求的行为</span><br>&#125;    <span class="hljs-comment">// 离开作用域自动调用析构, 析构中自动unlock</span><br></code></pre></td></tr></table></figure><hr><h3 id="言归正传-当一个RAII对象被复制-会发生什么事"><a href="#言归正传-当一个RAII对象被复制-会发生什么事" class="headerlink" title="言归正传, 当一个RAII对象被复制, 会发生什么事 ?"></a>言归正传, 当一个RAII对象被复制, 会发生什么事 ?</h3><p>以下是可能发生的复制策略 : </p><ul><li><p><strong>禁止复制</strong> : 很多时候我们并不希望资源管理类可以复制, 就像锁, 我们一定不希望多个锁对象控制同一个底层的互斥器, 这有违锁设计的初衷, 所以直接禁止就好了, 这时我们的<code>Uncopyable</code>类就有用了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;        <span class="hljs-comment">// 直接private继承自Uncopyable</span><br><span class="hljs-keyword">public</span>:                                    <br>...                                     <span class="hljs-comment">// 同上   </span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>对底层资源祭出”引用计数法”</strong> : 这个其实就是利用<code>shared_ptr</code>实现资源共享就好了.</p><p>需要注意的就是, <code>shared_ptr</code>还有一个和共享内存无关的性质—<strong>删除器</strong>, 这是一个函数, 可以传入<code>shared_ptr</code>构造函数的第二参数, 如果没有删除器会默认调用析构, 有删除器就调用删除器, 这其实就在一定程度上解决了智能指针只能针对<code>heap-based</code>资源的问题, 让没有析构函数的资源也可以通过调用删除器实现释放, 以下是书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span>       </span><br><span class="hljs-function">  : mutexPtr(pm, unlock)         // 初始化智能指针, 将unlock设置为删除器</span><br><span class="hljs-function">    lock(mutexPtr.get());</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* mtx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mtx) &#123;<br>        mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>        <br>    <span class="hljs-comment">// 不需要写析构函数了, 它可以被删除器替代</span><br>&#125;<br>   <br><span class="hljs-keyword">private</span>:<br>  std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;    <span class="hljs-comment">// 使用 shared_ptr</span><br>&#125;;                     <br></code></pre></td></tr></table></figure><p>请注意如果我们写的资源管理类不希望共享资源, <code>shared_ptr</code>可以共享就带来了隐患, 像是上面的锁, 其实更推荐禁止拷贝的做法, 这种做法只是告诉我们一种其他的做法而已.</p></li><li><p><strong>复制底层资源</strong> : 这其实就是我们常说的深拷贝.</p></li><li><p><strong>转移底部资源的拥有权</strong> : 为了保证资源的独占性, 我们可以选择这种策略.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>复制<code>RAII对象</code>必须一并复制他所管理的资源, 资源的<code>copying</code>行为决定<code>RAII对象</code>的<code>copying</code>行为.</li><li>普遍的<code>copying</code>行为是禁止复制或施行引用计数法.</li><li>文件句柄和锁这类资源可以选择<strong>禁止复制, 支持移动</strong>的策略</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款13 以对象管理资源</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 : 以对象管理资源"></a>条款13 : 以对象管理资源</h2><blockquote><p>所谓资源, 一旦用了它, 将来必须还给系统. 本条款及以后几项条款都致力于实现优秀的资源管理, 严守这些条款, 可以几乎消除资源管理问题.</p></blockquote><p>本条款主要提出<strong>以对象管理资源</strong>的思想, 以及对<code>std</code>内置的<code>auto_ptr</code>和<code>smart_prt</code>的使用策略做了分析.</p><p>书中塑模了一个投资行为, 让我们看看资源该如何处理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span> &#123; ... &#125;;  <span class="hljs-comment">// 一个投资类</span><br><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这是一个工厂函数, 返回一个动态分配的对象, 这里为了简化刻意不写参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Investment *pInv = <span class="hljs-built_in">createInvestment</span>();         <br>  ...                                            <br>  <span class="hljs-keyword">delete</span> pInv;                                  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有资源管理对象, 我们正常行为是请求指针使用后再<strong>手动删除</strong>.</p><p>书中提出了”以对象管理资源”的两个关键想法 : </p><ul><li><strong>获得资源后立即放进管理对象.</strong></li><li>**管理对象运用析构函数确保资源被释放, **这样便可倚赖 C++ 的”<strong>析构函数自动调用机制</strong>“确保资源被释放.</li></ul><p>这两个想法来源于一种资源管理观念 : </p><ul><li><strong>RAII (Resoure Acquisition Is Initialization)</strong> <strong>: 资源取得时机便是初始化时机 .</strong></li></ul><p>那么资源管理类该如何使用与实现呢 ? 不妨看看C++本身给我们提供的两个资源管理类(智能指针)吧. </p><hr><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;  <span class="hljs-comment">// 请求对象的同时直接存入auto_ptr中 </span><br>  ...                                                 <br>&#125;         <br></code></pre></td></tr></table></figure><p>这样我们可以一如既往地使用<code>pInv</code>, 当其离开作用域时, 会经由<code>auto_ptr</code>的析构函数自动删除<code>pInv</code>.</p><p><code>auto_ptr</code>的特性 : 受<code>auto_ptr</code>管理的资源必须绝对没有一个以上的<code>auto_ptr</code>同时指向它.</p><p>也就是说<code>auto_ptr</code>保证独占指向的资源, 如果发生拷贝也会转交使用权, 这种特性使得其在需求共享内存的场面起不到作用, 于是也就有了我们接下来的<code>shared_ptr</code>.</p><hr><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pInv1</span><span class="hljs-params">(createInvestment())</span></span>;<br>  ...    <br>    std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt;  <span class="hljs-title">pInv2</span><span class="hljs-params">(pInv1)</span></span>; <span class="hljs-comment">// 允许指向同一块内存</span><br>  pInv1 = pInv2; <span class="hljs-comment">// 允许赋值同时获得使用权</span><br>&#125;          <br></code></pre></td></tr></table></figure><p><code>share_ptr</code>是”<strong>引用计数型智能指针</strong>“, 其自己内部维护了一个计数器, 用于记录指向同一块资源的指针有多少, 当发生拷贝和赋值时都会使计数器 + 1, 当有指向其的指针离开作用域时都会使计数器 - 1, 当计数器为0时才自动触发真正的析构.</p><hr><p>请注意 : <code>auto_ptr</code>和<code>shared_ptr</code>的析构函数内部调用的都是 <code>delete</code>, 而非 <code>delete[]</code>, 虽然我们可以 <code>new []</code>, 但是这样new出来的指针就请不要存入智能指针了. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spi</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>])</span></span>; <span class="hljs-comment">// 这样是错误的!</span><br></code></pre></td></tr></table></figure><p>至于为什么没有<code>delete[]</code>版本的, 那是因为<code>vector</code>和<code>string</code>几乎总是可以取代动态分配而得的数组, 所以没必要.</p><hr><p>以上专门描述了<code>auto_ptr</code>和<code>shared_ptr</code>, 但是本条款并不专门针对它们, 而是在强调”<strong>以对象管理资源</strong>“的重要性, 有时候我们要使用的资源也许是这些<strong>预制式classes无法妥善管理</strong>的, 就需要我们有<strong>自己制作资源管理类</strong>的能力了, 至于其中要考虑的细节, 在接下来的条款14, 15中会提及.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>为防止资源泄露, 请使用<code>RAII</code>对象, 它们在构造函数中获得资源并在析构函数中释放资源. </li><li>优先使用<code>shared_ptr</code>, <code>auto_ptr</code>次之, 如果效果无法令你满意, 请自己制作资源管理类.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款10-12 拷贝与赋值</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="条款10-令-operator-返回一个-reference-to-this"><a href="#条款10-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10 : 令 operator&#x3D; 返回一个 reference to * this"></a>条款10 : 令 operator&#x3D; 返回一个 reference to * this</h2><blockquote><p>很多类都有重写operator&#x3D;函数的要求,  本质是 &#x3D; 左侧调用 operator&#x3D; 函数, 右侧作为参数传入, 将右侧参数赋值给左侧成员变量, 并且为了实现连锁赋值, 我们还应当使 operator&#x3D; 返回当前赋完值的对象.</p></blockquote><p>本条款的目的是<strong>实现连锁赋值</strong>, 接下来看看如何 令 operator&#x3D; 返回一个 reference to * this : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)     <span class="hljs-comment">// 返回一个引用, 符合右侧参数的类型</span><br>&#123;          <br>    <span class="hljs-comment">// 条款11, 12会告诉我们怎样实现中间的拷贝过程</span><br>    ...<br>    <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                        <span class="hljs-comment">// 返回=左侧的当前对象, 使其可以充当下一次operator=的右侧参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时这个协议不只适用于 &#x3D; , 也同样适用于 +&#x3D;, -&#x3D;, *&#x3D; 等运算符.</p><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>令赋值操作符重载返回一个 reference to * this</li></ul><hr><h2 id="条款11-在-operator-中处理”自我赋值”"><a href="#条款11-在-operator-中处理”自我赋值”" class="headerlink" title="条款11 : 在 operator&#x3D; 中处理”自我赋值”"></a>条款11 : 在 operator&#x3D; 中处理”自我赋值”</h2><blockquote><p>我们设置一个变量w, 令 w &#x3D; w , 这种自我赋值的做法虽然看上去很愚蠢, 但是合法, 这种程度的自由还是应该有的, 可是这在我们手动重载operator&#x3D; 时也会带来相应的麻烦, 有一些我们需要注意的点.</p></blockquote><p>正常来说, 如果我们的类中只有一些普通的本地变量, 其实不必考虑自我赋值的问题, 因为只要把正常情况下的 operator&#x3D; 函数写好(或者你也可以让编译器自动生成), 是没有什么问题的, 问题发生在<strong>需要动态管理内存</strong>时.</p><p>假如我们一个类中有一个成员变量是指针, 该指针指向一块动态分配的内存, 我们创建两个类对象 a 和 b , 其中的指针都指向不同的内存, 当使 a &#x3D; b, 从正常考量来说, b 赋值给 a 应当代表着 a 的指针将指向原先 b 所指向内存, 那么<strong>原先 a 所指向的内存就应当delete掉</strong>, 以完成最后的赋值操作. 书中举了一个指针指向bitmap的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  Bitmap *pb; <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)              <span class="hljs-comment">// 这是一个有隐患的赋值重载</span><br>&#123;<br>  <span class="hljs-keyword">delete</span> pb;                                      <span class="hljs-comment">// delete掉原来指向的动态内存</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);                       <span class="hljs-comment">// 再new一块用来拷贝rhs副本的空间, pb重新接手这块空间 </span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                   <span class="hljs-comment">// 见条款10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很合理, 但是带入自我赋值的情况, 你就会惊奇地发现, new Bitmap(*rhs.pb)用来拷贝的副本 rhs.pb 已经因为 delete pb 被释放了! 我们掉进了”<strong>在停止使用资源之前就意外释放了它</strong>“的陷阱! 虽然自我赋值是愚蠢的操作, 但我们程序员也不能让愚蠢的操作产生愚蠢的错误, 所以我们应当提前判断是否是自我赋值 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <span class="hljs-comment">// 判断是否是自我赋值, 是就直接返回</span><br>  <span class="hljs-keyword">delete</span> pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以对自我赋值的问题完全规避了! </p><hr><p>但是其实由于动态内存的存在, 还催生出了另一个问题, 就是其实new一个对象也会有产生异常的情况出现, 如果申请内存失败, pb就是折了孩子又赔兵, 原先的内存释放了, 新申请的还失败了, 这个问题就是<strong>异常安全性</strong>的问题了, 从原理上来说这和本条款重点针对的自我赋值毫无关联, 但是书中很高兴地告诉我们 : </p><ul><li><strong>让 operator&#x3D; 具备”异常安全性”往往会自动获得”自我赋值安全”的回报.</strong></li></ul><p>因此作者告诉我们可以把焦点放在实现异常安全性上, 对自我赋值问题倾向于不管理. 就是说虽然两个问题毫不相干, 但你解决一个问题却可以顺带解决另一个问题, 何乐而不为呢?</p><p>那么如何实现异常安全性呢? 异常安全性会在条款29着重讲解, 但不妨我们提前了解 : </p><p>简而言之就是 : <strong>不泄露任何资源, 不允许数据败坏, 强烈保证如果函数没有成功就回滚到函数被调用前的状态</strong>.</p><p>放在本例中, 就是<strong>如何确保new失败后pb可以依旧指向原先的内存, 而不是原先的内存被释放</strong>.</p><p>简单思考一下就可以写出如下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  Bitmap *pOrig = pb;               <span class="hljs-comment">// 用一个备份指针记住原先的pb指向的空间先不释放</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// 令左边pb指向右边pb所指向内存的副本</span><br>  <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// 如果new成功了再释放原先指向的空间</span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是异常安全性的问题就解决啦, 我们还可以发现, 确实自我复制安全的问题也被解决了, 因为pb不会被提前释放, 就算是对着自己再复制一遍也完全没有问题, 唯一的变化就是换了块内存而已.</p><p>书中还提出了一种理念相同, 但更推荐的编写方法 : <strong>copy and swap技术</strong>;</p><p>简而言之就是 : <strong>如果对某对象的操作有异常风险, 就直接先copy该对象的副本, 在该对象的副本上做出所有操作, 随后swap原件和副本</strong>.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; W);<br>  ...                       <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 大多数赋值重载最后用的都是这种方法</span><br>&#123;<br>  Widget <span class="hljs-built_in">temp</span>(rhs);             <span class="hljs-comment">// 使用重写的拷贝构造函数直接拷贝副本</span><br>  <span class="hljs-built_in">swap</span>(temp);                   <span class="hljs-comment">// 交换原件和副本</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里可能有些人似懂非懂, 前一个函数很明确要在拷贝目标内存成功后就释放原内存, 这个是怎么实现的呢?</p><p>这里的拷贝构造函数我们需要重写, 实现对 bitmap 的深拷贝, 拷贝完的对象就是 temp , 由于 temp 是一个临时对象, 离开这个函数的作用域就会析构掉, 此时我们交换原对象和目标对象, 那么最后析构掉的就是存在 temp 中的原对象, 而目标对象留在了我们的当前对象中.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>通过实现异常安全性顺便解决自我赋值的问题.</li><li>确保操作多个对象时, 其中多个对象实质上是同一个对象时, 其行为仍然正确.</li></ul><hr><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12 : 复制对象时勿忘其每一个成分"></a>条款12 : 复制对象时勿忘其每一个成分</h2><blockquote><p>copying函数 : 拷贝构造 和 赋值重载(operator&#x3D;) .</p><p>条款10&#x2F;11告诉了我们 operator&#x3D; 如何返回值 和 注意 operator&#x3D; 自我赋值, 本条款会告诉我们 copying函数 在赋值过程中应当注意些什么.</p></blockquote><p>书中提出, 如果我们决定自己实现 copying函数, 编译器会仿佛被冒犯似的, 以一种奇怪的方式回敬 : 当你的代码必然出错时也不会告诉你. </p><p>这也在警告我们, 复制对象时勿忘其每一个成分.</p><p>首先提出的观点是 : </p><ul><li><strong>如果你为class添加一个成员变量, 你必须同时修改copying函数</strong>.</li></ul><p>这点很好理解, 每个成员变量都必须和拷贝构造和赋值拷贝关联.</p><p>接下的观点就涉及继承层面了 : </p><ul><li><p><strong>只要为 derived class 撰写 copying函数, 必须很小心地复制其 base class 成分.</strong></p></li><li><p><strong>你应当让 derived class 的 copying函数 调用相应的 base class函数.</strong></p></li></ul><p>我们来看书中的代码来进一步了解这两句话 : </p><p>书中设定了一个<code>Customer顾客类</code>, 其派生类是<code>PriorityCustomer贵宾类</code>, 贵宾类中local int 变量 <code>priority</code>, 用来确定贵宾的优先度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logCall</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; funcName)</span></span>;  <span class="hljs-comment">// 用来产生一个日志通告</span><br><br><span class="hljs-comment">// Customer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<span class="hljs-comment">// 普通客户</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>  std::string name;<br>&#125;;<br><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>: <span class="hljs-built_in">name</span>(rhs.name)                                 <br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 赋值重载被触发&quot;</span>);<br>  name = rhs.name;                             <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                  <span class="hljs-comment">// 见条款10</span><br>&#125;<br><br><span class="hljs-comment">// PriorityCustomer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span>: <span class="hljs-keyword">public</span> Customer &#123;                  <span class="hljs-comment">// 贵宾客户</span><br><span class="hljs-keyword">public</span>:<br>   ...<br>   <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>   PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> priority;<br>&#125;;<br><br><span class="hljs-comment">// 重点看这个两个函数</span><br>PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br>  priority = rhs.priority;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似<code>PriorityCustomer</code>的构造函数好像复制了每一样东西, 但是其实它所<strong>继承的Customer部分并未进行复制</strong>, Customer部分中的name变量仍旧是未定义的, 当我们再仔细看看operator&#x3D;, 里面的问题是一样的.</p><p>接下来是改进后的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">Customer</span>(rhs)                   <span class="hljs-comment">// 调用 base class 的 copy构造函数</span><br>  , <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br><br>  Customer::<span class="hljs-keyword">operator</span>=(rhs);           <span class="hljs-comment">// 对 base class 成分进行赋值动作</span><br>  priority = rhs.priority;<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样代码就完美了! 再去回味前面提出的两句话, 其实就是在告诉我们<strong>显式且正确处理基类部分的拷贝和赋值</strong>的重要性.</p><p>我们要确保 : </p><ol><li>复制所有的 local 变量.</li><li>调用所有 <code>base classes</code> 内适当的 <code>copying函数</code>.</li></ol><hr><p>很多时候这两个<code>copying函数</code>往往有着近似的实现本体, 这可能会诱使我们用其中一个调用另外一个以实现代码复用的效果, 但是书中告诉我们这样做风险很大, 因为拷贝构造用来初始化新对象, 而赋值重载只能施行于已初始化的对象上, 二者的应用场景就不同, 不然也就不会分成两个默认成员函数了, 所以书中告诉我们 : </p><ul><li><p><strong>你不该令 copy assignment 操作符调用 copy构造函数 .</strong></p></li><li><p><strong>令 copy构造函数 调用 copy assignment 操作符同样无意义.</strong></p></li><li><p><strong>真正明智的做法是将相近代码封装进 init() 函数, 给二者调用.</strong></p></li></ul><hr><h3 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>copying函数</code>应当确保复制 “对象内的所有成员变量” 及 “所有<code>base class</code>成分”.</li><li>不要尝试<code>copying函数</code>相互调用, 应当封装一个共用函数实现代码复用.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款9 绝不在构造和析构函数过程中调用</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款09-绝不在构造和析构函数过程中调用virtual函数"><a href="#条款09-绝不在构造和析构函数过程中调用virtual函数" class="headerlink" title="条款09 : 绝不在构造和析构函数过程中调用virtual函数"></a>条款09 : 绝不在构造和析构函数过程中调用virtual函数</h2><p>开门见山阐释本条款的重点 : <strong>你不该在构造函数和析构函数中调用virtual函数</strong>.</p><p>书中给出了一个例子 : 假如我们要塑膜股市交易订单模型, 订单可以分成买入, 卖出等不同类型的订单, 当我们产生不同类型的订单, 也就是构造不同类型订单对象时, 我们也许会有记录订单日志的需求, 并我们希望订单根据不同的订单类型产生不同的订单日志.</p><p>于是我们可以抽象出以上需求的类构建过程, 一个订单基类, 派生出不同的订单派生类(如买入类, 卖出类), 基类的构造函数调用一个虚函数<code>logTransaction()</code>, 派生类重写出不同的<code>logTransaction()</code>, 就可以实现我们以上的需求.</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                               <span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span>:                                           <br>  <span class="hljs-built_in">Transaction</span>()<br>  &#123;                                                 <br>  ...<br>  <span class="hljs-built_in">logTransaction</span>();                        <span class="hljs-comment">// 订单构建时依据订单动态类型构建对应日志       </span><br>&#125;     <br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 要求派生类重写</span><br>  ...<br>&#125;;                       <br>                                            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;       <span class="hljs-comment">// 买入类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 提供重写版本日志</span><br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">// 卖出类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码看似很完美, 但是真正运行起来是无法实现的!</p><p>当我们创建一个<code>BuyTransaction</code>类对象<code>b</code>时, 并不会调用<code>BuyTransaction</code>重写的<code>logTransaction()</code>, 而是会调用基类<code>Transaction</code>的<code>logTransaction()</code>, 然而我们基类的<code>logTransaction()</code>设置为纯虚函数甚至都没有写, 就更别谈运行了. </p><p>为什么? 书中告诉我们, <strong>在base class构造期间, virtual函数不是virtual函数</strong>, 更细致的说就是<strong>base class构造期间virtual函数绝不会下降到derived class阶层</strong>. 原因很直观, <strong>base class 构造函数执行期间derived class的成员变量一定还未初始化</strong>, 如果此刻就可以通过virtual下降到派生类, 我们怎么确保这个虚函数不会调用派生类的成员变量呢? 太危险了, 所以C++不会让你走这条路.</p><p>而且不止是不能在构造析构函数内调用虚函数, 当然也不能调用包含了虚函数的普通函数, 这是显而易见的, 这就又回到了我们开头说的那句话 : <strong>绝不在构造和析构函数过程中调用virtual函数</strong>, 只要还在过程中, 就不要调用.</p><hr><p>那么我们最开始的需求还有其他实现的方式吗?</p><p>书中提出一种解决办法 : 将<code>logTransaction()</code>改为普通函数, 要求派生类构造函数传递必要的日志信息给基类的构造函数, 基类的构造函数再把接收到的日志信息传入<code>logTransaction()</code>, 这样就可以了!</p><p>我们可以宏观地理解一下, 有助于我们的思维进步. 其实派生类的构造函数是一个<code>自底向上</code>的过程, 一直递归调用到最顶层的基类, 当调用到最顶层后, 我们不好奢求基类再自顶向下调用派生类的重写函数, 不如在一开始自底向上时就把必要的信息传递至基类构造函数, 这样想就非常通顺了.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span>  <span class="hljs-comment">// 接收下层的日志信息</span></span><br><span class="hljs-function">  </span>&#123;<br>  ...<br>  <span class="hljs-built_in">logTransaction</span>(logInfo);<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 此时是普通函数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BuyTransaction</span>(<span class="hljs-type">const</span> std::string&amp; parameters)<br>: <span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>(parameters))             <span class="hljs-comment">// 将log信息传递给上层</span><br>  &#123; ... &#125;                                                 <br>   ...                                                  <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 这里利用一个辅助函数创建一个值传给base class构造函数往往比较方便美观可读</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; parameterss)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝不在构造和析构函数过程中调用<code>virtual</code>函数.</li><li>对象在<code>derived class构造函数</code>开始执行前不会成为一个<code>derived class对象</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款8 析构函数的异常管理</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 : 别让异常逃离析构函数"></a>条款08 : 别让异常逃离析构函数</h2><blockquote><p>日常编程中，常见异常通常由以下原因引发：</p><ol><li><strong>资源管理不当</strong>（如内存泄漏, 文件操作, 连接或断开连接失败）。</li><li><strong>边界和合法性检查不足</strong>（如数组越界、除以零）。</li><li><strong>并发编程问题</strong>（如死锁、数据竞争）。</li><li><strong>类型不匹配或错误的操作</strong>。</li></ol></blockquote><p>本条款主要讨论的是析构函数的异常管理, 为什么会不希望异常逃离析构函数, 因为<strong>析构函数是一个必须执行且有可能失败的函数</strong>, 因为内存泄漏, 文件操作, 连接或断开连接失败等资源管理行为的错误都是很难避免的, 而且由于<strong>析构函数是递归式调用并且可能一次性销毁大量结构</strong>, 同时产生大量异常的概率就提高了, 书中指出, <strong>如果同时存在多个异常, 程序不是结束执行就是导致不明确行为</strong>, 因此对于析构函数的异常管理在所难免.</p><hr><p>书中举出了一个数据库连接的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;  <span class="hljs-comment">// 数据库连接类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回创建出来的静态数据库连接.                                     </span><br>  ...                                      <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 调用此函数关闭与数据库的连接, 这里有抛出异常的隐患         </span><br>&#125;;         <br></code></pre></td></tr></table></figure><p>我们经常会设计一个资源管理类来控制数据库的连接 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;                          <span class="hljs-comment">// 数据库连接管理类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>   db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 调用析构函数时断开数据库连接</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  DBConnection db;   <span class="hljs-comment">// RAII风格, 由DBConn管理DBConnection, 离开作用域自动触发DBConn的析构函数断开连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以写出以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ...<br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// 直接建立DBConnection对象并交由DBConn对象dbc管理</span><br>    ... <span class="hljs-comment">// 进行数据库的CURD, 离开作用域自动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了上面例子的基础, 我们来思考一下如何避免异常抛出吧.</p><p>站在<code>DBConn析构函数</code>的角度, 书中给出了两个一般的方法 : </p><ol><li><p>如果close()抛出异常就利用abort()结束程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>   std::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 直接结束程序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接吞下该异常.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>      <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>      <span class="hljs-comment">// 不做处理, 直接吞下</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两个方法其实都是保底方法, 一个是草率结束进程, 一个是吞掉异常防止扩散, 但其实<code>DBConn析构函数</code>也就能做这么多了.</p><hr><p>现在的问题是<strong>没有办法对”导致close抛出异常”的情况做出反应</strong>, 问题核心在<code>close()</code>函数被<code>DBConn析构函数</code>掌握, 只能其自己管理, 上一层无法干预. 那么由此我们可以将close()函数的使用权上交, 也就是让上一层用户有权决定处理<code>close()</code>报错的方式. </p><p>较佳策略是<strong>重新设计DBConn接口, 使客户有机会对可能出现的问题作出反应</strong>. </p><p>具体做法如下 : </p><ol><li><code>DBConn</code>自己也提供一个close接口, 内部封装上<code>DBConnection</code>的<code>close()</code>.</li><li><code>DBConn</code>自己对<code>DBConnection</code>的<code>close()</code>是否已经触发进行追踪管理, 如果到最后客户都没有自行close成功, 由<code>DBConn析构函数</code>自行完成close的任务.</li></ol><p>我们来看书中给出的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 提供给上层用户的close函数</span></span><br><span class="hljs-function">  </span>&#123;                                       <br>    db.<span class="hljs-built_in">close</span>();<br>    closed = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>      <span class="hljs-comment">// 如果到最后都没有触发close, 就会回到析构函数调用close的老路</span><br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>   <span class="hljs-keyword">try</span> &#123;                                           <br>     db.<span class="hljs-built_in">close</span>();                           <br>   &#125;<br>   <span class="hljs-built_in">catch</span> (...) &#123;                                    <br>     <span class="hljs-comment">// 记录日志, 记录对close的调用失败  </span><br>     ...                                   <span class="hljs-comment">// 直接结束 或 吞下异常</span><br>   &#125;<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  DBConnection db;<br>  <span class="hljs-type">bool</span> closed;<span class="hljs-comment">// 用布尔变量closed来对close()进行追踪管理</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是客户便可做出如下操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 客户自己在认为合适的地方调用close()结束连接, 并用try-catch语句尝试捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能会抛出异常，如果关闭失败</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 客户端捕获从 close() 抛出的异常</span><br>        <span class="hljs-comment">// ... 出现异常时的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只考虑数据库断开连接的场景, 我们可行的具体操作可以是重试关闭或执行数据库回滚, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!success &amp;&amp; attempts &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;正在尝试断开数据库连接, 次数 :  &quot;</span> &lt;&lt; ++attempts &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;已经尝试三次断开数据库连接, 但都出现异常, 断开失败&quot;</span> &lt;&lt; std::endl;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;进行补偿操作, 回滚数据库&quot;</span> &lt;&lt; std::endl;<br>        dbConn.<span class="hljs-built_in">rollback</span>(); <span class="hljs-comment">// 内部调用数据库的回滚函数</span><br>&#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来捋一下流程, 先是客户需要考虑何时调用<code>close()</code>并写出应对异常的代码, 实际运行时如果没有异常就万事大吉, 有异常就触发客户的处理逻辑, 最后析构函数检查客户是否真的成功调用了<code>close()</code>, 如果还是没有调用, 就自己调用, 自己调用如果还出错, 就直接结束程序或吞掉异常.</p><p>至此我们将调用<code>close()</code>的责任从<code>DBConn析构函数</code>的手上移交到了使用<code>DBConn对象</code>的客户手上, 可以更好地避免异常逃离析构函数. 有人可能这样会加大客户的操作负担, 但是根据我们先前的分析, 只有客户才能有办法对”导致close抛出异常”的情况做出反应, 这样做是给客户提供一个根据实际情况回避异常的机会, 至于是否需要就看客户自己了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>析构函数绝对不要吐出异常. 如果分析出一个析构函数有抛出异常的风险, 应当先把异常捕捉下来, 看是否结束程序或吞下异常.</li><li>给客户提供自己处理异常的机会, 让客户可以根据实际情况对异常做出反应.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款7 virtual析构函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 : 为多态基类声明virtual析构函数"></a>条款07 : 为多态基类声明virtual析构函数</h2><blockquote><p>说到多态, 我们应当非常了解其运行时绑定的机制, 简单来说就是我们可以在任何时候根据用户的需求将基类绑定为不同的派生类, 用相同的操作实现不同的效果, 这其中virtual函数起到了至关重要的作用, 每一个含有虚函数的类都会维护一个虚表, 以此实现基类到派生类的动态绑定. </p></blockquote><p>这里书中提到了一个重要又经常发生的问题 : <strong>如果<code>drived class(派生类)</code>对象经由一个<code>base class(基类)</code>指针被删除, 而该base class带着一个non-virtual析构函数, 那么结果是未定义的</strong>.</p><p>这里的结果未定义, 一般情况下是只会调用<code>base class</code>自己的析构函数, 销毁的是该对象的<code>base class</code>部分, 而<code>drived class</code>部分却没有被销毁, 就造成了诡异的”局部销毁”现象.</p><p>而解决这个问题的方法就是 : <strong>给 base class 一个 virtual析构函数</strong>.</p><p>先回忆一下有关派生类析构函数的知识 : <strong>派生类的析构函数会默认先调用上一层的析构函数</strong>. 也就是说是从当前派生类的析构函数开始, 递归式调用上一层的析构函数, 直到到达最深层的基类. </p><p>再思考上面的话, 当<code>base class</code>指针动态绑定<code>drived class</code>对象时, 如果我们想删除这个对象时, 正确的结果应该是调用动态绑定的<code>drived class</code>的析构函数, 这样才能正确地全部销毁, 而想这样调用就只能依赖于虚函数来实现, 也就是我们需要把base class的析构函数设置为virtual, 删除时就会根据虚表找到当前动态类型绑定的析构函数.</p><p>以下是书中的给出的样例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TimeKeeper</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>  ...<br>&#125;;<br>TimeKeeper *ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br>...<br><span class="hljs-keyword">delete</span> ptk;                         <span class="hljs-comment">// 现在, 行为正确</span><br></code></pre></td></tr></table></figure><p>书中告诉我们 : </p><ul><li><strong>virtual 函数的目的是允许 derived class 的实现得以客制化</strong>.</li><li><strong>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数</strong>.</li></ul><hr><p>当然, 无端地将所有的 classes 的析构函数声明为 virtual, 就像从未声明他们为 virtual 一样, 都是错误的.</p><p>如果 class 不含 virtual 函数, 通常表示它并不意图被用作一个 base class, 也就完全不需要声明virtual析构函数.</p><p>我们知道使用虚函数是要带来额外的花销的, 包括维护虚表, 虚指针表等一系列繁杂的动作, 会带来时间成本和空间成本, 而且书中还提到由于对象大小的增加会影响其可移植性.</p><p>所以请记住一个心得 : <strong>只有当 class 内含至少一个 virtual 函数, 才为他声明 virtual析构函数</strong>.</p><hr><p><strong>请不要企图继承我们神圣的STL容器</strong>, 正因为考虑到上面虚函数有关时间, 空间, 可移植性的问题, STL容器并没有考虑被继承的情况, 它们的析构函数都是 non-virtual 的!</p><hr><p>这里书中提到了一个构建抽象类的小窍门 : </p><p>我们一般不希望抽象类被实体化, 它只提供一些接口 : </p><ol><li>被声明为<code>纯虚函数</code>的接口所有派生类必须重写.</li><li>被声明为<code>虚函数</code>的接口提供默认行为同时也允许派生类重写.</li><li>被声明为<code>普通函数</code>的接口可以被所有派生类继承, 使用.</li></ol><p>我们在设计一个抽象类时, 也许并不希望有什么类是必须重写的, 就是不希望有纯虚函数, 只需要提供虚函数和普通函数即可, 然而一个类想要不被实体化, <strong>必须存在一个纯虚函数</strong>, 那么哪里找一个纯虚函数呢? </p><p><strong>如果你拿不定主意, 选析构函数就好了!</strong> 毕竟抽象类一定有多态的需求, 只要有多态的需求, 析构函数就必须是 virtual 的, 已经是虚函数了, 变成纯虚函数也没什么问题, 而且当我们的派生类没有新增动态资源时, 就算我们不手动重写析构函数也没关系! 因为编译器会自动帮我们生成! 这样既满足了必须有一个纯虚函数的要求, 又不需要我们顾及纯虚函数必须重写的问题, 多么完美 !</p><p>不过有一个小细节必须要注意, 所有派生类析构函数最后都会调用到最底层基类的析构函数, 所以我们<strong>需要对纯虚析构函数进行定义</strong>!</p><p>纯虚析构函数真的能定义吗? 答案是能的, 虽然大多数情况下纯虚函数都不用定义, 但是真要定义还是可以的.</p><p>以下是书中的示例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br>AWOV::~<span class="hljs-built_in">AWOV</span>()  <span class="hljs-comment">// 纯虚函数的定义</span><br>&#123;<br>    <span class="hljs-comment">// delete ...</span><br>&#125;                    <br></code></pre></td></tr></table></figure><hr><p>再次重申, 本章的主要观点  <strong>给 base class 一个 virtual析构函数</strong> 只适用于多态用途, 这种<code>base class</code>的设计目的就是为了<strong>用来通过 <code>base class</code> 接口处理 <code>drived class</code> 对象</strong>.</p><p>我们也应当知道很多 class 的设计就不是为了作为 base class 来使用, 也并非所有的 base class 的设计目的是为了多态用途, 就像我们上一个条款的<code>Uncopyable</code>类, 它被作为基类就不是为了多态, 而是为了赋予派生类不可拷贝的属性, 就不需要使用基类接口, 使用也只是使用派生类, 使用 virtual析构函数就没必要了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>请为多态性质的<code>base class</code>设置 virtual析构函数, 反之请不要.</li><li>不要试图继承<code>STL</code>容器.</li><li>想设计抽象类又不知道纯虚函数选谁时, 选析构函数当纯虚函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款5-6 默认成员函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05 了解C++默默编写并调用哪些函数"></a>条款05 了解C++默默编写并调用哪些函数</h2><blockquote><p>编译器会默认为class创建default构造函数, 析构函数, copy构造函数, 赋值操作符重载, 这算是我们C++语言基础学习中的重中之重, 这里就不再过多阐释.</p></blockquote><p>书中提出一点 : 如果我们在实际使用中确实没有使用到某些默认成员函数, 编译器很大可能也不会自动创建对应的默认函数(例如copy构造函数, 赋值操作符重载).</p><hr><p>书中还提出了三种编译器拒绝自动生成赋值操作符重载的情景 : </p><ol><li>内含<code>reference(引用)</code>成员变量的类.</li><li>内含<code>const</code>成员变量的类</li><li>基类将赋值操作符重载声明为private的派生类</li></ol><p>原因都是显而易见的, <code>reference</code>不可改指不同对象, <code>const</code>不可被更改, 派生类基于基类.</p><hr><p>这里额外提一个小点, 就是默认生成的拷贝函数和辅助操作符重载默认都是浅拷贝, 就是只把类类对象的所有值进行复制, 如果有指针, 不会深入拷贝指针指向的内容, 只是单纯把指针本身拷贝.</p><h2 id="条款6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝"></a>条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝</h2><blockquote><p>虽然大多情况下一个类对象应当有外置的构造&#x2F;析构&#x2F;拷贝接口, 但是总会有一些独一无二的东西应当是不可复制的, 就想天下没有第二个你一样, 如果为你自己设计一个类, 你肯定也不希望有一个自动生成的拷贝函数可以拷贝出无数个你吧.</p></blockquote><p>因此, 若不想使用编译器自动生成的函数, 就该明确拒绝.</p><p>所以怎么拒绝呢?</p><ol><li>将该函数写入private中, 并且故意不实现它.</li><li>将该函数后加上<code>= delete</code>.</li></ol><p>假定我们要写一个房产买卖的类<code>HomeForSale</code>, 众所周知每一套房产都是独一无二的.</p><p>我们来看看怎么实现 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员函数</span><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;); <br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;); <span class="hljs-comment">// 这样拷贝函数无法在外部使用就相当于禁用</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 直接声明禁用, 其实在哪声明都可以</span><br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>   ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="设计一个专门为了阻止copying动作的base-class"><a href="#设计一个专门为了阻止copying动作的base-class" class="headerlink" title="设计一个专门为了阻止copying动作的base class"></a>设计一个专门为了阻止copying动作的base class</h4><p>针对某些对象独一无二的情况, 我们可以设计一个专门为了阻止copying动作的base class, 让所有有此需求的类继承自该类, 就可以完全不用在专门处理阻止copying动作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:              <span class="hljs-comment">// 允许构造和析构</span><br>  <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                            <br>  ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                           <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);   <span class="hljs-comment">// 阻止copying</span><br>  Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;     <br>  ...    <span class="hljs-comment">// 自此HomeForSale不需要再进行任何动作就可以实现阻止copying</span><br>&#125;;  <br></code></pre></td></tr></table></figure><p>ed : 也许有人觉得这样子反而多写的, 但在日常情况下<code>Uncopyable</code>完全可以是我们提前备好的, ctrl + v当然方便很多. 再说到为什么是<code>private继承</code>, 在后面的条款中我们会明白, <code>private继承</code>意味着<code>has-a(有一个)</code>的关系, 就是说, 派生类有着基类的部分性质, 而不等于基类, 符合此处<code>HomeForSale</code>和<code>Uncopyable</code>的关系.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住:"></a>请记住:</h3><ul><li>编译器会默认为class创建<code>default构造函数</code>, <code>析构函数</code>, <code>copy构造函数</code>, <code>赋值操作符重载</code>.</li><li>拒绝编译器自动生成的函数, 可以将其写在将该函数写入private中, 并且故意不实现它, 或者直接加上<code>= delete</code></li><li>可以写一些通用类如<code>Uncopyable</code>, 将功能和实现解耦.</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款4 初始化</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="headerlink" title="条款04 确定对象被使用前已先被初始化"></a>条款04 确定对象被使用前已先被初始化</h2><blockquote><p>本条讨论如何安全高效地实现初始化, 当然也有一些条件奇葩的初始化值得我们去讨论</p></blockquote><h3 id="普通变量初始化"><a href="#普通变量初始化" class="headerlink" title="普通变量初始化"></a>普通变量初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>cont <span class="hljs-type">char</span> text[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>cin &gt;&gt; d;    <span class="hljs-comment">// 这种也叫初始化</span><br></code></pre></td></tr></table></figure><h3 id="类内变量初始化"><a href="#类内变量初始化" class="headerlink" title="类内变量初始化"></a>类内变量初始化</h3><p>类内变量的初始化一般就是三种, <code>类内设置初始值</code>, <code>缺省值</code> , <code>初始值列表</code>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name = <span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age = <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-type">const</span> string&amp; sex = <span class="hljs-string">&quot;女&quot;</span>) <span class="hljs-comment">// 设置缺省值 (次之)</span><br>    :_name(name.<span class="hljs-built_in">c_str</span>())<br>        ,_age(age)<br>        ,_sex(sex.<span class="hljs-built_in">c_str</span>())<span class="hljs-comment">// 初始化列表 (优先)</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span> : <br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>    <span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">char</span> _sex[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;男&quot;</span>;  <span class="hljs-comment">// 类内设置初始值 (最次)</span><br>&#125;<br><br>Stu s1;  <span class="hljs-comment">// 小红 17 女</span><br><span class="hljs-function">Stu <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;男&quot;</span>)</span></span>;    <span class="hljs-comment">// 张三 35 男 </span><br></code></pre></td></tr></table></figure><p>这里虽然看起来三种方式都可以, 但是只推荐全部使用初始值列表, 当有特别想要设置的默认值时设置缺省值.</p><h3 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3><h4 id="优势描述"><a href="#优势描述" class="headerlink" title="优势描述 :"></a>优势描述 :</h4><p>为了描述初始值列表的优势, 请先阅读以下另一版本的构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age, <span class="hljs-type">const</span> string&amp; sex)<br>&#123;<br>_name = name.<span class="hljs-built_in">c_str</span>();<br>    _age = age;<br>    _sex = sex.<span class="hljs-built_in">c_str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这样子写构造函数其实和我们写初始值列表的最终结果是一样的, 而且相对直观.</p><p><strong>但是</strong>, 该版本在底层每个变量其实是先进行了一次default的构造, 再进行了一次copy操作, 其本质是<code>初始化 + 赋值</code>.</p><p>而<code>初始值列表</code>在底层只进行了一次copy构造, 比前者高效得多, 本质就是<code>初始化</code>.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项 :"></a>注意事项 :</h4><ul><li>最好在初始值列表中初始化所有的成员变量, 这样起码不会忘记没有初始化的变量.</li><li>C++中成员变量的初始化顺序是按照类中声明的次序, 而非初始值列表中的顺序! (如果有继承关系, 基类一定早于派生类初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : _b(b), _a(a) <span class="hljs-comment">// 尽管在初始化列表中是_b在前, 但是依旧是先初始化_a</span><br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a; <span class="hljs-comment">// _a 在 _b 之前声明</span><br>    <span class="hljs-type">int</span> _b; <span class="hljs-comment">// _b 在 _a 之后声明</span><br>&#125;;<br><span class="hljs-comment">// ----------------------------------------------------------//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Purple</span>&#123; <span class="hljs-comment">// 紫色需要类型为红色和蓝色的变量</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Purple</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red) ,<span class="hljs-built_in">b</span>(blue)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;<br>    Blue b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-comment">// Color类存储三种颜色, 并且可以用红蓝配出紫</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Color</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red)<br>        :<span class="hljs-built_in">b</span>(blue)<br>        :<span class="hljs-built_in">purper</span>(r, b)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;           <span class="hljs-comment">//purple p;</span><br>    Blue b; <span class="hljs-comment">//Red r;</span><br>    Purple p; <span class="hljs-comment">//Blue b; 假如是注释中的情况, 将无法编译通过, 因为p需要r,b都初始化完才能初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同编译单元内定义non-local-static对象-的初始化次序"><a href="#不同编译单元内定义non-local-static对象-的初始化次序" class="headerlink" title="[ 不同编译单元内定义non-local static对象 ] 的初始化次序"></a>[ 不同编译单元内定义non-local static对象 ] 的初始化次序</h3><p>初看第一眼根本就不知道是什么东西(再看也不知道), 所以先介绍一下定义:</p><ul><li><p>编译单元 : 可以简单理解为一个单独的<code>.cpp</code>文件或<code>.h</code>文件等, 就是有一定的隔离性.</p></li><li><p><code>local static</code>(局部静态变量) : 生命周期为整个程序, <strong>在局部第一次调用时初始化</strong>, 之后都是用这个.</p></li><li><p><code>non-local static</code>(全局静态变量) : 生命周期也为整个程序, <strong>程序启动时初始化</strong>, 之后都是用这个.(例如全局变量)</p></li></ul><p><code>local static</code>和<code>non-local static</code>的区别简单来看就在于初始化的时机.</p><hr><p>再举一个例子, 如果我在<code>a.h</code>中定义了<code>class A</code>, 在<code>b.h</code>中定义了<code>class B</code>, 又在<code>c.cpp</code>中要求使用类型为A和类型为B的<code>non-local static</code>变量, 那么这两个变量的初始化次序是怎样的?</p><p>答案是<strong>无法判断</strong>, 你看上面的定义, <code>non-local static</code>对象都是在程序启动时初始化, C++根本没有手段判断应该先初始化哪个,所以这就是没有定义的行为!</p><hr><p>说了这么多, 那这样会带来什么隐患呢? </p><p>如果两个编译单元中的类有依赖关系的话, 初始化次序的不确定性就会导致问题!</p><p>假如说B类static变量中使用到了A类static变量的话, 如果在<code>c.cpp</code>中先初始化了B类static变量, 可是A类static变量还没初始化, 那么就只有报错一条路了. </p><hr><p>可能看到这里有人不太理解这种情况有什么应用场景, 那么我在这里引入一个定义 :</p><ul><li>内置型对象 : 这个对象本身并没有太大意义, 目的是为了引出类中的各种功能性函数, 一般是non-local static的.</li></ul><p><strong>进一步解释</strong> : 有些类中会有许多应用实际场景的方法函数, 如果需要使用这些函数, 就需要客户构造一个类对象,再用这个对象使用函数, 那么我们就干脆在类的头文件中声明一个类对象, 要求使用这个头文件的客户必须记得生成一个对应对象, 而这个对象一般是non-local static的. </p><p>假如有一个钟表类, 内部需要用到一个计时器的类, 于是使用了计时器类的内置对象, 当用户创建一个non-local static类型的钟表类对象时, 你无法确定计时器类的内置对象和钟表类对象哪个先初始化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    ....<br>&#125;;<br><span class="hljs-keyword">extern</span> TimeKeeper tk;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(tk.<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里用tk获取当前时间来初始化time</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <span class="hljs-comment">// 如果用户设置一个全局变量的Clock类对象clock, 此时无法确定clock和tk的初始化次序!</span><br>...<br></code></pre></td></tr></table></figure><h4 id="解决方法-以local-static对象替换non-local-static对象"><a href="#解决方法-以local-static对象替换non-local-static对象" class="headerlink" title="解决方法 : 以local static对象替换non-local static对象"></a>解决方法 : 以local static对象替换non-local static对象</h4><p>这个解决方法用到了设计模式中最经典的<code>单例模式</code>的设计思想 : 延迟初始化.</p><p>思路简单来说就是, 既然给出一个non-local static对象有风险的话, 我就不给这个non-local static对象了, 我直接使用一个函数, 当客户有使用内置型对象相应需求的时候, 当真正客户调用这个函数时, 才会使用函数内部的代码自己生成一个local static对象供自己使用, 这样初始化次序就有了保障.</p><p>更通俗易懂地描述一下, 就是虽然不好直接使用内置型对象, 但是可以把函数返回值当成内置型对象来使用,  因为在函数内生成的对象时是local static对象, 没有初始化次序的问题.</p><p>看一看接下来的代码吧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>        <span class="hljs-keyword">return</span> timekeeper;<br>    &#125;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(<span class="hljs-built_in">tk</span>().<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里只是简单地将tk换成了tk(), 从调用对象改为调用函数而已</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <br><span class="hljs-comment">// 设置一个全局变量的Clock类对象clock, 此时一定是clock开始初始化, 当初始化时调用到tk()再进行timekeeper的初始化</span><br>...<br></code></pre></td></tr></table></figure><h4 id="多线程情况下的安全性"><a href="#多线程情况下的安全性" class="headerlink" title="多线程情况下的安全性 :"></a>多线程情况下的安全性 :</h4><p>书中指明, <code>内涵static对象</code>在多线程情况下会带有线程安全的问题, 等待某事发生都会有麻烦.</p><p>如果同时调用tk(), 没办法保证只有一个timekeeper生成, 除非用锁, 但那样花销太大得不偿失.</p><p>所以我们可以在线程的单线程启动阶段<code>手工调用</code>所有的初始化函数(例如tk()), 这样在多线程来临前就可以确保初始化完毕.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>对内置型对象进行手工初始化, C++本身并不会保证正确初始化他们.</li><li>最好使用初始化列表, 并且排序要和类内的声明顺序一致.</li><li>如果有跨编译单元的初始化次序问题, 请以local static对象替换non-local static对象.</li></ul><p>刚开始写博客, 如有错误感谢指正!</p><p>by 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款3 const</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 : 尽可能使用const"></a>条款03 : 尽可能使用const</h2><blockquote><p><code>const</code>(不可被改动), 是一种非常有效且多样的语义约束, 有了这项约束, 我们可以借用编译器之手规范我们的代码, 以免带来意想不到的错误, 毕竟任何的改动都会伴随着一定的风险, 如果可以提前规避, 我们何乐而不为呢? </p></blockquote><p><code>const</code>在实际表现上是多才多艺的, 他可以修饰对象, 对象指针, 甚至成员函数, 接下来逐一介绍 :</p><h3 id="const-修饰变量"><a href="#const-修饰变量" class="headerlink" title="const 修饰变量"></a>const 修饰变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>; <span class="hljs-comment">// 这样子定义的N又被称为常变量, 其实也就是常量了(因为不可被改动)</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 众所周知, arr数组名是一个指针</span><br><span class="hljs-type">char</span>* a = arr;<span class="hljs-comment">// a指针可修改, 指针指向的内容可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = arr;<span class="hljs-comment">// b指针不可修改, 指针指向的内容可修改</span><br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> c = arr;<span class="hljs-comment">// c指针可修改, 指针指向的内容不可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> d = arr;<span class="hljs-comment">// d指针不可修改, 指针指向的内容不可修改</span><br></code></pre></td></tr></table></figure><p>谈到指针就不可避免的就会想到<code> 迭代器</code>, 毕竟<code>迭代器</code>就是指针的封装嘛.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//看看下面两种迭代器的定义, 就可以对应上面指针的情况</span><br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-comment">// 迭代器本身是const的, 也就是说本身不可修改, 相当于指针在*前加const</span><br><span class="hljs-comment">// 此时无法进行 ++iter 等操作</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citer = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 语言自带的const_iterator本身就是为了对迭代器指向的内容设置只读, 本身可以进行运算操作, 相当于在*后加const </span><br></code></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><blockquote><p>先明确<code>const</code>成员函数的意义 : 告知编译器这个函数内部的对象不应被改动.</p><p>不是说明函数本身不可改动!!!</p></blockquote><ul><li>那么对成员函数声明<code>const</code>的意义何在?</li></ul><ol><li><strong>使这个函数接口更容易被理解</strong>, 一个函数是否可以改变类内变量的具体数值会很大程度上影响我们对这个函数的定位判断.</li><li><strong>使操作<code>const</code>对象成为可能</strong>, 首先我们要明晰<code>const</code>对象是什么, 就是类定义出的<code>const</code>对象(例如 const Stu stu(小明, 18);), 当我们声明一个类对象为<code>const</code>时, 这个对象对象只能调用<code>const</code>成员函数, 调用的任何<code>non-const</code>成员函数都无法通过编译的, 因此如果你所设计的类有需求<code>const</code>的情景时, 请设计<code>const</code>成员函数.</li></ol><hr><ul><li>这里书中给出了一个事实 : <strong>两个成员函数如果只是常量性不同(const &#x2F; non-const), 也可以被重载.</strong></li></ul><p>​这其实就告诉我们如果想要适配<code>const</code>版本的话, <strong>non-const版本和const版本各写一个就好了</strong>, 编译器会根据对象是否为<code>const</code>来选择使用哪个函数, 样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <span class="hljs-comment">// 1</span><br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <span class="hljs-comment">// 2</span><br> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;<br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数2</span><br>cout &lt;&lt; ctb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数1</span><br></code></pre></td></tr></table></figure><hr><ul><li>接下来需要介绍两种对<code> 成员函数为const</code>时应有行为的流派概念:</li></ul><h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const :"></a>bitwise const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, 应当<strong>不改变对象中的任何变量</strong>, 也就是物理上没有1bit被改变.</p><h4 id="logical-const"><a href="#logical-const" class="headerlink" title="logical const :"></a>logical const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, <strong>可以改变对象中的某些变量</strong>, <strong>但是不能对对象的主要逻辑产生影响</strong>, 也就是说对象在逻辑上没有被改变, 改变的部分只是起辅助优化作用, 例如修改日志, 对计算结果进行缓存, 记录当前容器大小等, 这些工作对主逻辑并没有任何影响, 却可以大大提高主逻辑的工作效率.</p><hr><ul><li>那么C++实际上是怎么定义<code>const</code>成员函数的行为的呢?</li></ul><p>​C++在<strong>一般情况下的定义按照<code>bitwise const</code>的规则进行</strong>, 也就是说一个<code>const</code>成员函数无法改变对象中任何变量.</p><p>​但是这其中有一个C++本身不好决断的情况需要了解 :</p><p>​还记得上面代码中定义的[]重载函数吗 ? const char&amp; operator[](const std::size_t position) const </p><p>​假如我把返回值改为char&amp; : char&amp; operator[](const std::size_t position) const</p><p>​那么这样就会产生一个奇怪的情况 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc = &amp;<span class="hljs-built_in">cbt</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 返回的指针没有const</span><br>*pc = <span class="hljs-string">&#x27;j&#x27;</span>;<span class="hljs-comment">// &quot;hello&quot;被变成了&quot;jello&quot;!!!</span><br></code></pre></td></tr></table></figure><p>​通过以上的情况我们可以发现, C++虽然确保在<code>const</code>成员函数内部不会改变任何对象, 但是并不会检查返回对象所指向的内容是否是不可改变的, C++可能认为在函数外的行为是程序员的自由吧, 所以我们应当注意这一点.</p><hr><ul><li>那么问题又来了, 既然<code>logical const</code>也有其道理所在, C++是如何解决的呢?</li></ul><p>​C++引入了一个与<code>const</code>相关的摆动场 : <strong>mutable(可变的).</strong></p><p>​<code>mutable</code> 的主要用途是在 <code>const</code> 成员函数中允许对特定成员变量的修改, 这样<code>logical const</code>的诉求就可以满足了。</p><p>​请阅读以下代码 : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">text</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br>        <br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">updateLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!lengthIsValid)<br>&#123;<br><span class="hljs-comment">// 以下两句就是因为mutable得以通过</span><br>length = pText.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 重新更新text的长度</span><br>lengthIsValid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 定义当前length可用</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>string pText;<br><br><span class="hljs-comment">// mutable 关键字可以使某个成员变量在const成员函数被修改</span><br><span class="hljs-comment">// 作用是在不改变内部变量的基础逻辑的情况下, 可以引入少量变量可以被改变, 丰富逻辑</span><br><span class="hljs-comment">// 保证函数的安全, 使用mutable意味着在const成员函数中只能改变mutable变量, 其他变量不会被改变</span><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>​以上代码将<code>lenth</code>和<code>lengthIsValid</code>赋予<code>mutable</code>特性, 使其在<code>const</code>成员函数中可以改变, 从而可以用非常小的代价更新<code>text</code>的长度, 方便其他需要使用text长度的函数, 这两个变量均对<code>text</code>存储字符串的主逻辑没有影响.</p><hr><p>​最后还有一个比较有价值的观点 : 我们知道要适配<code>const</code>版本需要写两个类似的函数, 一个处理<code>const</code>对象, 一个处理<code>non-const</code>对象, 但是我们也应当发现这两个函数其实非常相似, 那么这就带来了一些问题:</p><ol><li><strong>代码重复</strong>, 这会带来阅读性降低, 维护成本提高的负面作用.</li><li>我们在以后的条款学习中会知道, 编译器一般会把成员函数替换为<code>inline</code>函数, 这在一般情况下肯定是更高效的, 但是<code>inline</code>函数中的代码越多, 会带来一系列如代码膨胀之类的问题, 这点我们应当避免.</li></ol><ul><li>书中提出了这样的解决方案 : <strong>令<code>non-const</code>版本调用<code>const</code>版本</strong>.</li></ul><p>​这样子做的前提是两个版本的内容一定相等, 或者说<code>non-const</code>版本不能修改对象内的变量, 毕竟如果修改了那和<code>const</code>版本就一定不一样了, 我们来改写上面[]重载的两个版本.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br>&#123; <br>    <span class="hljs-comment">//我们假定[]重载在返回下标引用之前还要做许多工作, 代码量巨大</span><br>    <span class="hljs-comment">// ...边界检验</span><br>    <span class="hljs-comment">// ...将数据访问的行为加入日志</span><br>    <span class="hljs-comment">// ...检验指向内容数据的完整性</span><br>    <span class="hljs-keyword">return</span> text[position]; <br>&#125;<br><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br>&#123; <br>    <span class="hljs-comment">// 这段代码实现了两次类型转换, 目的是调用const版本的operator[]函数并返回non-const的char&amp;</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> text&amp;&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>    <span class="hljs-comment">/* 我们把这段代码拆分开来解读</span><br><span class="hljs-comment">    return const_cast&lt;char&amp;&gt;(    // 3. 将[]返回结果由const版本通过const_cast转换为non-const版本</span><br><span class="hljs-comment">        static_cast&lt;const text&amp;&gt;(*this)  // 1. 先将this指针通过static_cast转换为const text&amp;</span><br><span class="hljs-comment">        [pos] // 2. const text&amp;类型调用[]重载, 自然使用的是const版本的[]重载</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​经过以上的操作, 无论<code>const</code>版本需要多少行代码, <code>non-const</code>版本都只需要一行代码即可, 相当实用.</p><p>​另外如果在<code>non-const</code>版本虽然和<code>const</code>版本十分相似, 但是还是想要修改一部分的数据, 也可以在调用完重载版本后不返回, 再进行一些修改操作再返回.</p><ul><li>小问题 : 为什么不用<code>const</code>版本调用<code>non-const</code>版本?  因为<code>non-const</code>版本不会限制修改行为, 无法监督<code>const</code>实现.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h2><ul><li>将某些东西声明为<code>const</code>可以帮助编译器检查出错误语法, <code>const</code>可被施加于任何对象, 函数参数, 函数返回值, 成员函数</li><li>C++在<code>const</code>成员函数定义上默认支持<code>bitwise const</code>流派, 但是也通过关键字<code>mutable</code>变相支持了<code>logical const</code>流派</li><li>当<code>non-const</code>版本和<code>const</code>版本等价实质时, 可以用<code>non-const</code>版本调用<code>const</code>版本</li></ul><p>作者 : 天目中云</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款1-2</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/</url>
    
    <content type="html"><![CDATA[<h3 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01 : 视C++为一个语言联邦"></a>条款01 : 视C++为一个语言联邦</h3><blockquote><p>不像Java对各种资源都进行了整合内聚, C++更像是由四种次语言组合而成的语言联邦, 每种次语言都有自己的规约, 也都有不同的用武之地, 每个都可以给C++这门语言带来独特的优势.</p><ul><li><h4 id="C-C-的基础-包含指针-内置数据类型等基础思想"><a href="#C-C-的基础-包含指针-内置数据类型等基础思想" class="headerlink" title="C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想."></a>C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想.</h4></li></ul></blockquote><ul><li><h4 id="Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态"><a href="#Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态" class="headerlink" title="Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态."></a>Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态.</h4></li><li><h4 id="Template-C-泛型编程"><a href="#Template-C-泛型编程" class="headerlink" title="Template C++  :  泛型编程."></a>Template C++  :  泛型编程.</h4></li><li><h4 id="STL-一套template的程序库-包含各种数据结构与算法"><a href="#STL-一套template的程序库-包含各种数据结构与算法" class="headerlink" title="STL  :  一套template的程序库, 包含各种数据结构与算法."></a>STL  :  一套template的程序库, 包含各种数据结构与算法.</h4><p>  这四个方向我们都应熟识掌握, 但是可以给自己这样一个印象 : C++并不是一个一体的语言, 编程时的思想规范应当随你使用C++的对应部分而改变.</p></li></ul><hr><h3 id="条款02-尽量以cnost-enum-inline-替换-define"><a href="#条款02-尽量以cnost-enum-inline-替换-define" class="headerlink" title="条款02 : 尽量以cnost, enum, inline 替换 #define"></a>条款02 : 尽量以cnost, enum, inline 替换 #define</h3><blockquote><p>由 ‘#’ 引出的语句一般与C的预处理机制相关, 我们很需要预处理机制中的 #include 和 #ifdef, 前者保证库的引入, 后者可以针对不同的环境进行条件编译, 而 #define 却在语言的发展下显得有些与时代脱节了, 现在我们应当有心减少 #define 的使用.</p></blockquote><p>以下列举 #define 所带来的一些问题:</p><ol><li>书写代码时很难自动显示错误</li><li>编译错误时显示的信息并不直观</li><li>#define并不重视作用域, 面向全局生效, 这与我们应当坚持的封装思想相悖</li></ol><p>简而言之, 就是#define可能带来一些不可预料的行为并且无法保证类型安全, 而如今我们由足够多的方法可以安全有效地替代#define的功能, 比如const和enum可以替代#define在常量定义上功能, inline又可以替代#define在宏函数上的功能.</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100 <span class="hljs-comment">// 这个步骤在预处理阶段实现</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-comment">// 这个步骤在编译阶段实现</span><br></code></pre></td></tr></table></figure><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里我们想定义三元色的对应数值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED = 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN = 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE = 3</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED = <span class="hljs-number">1</span>, <br>    GREEN = <span class="hljs-number">2</span>,<br>    BLUE = <span class="hljs-number">3</span><br>&#125;<span class="hljs-comment">// 使用enum枚举类型在增强代码的可读性的同时也提升了可维护性</span><br><br><span class="hljs-comment">//-----------------------------------------------------//</span><br><span class="hljs-keyword">enum</span> Action&#123;<br>    RUN = <span class="hljs-number">0x0001</span>,    <span class="hljs-comment">// 第一位</span><br>    JUMP = <span class="hljs-number">0x0002</span>, <span class="hljs-comment">// 第二位</span><br>    SAY = <span class="hljs-number">0x0004</span>, <span class="hljs-comment">// 第三位</span><br>    SLEEP = <span class="hljs-number">0x0008</span> <span class="hljs-comment">// 第四位</span><br>&#125;<span class="hljs-comment">// 使用enum还可以实现比特级别的状态判断</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">CheckAction</span>(<span class="hljs-type">int</span> action);   <span class="hljs-comment">// 假设我们有这样一个检查运动状态的函数, 那么我们就可以只接受一个int就可以判断复数的状态</span><br><span class="hljs-built_in">CheckAction</span>(RUN | JUMP | SAY);<span class="hljs-comment">// 这里的状态就 跑 + 跳 + 说话</span><br></code></pre></td></tr></table></figure><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入我们想实现的MAX(a, b), 我们可以通过以下实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b)  (a) &gt; (b) ? (a) : (b)</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MAX</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用模板 + inline就可以完全代替宏函数的作用, 首先inline的书写模式更加自然, 另外还保证了类型安全, 规避了#define的危险性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
