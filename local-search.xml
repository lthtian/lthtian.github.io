<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(3)</title>
    <link href="/2025/05/15/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(3)/"/>
    <url>/2025/05/15/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(3)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在构建通信框架前,  一定要先了解我们的框架该怎么使用, 大体有哪几个部件, 在本章将会先写出一个简易的客户端和服务端, 让我们了解该设计出什么样的网络通信框架.</p></blockquote><h3 id="统一通信标准"><a href="#统一通信标准" class="headerlink" title="统一通信标准"></a>统一通信标准</h3><p>首先双方如果需要通信, 那么<strong>统一通信标准</strong>必不可少, 这也是为什么讲解proto的原因, 所以我们的第一步是编写proto文件并且生成.h和.cpp文件, 这里还是已先前的登录服务为例 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> fixbug;<br><br><span class="hljs-keyword">option</span> cc_generic_services = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ResultCode</span><br>&#123;<br>    <span class="hljs-type">int32</span> errcode = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> errmsg = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginRequest</span> <br>&#123;<br>    <span class="hljs-type">bytes</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> pwd = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginResponse</span><br>&#123;<br>    ResultCode result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">UserServiceRpc</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(LoginRequest) <span class="hljs-keyword">returns</span>(LoginResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们通过终端命令获得.h和.cpp文件后, 这个文件会共享给客户端和服务端, 你也许会觉得这增加了远程调用的难度, 因为这意味着客户端还要获取这些文件, 但是这是必须前提.</p><h3 id="服务端发布服务"><a href="#服务端发布服务" class="headerlink" title="服务端发布服务"></a>服务端发布服务</h3><p>当我们想给一个方法或一类方法提供远程调用服务时, 我们要把其包装进一个Service(服务类)中, 这个类提供远程调用版本的方法, 并且这个类还要继承自我们先前用proto生成的服务类封装, 我们具体看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// UserServic原本是一个本地服务</span><br><span class="hljs-comment">// 只要继承UserServiceRpc再重写一个虚函数就可以实现rpc服务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> : <span class="hljs-keyword">public</span> fixbug::UserServiceRpc<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Login</span><span class="hljs-params">(std::string name, std::string pwd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;doing local servie : Login&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; pwd:&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(::google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">const</span> ::fixbug::LoginRequest *request,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::fixbug::LoginResponse *response,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::google::protobuf::Closure *done)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>        std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br><br>        <span class="hljs-type">bool</span> login_result = <span class="hljs-built_in">Login</span>(name, pwd);<br><br>        <span class="hljs-comment">// 把结果response</span><br>        ResultCode *code = response-&gt;<span class="hljs-built_in">mutable_result</span>();<br>        code-&gt;<span class="hljs-built_in">set_errcode</span>(<span class="hljs-number">0</span>);<br>        code-&gt;<span class="hljs-built_in">set_errmsg</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        response-&gt;<span class="hljs-built_in">set_success</span>(login_result);<br><br>        <span class="hljs-comment">// 执行回调操作 直接执行响应对象数据的序列化和网络发送</span><br>        done-&gt;<span class="hljs-built_in">Run</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>fixbug : 这个就是我们先前在proto中设置的命名空间, 在这个命名空间中就会有我们设置的<code>UserServiceRpc服务类</code>.</p></li><li><p>继承后我们就要写一个Login函数重写版本, 相当于一个远程调用版本, 其参数是固定的 : </p><p>RpcController + 先前设定的请求参数类型 + 响应参数类型 + Closure.</p><p>中间两个我们很熟悉, 第一个我们先不用关心, 最后一个你可以理解为执行类型, 帮我们执行最后发送操作.</p></li></ul><p>在写完我们要发布的服务类后我们来看具体如何发布 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../user.pb.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rpcprovider.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;logger.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> fixbug;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mprpc;<br><br><span class="hljs-comment">// UserServic原本是一个本地服务</span><br><span class="hljs-comment">// 只要继承UserServiceRpc再重写一个虚函数就可以实现rpc服务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> : <span class="hljs-keyword">public</span> fixbug::UserServiceRpc<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Login</span><span class="hljs-params">(std::string name, std::string pwd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;doing local servie : Login&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; pwd:&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(::google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">const</span> ::fixbug::LoginRequest *request,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::fixbug::LoginResponse *response,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::google::protobuf::Closure *done)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>        std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br><br>        <span class="hljs-type">bool</span> login_result = <span class="hljs-built_in">Login</span>(name, pwd);<br><br>        <span class="hljs-comment">// 把结果response</span><br>        ResultCode *code = response-&gt;<span class="hljs-built_in">mutable_result</span>();<br>        code-&gt;<span class="hljs-built_in">set_errcode</span>(<span class="hljs-number">0</span>);<br>        code-&gt;<span class="hljs-built_in">set_errmsg</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        response-&gt;<span class="hljs-built_in">set_success</span>(login_result);<br><br>        <span class="hljs-comment">// 执行回调操作 直接执行响应对象数据的序列化和网络发送</span><br>        done-&gt;<span class="hljs-built_in">Run</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用框架初始化操作</span><br>    MprpcApplication::<span class="hljs-built_in">Init</span>(argc, argv);<br><br>    <span class="hljs-built_in">log_info</span>(<span class="hljs-string">&quot;first log message.&quot;</span>);<br><br>    <span class="hljs-comment">// 把UserService发布到rpc节点上</span><br>    RpcProvider provider;<br>    provider.<span class="hljs-built_in">NotifyService</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">UserService</span>());<br>    <span class="hljs-comment">// 启动一个rpc服务发布节点</span><br>    provider.<span class="hljs-built_in">Run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里引出两个关键类 :  <code>MprpcApplication</code> 和 <code>RpcProvider</code> .</p><ul><li>MprpcApplication : 负责框架的初始化, 其更多的功能在于加载配置文件, 后面会详细介绍.</li><li>RpcProvider : 核心类, 其作用在于将服务发布到rpc节点上, 发布成功后就可以持续监听对于该服务的请求并做出响应.<ul><li>NotifyService : 将服务中的信息的记录下来, 在运行后以供查询.</li><li>Run : 调用网络库的网络服务, 开始接收外部调用请求.</li></ul></li></ul><h3 id="客户端调用远程服务"><a href="#客户端调用远程服务" class="headerlink" title="客户端调用远程服务"></a>客户端调用远程服务</h3><p>客户端的调用就相对方便了, 设置好请求对象就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.pb.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 想要使用rpc服务, 就要调用框架的初始化服务</span><br>    MprpcApplication::<span class="hljs-built_in">Init</span>(argc, argv);<br><br>    <span class="hljs-comment">// 演示调用远程发布的rpc方法的Login</span><br>    <span class="hljs-function">fixbug::UserServiceRpc_Stub <span class="hljs-title">stub</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MprpcChannel())</span></span>;<br><br>    fixbug::LoginRequest request;<br>    request.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br>    request.<span class="hljs-built_in">set_pwd</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>    fixbug::LoginResponse response;<br><br>    MprpcController controller;<br><br>    stub.<span class="hljs-built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 如果rpc服务确实成功再继续接下来的内容</span><br>    <span class="hljs-keyword">if</span> (controller.<span class="hljs-built_in">Failed</span>())<br>    &#123;<br>        std::cout &lt;&lt; controller.<span class="hljs-built_in">ErrorText</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// rpc方法调用完成, 读响应</span><br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errcode</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response:&quot;</span> &lt;&lt; response.<span class="hljs-built_in">success</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response error : &quot;</span> &lt;&lt; response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errmsg</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>fixbug::UserServiceRpc_Stub stub(new MprpcChannel());</code></p><p>stub其目的在于帮助我们调用到我们需求函数的远程版本, 其构造必须传入一个MprpcChannel类型的参数, 这个也是框架的核心类, 在之后会详细讲解.</p></li><li><p>之后就是正常的设置请求对象, 将响应对象一并放入远程调用函数, 如果框架帮我们调用成功, 这里便可以从响应对象中取出我们想要的响应.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(2) protobuf</title>
    <link href="/2025/05/11/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(2)/"/>
    <url>/2025/05/11/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>protobuf部分</p></blockquote><p>protobuf的功效和json相似, 都是便利数据的序列化和反序列化用于网络传输, 在rpc分布式网络通信中可以使用protobuf, 让我们先了解其优势 : </p><ul><li>传输数据由二进制存储, 节省空间且效率更高.</li><li>有专门对于服务&#x2F;方法的封装, 可以更方便地传输一个方法的信息.</li></ul><p>当然其劣势在于需要编写.proto文件, 安装和使用都麻烦些, 不过这并不妨碍我们学习.</p><h3 id="proto文件"><a href="#proto文件" class="headerlink" title=".proto文件"></a>.proto文件</h3><p>首先我们要知道, 写一个.proto文件实际就是类似c++中写几个类, 每个类都是对你要传输数据的封装, 下面是一个对于登录所需数据的.proto文件 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;  <span class="hljs-comment">// 声明proto版本</span><br><br><span class="hljs-keyword">package</span> fixbug;  <span class="hljs-comment">// 类似namespace</span><br><br><span class="hljs-keyword">option</span> cc_generic_services = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 这个是在你想要使用service类型时添加</span><br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ResultCode</span><br>&#123;<br>    <span class="hljs-type">int32</span> errcode = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> errmsg = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginRequest</span> <br>&#123;<br>    <span class="hljs-type">bytes</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> pwd = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginResponse</span><br>&#123;<br>    ResultCode result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">UserServiceRpc</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(LoginRequest) <span class="hljs-keyword">returns</span>(LoginResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出, 普通数据封装都是message类型, 里面可以存, int, bool等类型, 注意这里bytes实际就是string类型, 当然直接写string也可以, 但是使用bytes效率更佳.</p><p>最后sevice类型用来描述一个服务, 其中可以有多个方法(函数), 其中每个方法的写法是 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> 函数名(参数类型) <span class="hljs-keyword">returns</span>(返回类型)</span>;<br></code></pre></td></tr></table></figure><p>为什么要封装方法? 假设我们要调用一个远程服务, 作为客户端, 我们就要告诉服务端我们要调用什么服务的什么方法. 假设我们要发布服务, 那么为了让我们的服务可以被更多的客户端找到, 我们所封装的服务格式就应当符合一些广为人知的标准, 而这个标准一般就是proto所封装的服务.</p><h3 id="生成头文件和源文件"><a href="#生成头文件和源文件" class="headerlink" title="生成头文件和源文件"></a>生成头文件和源文件</h3><p>在写完.proto文件后, 我们就可以执行终端命令来自动生成头文件和源文件了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc xxx.proto --cpp_out=./<br></code></pre></td></tr></table></figure><p>调用该命令便可以在当前目录下生成 xxx.pb.h 和 xxx.pb.cpp 文件了, 这两个文件才是我们真正使用的文件.</p><h3 id="使用proto进行序列化和反序列化"><a href="#使用proto进行序列化和反序列化" class="headerlink" title="使用proto进行序列化和反序列化"></a>使用proto进行序列化和反序列化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在客户端, 我们可以这样构建请求类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.pb.h&quot;</span></span><br><br>fixbug::LoginRequest request;<br>request.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br>request.<span class="hljs-built_in">set_pwd</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br><br><span class="hljs-comment">// 在服务端, 可以这样取出请求类型</span><br>std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法细节复习(1)</title>
    <link href="/2025/04/28/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(1)/"/>
    <url>/2025/04/28/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="MyString"><a href="#MyString" class="headerlink" title="MyString"></a>MyString</h2><p>最普通的String模仿, 没有追加功能函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!str)<br>        &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *mptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(mptr, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyString</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!mptr)<br>            <span class="hljs-keyword">delete</span>[] mptr;<br>    &#125;<br><br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> MyString &amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发左值拷贝&quot;</span> &lt;&lt; endl;<br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(mptr, cp.mptr, <span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发右值拷贝&quot;</span> &lt;&lt; endl;<br>        mptr = cp.mptr;<br>        cp.mptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyString &amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发左值赋值重载&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;cp)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-keyword">delete</span>[] mptr;<br><br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(mptr, cp.mptr, <span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发右值赋值重载&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;cp)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-keyword">delete</span>[] mptr;<br><br>        mptr = cp.mptr;<br>        cp.mptr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> *&amp;<span class="hljs-title">getPtr</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> mptr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *mptr;<br>&#125;;<br><br>MyString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyString &amp;first, <span class="hljs-type">const</span> MyString &amp;second)<br>&#123;<br>    MyString tmp;<br>    tmp.<span class="hljs-built_in">getPtr</span>() = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(first.<span class="hljs-built_in">getPtr</span>()) + <span class="hljs-built_in">strlen</span>(second.<span class="hljs-built_in">getPtr</span>()) + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(tmp.<span class="hljs-built_in">getPtr</span>(), first.<span class="hljs-built_in">getPtr</span>());<br>    <span class="hljs-built_in">strcat</span>(tmp.<span class="hljs-built_in">getPtr</span>(), second.<span class="hljs-built_in">getPtr</span>());<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> MyString &amp;str)<br>&#123;<br>    out &lt;&lt; str.<span class="hljs-built_in">getPtr</span>();<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MyString <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">MyString <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot; world!&quot;</span>)</span></span>;<br>    str = <span class="hljs-built_in">move</span>(str2);<br>    <span class="hljs-function">MyString <span class="hljs-title">str3</span><span class="hljs-params">(MyString(<span class="hljs-string">&quot;222&quot;</span>))</span></span>;<br>    MyString str4 = <span class="hljs-built_in">MyString</span>(<span class="hljs-string">&quot;111&quot;</span>);<br>    cout &lt;&lt; str4 &lt;&lt; endl;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul><li>左值 : 有内存, 有名字 |  右值 : 没内存, 没名字</li><li>int&amp;&amp; d &#x3D; 20; <ul><li>一个右值引用变量本身是一个左值, 只不过引用了一个右值而已.</li><li>20是右值, d是左值, 也是右值引用变量.</li></ul></li></ul><h2 id="引用折叠-完美转发"><a href="#引用折叠-完美转发" class="headerlink" title="引用折叠 &#x2F; 完美转发"></a>引用折叠 &#x2F; 完美转发</h2><p>我们先引入一个例子 : vector的push_back, 其可以有两个版本, 分别对应接收左值和右值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, val);<br>    _last++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, std::<span class="hljs-built_in">move</span>(val));<br>    _last++;<br>&#125;<br></code></pre></td></tr></table></figure><p>其区别在于, 因为右值在使用时会降级为左值, 所以在右值版本必须通过move保证传递的依然是个左值. 而引用折叠 + 完美转发可以帮助我们合并这两个版本.</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><ul><li><p>&amp; + &amp; &#x3D; &amp;</p></li><li><p>&amp; + &amp;&amp; &#x3D; &amp;</p></li><li><p>&amp;&amp; + &amp;&amp; &#x3D; &amp;&amp;</p></li></ul><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><ul><li>forward<T>() : 使用这个函数可以保证右值不会降级.</li></ul><h3 id="函数模板类型推导-引用折叠-完美转发-实现左右值版本合并"><a href="#函数模板类型推导-引用折叠-完美转发-实现左右值版本合并" class="headerlink" title="函数模板类型推导 + 引用折叠 + 完美转发 实现左右值版本合并"></a>函数模板类型推导 + 引用折叠 + 完美转发 实现左右值版本合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ty&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(Ty&amp;&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, std::forward&lt;Ty&gt;(val);<br>    _last++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本等同于我们以上两个版本, 这里的逻辑是 : </p><ul><li>使用函数模板开启类型推导, 不再按照定死的类型判断, 也就是可以使用引用折叠了.</li><li>如果传入左值, T&amp;  &amp;&amp; -&gt; T&amp;.</li><li>如果传入右值, T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;.</li><li>forward将val按照原来的类型完美转发出去, 不改变其左右值类型.</li></ul><p>于是我们通过 <strong>函数模板类型推导 + 引用折叠 + 完美转发</strong> 实现了代码简化, 让其可以同时处理左右值情况, 这种操作适用于希望同时接受左右值同时对左右值没有操作上的区别的函数, 你可以认为这就是<strong>引用折叠和完美转发最主要的作用</strong>了.</p><p>当然完美转发的用途更加广泛一些, 比如 : </p><ul><li><p>在工厂函数中根据不同类型转发不同的参数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">create</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>create就在分析完T的类型后向T的构造函数中完美转发参数包, 也就是说, 他可以为任何类型在堆上开辟空间, 只用参数和其构造函数匹配.</p></li><li><p>原地构造, 最经典的就是vector的emplace_back.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">construct_at</span>(<span class="hljs-built_in">end</span>(), std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>在以前push_back只可以传入对应类型的对象, 这样还要进行拷贝再填入到开辟的空间中, 而有了完美转发, 就可以直接在开辟的空间上用传入的参数直接调用对应类型的构造函数, 这样更加快速.</p></li></ul><h2 id="对象优化的原则"><a href="#对象优化的原则" class="headerlink" title="对象优化的原则"></a>对象优化的原则</h2><ul><li><p>函数参数传递过程中, 对象优先传引用传参, 不要传值传参.</p></li><li><p>当函数返回对象时, 返回临时对象效率最优, 而非先定义局部对象然后返回局部对象.</p><ul><li>返回临时对象会直接在main函数栈帧上构建该对象, 不受这个函数影响. 如果是后者还要将原本构建的局部对象拷贝构造到main函数的栈帧上, 离开函数作用域还要调用局部对象的析构, 也就是说会多两个函数调用.</li></ul></li><li><p>当函数返回对象时, 优先按初始化方式接收, 而非初始化完了再赋值.</p><ul><li>因为这个返回的对象肯定是右值, 所以可以直接拿来用来构建, 都省去了再拷贝操作. 不过如果有了移动语义, 右值进行拷贝或赋值重载的消耗很小, 其实也可以忽略不计.</li><li>在C++17中有RVO机制, 要求强制返回值优化, 也就说上面的行为在C++17以前可能算是编译器优化, 但在C++17以后就算是语言特性了.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>移动语义</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(1)</title>
    <link href="/2025/04/27/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(1)/"/>
    <url>/2025/04/27/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理论准备</p></blockquote><p><strong>单机聊天服务器的缺点 :</strong> </p><ul><li>受限于硬件资源, 并发量有限制  -&gt;  集群服务器解决</li><li>任意模块的修改都会导致整体的编译部署  -&gt; 分布式解决</li><li>有些模块是CPU密集型, 有些是IO密集型, 对硬件资源不一样  -&gt; 分布式解决</li></ul><p><strong>集群与分布式 :</strong> </p><ul><li>集群 : 每个里面都运行了一个独立系统, 有全套的服务.</li><li>分布式 : 将不同服务搭载在不同的服务器上, 还可以对单个分布式节点集群.</li></ul><p><strong>分布式面临问题 :</strong> </p><ul><li>模块如何划分?</li><li>各模块之间如何访问? -&gt; 涉及网络传输</li></ul><h3 id="RPC-remote-procedure-call-远程过程调用-通信原理"><a href="#RPC-remote-procedure-call-远程过程调用-通信原理" class="headerlink" title="RPC(remote procedure call 远程过程调用)通信原理"></a>RPC(remote procedure call 远程过程调用)通信原理</h3><ul><li>将请求序列化, 经由服务发现将请求通过网络发送到目标服务器, 对端接收并反序列化, 调用目标函数并返回, 返回也要经历上述过程.</li></ul><h3 id="RPC分布式网络通信框架"><a href="#RPC分布式网络通信框架" class="headerlink" title="RPC分布式网络通信框架"></a>RPC分布式网络通信框架</h3><p>这只是一个框架, 可以帮助我们将自己的服务发布为rpc节点, 或帮助我们调用其他发布者发布的rpc节点中的方法, 接下来让我们深入了解.</p><h4 id="服务与方法"><a href="#服务与方法" class="headerlink" title="服务与方法"></a>服务与方法</h4><p>这只是一个标准的概念, 服务包含方法, 一个服务可以有很多方法, 一个方法就对应一个函数, 其实服务就是起到一个分类的作用, 在rpc中通常以此作为分类标准.</p><h4 id="具体框架"><a href="#具体框架" class="headerlink" title="具体框架"></a>具体框架</h4><ul><li><p>假如我们要调用一个远程服务, 也就是调用一个远程服务器上的函数并将参数传入, 获取该函数返回的内容, 在这之中函数发布者和函数调用者都会有一些特定的操作.</p></li><li><p>Provider(发布者)</p><p>将自己想发布的方法包装进服务中, 发布该服务, 意味着自己作为服务器持续接收远端通过网络发送来的调用请求, 接收请求的处理逻辑如下 : </p><ul><li>利用muduo库进行网络消息的接收 -&gt; 反序列化取出请求的服务&#x2F;方法&#x2F;参数 -&gt; 调用对应函数并产生返回值 -&gt; 将返回值序列化 -&gt; 通过muduo库将返回值发送回去</li></ul></li><li><p>Consumer(调用者)</p><p>只要知道了发布rpc服务节点的地址, 就可以通过接近普通方法的调用方式调用到远程方法.</p><ul><li>直接获知目标rpc的地址或通过服务发现获取地址 -&gt; 将服务&#x2F;方法&#x2F;参数序列化发送给目标地址 -&gt; 等待接收返回值并反序列化.</li></ul></li></ul><p>这其中我们有两大工具必不可少 : </p><ul><li><p>Protobuf </p><p>类似于json用于网络通信的序列化和反序列化的工具, 不过其支持对rpc服务的序列化和反序列化, 可以使框架的构建更加简便.</p></li><li><p>Zookeeper</p><p>服务发现工具, 帮助客户端找到目标服务方法的地址.</p></li></ul><h2 id="Zookeeper分布式协调服务"><a href="#Zookeeper分布式协调服务" class="headerlink" title="Zookeeper分布式协调服务"></a>Zookeeper分布式协调服务</h2><blockquote><p>服务发现 &#x2F; 分布式锁</p></blockquote><p>一个注册中心, 保存了所有可获得的服务和其对应的URL(ip &#x2F; port).</p><h3 id="znode节点"><a href="#znode节点" class="headerlink" title="znode节点"></a>znode节点</h3><p>zookeeper服务专属的数据存储节点, 类似一个树, 用来存储服务, 一个节点最多存储1兆数据</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>在节点变化时使用Watcher的客户端会得到通知.</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(6) TcpServer</title>
    <link href="/2025/04/23/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(6)%20TcpServer/"/>
    <url>/2025/04/23/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(6)%20TcpServer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>TcpServer类详解</p></blockquote><p>TcpServer将会作为Muduo库对外开放的核心类, 其提供接口开启服务器并设置设置回调函数与线程数量.</p><p>我们可以先预测一下TcpServer将要实现的功能 : </p><ul><li>构造Acceptor并控制listen决定开始监听的时机.</li><li>构造EventLoopThreadPool并开辟设置的线程数量.</li><li>处理Acceptor监听到的每个connfd, 构建对应的TcpConnection, 并把该连接保存下来.</li><li>对外提供开始监听, 设置回调, 设置线程数量等接口.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Accept.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Callbacks.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpConnection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpServer</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span> <span class="hljs-comment">// 表明对端口是否可重用</span><br>    &#123;<br>        kNoReusePort,<br>        kReusePort,<br>    &#125;;<br><br>    <span class="hljs-built_in">TcpServer</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">const</span> std::string name, Option option = kNoReusePort);<br>    ~<span class="hljs-built_in">TcpServer</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadInitcallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; _threadInitCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; _connectionCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp;cb)</span> </span>&#123; _messageCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCommpleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; _writeCompleteCallback = cb; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadNum</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span> </span>&#123; _threadPool-&gt;<span class="hljs-built_in">setThreadNum</span>(numThreads); &#125;<br><br>    <span class="hljs-comment">// 开启服务器监听</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span>;<br><br>    <span class="hljs-keyword">using</span> ConnectionMap = std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;<br><br>    EventLoop *_mainloop;<br>    <span class="hljs-type">const</span> std::string _ipPort;<br>    <span class="hljs-type">const</span> std::string _name;<br><br>    std::unique_ptr&lt;Acceptor&gt; _acceptor;<br>    std::shared_ptr&lt;EventLoopThreadPool&gt; _threadPool; <span class="hljs-comment">// one loop per thread</span><br><br>    ConnectionCallback _connectionCallback;<br>    MessageCallback _messageCallback;<br>    WriteCompleteCallback _writeCompleteCallback;<br><br>    ThreadInitCallback _threadInitCallback;<br><br>    std::atomic_int _started;<br><br>    <span class="hljs-type">int</span> _nextConnId;<br>    ConnectionMap _connections;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们先来看成员变量 : </p><ul><li>_mainloop : 这个mainloop是由用户传入的, 用户会决定何时调用<code>loop.loop();</code>来开启循环.</li><li>_acceptor : 维护listensocketfd对新连接进行监听.</li><li>_threadPool : 维护线程池提供subloop的指针, 在建立TcpConnection时为其轮询挑提供subloop.</li><li>各类回调函数 : 这里主要是用户提供给TcpConnection建立时设置的各种回调.</li><li>_connections : 维护所有建立的连接.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> EventLoop *<span class="hljs-title">CheckLoopNotNull</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (loop == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d mainLoop is null!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>TcpServer::<span class="hljs-built_in">TcpServer</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">const</span> std::string name, Option option)<br>    : _mainloop(<span class="hljs-built_in">CheckLoopNotNull</span>(loop))<br>    , _ipPort(listenAddr.<span class="hljs-built_in">toIpPort</span>())<br>    , _name(name)<br>    , _acceptor(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))<br>    , _threadPool(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThreadPool</span>(loop, name))<br>    , _connectionCallback()<br>    , _messageCallback()<br>    , _nextConnId(<span class="hljs-number">1</span>)<br>    , _started(<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">// 当有新用户连接时, 会执行newConnection</span><br>    _acceptor-&gt;<span class="hljs-built_in">setNewConnectionCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::newConnection, <span class="hljs-keyword">this</span>,<br>          std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br>TcpServer::~<span class="hljs-built_in">TcpServer</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : _connections)<br>    &#123;<br>        <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(item.second)</span></span>; <span class="hljs-comment">// 局部强智能指针对象会自动释放</span><br>        item.second.<span class="hljs-built_in">reset</span>();                <span class="hljs-comment">// 原map中放弃对强指针的使用</span><br><br>        conn-&gt;<span class="hljs-built_in">getLoop</span>()-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestoryed, conn));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_started++ == <span class="hljs-number">0</span>) <span class="hljs-comment">// 防止被重复启动多次</span><br>    &#123;<br>        _threadPool-&gt;<span class="hljs-built_in">start</span>(_threadInitCallback);<br>        _mainloop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::listen, _acceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在TcpServer中具体是轮询找到subLoop, 唤醒该loop</span><br><span class="hljs-comment">// 把sockfd封装成channel加入到subLoop中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    EventLoop *subLoop = _threadPool-&gt;<span class="hljs-built_in">getNextLoop</span>();<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;-%s#%d&quot;</span>, _ipPort.<span class="hljs-built_in">c_str</span>(), _nextConnId);<br>    ++_nextConnId;<br>    std::string connName = _name + buf;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,<br>             _name.<span class="hljs-built_in">c_str</span>(), connName.<span class="hljs-built_in">c_str</span>(), peerAddr.<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 通过sockfd直接获取绑定的ip+port</span><br>    sockaddr_in local;<br>    <span class="hljs-built_in">bzero</span>(&amp;local, <span class="hljs-keyword">sizeof</span> local);<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-keyword">sizeof</span> local;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getsockname</span>(sockfd, (sockaddr *)&amp;local, &amp;addrlen) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;sockets::getLocalAddr&quot;</span>);<br><br>    <span class="hljs-function">InetAddress <span class="hljs-title">localAddr</span><span class="hljs-params">(local)</span></span>;<br><br>    <span class="hljs-comment">// 根据连接成功的sockfd, 创建TcpConnection连接对象</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TcpConnection(subLoop, connName, sockfd, localAddr, peerAddr))</span></span>;<br>    <span class="hljs-comment">// 存储连接名字与对应连接的映射</span><br>    _connections[connName] = conn;<br>    <span class="hljs-comment">// 下面的回调都是用户设置给TcpServer的</span><br>    conn-&gt;<span class="hljs-built_in">setConnectionCallback</span>(_connectionCallback);<br>    conn-&gt;<span class="hljs-built_in">setMessageCallback</span>(_messageCallback);<br>    conn-&gt;<span class="hljs-built_in">setWriteCompleteCallback</span>(_writeCompleteCallback);<br>    <span class="hljs-comment">// 设置了如何关闭连接的回调</span><br>    conn-&gt;<span class="hljs-built_in">setCloseCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br>    <span class="hljs-comment">// 直接调用TcpConnection::connectEstablished</span><br>    <span class="hljs-comment">// 代表连接建立成功</span><br>    subLoop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    _mainloop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="hljs-keyword">this</span>, conn));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s\n&quot;</span>,<br>             _name.<span class="hljs-built_in">c_str</span>(), conn-&gt;<span class="hljs-built_in">name</span>().<span class="hljs-built_in">c_str</span>());<br><br>    _connections.<span class="hljs-built_in">erase</span>(conn-&gt;<span class="hljs-built_in">name</span>());<br>    EventLoop *subloop = conn-&gt;<span class="hljs-built_in">getLoop</span>();<br>    subloop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestoryed, conn));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源文件来分析成员函数 : </p><ul><li><p>构造函数 : </p><p>接收loop, ip端口, 服务器名, 利用接收到的loop和ip端口直接构造_acceptor, 利用接收到的loop和name直接构造ThreadPool. 这里为 _acceptor中设置了其新连接建立回调函数, 这个函数会在listensocketfd读事件触发时被调用, 回调函数newConnection是TcpServer的核心函数, 我们将会再后面着重讲解.</p></li><li><p>析构函数 : </p><p>这里就是遍历_connections对每个连接进行销毁, 将每个智能指针做完局部变量取出再让原map放弃对该指针的使用, 这样调用对应的connectDestoryed后就会离开作用域自动析构.</p></li><li><p>start : </p><p>调用_threadPool的start, 让其构造出多个线程备用. 调用 _acceptor的listen, 开启对listensocketf的监听.</p></li><li><p>newConnection :</p><p>核心函数, 在_acceptor接收到新连接后调用, 其从 _threadPool中轮询取出一个工作线程, 再将自身的地址取出, 并以此构造出对应的TcpConnection, 然后将用户设置的回调函数再设置到TcpConnection中, 一切设置完毕后, 调用connectEstablished注册其内部 _channel中的读事件以真正开启对socket读事件的监听.</p></li><li><p>removeConnection &#x2F; removeConnectionInLoop : </p><p>先将该连接从_connections中移除,再去调用connectDestoryed.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(5) TcpConnection</title>
    <link href="/2025/04/21/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(5)%20TcpConnection/"/>
    <url>/2025/04/21/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(5)%20TcpConnection/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Buffer 和 TcpConnection 详解</p></blockquote><p>本章我们将学习Buffer类和其上级类TcpConnection, 先了解两个类的职能 : </p><ul><li><p>Buffer</p><p>和通常的缓冲区认知类似, 目的在于提升传入传出的效率, 就是在read中可以提前把数据从内核接收缓冲区中读出, 便于对端再向内核接收缓冲区输入. 在write中可以提前把要写入的数据存进缓冲区, 等待内核发送缓冲区空余.</p></li><li><p>TcpConnection</p><p>专门用来维护每条与客户端的连接的类, 也就是对Acceptor中得到的connfd进行封装, 包括其对应的Socket和Channel类. 并且连接也代表了<strong>有连接的建立与断开, 数据的传入与传出等</strong>活动, 这些活动中, 一部分需要<strong>上级设置的回调函数</strong>来处理(例如连接建立断开, 数据传入, 都需要网络库调用者设置), 一部分需要TcpConnection<strong>利用自己手头的资源自行处理</strong>(例如数据传出, 需要调用自己的send函数). 既然与数据的传入传出有关, 其内部也内置Buffer类来优化传入传出的效率.</p></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>先看源码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Buffer.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kCheapPrepend = <span class="hljs-number">8</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kInitialSize = <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Buffer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> initialSize = kInitialSize)</span></span><br><span class="hljs-function">        : _buffer(kCheapPrepend + initialSize), _readerIndex(kCheapPrepend), _writerIndex(kCheapPrepend)</span><br><span class="hljs-function">    &#123;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">readableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _writerIndex - _readerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">writableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">size</span>() - _writerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">prependableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _readerIndex; &#125;<br>    <span class="hljs-comment">// 返回缓冲区中可读区域的起始地址</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _readerIndex; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-built_in">readableBytes</span>())<br>            _readerIndex += len; <span class="hljs-comment">// 只读取了可读缓冲区的一部分</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">retrieveAll</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        _readerIndex = _writerIndex = kCheapPrepend; <span class="hljs-comment">// 全读了, 复位</span><br>    &#125;<br>    <span class="hljs-comment">// Buffer -&gt; string</span><br>    <span class="hljs-function">std::string <span class="hljs-title">retrieveAllAsString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">retrieveAsString</span>(<span class="hljs-built_in">readableBytes</span>()); &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">retrieveAsString</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::string <span class="hljs-title">res</span><span class="hljs-params">(peek(), len)</span></span>;<br>        <span class="hljs-built_in">retrieve</span>(len);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ensureWriteableBytes</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() &lt; len)<br>            <span class="hljs-built_in">makeSpace</span>(len);<br>    &#125;<br><br>    <span class="hljs-comment">// 向缓冲区中追加数据[data, data + len]</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">ensureWriteableBytes</span>(len);<br>        std::<span class="hljs-built_in">copy</span>(data, data + len, <span class="hljs-built_in">beginWrite</span>());<br>        _writerIndex += len;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">beginWrite</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _writerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">beginWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _writerIndex; &#125;<br><br>    <span class="hljs-comment">// 从fd上读取数据, Poller工作在LT模式</span><br>    <span class="hljs-comment">// Buffer缓冲区是有大小的, 但从fd上读数据时却不知道tcp数据最终的大小</span><br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">writeFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;*_buffer.<span class="hljs-built_in">begin</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;*_buffer.<span class="hljs-built_in">begin</span>(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSpace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 后面真正可写的 + 前面读出来空余的 &lt; 要求的大小</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() + _readerIndex &lt; len + kCheapPrepend)<br>            _buffer.<span class="hljs-built_in">resize</span>(_writerIndex + len);<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果够, 把后面未读的移到前面, 给后面空出来</span><br>        &#123;<br>            <span class="hljs-type">size_t</span> readable = <span class="hljs-built_in">readableBytes</span>();<br>            std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>() + _readerIndex, <span class="hljs-built_in">begin</span>() + _writerIndex, <span class="hljs-built_in">begin</span>() + kCheapPrepend);<br>            _readerIndex = kCheapPrepend;<br>            _writerIndex = kCheapPrepend + readable;<br>        &#125;<br>    &#125;<br><br>    std::vector&lt;<span class="hljs-type">char</span>&gt; _buffer;<br>    <span class="hljs-type">size_t</span> _readerIndex;<br>    <span class="hljs-type">size_t</span> _writerIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Buffer.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> extrabuf[<span class="hljs-number">65536</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 栈上的内存空间 64k</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> writable = <span class="hljs-built_in">writableBytes</span>();<br>    vec[<span class="hljs-number">0</span>].iov_base = <span class="hljs-built_in">begin</span>() + _writerIndex;<br>    vec[<span class="hljs-number">0</span>].iov_len = writable;<br>    vec[<span class="hljs-number">1</span>].iov_base = extrabuf;<br>    vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-keyword">sizeof</span> extrabuf;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> iovcnt = (writable &lt; <span class="hljs-keyword">sizeof</span> extrabuf) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 在非连续的区块中依次写入同一个fd传入的信息</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">ssize_t</span> n = ::<span class="hljs-built_in">readv</span>(fd, vec, iovcnt);<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        *saveErrno = errno;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= writable) <span class="hljs-comment">// 已经够了不需要扩容</span><br>    &#123;<br>        _writerIndex += n;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// extrabuf中也写入了数据, 需要扩容加进去</span><br>    &#123;<br>        _writerIndex = _buffer.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">append</span>(extrabuf, n - writable);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::writeFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = ::<span class="hljs-built_in">write</span>(fd, <span class="hljs-built_in">peek</span>(), <span class="hljs-built_in">readableBytes</span>());<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        *saveErrno = errno;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看成员变量 : </p><ul><li><p>_buffer : 用vector存储数据, 便于扩容.</p></li><li><p>_readerIndex &#x2F; _writerIndex : </p><p>这两个参数标定了可读区域和可写区域的大小. 想要理解这两个参数, 需要理解Buffer中对_buffer的划分 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">|&lt;---- prependable ----&gt;|&lt;---- readable ----&gt;|&lt;---- writable ----&gt;|<br>|-----------------------|--------------------|--------------------|<br>^                        ^                    ^                     <br><span class="hljs-built_in">begin</span>()           _readerIndex          _writerIndex         <br></code></pre></td></tr></table></figure><ul><li>prependable : 前置空余区域, 当我们发送消息时, 如果向要加一些报头之类的信息, 可以便于向其中填入, 在Muduo库中作用不大.</li><li>readable : 已经有数据存入的部分, 如果当前要读出, 则这部分是可读部分, 如果当前要写入, 则这部分是已填充完毕的区域.</li><li>writeable : 还没有数据的部分, 如果当前要读入, 则这部分是空余空间, 如果当前要写入, 则这部分是可以继续写入的部分.</li></ul><p>我们可以看出Buffer既可以处理read也可以处理write, 其对应的readable和writeable区域也有不同的作用. 在TcpConnection就封装了两个Buffer, _inputBuffer和 _outputBuffer, 共同处理了缓冲任务.</p></li></ul><p>再看成员函数 :</p><ul><li><p>readable&#x2F;writable&#x2F;prependableBytes : 返回对应区域的字节数大小.</p></li><li><p>begin : 返回_buffer的首元素地址.</p></li><li><p>peek :  返回缓冲区中可读区域的起始地址.</p></li><li><p>makespace :</p><p>扩容函数, 确保_buffer有参数len的大小使write成功, 如果可写的空间不够就扩容, 够用就经过调整把前面的空余和后面的空余合并一块放在后面.</p></li><li><p>retrieve &#x2F; retrieveAll :</p></li></ul><p>​这个函数一般会在下面的retrieveAsString中使用, 或是调用readfd&#x2F;writefd后使用, 用来进行两个Index的置位.</p><ul><li><p>retrieveAsString &#x2F; retrieveAllAsString : </p><p><strong>从_buffer中读出数据的函数</strong>, 这个函数会将可读区域中len长度的数据当作string读出来, 并在调用retrieve后返回, 通常被客户用来从Buffer中直接读出接收到的数据.</p></li><li><p>ensureWriteableBytes : 对makeSpace的调用.</p></li><li><p>append :</p><p><strong>从_buffer中追加数据的函数</strong>, 向缓冲区中追加数据[data, data + len], 空间不够时会调用ensureWriteableBytes.</p></li><li><p>readFd : </p><p>核心函数, 目的是<strong>高效从一个fd上读取传来的数据到 _buffer 中</strong>, 其高效在于使用到了readv函数, 这个函数不细讲, 不知道可以去查, 简单来说就是就是其实现了<strong>在非连续的区块中依次写入同一个fd传入的信息</strong>, 函数中划分了两块区域, 一块是 _buffer的可写区域, 一块是我们在栈上开辟的64K临时空间, readv可以实现先向可写区域中写, 可写区域写满了再读入我们开辟的临时空间, 读完后加入临时空间有读入, 我们再用append加进去就行, 这样实现了灵活应对读入不同大小的情况.</p></li><li><p>writeFd : </p><p>这个就比较简单了, 因为网络输出缓冲区就一个, 就不需要考虑writev的使用, 直接调用write从Buffer中将有数据的部分发送出去即可.</p></li></ul><h2 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h2><blockquote><p>专门用来维护每条与客户端的连接的类, 也就是对Acceptor中得到的connfd进行封装, 包括其对应的Socket和Channel类. 并且连接也代表了<strong>有连接的建立与断开, 数据的传入与传出等</strong>活动, 这些活动中, 一部分需要<strong>上级设置的回调函数</strong>来处理(例如连接建立断开, 数据传入, 都需要网络库调用者设置), 一部分需要TcpConnection<strong>利用自己手头的资源自行处理</strong>(例如数据传出, 需要调用自己的send函数). 既然与数据的传入传出有关, 其内部也内置Buffer类来优化传入传出的效率.</p></blockquote><p>通过上文我们的对TcpConnection的描述, 我们可以将其分为以下几个功能模块 : </p><ul><li>构造 &#x2F; 析构函数</li><li>TcpServer对TcpConnection设置连接建立回调, 断开回调, 消息回调等, 正式开启&#x2F;关闭连接.</li><li>TcpConnection对自己负责的connfd相关联的Channel类设置读&#x2F;写&#x2F;关闭&#x2F;错误回调.</li><li>用户发送信息所调用的send函数, 手动关闭连接所调用的shutdown函数.</li></ul><p>让我们先分析头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Callbacks.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span>;<br><br><span class="hljs-comment">// TcpServer -&gt; Acceptor -&gt; 新连接 -&gt; accept得到connfd -&gt; 打包回调到TcpConnection</span><br><span class="hljs-comment">// -&gt; 回调设置给Channel -&gt; Poller -&gt; Channel的回调操作</span><br><br><span class="hljs-comment">// 各种回调函数 : 用户 -&gt; TcpServer -&gt; TcpConnection -&gt; Channel</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpConnection</span> : UnCopyable, <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TcpConnection</span>(EventLoop *loop, <span class="hljs-type">const</span> std::string name, <span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;LocalAddr, <span class="hljs-type">const</span> InetAddress &amp;peerAddr);<br>    ~<span class="hljs-built_in">TcpConnection</span>();<br><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">getLoop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _loop; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> InetAddress &amp;<span class="hljs-title">localAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _localAddr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> InetAddress &amp;<span class="hljs-title">peerAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _peerAddr; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _state == kConnected; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; _connectionCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp;cb)</span> </span>&#123; _messageCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCompleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; _writeCompleteCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHighWaterMarkCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> HighWaterMarkCallback &amp;cb)</span> </span>&#123; _highWaterMarkCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> CloseCallback &amp;cb)</span> </span>&#123; _closeCallback = cb; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectEstablished</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 连接建立</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDestoryed</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 连接销毁</span><br><br>    <span class="hljs-comment">// 发送数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(std::string buf)</span></span>;<br>    <span class="hljs-comment">// 关闭Tcp连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleWrite</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleClose</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *message, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownInLoop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">StateE</span><br>    &#123;<br>        kDisconnected,<br>        kConnecting,<br>        kConnected,<br>        kDisconnecting<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(StateE state)</span> </span>&#123; _state = state; &#125;<br><br>    EventLoop *_loop; <span class="hljs-comment">// 这里只会是subLoop</span><br>    <span class="hljs-type">const</span> std::string _name;<br>    std::atomic_int _state;<br>    <span class="hljs-type">bool</span> _reading;<br>    <span class="hljs-comment">// 管理的_socket / _channel</span><br>    std::unique_ptr&lt;Socket&gt; _socket;<br>    std::unique_ptr&lt;Channel&gt; _channel;<br><br>    <span class="hljs-type">const</span> InetAddress _localAddr; <span class="hljs-comment">// 主机addr</span><br>    <span class="hljs-type">const</span> InetAddress _peerAddr;  <span class="hljs-comment">// 对端客户addr</span><br>    <span class="hljs-comment">// 回调</span><br>    ConnectionCallback _connectionCallback;<br>    MessageCallback _messageCallback;<br>    WriteCompleteCallback _writeCompleteCallback;<br>    HighWaterMarkCallback _highWaterMarkCallback;<br>    CloseCallback _closeCallback;<br>    <span class="hljs-type">size_t</span> _highWaterMark;<br>    <span class="hljs-comment">// 缓冲区</span><br>    Buffer _inputBuffer;<br>    Buffer _outputBuffer;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里先介绍一下公开继承enable_shared_from_this的作用 : </p><p>其可以让继承其的类的成员函数可以调用shared_from_this()函数, 作用是返回当前类对象的智能指针封装, 也就是把this指针包到智能指针中再传出来, 所以使用他的原因主要是TcpConnection对象可能随使销毁, 传出的this指针随时可能失效, 但如果我们本身传出的就是智能指针, 就可以有效防止提前销毁.</p><p>了解一下成员变量 : </p><ul><li>_loop : 这里保存自己所在subLoop的指针, 是为了将需要调用的函数加入到事件循环中.</li><li>_state : 用来记录一个连接的各种状态, 状态同一时间只能有一种, 所以是atomic类型.</li><li>_socket &#x2F; _channel : 将Acceptor接收到的connfd封装为Socket和Channel.</li><li>…Callback : 各种有关于连接的事件回调.</li><li>_inputBuffer &#x2F; _outputBuffer : 分别处理TcpConnection的消息接受和发送.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpConnection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 为什么用static可防止名字冲突</span><br><span class="hljs-function"><span class="hljs-type">static</span> EventLoop *<span class="hljs-title">CheckLoopNotNull</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (loop == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d mainLoop is null!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>TcpConnection::<span class="hljs-built_in">TcpConnection</span>(EventLoop *loop, <span class="hljs-type">const</span> std::string name, <span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;localAddr, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)<br>    : _loop(<span class="hljs-built_in">CheckLoopNotNull</span>(loop)), _name(name), _state(kConnecting), _reading(<span class="hljs-literal">true</span>), _socket(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Socket</span>(sockfd)), _channel(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Channel</span>(loop, sockfd)), _localAddr(localAddr), _peerAddr(peerAddr), _highWaterMark(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-comment">// 64MB</span><br>&#123;<br>    <span class="hljs-comment">// 把回调设置进channel, TcpConnection有一套自己的回调函数</span><br>    _channel-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br>    _channel-&gt;<span class="hljs-built_in">setWriteCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="hljs-keyword">this</span>));<br>    _channel-&gt;<span class="hljs-built_in">setCloseCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="hljs-keyword">this</span>));<br>    _channel-&gt;<span class="hljs-built_in">setErrorCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleError, <span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), sockfd);<br>    _socket-&gt;<span class="hljs-built_in">setKeepAlive</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br>TcpConnection::~<span class="hljs-built_in">TcpConnection</span>()<br>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Tcpconnection::dtor[%s] at fd=%d state=%d \n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), _channel-&gt;<span class="hljs-built_in">fd</span>(), (<span class="hljs-type">int</span>)_state);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ssize_t</span> n = _inputBuffer.<span class="hljs-built_in">readFd</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 有可读事件发生, 调用用户传入的回调操作</span><br>        _messageCallback(<span class="hljs-built_in">shared_from_this</span>(), &amp;_inputBuffer, receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        errno = savedErrno;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleRead&quot;</span>);<br>        <span class="hljs-built_in">handleError</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleWrite</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_channel-&gt;<span class="hljs-built_in">isWriting</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ssize_t</span> n = _outputBuffer.<span class="hljs-built_in">writeFd</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            _outputBuffer.<span class="hljs-built_in">retrieve</span>(n);<br>            <span class="hljs-keyword">if</span> (_outputBuffer.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 已经发送完成</span><br>            &#123;<br>                _channel-&gt;<span class="hljs-built_in">disableWriting</span>();<br>                <span class="hljs-keyword">if</span> (_writeCompleteCallback)<br>                &#123;<br>                    _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_writeCompleteCallback, <span class="hljs-built_in">shared_from_this</span>()));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (_state == kDisconnecting)<br>                &#123;<br>                    <span class="hljs-built_in">shutdownInLoop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleWrite&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection fd=%d is down, no more writing&quot;</span>, _channel-&gt;<span class="hljs-built_in">fd</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;fd=%d state=%d \n&quot;</span>, _channel-&gt;<span class="hljs-built_in">fd</span>(), (<span class="hljs-type">int</span>)_state);<br>    <span class="hljs-built_in">setState</span>(kDisconnected);<br>    _channel-&gt;<span class="hljs-built_in">disableAll</span>();<br><br>    <span class="hljs-comment">// 获取当前的Connention对象</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">connPtr</span><span class="hljs-params">(shared_from_this())</span></span>;<br>    _connectionCallback(connPtr);<br>    _closeCallback(connPtr); <span class="hljs-comment">// 关闭连接, 执行TcpServer::removeConnection</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleError</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-type">socklen_t</span> optlen = <span class="hljs-keyword">sizeof</span> op;<br>    <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockopt</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), SOL_SOCKET, SO_ERROR, &amp;op, &amp;optlen) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        err = errno;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        err = op;<br><br>    <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleErrno name:%s - SO_ERROR:%d \n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), err);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectEstablished</span><span class="hljs-params">()</span> <span class="hljs-comment">// 连接建立</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">setState</span>(kConnected);<br>    <span class="hljs-comment">// 把自己的指针传给负责的channel, 让其知晓自己的存在状态</span><br>    <span class="hljs-comment">// 防止上层TcpConnection析构后下层channel依旧运行</span><br>    <span class="hljs-comment">// 根本原因是TcpConnection要给到用户手里, 不确定何时析构</span><br>    _channel-&gt;<span class="hljs-built_in">tie</span>(<span class="hljs-built_in">shared_from_this</span>());<br>    _channel-&gt;<span class="hljs-built_in">enableReading</span>(); <span class="hljs-comment">// 注册Channel读事件</span><br><br>    <span class="hljs-comment">// 新连接已经建立, 执行连接建立回调</span><br>    _connectionCallback(<span class="hljs-built_in">shared_from_this</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectDestoryed</span><span class="hljs-params">()</span> <span class="hljs-comment">// 连接销毁</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnected);<br>        _channel-&gt;<span class="hljs-built_in">disableAll</span>();<br>        _connectionCallback(<span class="hljs-built_in">shared_from_this</span>());<br>    &#125;<br>    _channel-&gt;<span class="hljs-built_in">remove</span>();<br>&#125;<br><br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_loop-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123;<br>            <span class="hljs-built_in">sendInLoop</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _loop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::sendInLoop, <span class="hljs-keyword">this</span>, buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">size</span>()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发送数据时, 应用写的快, 而内核发送数据慢, 需要把待发送的数据写入缓冲区并设置水位回调</span><br><span class="hljs-comment">// 该函数实现对写事件的缓冲</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">ssize_t</span> nwrite = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> remaining = len;<br>    <span class="hljs-type">bool</span> faultError = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 之前调用过shutdown</span><br>    <span class="hljs-keyword">if</span> (_state == kDisconnected)<br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;disconnected, give up writing!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// _channel第一次开始写数据, 并且缓冲区没有待发送数据</span><br>    <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>() &amp;&amp; _outputBuffer.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        nwrite = ::<span class="hljs-built_in">write</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), data, len);<br>        <span class="hljs-keyword">if</span> (nwrite &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            remaining = len - nwrite;<br>            <span class="hljs-comment">// 如果已经直接发送完了, 不需要缓冲, 如果有设置写入完成回调就触发</span><br>            <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span> &amp;&amp; _writeCompleteCallback)<br>                _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_writeCompleteCallback, <span class="hljs-built_in">shared_from_this</span>()));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// nwrote &lt; 0</span><br>        &#123;<br>            nwrite = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK)<br>            &#123;<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::sendInLoop&quot;</span>);<br>                <span class="hljs-keyword">if</span> (errno == EPIPE || errno == ECONNRESET)<br>                    faultError = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 一次write并没有一次发送出去, 需要保存到缓冲区</span><br>    <span class="hljs-comment">// 要给channel设置epollout事件, poller发现tcp发送缓冲区有空间</span><br>    <span class="hljs-comment">// 调用writeCallback -&gt; handleWrite, 把发送缓冲区的数据全部发送完成</span><br>    <span class="hljs-keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 目前发送缓冲区剩余的待发送数据长度</span><br>        <span class="hljs-type">size_t</span> oldlen = _outputBuffer.<span class="hljs-built_in">readableBytes</span>();<br>        <span class="hljs-keyword">if</span> (oldlen + remaining &gt;= _highWaterMark &amp;&amp; oldlen &lt; _highWaterMark &amp;&amp; _highWaterMark)<br>            _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_highWaterMarkCallback, <span class="hljs-built_in">shared_from_this</span>(), oldlen + remaining));<br>        _outputBuffer.<span class="hljs-built_in">append</span>((<span class="hljs-type">char</span> *)data + nwrite, remaining);<br>        <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>())<br>        &#123;<br>            _channel-&gt;<span class="hljs-built_in">enableWriting</span>(); <span class="hljs-comment">// 注册channel的写事件, 否则poller不会给channel通知EPOLLOUT,</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 关闭Tcp连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        _loop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="hljs-keyword">this</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdownInLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>()) <span class="hljs-comment">// 说明发送缓冲区已经全部发送完成</span><br>    &#123;<br>        _socket-&gt;<span class="hljs-built_in">shutdownWrite</span>(); <span class="hljs-comment">// 关闭写端</span><br>        <span class="hljs-comment">// 之后poller会通知channel触发_closeCallback, 会触发TcpConnection中的handleClose</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配合源文件来分析成员函数 : </p><ul><li><p>构造函数 :</p><p>掌握一个不为空的loop指针, 利用传进的connfd构造_socket和 _channel. 随后设置 _channel的读写关闭错误回调, 就像Acceptor对 listensocketfd 设置读事件回调一样, 普通连接connfd四种事件都要关注, 所以我们四种事件都设置回调, 而回调函数分别是下面的handleRead&#x2F;Write&#x2F;Colse&#x2F;Error.</p></li><li><p>handleRead :</p><p>当connfd的读事件触发时, 会触发该函数, 向 _inputBuffer中读入数据, 然后调用TcpServer设置的消息回调函数, 这个回调函数中一般会调用retrieveAsString从 _inputBuffer中读出数据然后进行客户希望的处理.</p></li><li><p>handleWrite : </p><p>当connfd的读事件触发时, 说明对端可写, 从_outputBuffer中读出所有或部分向对端写入, 如果全写了, 就取消对 _channel的写事件关心然后调用写完回调(如果有的话); 如果没写完就不做处理.</p></li><li><p>handleClose :</p><p>当我们关闭connfd的写端时, 就会默认触发EPOLLHUP事件, 进而调用该函数, 取消_channel对所有事件的关心, 然后调用连接建立&#x2F;断开回调.</p></li><li><p>connectEstablished : </p><p>这个函数用来开启_channel读事件的关注, 也就是说在这之后就可以读connfd上传来的信息了. 至于为什么单独分出一个函数处理, 原因是在TcpConntion对象在TcpServer中创建后不能直接开启读事件, 还要进行回调函数的设置和数据处理, 在这些准备工作都做完后才可以真正开启读事件.</p></li><li><p>connectDestoryed : </p><p>这个函数用于在最后销毁连接并移除_channel, 属于销毁链路的最后一环, 由TcpServer在合适时机调用, 我们可以在后面的shutdownInLoop中有更深的认识.</p></li><li><p>send : </p><p>这个函数是提供给用户调用的, 所以调用时不一定在当前线程, 所以需要判断是否换线程.</p></li><li><p>sendInLoop : </p><p>前面handleWrite函数是在写事件触发时从_outputBuffer中读取数据, 那么这个函数就是直接发送或将要发送的数据写入 _outputBuffer.</p><p>首先如果_channel第一次开始写数据, 并且缓冲区没有待发送数据, 就直接先写一部分, 最后如果还是没写完, 说明对端接收缓冲区已经满了, 就追加到 _outputBuffer中, 再关注读事件, 那么当对端接收缓冲区可写时就会调用handleWrite从 _outputBuffer中读取数据.</p></li><li><p>shutdown : </p><p>这个函数也是提供给用户调用的, 需要判断换线程.</p></li><li><p>shutdownInLoop : </p><p>这里操作很简单, 关闭connfd写端就行, 主要是了解其中的连锁反应 : </p><p>关闭写端 -&gt; 触发EPOLLHUP -&gt; _channel调用handleClose -&gt; handleClose调用TcpServer设置的回调函数 -&gt; TcpServer设置的回调函数再调用TcpConnection中的connectDestoryed.</p><p>这样一看这个过程非常繁琐, 其主要是为了让TcpServer可以及时对关闭的连接进行反应并修改内部资源.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(4) Acceptor</title>
    <link href="/2025/04/17/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(4)%20Acceptor/"/>
    <url>/2025/04/17/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(4)%20Acceptor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Socket + Acceptor 详解</p></blockquote><p>本章我们将学习Socket类和Acceptor类, 首先应当明确其在Muduo库中的职责所在 : </p><ul><li><p>Socket就是对原生socketAPI的封装, 供Acceptor使用. </p></li><li><p>Acceptor简单来说是用来处理新连接的建立的. 我们来认识一下Acceptor的调用流程</p><p>TcpServer中会维护一个Acceptor作为成员变量, 由TcpServer向Acceptor设置建立新连接的回调函数, Acceptor则内含一个Socket和一个Channel, 其利用Socket维护listensocketfd, 控制listen的时机, 也利用Channel让Poller帮自己监听listensocketfd上的读事件, 设置的读事件回调就会调用accept获取新连接的connfd, 然后利用得到的connfd去调用TcpServer传入的回调函数, 让TcpServer帮自己处理新连接事务.</p></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Socket.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span> : _sockfd(sockfd) &#123;</span>&#125;<br>    ~<span class="hljs-built_in">Socket</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sockfd; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress &amp;localaddr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(InetAddress *peeraddr)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> _sockfd;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Socket.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><br>Socket::~<span class="hljs-built_in">Socket</span>()<br>&#123;<br>    ::<span class="hljs-built_in">close</span>(_sockfd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress &amp;localaddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ::<span class="hljs-built_in">bind</span>(_sockfd, (sockaddr *)localaddr.<span class="hljs-built_in">getSockAddr</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_in)))<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;bind sockfd:%d fail \n&quot;</span>, _sockfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::listen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ::<span class="hljs-built_in">listen</span>(_sockfd, <span class="hljs-number">1024</span>))<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;listen sockfd:%d fail \n&quot;</span>, _sockfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket::accept</span><span class="hljs-params">(InetAddress *peeraddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;addr, <span class="hljs-keyword">sizeof</span> addr);<br>    <span class="hljs-function"><span class="hljs-type">socklen_t</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span> addr)</span></span>;<br>    <span class="hljs-comment">// accept4可以直接给接受到的sockfd设置选项(非阻塞)</span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept4</span>(_sockfd, (sockaddr *)&amp;addr, &amp;len, SOCK_CLOEXEC | SOCK_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        peeraddr-&gt;<span class="hljs-built_in">setSockAddr</span>(addr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> connfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::shutdownWrite</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">shutdown</span>(_sockfd, SHUT_WR);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br></code></pre></td></tr></table></figure><p>外部通过socket函数将listensocketfd传入Socket, 将其维护在Socket内, 便于简便的调用bind &#x2F; listen &#x2F; accept.</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> NewConnectionCallback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;)&gt;;<br><br>    <span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport);<br>    ~<span class="hljs-built_in">Acceptor</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNewConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123; _newConnectionCallback = <span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listenning</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _listenning; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;<br><br>    EventLoop *_loop;<span class="hljs-comment">// 用来标注这个Acceptor属于的mainLoop</span><br>    Socket _acceptSocket;<span class="hljs-comment">// 存储listensocketfd</span><br>    Channel _acceptChannel;<span class="hljs-comment">// 对listensocketfd进行封装的Channel, 便于注册读事件</span><br>    NewConnectionCallback _newConnectionCallback;<span class="hljs-comment">// TcpServer给其设置的新连接回调函数</span><br>    <span class="hljs-type">bool</span> _listenning;<span class="hljs-comment">// 是否正在监听</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Accept.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">createNonblocking</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d listen socket create error:%d&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-comment">// 创建socket, 封装进Channel, 往当前loop的poller中添加</span><br>Acceptor::<span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport)<br>    : _loop(loop), _acceptSocket(()), _acceptChannel(loop, _acceptSocket.<span class="hljs-built_in">fd</span>()), _listenning(<span class="hljs-literal">false</span>)<br>&#123;<br>    _acceptSocket.<span class="hljs-built_in">setReuseAddr</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (reuseport)<br>        _acceptSocket.<span class="hljs-built_in">setReusePort</span>(<span class="hljs-literal">true</span>);<br>    _acceptSocket.<span class="hljs-built_in">bindAddress</span>(listenAddr);<br><br>    <span class="hljs-comment">// 一旦有一个新用户的连接, 就需要执行回调, connfd -&gt; channel -&gt; subloop</span><br>    <span class="hljs-comment">// 具体回调由TcpServer给出</span><br>    _acceptChannel.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::handleRead, <span class="hljs-keyword">this</span>));<br>&#125;<br>Acceptor::~<span class="hljs-built_in">Acceptor</span>()<br>&#123;<br>    _acceptChannel.<span class="hljs-built_in">disableAll</span>();<br>    _acceptChannel.<span class="hljs-built_in">remove</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::listen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _listenning = <span class="hljs-literal">true</span>;<br>    _acceptSocket.<span class="hljs-built_in">listen</span>();<br>    _acceptChannel.<span class="hljs-built_in">enableReading</span>(); <span class="hljs-comment">// 把acceptChannel注册到poller中监听读事件</span><br>&#125;<br><br><span class="hljs-comment">// 在listenfd读事件触发时调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    InetAddress peerAddr;<br>    <span class="hljs-type">int</span> connfd = _acceptSocket.<span class="hljs-built_in">accept</span>(&amp;peerAddr);<br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 在TcpServer中具体是轮询找到subLoop, 唤醒该loop, 将该sockfd分发到其中</span><br>        <span class="hljs-keyword">if</span> (_newConnectionCallback)<br>            _newConnectionCallback(connfd, peerAddr);<br>        <span class="hljs-keyword">else</span><br>            ::<span class="hljs-built_in">close</span>(connfd);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:%s:%d accept error:%d&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);<br>        <span class="hljs-keyword">if</span> (errno == EMFILE)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:%s:%d sockfd reached limit!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>createNonblocking : 我们可以看到这个函数在Accept构造函数中被调用, 也就是说在Acceptor构造时会调用该函数构造一个非阻塞的listensocketfd.</li><li>构造函数 : 首先是调用createNonblocking构造出listensocketfd存入Socket, 随后将listensocketfd封装进Channel, 接下来设置Socket中fd的各种属性并bind, 最后将handleRead读事件回调注册进Channel.</li><li>listen : 该函数控制何时开始监听listensocketfd并注册读事件, 一般由上层TcpServer控制.</li><li>handleRead : listensocketfd封装的Channel将被放到mainLoop的Poller中监听读事件, 而触发的回调就是该函数, handleRead将调用accept获取新连接的connfd, 随后将其传给TcpServer设置的回调函数.</li></ul><p>为什么要调用TcpServer的新连接回调呢? 因为Acceptor的职责仅仅在于构造listensocketfd和对新连接及时做出反应并报告给TcpServer, TcpServer才是真正处理新连接的核心, 其拥有的资源远超过Acceptor(例如线程池), 有了这些资源才能真正处理新连接.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(3) ThreadPool</title>
    <link href="/2025/04/16/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(3)%20ThreadPool/"/>
    <url>/2025/04/16/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(3)%20ThreadPool/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ThreadPool相关</p></blockquote><p>本章我们将把EventLoop和C++11的thread结合, 实现Thread &#x2F; EventLoopThread &#x2F; EventLoopThreadPool. </p><p>首先我们应当明晰将创建的三个类的意义何在 : </p><ul><li><p>Thread : 这是对thread库的封装, 会增加对各种线程运行状态与数据的维护.</p></li><li><p>EventLoopThread :</p><p>将Thread和EventLoop组合, 真正实现 <strong>one loop per thread</strong> 思想的地方, 最终达成的效果就是创建一个线程并在线程中创建一个loop并运行该loop.</p></li><li><p>EventLoopThreadPool : </p><p>学到这里线程池的作用应该都知道, 就是提前创建线程以减少运行开销, 这里就是开一个池填充EventLoopThread, 我们最后的TcpServer中就会维护这样一个线程池存放subLoop.</p></li></ul><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>对C++11的thread库封装 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 一个Thread对象记录的就是一个新线程的详细信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadFunc = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> std::string &amp;name = std::string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _tid; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">bool</span> _joined;<br>    std::shared_ptr&lt;std::thread&gt; _thread;<br>    <span class="hljs-type">pid_t</span> _tid;<br>    ThreadFunc _func;<br>    std::string _name;<br>    <span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated; <span class="hljs-comment">// 记录产生的线程个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br>std::atomic_int Thread::_numCreated(<span class="hljs-number">0</span>);<br><br>Thread::<span class="hljs-built_in">Thread</span>(ThreadFunc func, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _started(<span class="hljs-literal">false</span>), _joined(<span class="hljs-literal">false</span>), _tid(<span class="hljs-number">0</span>), _func(std::<span class="hljs-built_in">move</span>(func)), _name(name)<br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br>Thread::~<span class="hljs-built_in">Thread</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_started &amp;&amp; !_joined)<br>        _thread-&gt;<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">sem_t</span> sem;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>    _thread = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;([<span class="hljs-keyword">this</span>, &amp;sem]()&#123;<br>        _tid = CurrentThread::<span class="hljs-built_in">tid</span>();<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<br>        _func(); <br>    &#125;);<br>    <span class="hljs-comment">// 确保子线程tid已经确定</span><br>    <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _joined = <span class="hljs-literal">true</span>;<br>    _thread-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = ++_numCreated;<br>    <span class="hljs-keyword">if</span> (_name.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        _name = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行封装的主要目的除了进行信息记录之外, 就是可以<strong>控制创建线程的时机</strong>. 对于C++11thread库中的thread类来说, 只要创建出对象就代表了线程开启, 这样就没有进行初始化准备的时间了, 我们在封装中用智能指针维护thread类, 在start中才真正传入回调函数并创建thread对象开启线程.</p><p>这里还需要注意的一点就是为了在Thread对象中维护线程的tid, 需要使用条件变量进行线程间通信, 以获取到创建线程的tid并存储在Thread对象中.</p><p>这里补充一下CurrentThread类, 其可以获取当前线程的tid, 在上一章的EventLoop中也有使用过, 用来判断是不是当前进程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CurrentThread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">namespace</span> CurrentThread<br>&#123;<br>    <span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_cachedTid;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cacheTid</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(t_cachedTid == <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            <span class="hljs-built_in">cacheTid</span>();<br>        <span class="hljs-keyword">return</span> t_cachedTid;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// CurrentThread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> CurrentThread<br>&#123;<br>    __thread <span class="hljs-type">int</span> t_cachedTid = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cacheTid</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (t_cachedTid == <span class="hljs-number">0</span>)<br>        &#123;<br>            t_cachedTid = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">pid_t</span>&gt;(::<span class="hljs-built_in">syscall</span>(SYS_gettid));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h2><p>EventLoopThread类内部提供了线程函数来实现构建一个EventLoop并运行的效果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopThread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br>    <span class="hljs-built_in">EventLoopThread</span>(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb = <span class="hljs-built_in">ThreadInitCallback</span>(),<br>                    <span class="hljs-type">const</span> std::string &amp;name = std::<span class="hljs-built_in">string</span>());<br>    ~<span class="hljs-built_in">EventLoopThread</span>();<br><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">startLoop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span>;<br><br>    EventLoop *_loop;<span class="hljs-comment">// 记录Thread中创建出来的唯一的loop的指针</span><br>    <span class="hljs-type">bool</span> _exiting;<br>    Thread _thread;<br>    std::mutex _mutex;<br>    std::condition_variable _cond;<br>    ThreadInitCallback _cb;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br>EventLoopThread::<span class="hljs-built_in">EventLoopThread</span>(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb,<br>                                 <span class="hljs-type">const</span> std::string &amp;name)<br>    : _loop(<span class="hljs-literal">nullptr</span>)<br>    , _exiting(<span class="hljs-literal">false</span>)<br>    , _thread(std::<span class="hljs-built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="hljs-keyword">this</span>), name)<br>    , _mutex()<br>    , _cond()<br>    , _cb(cb)<br>&#123;&#125;<br><br>EventLoopThread::~<span class="hljs-built_in">EventLoopThread</span>()<br>&#123;<br>    _exiting = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (_loop != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        _loop-&gt;<span class="hljs-built_in">quit</span>();<br>        _thread.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取一个新线程中单独运行的EventLoop对象指针</span><br><span class="hljs-comment">// 利用条件变量 + 共享内存实现了线程间通信</span><br><span class="hljs-function">EventLoop *<span class="hljs-title">EventLoopThread::startLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _thread.<span class="hljs-built_in">start</span>();<br><br>    EventLoop *loop = <span class="hljs-literal">nullptr</span>;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <span class="hljs-keyword">while</span> (_loop == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _cond.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        loop = _loop;<br>    &#125;<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br><span class="hljs-comment">// 在单独的新线程里面运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoopThread::threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// one loop per thread</span><br>    EventLoop loop;<br>    <span class="hljs-keyword">if</span> (_cb) _cb(&amp;loop);<br><br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        _loop = &amp;loop;<br>        _cond.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    loop.<span class="hljs-built_in">loop</span>();<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    _loop = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>threadFunc :</p><p>该函数是Muduo库的核心函数, 是每个线程中将要执行的代码, 里面有很多需要学习的设计 : </p><ul><li><p><code>EventLoop loop;</code>  </p><p>我们知道线程的栈空间是独立的, 这里就是直接在栈上开辟了这个loop, 使得这个loop和当前线程强绑定, 线程结束该loop也会析构, 遵循了 one loop per thread 的理念.</p></li><li><p><code>if (_cb) _cb(&amp;loop);</code> </p><p>_cb的类型是<code>ThreadInitCallback</code>, 其并不是必要的, 只是如果有在线程刚建立时的初始化需求的话, 可以在构造函数中传入想执行的初始化操作.</p></li><li><p>接下来的代码中, 线程将在栈上构造出的loop的指针存储到_loop中, 这里使用条件变量进行线程通信, 主线程就可以知道它所开辟的新线程上loop的指针何在了.</p></li><li><p><code>loop.loop();</code></p><p>这里直接调用loop开启事件循环.</p></li><li><p><code>, _thread(std::bind(&amp;EventLoopThread::threadFunc, this), name)</code></p><p>还需要注意的一点是这个函数会在构造函数构造_thread时绑定到 _thread中, 在startLoop中被触发.</p></li></ul></li></ul><p>我们来梳理一遍EventLoopThread的使用流程 :</p><p>已知其上层还有EventLoopThreadPool会存入很多EventLoopThread, 并且其内部也会记录每个EventLoopThread中loop的指针, 那么实际调用流程就是 : </p><ul><li><p>EventLoopThreadPool创建EventLoopThread对象.</p></li><li><p>调用startLoop函数, 创建线程并执行threadFunc.</p></li><li><p>threadFunc中, 在栈上构造loop并将_loop修改, 用条件变量唤醒startLoop.</p></li><li><p>startLoop将获取到的_loop作为返回值传出.</p></li></ul><p>而这个返回值将被存入EventLoopThreadPool的_loops中.</p><h2 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h2><p>EventLoopThreadPool会构建多个EventLoopThread并储存, 而在Muduo库中是通过轮询的方式实现subLoopd的选择的, 也就是说这个线程池内部提供了轮询方法将loop指针提供出去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopThreadPool</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br><br>    <span class="hljs-built_in">EventLoopThreadPool</span>(EventLoop *mainloop, <span class="hljs-type">const</span> std::string &amp;name);<br>    ~<span class="hljs-built_in">EventLoopThreadPool</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadNum</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span> </span>&#123; _numThreads = numThreads; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span></span>;<br><br>    <span class="hljs-comment">// 如果工作在多线程中, ThreadPool以轮循的方式分配subloop</span><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">getNextLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::vector&lt;EventLoop *&gt; <span class="hljs-title">getAllLoops</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    EventLoop *_mainLoop;<br>    std::string _name;<br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">int</span> _numThreads;<br>    <span class="hljs-type">int</span> _next;<br>    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; _threads;<br>    std::vector&lt;EventLoop *&gt; _loops;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先来介绍一下成员变量 : </p><ul><li>_mainLoop : 这就是主线程构建的loop, 也就是我们作为用户一开始向TcpServer手动传入的loop的指针, 在EventLoopThreadPool中其存在价值在于当线程池中创建线程数为0时, 作为替补方案用来执行subLoop的工作.</li><li>_numThreads : 我们可以通过setThreadNum来设置线程池中需要有多少个线程, 也就是有多少个subLoop.</li><li>_threads : 存储线程对象的vector.</li><li>_loops : 存储每个线程中构建的loop指针.</li><li>_next : 记录当前轮询到 _loop中的哪一个.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br>EventLoopThreadPool::<span class="hljs-built_in">EventLoopThreadPool</span>(EventLoop *mainloop, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _mainLoop(mainloop), _name(name), _started(<span class="hljs-literal">false</span>), _numThreads(<span class="hljs-number">0</span>), _next(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>EventLoopThreadPool::~<span class="hljs-built_in">EventLoopThreadPool</span>()<br>&#123;<br>    <span class="hljs-comment">// 线程上绑定的对象都是栈上的的对象, 无需关心析构</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoopThreadPool::start</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _numThreads; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[_name.<span class="hljs-built_in">size</span>() + <span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;%s%d&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), i);<br>        EventLoopThread *t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThread</span>(cb, buf);<br>        _threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));<br>        _loops.<span class="hljs-built_in">push_back</span>(t-&gt;<span class="hljs-built_in">startLoop</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 整个服务端只有一个线程, 让mainloop来运行</span><br>    <span class="hljs-keyword">if</span> (_numThreads == <span class="hljs-number">0</span> &amp;&amp; cb)<br>    &#123;<br>        <span class="hljs-built_in">cb</span>(_mainLoop);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果工作在多线程中, mainLoop以轮询的方式分配channel给subloop</span><br>EventLoop *EventLoopThreadPool::EventLoopThreadPool::<span class="hljs-built_in">getNextLoop</span>()<br>&#123;<br>    EventLoop *loop = _mainLoop;<br><br>    <span class="hljs-comment">// 轮询</span><br>    <span class="hljs-keyword">if</span> (!_loops.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        loop = _loops[_next];<br>        ++_next;<br>        <span class="hljs-keyword">if</span> (_next &gt;= _loops.<span class="hljs-built_in">size</span>())<br>            _next = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>std::vector&lt;EventLoop *&gt; EventLoopThreadPool::EventLoopThreadPool::<span class="hljs-built_in">getAllLoops</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_loops.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;EventLoop *&gt;(<span class="hljs-number">1</span>, _mainLoop);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> _loops;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共有两个重要的函数要解释 : </p><ul><li><p>start : </p><p>可以见得其依据_numThreads的数目构建EventLoopThread, 将创建出的对象存入 _threads, 然后再调用该对象的startLoop方法, 开启线程中的事件循环, 将其返回的loop指针存入 _loops.</p></li><li><p>getNextLoop : </p><p>这个函数将供给上层TcpServer调用, 以轮询方式提供出一个subLoop的指针, TcpServer则会将利用runInLoop将任务发配到该subLoop上, 当然如果一个subLoop都没有, 就还由mainLoop执行这些任务.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(2) EventLoop</title>
    <link href="/2025/04/15/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(2)%20EventLoop/"/>
    <url>/2025/04/15/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(2)%20EventLoop/</url>
    
    <content type="html"><![CDATA[<blockquote><p>EventLoop 详解</p></blockquote><p>EventLoop类似于Reactor模型中的<strong>反应堆</strong>(Reactor)和<strong>事件分发器</strong>(Demultiplex)的合并, 其目的在于高效的接收事件, 并正确分配给对应的事件处理器.</p><p>EventLoop中有两类关键的子控件 : <strong>Channel 和 Poller</strong>.</p><ul><li><p>Channel 即通道, 其负责对单个文件描述符的事件管理, 存储该文件描述符感兴趣的事件与对应回调函数, 该类与EventLoop类联通, EventLoop会将从Poller中得到的发生的事件传给Channel, Channel再调用对应的回调.</p></li><li><p>Poller 即轮询器或检测器, 其负责IO复用函数(poll &#x2F; epoll)的调用, 将从epoll上检测到的事件发生传递给Channel和EventLoop, 如果选用epoll, 其内部会封装epoll系列函数.</p></li><li><p>EventLoop 即一个事件循环, 其内部维护了一个事件循环要关心和处理的所有信息.</p><ul><li>一个EventLoop包含多个Channel, 维护多个文件描述符的资源.</li><li>一个EventLoop包含一个Poller, 使用该轮循器执行核心的IO复用函数.</li><li>EventLoop负责管理事件循环的开始, 结束, 线程管理与Channel和Poller之间的互动.</li></ul></li></ul><hr><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>可以先通过头文件来了解其功能 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><br><span class="hljs-comment">// 通道, 封装了sockfd和其感兴趣的event, 如EPOLLIN, EPOLLOUT</span><br><span class="hljs-comment">// 需要和Poller互动, Channel向Poller设置感兴趣的事件, Poller向Channel返回发生的事件</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> EventCallback = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br>    <span class="hljs-keyword">using</span> ReadEventCallback = std::function&lt;<span class="hljs-built_in">void</span>(Timestamp)&gt;;<br><br>    <span class="hljs-built_in">Channel</span>(EventLoop *Loop, <span class="hljs-type">int</span> fd);<br>    ~<span class="hljs-built_in">Channel</span>();<br><br>    <span class="hljs-comment">// fd得到poller通知以后, 处理事件的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-comment">// 这个函数暂不解释</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; &amp;)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _fd; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">events</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events; &#125;<br>    <span class="hljs-comment">// Channel本身无法取得发生的事件, 是Poller取得发生的事件设置到Channel中的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_revents</span><span class="hljs-params">(<span class="hljs-type">int</span> revt)</span> </span>&#123; _revents = revt; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNoneEvent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events == kNoneEvent; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isWriting</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events &amp; kWriteEvent; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isReading</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events &amp; kReadEvent; &#125;<br>    <br>    <span class="hljs-comment">// 设置回调函数对象</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadCallback</span><span class="hljs-params">(ReadEventCallback cb)</span> </span>&#123; _readCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _writeCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _closeCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setErrorCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _errorCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-comment">// 设置fd相应的事件状态</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableReading</span><span class="hljs-params">()</span> </span>&#123; _events |= kReadEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableReading</span><span class="hljs-params">()</span> </span>&#123; _events &amp;= ~kReadEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableWriting</span><span class="hljs-params">()</span> </span>&#123; _events |= kWriteEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableWriting</span><span class="hljs-params">()</span> </span>&#123; _events &amp;= ~kWriteEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableAll</span><span class="hljs-params">()</span> </span>&#123; _events = kNoneEvent, <span class="hljs-built_in">update</span>(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">state</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _state; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_state</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123; _state = idx; &#125;<br><br>    <span class="hljs-comment">// 每个Channel都属于一个EventPool, EventPool可以有多个Channel</span><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">ownerLoop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _loop; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-comment">// 表示当前fd的状态</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNoneEvent;  <span class="hljs-comment">// 没有对任何事件感兴趣</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kReadEvent;  <span class="hljs-comment">// 对读事件感兴趣</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kWriteEvent; <span class="hljs-comment">// 对写事件感兴趣</span><br><br>    EventLoop *_loop; <span class="hljs-comment">// 事件循环</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> _fd;    <span class="hljs-comment">// 监听对象</span><br>    <span class="hljs-type">int</span> _events;      <span class="hljs-comment">// 注册fd感兴趣的事件</span><br>    <span class="hljs-type">int</span> _revents;     <span class="hljs-comment">// fd上发生的事件</span><br>    <span class="hljs-type">int</span> _state;<br><br>    <span class="hljs-comment">// 防止回调函数在 Channel 所绑定的对象已析构的情况下仍然被调用</span><br>    std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; _tie;<br>    <span class="hljs-type">bool</span> _tied;<br><br>    <span class="hljs-comment">// 因为channel通道里可以获知fd发生的具体事件, 所以其负责调用具体的事件回调</span><br>    ReadEventCallback _readCallback;<br>    EventCallback _writeCallback;<br>    EventCallback _closeCallback;<br>    EventCallback _errorCallback;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先从成员变量分析 : </p><ul><li><p>_loop : 维护一个loop指针便于通过EventLoop与Poller互动.</p></li><li><p>_fd &#x2F; _events &#x2F; _revents : 维护的文件描述符, 其上关心的事件, 通过Poller获知的真正发生的事件.</p></li><li><p>_state : 这个变量用于表示与Poller互动的状态, 因为Poller中要存储Channel*, 可以通过该变量判断将要采取的行为, 现在不理解也没关系, 后面会见到.</p></li><li><p>各种Callback : Channel会持有各种事件处理的回调函数.</p></li><li><p>_tie &#x2F; _tied : 防止回调函数在 Channel 所绑定的对象已析构的情况下仍然被调用, 这样看可能比较抽象, 在后文配合cpp文件理解.</p></li></ul><p>再看成员函数 ： </p><ul><li>set_revents : 当Poller监听到有事件发生时, 会先触发该函数给对应Channel设置revents, 可以让之后触发的handleEvent知道要处理哪些事件.</li><li>handleEvent : 当Poller监听到有事件发生时, 会通知EventLoop, EventLoop会调用对应Channel的该函数以执行回调函数.</li></ul><p>set_revents 供 Poller 调用, 因为Poller是轮询器, 它的作用是检测状态, 职责是把检测到的状态传递给目标类, 其内部不做任何其他操作. handleEvent 供 EventLoop 调用, 因为其负责事件的分发与调配, 触发回调函数是其的职责, 因此Poller检测到事件发生应当将其提供给EventLoop, 让EventLoop判断是否调用回调函数. 这涉及到职责分配和设计哲学.</p><ul><li>setXXXCallback系列函数 : 提供给EventLoop用来从外部传入各种事件回调函数的事件.</li><li>eable &#x2F; disable 系列函数 : 确定当前Channel中fd真正关心的事件, 当前不关心的事件就算被设置了也不会被触发.</li></ul><p>接下来给出cpp文件, 之后再继续深入解释一些细节 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kNoneEvent = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kWriteEvent = EPOLLOUT;<br><br>Channel::<span class="hljs-built_in">Channel</span>(EventLoop *Loop, <span class="hljs-type">int</span> fd)<br>    : _loop(Loop), _fd(fd), _events(<span class="hljs-number">0</span>), _revents(<span class="hljs-number">0</span>), _state(<span class="hljs-number">-1</span>), _tied(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;<br><br>Channel::~<span class="hljs-built_in">Channel</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; &amp;obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    _tie = obj;<br>    _tied = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过channel所属的EventLoop, 调用poller对应的方法, 注册fd的事件</span><br>    _loop-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 在channel所属的EventLoop中删除该channel</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _loop-&gt;<span class="hljs-built_in">removeChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_tied)<br>    &#123;<br>        std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard = _tie.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>            <span class="hljs-built_in">handleEventWithGuard</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">handleEventWithGuard</span>(receiveTime);<br>&#125;<br><br><span class="hljs-comment">// 根据当前设置的事件执行相应的回调操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;channle handleEvent revents: %d\n&quot;</span>, _revents);<br>    <span class="hljs-keyword">if</span> ((_revents &amp; EPOLLHUP) &amp;&amp; !(_revents &amp; EPOLLIN))<br>    &#123;<br>        <span class="hljs-comment">// 回调不为空则执行回调</span><br>        <span class="hljs-keyword">if</span> (_closeCallback)<br>            _closeCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; EPOLLERR)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_errorCallback)<br>            _errorCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; EPOLLOUT)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_writeCallback)<br>            _writeCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; (EPOLLIN | EPOLLPRI))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_readCallback)<br>            _readCallback(receiveTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面还没有解释update&#x2F;remove, 这里可以看到其中调用了_loop的成员函数, 其实 _loop 也会继续调用其内部的poller, 从宏观角度来看就是Channel一旦设定&#x2F;改变&#x2F;删除了自己关心的事件, 就应当通知poller对监听事件进行相应的改变, 细致说就是再poller中调用epoll_ctl修改内核事件表.</li><li>继续解释一下上文的_tie,  这是一个weak_ptr, 再handleEvent中调用了<code>std::shared_ptr&lt;void&gt; guard = _tie.lock();</code>  , 这里lock()函数的作用是<strong>尝试将一个 <code>weak_ptr</code> 升级为 <code>shared_ptr</code>, 前提是被观察的对象还没有被析构</strong>, 因此就算对象已经被析构也不会崩溃, guard也只会变为nullptr. <strong>所以为什么Channel可能调用到已析构对象的成员函数呢?</strong> 是因为Muduo还有个类叫做TcpConnection, 这个类类似于Channel的上级部件, 其内部会封装一个channel, 而这个channel的各种回调函数是由TcpConnection设定的, 然而<strong>TcpConnection是一个用户可以使用的类, 用户可以随时销毁它</strong>, 因此一旦TcpConnection对象开始销毁, 而还没有来得及从Poller上移除Channel, 如果有对应事件到来, 调用的回调函数还在那个对象中, 如果不利用tie提前检测, 一旦调用就会崩溃.</li></ul><h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>Poller主要管理对IO复用函数的调用, 这里Muduo库为了实现对poll和epoll共同支持, 先写了一个抽象基类Poller, 之后再分别写了调用poll和epoll的子类, 这里只介绍epoll的EPollPoller类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Poller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">// muduo库中多路事件分发器中的核心, 用于触发IO复用</span><br><span class="hljs-comment">// 此层为抽象基类, 用于作为Epoll和Poll的基类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ChannelList = std::vector&lt;Channel *&gt;;<br>    <span class="hljs-built_in">Poller</span>(EventLoop *loop) : _ownerLoop(loop) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Poller</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 判断参数channel是否在当前Poller中</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// EventLoop可以通过该接口获取默认Poller</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Poller *<span class="hljs-title">newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="hljs-type">int</span>, Channel *&gt;;<br>    <span class="hljs-comment">// 每个loop真正是在这里维护监听的channel</span><br>    ChannelMap _channels;<br><br><span class="hljs-keyword">public</span>:<br>    EventLoop *_ownerLoop;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先看成员变量 : </p><ul><li>_channels : 其类型底层是<code>vector&lt;Channel*&gt;</code>,  其作用在于储存了所有监视过的Channel, 其作用仅在提供安全性检查(例如检查某个Channel是否已经注册在内核事件表中), 也可以为上层提供这种检查的方法.</li></ul><p>再看一些关键的成员函数 : </p><ul><li><p>Poller构造函数 : 既然要调用epoll系列函数, 那么epoll_create一般就会在构造函数中直接调用.</p></li><li><p>poll : 执行轮询的核心函数, 在epoll中就是调用epoll_wait, 传入的<code>ChannelList *activeChannels</code>就会用做epoll_wait的第二个输出型参数, 返回活跃的事件.</p></li><li><p>update&#x2F;removeChannel : 可以感觉到这就是在调用epoll_ctl.</p></li><li><p>newDefaultPoller : 这个函数使poller在堆上开辟默认的poller对象, 这里默认EPollPoller.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EPollPoller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EPollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EPollPoller</span>(EventLoop *loop);<br>    ~<span class="hljs-built_in">EPollPoller</span>() <span class="hljs-keyword">override</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInitEventListSize = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-comment">// epoll_wait得到活跃的事件进行填入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 更新epoll的内核事件表, 就是使用epoll_ctl</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel *channel)</span></span>;<br><br>    <span class="hljs-keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;<br>    <span class="hljs-type">int</span> _epollfd;<br>    EventList _events; <span class="hljs-comment">// 存储发生的事件</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>fillActiveChannels : 这个是EPollPoller独有的函数, 一旦监视到活跃的事件就会触发该函数, 其向EventLoop传递活跃的Channel, 让其执行回调函数的调用, 同时还重新设置每个活跃Channel的revents, 切实做到了其作为轮询器的检测职能.</li></ul><p>以下是cpp具体实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EPollPoller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EPollPoller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 有一个channel还没有添加到poller里, 与channel的成员_index初始值相同</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kNew = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// channel已添加到poller中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kAdded = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// channel从poller中删除</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kDeleted = <span class="hljs-number">2</span>;<br><br>EPollPoller::<span class="hljs-built_in">EPollPoller</span>(EventLoop *loop)<br>    : <span class="hljs-built_in">Poller</span>(loop), _epollfd(::<span class="hljs-built_in">epoll_create1</span>(EPOLL_CLOEXEC)) <span class="hljs-comment">// 子进程继承的epid会在调用exec后关闭</span><br>    , _events(kInitEventListSize) <span class="hljs-comment">// vector初始长度设置为16</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_epollfd &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;epoll_create error: %d\n&quot;</span>, errno);<br>&#125;<br><br>EPollPoller::~<span class="hljs-built_in">EPollPoller</span>()<br>&#123;<br>    ::<span class="hljs-built_in">close</span>(_epollfd);<br>&#125;<br><br><span class="hljs-comment">// virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) override;</span><br><br><span class="hljs-comment">// 对应epoll_ctl</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> state = channel-&gt;<span class="hljs-built_in">state</span>();<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s fd=%d events=%d index=%d \n&quot;</span>, __FUNCTION__, channel-&gt;<span class="hljs-built_in">fd</span>(), channel-&gt;<span class="hljs-built_in">events</span>(), state);<br><br>    <span class="hljs-keyword">if</span> (state == kNew || state == kDeleted)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (state == kNew)<br>        &#123;<br>            <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>            _channels[fd] = channel;<br>        &#125;<br>        channel-&gt;<span class="hljs-built_in">set_state</span>(kAdded);<br>        <span class="hljs-built_in">update</span>(EPOLL_CTL_ADD, channel);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        <span class="hljs-comment">// 不是新增, 如果发现fd已经没有关心的事件, 就直接取消对fd的监视</span><br>        <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">isNoneEvent</span>())<br>        &#123;<br>            <span class="hljs-built_in">update</span>(EPOLL_CTL_DEL, channel);<br>            channel-&gt;<span class="hljs-built_in">set_state</span>(kDeleted);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">update</span>(EPOLL_CTL_MOD, channel);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 这里通过ctl将event存入内核中, 之后会通过wait把data原封不动地返回回来</span><br>    epoll_event event;<br>    <span class="hljs-built_in">bzero</span>(&amp;event, <span class="hljs-keyword">sizeof</span> event);<br>    event.events = channel-&gt;<span class="hljs-built_in">events</span>();<br>    event.data.ptr = channel;<br>    <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">epoll_ctl</span>(_epollfd, operation, fd, &amp;event) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (operation == EPOLL_CTL_DEL)<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;epoll_ctl del error: %d\n&quot;</span>, errno);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;epoll_ctl add/mod: %d\n&quot;</span>, errno);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>    _channels.<span class="hljs-built_in">erase</span>(fd);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s fd=%d\n&quot;</span>, __FUNCTION__, fd);<br><br>    <span class="hljs-type">int</span> state = channel-&gt;<span class="hljs-built_in">state</span>();<br>    <span class="hljs-keyword">if</span> (state == kAdded)<br>        <span class="hljs-built_in">update</span>(EPOLL_CTL_DEL, channel);<br>    channel-&gt;<span class="hljs-built_in">set_state</span>(kNew);<br>&#125;<br><br><span class="hljs-comment">// 通过epoll_wait监听到哪些事件发生, 并把发生的事件填入EventLoop提供的ChannelList中</span><br><span class="hljs-function">Timestamp <span class="hljs-title">EPollPoller::poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s =&gt; fd total count: %lu \n&quot;</span>, __FUNCTION__, _channels.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// epoll_wait第二个参数要求原生数组, 但是用下面的方式可以改为使用vector, 便于扩容</span><br>    <span class="hljs-type">int</span> numEvents = ::<span class="hljs-built_in">epoll_wait</span>(_epollfd, &amp;*_events.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(_events.<span class="hljs-built_in">size</span>()), timeoutMs);<br>    <span class="hljs-type">int</span> saveErron = errno; <span class="hljs-comment">// errno是全局变量, 可以先存起来防止线程问题</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br><br>    <span class="hljs-keyword">if</span> (numEvents &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%d events happened \n&quot;</span>, numEvents);<br>        <span class="hljs-built_in">fillActiveChannels</span>(numEvents, activeChannels);<br>        <span class="hljs-comment">// 如果监听到发生的事件数量已经等于数组大小</span><br>        <span class="hljs-comment">// 说明有可能更多, 需要扩容</span><br>        <span class="hljs-keyword">if</span> (numEvents == _events.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            _events.<span class="hljs-built_in">resize</span>(_events.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numEvents == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;%s timeout! \n&quot;</span>, __FUNCTION__);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (saveErron != EINTR)<br>        &#123;<br>            errno = saveErron;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;poll() error!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 遍历返回的活跃事件, 将每个事件存入EventLoop的活跃数组, 并修改对应Channel</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numEvents; i++)<br>    &#123;<br>        Channel *channel = <span class="hljs-built_in">static_cast</span>&lt;Channel *&gt;(_events[i].data.ptr);<br>        channel-&gt;<span class="hljs-built_in">set_revents</span>(_events[i].events);<br>        activeChannels-&gt;<span class="hljs-built_in">push_back</span>(channel);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// DefaultPoller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EPollPoller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// EventLoop可以通过该接口获取默认Poller</span><br><span class="hljs-function">Poller *<span class="hljs-title">Poller::newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;MUDUO_USE_POLL&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">EPollPoller</span>(loop);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里再摘出源文件中需要进一步理解的点 : </p><ul><li><p>epoll_create1 : </p><p>这里使用的是epoll_create1而非epoll_create, 目的是向其中传入<code>EPOLL_CLOEXEC</code>这个选项, 使得调用了exec系列函数就会直接关闭传出的epfd, 防止子进程继承该文件描述符, 使其变为当前进程独享.</p></li><li><p>kNew &#x2F; KAdded &#x2F; KDetele : </p><p>这里三个const变量的作用更像是enum类型, 其表示了每个Channel类型对于Poller可能有的三种状态(新 &#x2F; 已添加 &#x2F; 没有关心的事件), 而我们在updateChannel和removeChannel中就会通过调用Channel的state()获取其状态并与这三个const变量做对比, 进而实现不同的epoll_ctl操作.</p></li><li><p>updateChannel和removeChannel中都是在通过上面的三种const变量决定epoll_ctl的参数如何设置, 在update函数才执行真正的epoll_ctl函数, 并且这里需要注意的一点是 : <code>event.data.ptr = channel;</code>这里直接将channel指针存入了内核事件表中, 实际是非常便利快捷的操作, 后续使用中可以在epoll_wait返回的活跃事件中直接调用.</p></li></ul><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop内含Poller实现Demultiplex(事件分发器)的作用, Poller的内核事件表中维护了所有关心的Channel,  而EventLoop(事件循环)本身所起到作用类似于Reactor模型中的Reactor(反应堆).</p><p>我们首先要明晰EventLoop的职能, 主要就是三部分 : </p><ol><li>决定事件循环的开始和结束(loop &#x2F; quit).</li><li>使用Poller和Channel(接受Poller的状态检测结果并调用Channel的回调函数, 这就是所谓的”反应”).</li><li>线程调度(最难懂的部分, 有关one loop per thread的设计哲学).</li></ol><p>先来看头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Functor = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-built_in">EventLoop</span>();<br>    ~<span class="hljs-built_in">EventLoop</span>();<br>    <br>    <span class="hljs-function">Timestamp <span class="hljs-title">pollReturnTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _pollReturnTime; &#125;<br><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 开启事件循环</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 退出事件循环</span><br>    <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">// Channel -&gt; EventLoop -&gt; Poller的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hansChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-comment">// 判断对象是否在自己的线程里</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _threadId == CurrentThread::<span class="hljs-built_in">tid</span>(); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInLoop</span><span class="hljs-params">(Functor cb)</span></span>;   <span class="hljs-comment">// 先判断是否是在自己的线程中, 是就使用回调, 不是就放入队列</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queueInLoop</span><span class="hljs-params">(Functor cb)</span></span>; <span class="hljs-comment">// 把cb放入队列中, 唤醒loop所在的线程, 执行cb</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// weak up</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPendingFunctors</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 执行回调</span><br><br>    <span class="hljs-keyword">using</span> ChannelList = std::vector&lt;Channel *&gt;;<br>    std::atomic_bool _looping;<br>    std::atomic_bool _quit;                   <span class="hljs-comment">// 标识退出loop循环</span><br>    std::atomic_bool _callingPendingFunctors; <span class="hljs-comment">// 标识当前loop是否有需要执行的回调操作</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">pid_t</span> _threadId;                    <span class="hljs-comment">// 记录创建该loop所在的线程id</span><br>    Timestamp _pollReturnTime;                <span class="hljs-comment">// poller返回发生事件的channels的时间点</span><br>    <br>    std::unique_ptr&lt;Poller&gt; _poller;<br>    <span class="hljs-comment">// 由eventfd()创建, 当mainLoop获取一个新用户的channel, 通过轮循算法选择一个subLoop, 唤醒该成员</span><br>    <span class="hljs-type">int</span> _wakeupFd;<br>    std::unique_ptr&lt;Channel&gt; _wakeupChannel;<br><br>    ChannelList _activeChannels;<br><br>    <span class="hljs-comment">// 这个资源有可能被其他线程访问, 需要上锁</span><br>    std::vector&lt;Functor&gt; _pendingFunctors; <span class="hljs-comment">// 存储loop需要执行的所有回调操作d</span><br>    std::mutex _mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以先理解部分函数 : </p><ul><li><p>_poller + loop() &#x2F; quit() :</p><p>这里可以理解到loop中就是再一个循环中调用_poller的poll方法, quit可以打破循环.</p></li><li><p>_activeChannels + update &#x2F; removeChannel() : </p><p>这里的逻辑链路是 : EventLoop会将_activeChannels传给Poller的poll中, EventLoop会及时得到活跃的事件, </p><p>然后调用原先设置的Channel对应的回调.</p></li></ul><p>接下来我们需要静下心来理解EventLoop中线程调度的必要性 : </p><p>首先是Muduo库的设计哲学 : <strong>one loop per thread</strong>.</p><p>每个线程只运作一个事件循环, 可以达到非常高的处理效率, 而一个loop中会内含一个poller和多个channel, 包括我们看到的成员变量(各种状态判断标记 &#x2F; _activeChannels &#x2F; _pendingFunctors等), 这些资源都是每个loop<strong>独有</strong>的.</p><p>也就是说其实<strong>每个loop和创建其的线程其实是绑定的</strong>, 如果一个loop的功能如果不在创建其的线程中被调用, 就会导致逻辑不一致而失败甚至崩溃. <strong>因此如果产生这种情况, 我们要将线程切换到loop对应的线程</strong>. 而切换的方法就是利用_wakeupfd , _wakeupChannel, 和第三部分的一系列函数, 具体实现我们一会再说. </p><p>那么问题来了,  <strong>一个loop为什么会不在创建其的线程中被调用呢?</strong> 答案在于Muduo库的框架设计中有两种EventLoop, 一种是mainLoop(一个), 处理连接与分配, 一种是subLoop(多个), 处理每个连接的回调事务. 我们在使用Muduo库时创建并传入TcpServer的loop就是mainLoop, 而当mainLoop接收到新连接时, 就会分配给subLoop(实现会存储每个subLoop的指针), 而分配的方式就是<strong>把希望subLoop执行的回调函数加入其线程专属的_pendingFunctors中, 然后通过某种方式切换到subLoop所在的线程并且执行该回调</strong>(例如将新连接注册到自己的Poller中), 而这就是 <strong>runInLoop &#x2F; queueInLoop &#x2F; wakeup</strong> 这一系列函数可以实现的事情.  </p><p>我们来看cpp文件了解他们的具体实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 线程局部全局变量指针</span><br><span class="hljs-comment">// 防止一个线程创建多个EventLoop</span><br>__thread EventLoop *t_loopInThread = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 定义默认IO复用接口的超时时间</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kPollTimeMs = <span class="hljs-number">10000</span>;<br><br><span class="hljs-comment">// 创建wakeupfd, 用来notify唤醒subReactor处理新来的channel</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createEventfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> efd = ::<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (efd &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;eventfd error: %d \n&quot;</span>, errno);<br>    <span class="hljs-keyword">return</span> efd;<br>&#125;<br><br><span class="hljs-comment">// 一个线程启用一个EventLoop, 一个EventLoop在创立之初确立一个该线程该loop专属的_weakfd</span><br>EventLoop::<span class="hljs-built_in">EventLoop</span>()<br>    : _looping(<span class="hljs-literal">false</span>)<br>    , _quit(<span class="hljs-literal">false</span>)<br>    , _callingPendingFunctors(<span class="hljs-literal">false</span>)<br>    , _threadId(CurrentThread::<span class="hljs-built_in">tid</span>())<br>    , _poller(Poller::<span class="hljs-built_in">newDefaultPoller</span>(<span class="hljs-keyword">this</span>))<br>    , _wakeupFd(<span class="hljs-built_in">createEventfd</span>())<br>    , _wakeupChannel(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Channel</span>(<span class="hljs-keyword">this</span>, _wakeupFd))<br>&#123;<br>    <span class="hljs-keyword">if</span> (t_loopInThread)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;Another EventLoop %p exists int this thread %d \n&quot;</span>, t_loopInThread, _threadId);<br>    <span class="hljs-keyword">else</span><br>        t_loopInThread = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-comment">// 设置wakeupfd的读事件回调</span><br>    _wakeupChannel-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// 使当前loop监听_wakeupfd的EPOLLIN读事件</span><br>    _wakeupChannel-&gt;<span class="hljs-built_in">enableReading</span>();<br>&#125;<br><br>EventLoop::~<span class="hljs-built_in">EventLoop</span>()<br>&#123;<br>    _wakeupChannel-&gt;<span class="hljs-built_in">disableAll</span>();<br>    _wakeupChannel-&gt;<span class="hljs-built_in">remove</span>();<br>    ::<span class="hljs-built_in">close</span>(_wakeupFd);<br>    t_loopInThread = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 触发这个事件只是为了触发离开循环后的回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">read</span>(_wakeupFd, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-keyword">sizeof</span> one)<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _looping = <span class="hljs-literal">true</span>;<br>    _quit = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-keyword">while</span> (!_quit)<br>    &#123;<br>        _activeChannels.<span class="hljs-built_in">clear</span>();<br>        _pollReturnTime = _poller-&gt;<span class="hljs-built_in">poll</span>(kPollTimeMs, &amp;_activeChannels);<br>        <span class="hljs-comment">// 处理自己本身监听的事件</span><br>        <span class="hljs-keyword">for</span> (Channel *channel : _activeChannels)<br>        &#123;<br>            <span class="hljs-comment">// 通知每个channel处理对应的事件</span><br>            channel-&gt;<span class="hljs-built_in">handleEvent</span>(_pollReturnTime);<br>        &#125;<br>        <span class="hljs-comment">// 处理mainLoop/其他subLoop发配给自己的任务(注册新channel, 修改channel)</span><br>        <span class="hljs-comment">// 执行当前EventLoop事件循环需要处理的回调操作</span><br>        <span class="hljs-built_in">doPendingFunctors</span>();<br>    &#125;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;EventLoop %p stop looping \n&quot;</span>, <span class="hljs-keyword">this</span>);<br>    _looping = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::quit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _quit = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 要判断当前工作线程是不是IO线程, 如果不是, 则唤醒主线程</span><br>    <span class="hljs-comment">// 由于_quit线程是共享资源的, 在工作线程修改的_quit会在IO线程产生效果, 从而真正在主线程quit</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>())<br>        <span class="hljs-built_in">wakeup</span>();<br>&#125;<br><br><span class="hljs-comment">// Channel -&gt; EventLoop -&gt; Poller的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    _poller-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    _poller-&gt;<span class="hljs-built_in">removeChannel</span>(channel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::hansChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _poller-&gt;<span class="hljs-built_in">hasChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">// 在当前的loop执行cb</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>        <span class="hljs-built_in">cb</span>();<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">queueInLoop</span>(cb);<br>&#125;<br><br><span class="hljs-comment">// 把cb放入队列中, 唤醒loop所在的线程, 执行cb</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        _pendingFunctors.<span class="hljs-built_in">emplace_back</span>(cb);<br>    &#125;<br><br>    <span class="hljs-comment">// 唤醒相应loop</span><br>    <span class="hljs-comment">// 不在对应线程 | 在对应线程但是正在执行回调(执行完会回到阻塞, 可用wakeup触发)</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || _callingPendingFunctors)<br>        <span class="hljs-built_in">wakeup</span>();<br>&#125;<br><br><span class="hljs-comment">// 唤醒loop所在的线程 向wakeupfd写一个数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">write</span>(_wakeupFd, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-keyword">sizeof</span> one)<br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::doPendingFunctors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;Functor&gt; functors;<br>    _callingPendingFunctors = <span class="hljs-literal">true</span>;<br><br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        functors.<span class="hljs-built_in">swap</span>(_pendingFunctors);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Functor &amp;functor : functors)<br>    &#123;<br>        <span class="hljs-built_in">functor</span>(); <span class="hljs-comment">// 执行当前loop需要执行的回调操作</span><br>    &#125;<br><br>    _callingPendingFunctors = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们逐一讲解重要的实现 : </p><ul><li><p>构造函数 : </p><p>在这里new出了内部调用的Poller, 创建出了每个线程专属的_wakeupfd, 并且把这个fd封装进了 _wakeupChannel中, 在其中设置了这个fd读事件发送的回调函数并且关注读事件, 至于这里为什么创建 _wakeupfd和设置回调, 后面详述.</p><ul><li>eventfd() : 你可以理解为一个类似于socket可以创建出fd的函数, 但是该fd只能发送64位数据用于线程间通信.</li></ul></li><li><p>loop : </p><p>这里循环调用poller的poll函数, 是整个EventLoop的核心逻辑, 当有事件发生就会离开阻塞, 然后处理两类事件:</p><ul><li>其一处理poll返回的loop本身关心的事件.</li><li>其二处理mainLoop或其他subLoop希望当前subLoop执行的加入到_pendingFunctors中的回调函数.</li></ul></li><li><p>quit : </p><p>这里quit希望退出循环, 就把目标subLoop的_quit置成true, 然后唤醒目标subLoop的线程, 目标线程的loop中就会感知到 _quit的变化并作出判断.</p></li><li><p>update &#x2F; remove &#x2F; hasChannel : </p><p>这里其实就是Channel通过EventLoop修改Poller的途径, 具体可以再回忆一下Poller中对应的函数.</p></li><li><p>runInLoop &#x2F; queueInLoop &#x2F; wakeup &#x2F; doPendingFunctors : </p><p>这一部分是线程调度的核心 : </p><ul><li>当mainLoop&#x2F;subLoop希望某个Loop执行某个函数时, 其就会调用该loop的runInLoop把回调函数传进去.</li><li>如果当前线程就是创建该loop的线程, 则会直接执行该函数.</li><li>反之就会执行以下逻辑 : <ul><li>将该函数加入该loop的_pendingFunctors.</li><li>调用wakeup()向该loop的_wakeupfd发送一个数据.</li><li>在上文中我们知道在构造函数中已经设置了对应_wakeupfd的读事件回调, 那么这个loop如果原来阻塞在epoll_wait, 就会离开阻塞向下执行.</li><li>关键不在我们设置的读事件回调handleRead(它只是读了一个没有用的数据而已), 而在于loop的事件循环不再处于阻塞状态, 就可以继续执行之后的doPendingFunctors函数了 !</li><li>而在doPendingFunctors函数中就会执行我们在第一步存入_pendingFunctors中的回调函数 !</li></ul></li></ul><p>这里确实比较难懂, 如果想真正理解, 最好认识到每个Loop的资源都是独立且和线程绑定的, 在运行中会有很多不同的Loop资源存在, <strong>当mainLoop希望subLoop执行函数时, 其手上会有目标subLoop的指针, 借着这个指针找到该subLoop对应的资源, 利用该资源中的_weakupfd唤醒该subLoop, 也就是切换到subLoop对应线程, 让这个subLoop执行函数.</strong></p></li></ul><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>至此整个EvnetLoop已经讲解完毕, 但我认为很多地方还是比较晦涩难懂的.</p><p>在整体框架上就是一个EventLoop内置一个Poller管理多个Channel上发生事件的模型, Poller负责轮询, EvnetLoop根据Poller返回的活跃事件进行函数回调.</p><p>在此基础上, 由于mainLoop和subLoop的设计理念, 需要实现Loop之间的互动与函数传递, 其实这种行为用生产者消费者模型就可以实现(例如mainLoop当S, subLoop当C, 中间维护一个任务队列), 但这种模型其实效率并不高, 肉眼可见的要使用很多锁来维护任务队列.</p><p>反观Muduo库的设计, 虽然设计比较复杂, 但是几乎没有用到锁的地方, 除了_pendingFunctors的使用, 因为有可能有多个线程同时使用 _pendingFunctors 向其中加入回调函数, 而且对于线程的切换由于weakup()的存在, 都是精确且没有过多消耗的, 避免了主动轮询或额外线程开销, 足以见得其效率. </p><p>而且和libevent库很像的一点是都有<strong>统一事件源</strong>的思想内核, 比如这里设计的基于Channel&#x2F;Poller&#x2F;EventLoop的一套监测&#x2F;分发&#x2F;处理的流程, 既可以用在处理普通socketfd的读写事件上, 也可以处理_weakupfd这种线程切换事件上, 在之后还可以用来处理Acceptor的listensocketfd的连接建立事件上, 其实就是掌握了不同事件之间的相通点(用fd进行事件读写), 进而转化为统一的处理方式.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(1)</title>
    <link href="/2025/04/07/Moduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(1)/"/>
    <url>/2025/04/07/Moduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理论知识</p></blockquote><h2 id="阻塞-非阻塞-同步-异步"><a href="#阻塞-非阻塞-同步-异步" class="headerlink" title="阻塞, 非阻塞, 同步, 异步"></a>阻塞, 非阻塞, 同步, 异步</h2><h3 id="数据准备-网络IO阶段1"><a href="#数据准备-网络IO阶段1" class="headerlink" title="数据准备 - 网络IO阶段1"></a>数据准备 - 网络IO阶段1</h3><ul><li>阻塞 : 当前线程调用IO方法的线程进入阻塞状态</li><li>非阻塞 : 不会改变线程状态, 通过返回值判断<ul><li>size &#x3D;&#x3D; 0 对端关闭了连接</li><li>size &gt; 0 接收到资源</li><li>size &#x3D;&#x3D; 0 &amp;&amp; errno &#x3D; EAGAIN</li></ul></li></ul><h3 id="数据读写-网络IO阶段2"><a href="#数据读写-网络IO阶段2" class="headerlink" title="数据读写 - 网络IO阶段2"></a>数据读写 - 网络IO阶段2</h3><ul><li>并发同步 : 同步IO接口 - 应用程序自己把数据从接收缓冲区搬过来  select &#x2F; poll &#x2F; epoll</li><li>并发异步 : 异步IO接口 - 应用程序发出请求, 传入sockfd, buf和sigio信号(通知方式), 由系统把数据搬到buf中, 当系统搬完后, 对应用程序发送sigio通知, 告诉应用程序有数据发来且已经搬运完成.</li></ul><blockquote><p>在处理IO时, 阻塞和非阻塞都是同步IO, 只有使用了特殊的的API才是异步.</p></blockquote><hr><h2 id="Linux上的五种IO模型"><a href="#Linux上的五种IO模型" class="headerlink" title="Linux上的五种IO模型"></a>Linux上的五种IO模型</h2><ul><li>阻塞 : 同步阻塞</li><li>非阻塞 : 同步非阻塞</li><li>IO复用 : select &#x2F; poll &#x2F; epoll 监听fd是否可读, 返回可读fd.</li><li>信号驱动 : 注册SIGIO信号, 发起请求, 拷贝过程还是自己承担</li><li>异步 : 同上</li></ul><hr><h2 id="一个好的网络服务器"><a href="#一个好的网络服务器" class="headerlink" title="一个好的网络服务器"></a>一个好的网络服务器</h2><ul><li>非阻塞 + IO复用 : 就是用IO复用替代轮询操作</li><li>epoll + 非阻塞IO + 线程池</li></ul><hr><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250115173257202.png" alt="image-20250115173257202"></p><hr><h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><ul><li>select : 会设置一个保存句柄的数组, 会轮循扫描数组, 拷贝句柄数据结构会有巨大开销</li><li>epoll :<ul><li>调用epoll_create()在内核申请一个文件系统的数据结构, 结构包括红黑树(存储socketfd)和双向链表(存储发生事件的fd)</li><li>调用epoll_ctl()像对象中(红黑树)添加要监视的所有socketfd</li><li>调用epoll_wait()收集发生事件的fd资源</li></ul></li></ul><hr><h2 id="事件触发模式"><a href="#事件触发模式" class="headerlink" title="事件触发模式"></a>事件触发模式</h2><ul><li>LT模式(水平触发) : 只要内核数据没被读完, 处于可读可写的状态, 就会一直上报数据(默认)</li><li>ET模式(边缘触发) : 仅在状态变化时(不可读-&gt;可读)进行通知</li><li>Muduo库采用的LT模式<ul><li>不会丢失数据或消息</li><li>低延迟处理, ET会针对一个事件一直读取, 有可能分配不均, LT就非常公平, 延迟较低.</li><li>便于跨平台使用</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 状压dp | 区间dp | 树形dp</title>
    <link href="/2025/04/03/%5B%E7%AE%97%E6%B3%95%5D%20%E7%8A%B6%E5%8E%8Bdp%20%20%E5%8C%BA%E9%97%B4dp%20%20%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2025/04/03/%5B%E7%AE%97%E6%B3%95%5D%20%E7%8A%B6%E5%8E%8Bdp%20%20%E5%8C%BA%E9%97%B4dp%20%20%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p>棋盘型状压,  重点考虑行与行之间的转移.</p><ul><li><p>首先枚举每行可能的状态, <strong>预处理出合法行状态</strong>. </p></li><li><p>可以选择预处理出行与行之间的合法转移</p></li><li><p><code>f[i][j]</code>代表处理完前i行, 第i行状态为j的xxx.</p></li><li><p>转移方程通过枚举前状态k来实现, 看k是否可以合法转移为j</p></li></ul><blockquote><p>玉米田 : 十字型 + 地图机制</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">13</span>, mod = <span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; state; <span class="hljs-comment">// 记录初始每行合法状态!</span><br><span class="hljs-type">int</span> g[N]; <span class="hljs-comment">// 记录原图每行的状态</span><br>vector&lt;<span class="hljs-type">int</span>&gt; trans[<span class="hljs-number">1</span> &lt;&lt; N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">1</span> &lt;&lt; N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;<br>        i &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> y; cin &gt;&gt; y;<br>            x += !y &lt;&lt; j;<br>        &#125;<br>        g[i] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; m; i ++ )<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i)) state.<span class="hljs-built_in">push_back</span>(i);<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : state)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : state)<br>            <span class="hljs-keyword">if</span>((a &amp; b) == <span class="hljs-number">0</span>) trans[a].<span class="hljs-built_in">push_back</span>(b);<br>    <br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : state)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : trans[a])<br>                <span class="hljs-keyword">if</span>((a &amp; g[i]) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 要求不能种在不育土壤上</span><br>                    f[i][a] = (f[i][a] + f[i - <span class="hljs-number">1</span>][b]) % mod;<br>                    <br>    cout &lt;&lt; f[n + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] % mod &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h3 id="环状区间dp"><a href="#环状区间dp" class="headerlink" title="环状区间dp"></a>环状区间dp</h3><p>破环成链 + 区间dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">410</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> f1[N][N], f2[N][N]; <span class="hljs-comment">// 最小, 最大</span><br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] = a[i - n];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] += a[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-built_in">memset</span>(f1, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f1);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) f1[i][i] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> * n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt; r; k ++ )<br>            &#123;<br>                f1[l][r] = <span class="hljs-built_in">min</span>(f1[l][r], f1[l][k] + f1[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>                f2[l][r] = <span class="hljs-built_in">max</span>(f2[l][r], f2[l][k] + f2[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-type">int</span> mi = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) mi = <span class="hljs-built_in">min</span>(mi, f1[i][i + n - <span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> ma = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) ma = <span class="hljs-built_in">max</span>(ma, f2[i][i + n - <span class="hljs-number">1</span>]);<br>    cout &lt;&lt; mi &lt;&lt; endl;<br>    cout &lt;&lt; ma &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有关二叉树的区间dp"><a href="#有关二叉树的区间dp" class="headerlink" title="有关二叉树的区间dp"></a>有关二叉树的区间dp</h3><blockquote><p>加分二叉树 : 给出中序遍历,  求出加分最高的二叉树并给出最高分和其前序遍历. 加分规则 : 根 + 左子树 * 右子树.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">35</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> ord[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> root[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root[l][r] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(l, root[l][r] - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root[l][r] + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     cin &gt;&gt; n;<br>     <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; ord[i];<br>     <br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) f[l][r] = ord[l], root[l][r] = l;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-type">int</span> sum;<br>                <span class="hljs-comment">// 枚举根节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt;= r; k ++ )<br>                &#123;<br>                    sum = ord[k];<br>                    <span class="hljs-type">int</span> left = k == l ? <span class="hljs-number">1</span> : f[l][k - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> right = k == r ? <span class="hljs-number">1</span> : f[k + <span class="hljs-number">1</span>][r];<br>                    sum += left * right;<br>                    <span class="hljs-keyword">if</span>(sum &gt; f[l][r])<br>                    &#123;<br>                        f[l][r] = sum;<br>                        root[l][r] = k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维区间dp"><a href="#二维区间dp" class="headerlink" title="二维区间dp"></a>二维区间dp</h3><p>dfs + 区间dp</p><blockquote><p>棋盘划分 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[M][M];<br><span class="hljs-type">double</span> f[M][M][M][M][<span class="hljs-number">15</span>]; <span class="hljs-comment">// x1, y1, x2, y2, 还有k块</span><br><span class="hljs-type">double</span> X;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> sum = s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] - X;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)sum * sum / n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span>&amp; v = f[x1][y1][x2][y2][k];<br>    <span class="hljs-keyword">if</span>(v &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> v = <span class="hljs-built_in">get</span>(x1, y1, x2, y2);<br>    <br>    v = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">// 横切</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x1; i &lt; x2; i ++ )<br>    &#123;<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, y1, i, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(i + <span class="hljs-number">1</span>, y1, x2, y2));<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, y1, x2, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, y1, i, y2));<br>    &#125;<br>    <span class="hljs-comment">// 纵切</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = y1; i &lt; y2; i ++ )<br>    &#123;<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, y1, x2, i, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, i + <span class="hljs-number">1</span>, x2, y2));<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, i + <span class="hljs-number">1</span>, x2, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, y1, x2, i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>) <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>)<br>    &#123;<br>        cin &gt;&gt; s[i][j];<br>        s[i][j] += s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <br>    X = (<span class="hljs-type">double</span>)s[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>] / n;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf&quot;</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, n)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><blockquote><p>树的中心 : 求中心到其他所有点的最远距离, 中心是到所有点最远距离最小的点.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> w[M];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> d1[N], d2[N];<br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 记录当前子树的最长路径从哪个点来</span><br><span class="hljs-type">int</span> up[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs_d</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">dfs_d</span>(j, u) + w[i];<br>        <span class="hljs-keyword">if</span>(ret &gt; d1[u]) d2[u] = d1[u], d1[u] = ret, p[u] = j;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; d2[u]) d2[u] = ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d1[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_up</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 先处理up</span><br>        <span class="hljs-keyword">if</span>(p[u] == j) up[j] = <span class="hljs-built_in">max</span>(up[u], d2[u]) + w[i];<br>        <span class="hljs-keyword">else</span> up[j] = <span class="hljs-built_in">max</span>(up[u], d1[u]) + w[i];<br>        <span class="hljs-built_in">dfs_up</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs_d</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">dfs_up</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(d1[i], up[i]));<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形dp-分组背包"><a href="#树形dp-分组背包" class="headerlink" title="树形dp + 分组背包"></a>树形dp + 分组背包</h3><blockquote><p>二叉苹果树 : 给定一棵含有 n 个结点的树，树根编号为 1，且树上的每条边有一个边权 wedge j, 要求我们只保留树中的 m 条边，使得 树根 所在的 连通块 的所有边 边权之和 最大.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dfs + 分组背包</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], w[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">// 根节点为i, 要保留j根树枝的max</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> x = e[i];<br>        <span class="hljs-keyword">if</span>(x == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(x, u);<br>        <span class="hljs-comment">// 每个子树就是一组, 选择保留当前子树中多少个树枝就是分组</span><br>        <span class="hljs-comment">// u-&gt;j也需要一条树枝 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j -- )<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; j; k ++ )<br>                f[u][j] = <span class="hljs-built_in">max</span>(f[u][j], f[u][j - k - <span class="hljs-number">1</span>] + f[x][k] + w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形dp-状态机"><a href="#树形dp-状态机" class="headerlink" title="树形dp + 状态机"></a>树形dp + 状态机</h3><p>重点在于列举出状态, 以及状态之间的转移.</p><blockquote><p>战略游戏 : 给出一个树, 一个人可以观察到所在点所连的所有边, 求观察到所有边的最小人数.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 根节点为i, 此处不放/放士兵 士兵数的最小值</span><br><span class="hljs-comment">// 必须要接触所有的边</span><br><span class="hljs-comment">// f[i][0] += f[j][1] 必须放置</span><br><span class="hljs-comment">// f[i][1] += min(f[j][0], f[j][1])所有都是可放可不放</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(j, u);<br>        f[u][<span class="hljs-number">0</span>] += f[j][<span class="hljs-number">1</span>];<br>        f[u][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>        &#123;<br>            <span class="hljs-type">int</span> u; cin &gt;&gt; u;<br>            <span class="hljs-type">char</span> ch; cin &gt;&gt; ch &gt;&gt; ch;<br>            <span class="hljs-type">int</span> k; cin &gt;&gt; k &gt;&gt; ch;<br>            <span class="hljs-keyword">while</span>(k -- )<br>            &#123;<br>                <span class="hljs-type">int</span> v; cin &gt;&gt; v;<br>                <span class="hljs-built_in">add</span>(u, v), <span class="hljs-built_in">add</span>(v, u);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        cout &lt;&lt; <span class="hljs-built_in">min</span>(f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>皇宫看守 : 给出一个树, 一个人可以观察到当前点和所有邻点, 花销为当前点对应花销, 求观察到所有点的最小花销.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 记录安排侍卫的花销</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">3</span>];  <span class="hljs-comment">// 根节点为i, 不放但父节点放/不放但子节点放/放</span><br><span class="hljs-comment">// f[i][0] += min(f[j][1], f[j][2]) -&gt; 子节点可以放或子节点的子节点放</span><br><span class="hljs-comment">// f[i][1] += min(f[j][2] + 集合min(f[k][2], f[k][1]))  -&gt; 子节点有一个放, 其他可放可不放</span><br><span class="hljs-comment">// f[i][2] += min(f[j][1], f[j][2], f[j][0]);</span><br><span class="hljs-type">bool</span> st[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">2</span>] = p[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]);<br>        f[u][<span class="hljs-number">2</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">2</span>], f[j][<span class="hljs-number">0</span>]));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分别每个子节点为必2点</span><br>    f[u][<span class="hljs-number">1</span>] = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        f[u][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(f[u][<span class="hljs-number">1</span>], f[u][<span class="hljs-number">0</span>] - <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]) + f[j][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> t = n;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-type">int</span> i, k;<br>        cin &gt;&gt; i &gt;&gt; p[i] &gt;&gt; k;<br>        <span class="hljs-keyword">while</span>(k -- )<br>        &#123;<br>            <span class="hljs-type">int</span> r; cin &gt;&gt; r;<br>            <span class="hljs-built_in">add</span>(i, r);<br>            st[r] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(st[root]) root++;<br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">2</span>]) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 背包dp</title>
    <link href="/2025/03/30/%5B%E7%AE%97%E6%B3%95%5D%20%E8%83%8C%E5%8C%85dp/"/>
    <url>/2025/03/30/%5B%E7%AE%97%E6%B3%95%5D%20%E8%83%8C%E5%8C%85dp/</url>
    
    <content type="html"><![CDATA[<h2 id="关于”不大于””恰好””至少是”的讨论"><a href="#关于”不大于””恰好””至少是”的讨论" class="headerlink" title="关于”不大于””恰好””至少是”的讨论"></a>关于”不大于””恰好””至少是”的讨论</h2><p>最标准的背包问题中, 装入背包的体积是要不大于m的, 但有些题目要求装入体积恰好是m, 或者至少是m, 思路一样, 但是初始化和最终获取答案的方式有区别.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不大于</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这是最普通的一维优化01背包, 针对不大于的情况, 我们保证的是j - v[i]一定大于等于0, 因为体积不可能不大于负数, 初始化都是0, 至于原因, 是因为”什么都不装”也是”不大于”中的一种合法条件, 什么都不装值一定是0, 也就是说没个状态一定都有值为0这个合法条件, 可以取得并使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 恰好</span><br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ ) ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>cout &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>恰好相比于不大于, 对f全部进行了最小化, 只有f[0] &#x3D; 0, 原因依旧从定义分析 : 初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了.</p><p>另外这种恰好得到结果不会涵盖前面的状态, 每个状态是相互独立的, 如果没有明确指明是恰好为多少, 通常要遍历统计一遍.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - v[i])] + w[i]);<br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>“至少是”相比于前两者, 多了j - v[i] &lt; 0的情况, 因为”至少是负数”在理论上来说是正确的, 所以我们应当将小于0的情况也纳入考虑, 由于数组下标限制, 小于0的情况就当0处理.</p><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><p>求具体方案是一种提醒, 其解法在于通过背包dp得到的f数组倒推选择从而得到方案.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, m) cin &gt;&gt; w[i][j];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++ )<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++ )<br>                <span class="hljs-keyword">if</span>(j - k &gt;= <span class="hljs-number">0</span>) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k] + w[i][k]);<br>        &#125;<br>    <br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <br>    <span class="hljs-type">int</span> j = m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j - k &gt;= <span class="hljs-number">0</span> &amp;&amp; f[i][j] == f[i - <span class="hljs-number">1</span>][j - k] + w[i][k])<br>            &#123;<br>                ans[i] = k;<br>                j -= k;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans[i] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个分组背包的方案倒推, 可以掌握到关键在于找到<code>f[i][j] == f[i - 1][j - k] + w[i][k]</code>, 这说明在最后的方案选择一定选择了第i件, 然后<code>j -= k;</code>就是原来怎么加的, 现在怎么减回去, 就这样一直到这推就可以得到方案.</p><h2 id="背包问题求最优方案数"><a href="#背包问题求最优方案数" class="headerlink" title="背包问题求最优方案数"></a>背包问题求最优方案数</h2><p>关键在于维护另外一个dp, 用来记录体积为j时的方案数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从方案数变成最优方案数, 需要再用一个dp维护使用前i个物品的最优方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N], g[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        &#123;<br>            <span class="hljs-type">int</span> ma = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(ma == f[j]) cnt = g[j];<br>            <span class="hljs-keyword">if</span>(ma == f[j - v[i]] + w[i]) cnt += g[j - v[i]];<br>            g[j] = cnt % mod;<br>            f[j] = ma;<br>        &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <br>        <span class="hljs-keyword">if</span>(ans == f[i])<br>            cnt += g[i];<br>    cout &lt;&lt; cnt % mod &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到g[i]是根据f[j]的两个源状态所对应的结果所改变的, 思路很简单, 就是谁大就记录谁的方案数, 一样大就一起记录.</p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>不同物品对应不同的处理方法, 其实就是分别对待就行, 可以把01背包当成特殊的多重背包处理, 这样就只用处理完全背包和多重背包了, 更具n大小判断多重背包用哪个版本的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, W = <span class="hljs-number">6010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], s[N], w[N];<br><span class="hljs-type">int</span> f[W];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <br>    &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">-1</span>) s[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) s[i] = <span class="hljs-number">1010</span>;<br>        <span class="hljs-keyword">else</span> s[i] = op;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">// 完全背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j ++ ) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 多重背包</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k *= <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= k * v[i]; j -- )<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - k * v[i]] + k * w[i]);<br>                s[i] -= k;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i])<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= s[i] * v[i]; j --)<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - s[i] * v[i]] + s[i] * w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>        <br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><p>当使用物品间存在树形依赖关系, 需要用到树形dp.</p><ul><li><code>f[i][j]</code>的定义将转变为 : <strong>根节点为u的子树, 且选中节点u, 总体积不超过j的最大价值</strong>.</li></ul><p>至于为什么要选中节点u, 也是因为题目性质, 选中也可以方便计算, 因为如果不选中u, 那么它的所有子树也就不能选, 就没有意义了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-comment">// 想选一定要选根节点, 所以无需担心不选中root的结果</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">// 根节点为u的子树, 且选中节点u, 总体积不超过j的最大价值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j); <span class="hljs-comment">// 先往里走把前置子树都更新完</span><br>        <br>        <span class="hljs-comment">// 每个子树做一次分组背包, 枚举当前子树不超过的体积[0, 100], 再枚举从该子树中选中多少体积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = m - v[u]; x &gt;= <span class="hljs-number">0</span>; x -- )<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y ++ )<br>                f[u][x] = <span class="hljs-built_in">max</span>(f[u][x], f[u][x - y] + f[j][y]); <span class="hljs-comment">// 子树体积不超过x, 从该子树选中y体积总和物品</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 我们假定一定要选中u, 将分组背包的结果加上u</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v[u]; i ++ ) f[u][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-type">int</span> root;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, fa;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; fa;<br>        v[i] = a, w[i] = b;<br>        <span class="hljs-keyword">if</span>(fa == <span class="hljs-number">-1</span>) root = i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(fa, i);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    <br>    cout &lt;&lt; f[root][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里分组背包相当于每次dfs得到的一个子树就是新的一组, 但当根节点想要知道子节点子树的答案是, 子节点可能很多如果枚举子节点的使用与否将是2的幂次级, n &lt; 100, 2的100次有很大问题. 解决问题是不枚举状态, 改为枚举体积, 因为所有枚举的结果最后一定都会落在体积范围内, 也就是[0, 100].</p><p>所以先枚举根节点子树打算占用多少体积, 再枚举当前子节点子树打算占用多少体积, 就可以得到状态转移方程了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 树状数组|线段树</title>
    <link href="/2025/03/29/%5B%E7%AE%97%E6%B3%95%5D%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2025/03/29/%5B%E7%AE%97%E6%B3%95%5D%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树状数组-O-logn"><a href="#树状数组-O-logn" class="headerlink" title="树状数组 O(logn)"></a>树状数组 O(logn)</h2><ol><li>在某个位置上的数加上一个数, <strong>单点修改</strong></li><li>求任意某区间的前缀和, <strong>区间查询</strong></li></ol><p>如果想用前缀和实现单点修改+区间查询, 需要O(n) + O(1) &#x3D; O(n), 而树状数组中两种操作都是O(logn).</p><ul><li><p>tr[x] &#x3D; ( x - lowbit(x), x ] , 每个tr[x]代表了这个一个区间内的前缀和</p></li><li><p>三大操作 : lowbit + add + query</p></li><li><p>query(x) 查询的是x前的所有前缀和</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单点修改 + 区间查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N], tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) ret += tr[i];<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, a[i]);<br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x, y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改 + 单点查询"></a>区间修改 + 单点查询</h3><p>原来树状数组维护的是原数组a, query得到的结果的前缀和s, 整体过程是 <strong>a -&gt; s</strong>. 那么 <strong>b-&gt;a</strong> 也有相同的积分关系, 也就是差分数组到原数组, 我们可以将add改为两个点的修改操作(b), query得到的结果是a, 这就是单点的值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间修改 + 单点查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, a[i] - a[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// tr要维护的是差分数组</span><br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        string op; cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;C&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> l, r, d;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>            <span class="hljs-built_in">add</span>(l, d), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -d);  <span class="hljs-comment">// 用两个单点操作取代区间操作</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(x) &lt;&lt; endl;<span class="hljs-comment">// 单点查询求a</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改 + 区间查询"></a>区间修改 + 区间查询</h3><p>这种操作实际希望我们达到的效果是 <strong>b -&gt; s</strong>, 也就是我们通过修改差分数组, 之后就可以通过O(logn)的时间得到前缀和, 想要实现b-&gt;s, 是通过分析数学公式得到的 : </p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250323101825181.png" alt="image-20250323101825181"></p><p>这里的d可以当作b, 我们看图可以分析出 si &#x3D; (d1 + d2 + … + dn) * (x + 1) - (1 * d1 + 2 * d2 + .. + n * dn);</p><p>前半部和后半部要求我们各维护一个树状数组, 整体过程可以理解为b —树状数组O(logn)—&gt; 特殊的a —数学计算O(1)—&gt; s.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间修改 + 区间查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr1[N * <span class="hljs-number">2</span>], tr2[N * <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span> <span class="hljs-comment">// 修改b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 获取a</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">// 通过a再获取s</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(tr1, x) * (x + <span class="hljs-number">1</span>) - <span class="hljs-built_in">query</span>(tr2, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <br>    &#123;<br>        <span class="hljs-type">int</span> b = a[i] - a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">add</span>(tr1, i, b);<br>        <span class="hljs-built_in">add</span>(tr2, i, i * b);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        string op;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;C&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> d; cin &gt;&gt; d;<br>            <span class="hljs-built_in">add</span>(tr1, l, d), <span class="hljs-built_in">add</span>(tr2, l, l * d);<br>            <span class="hljs-built_in">add</span>(tr1, r + <span class="hljs-number">1</span>, -d), <span class="hljs-built_in">add</span>(tr2, r + <span class="hljs-number">1</span>, (r + <span class="hljs-number">1</span>) * -d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组-二分答案"><a href="#树状数组-二分答案" class="headerlink" title="树状数组 + 二分答案"></a>树状数组 + 二分答案</h3><p>这种算法一般是 遍历 + 树状数组 + 二分, 时间复杂度是O(nlognlogn), 其实非常快捷, 1e5 - 1e6的数据都可以解决.</p><p>该算法常用来获取第k大元素, 相比于小根堆, 其优势在于k值非常灵活, 小根堆的k值必须固定, 但是这种算法的k可以是任意的.</p><blockquote><p>&lt;L3-002 特殊堆栈&gt; 堆栈是一种经典的后进先出的线性结构，相关的操作主要有“入栈”（在堆栈顶插入一个元素）和“出栈”（将栈顶元素返回并从堆栈中删除）。本题要求你实现另一个附加的操作：“取中值”——即返回所有堆栈中元素键值的中值。给定 N 个元素，如果 N 是偶数，则中值定义为第 N&#x2F;2 小元；若是奇数，则为第 (N+1)&#x2F;2 小元。</p></blockquote><p>该题在普通栈的基础上可以求中值, 中值在这里近似于第k大元素, k 可以通过计算得来, 是灵活可变的. 并且这里入堆的值只到1e5, 于是我们就可以用树状数组维护[1 - 1e5]区间上在堆中的元素个数, push就单点修改 + 1, pop就单点修改 - 1, query(x)得到的就是堆中有的范围在[1, x] 中的元素个数.</p><p>有了这样的树状数组, 当我需要求第k大元素时, 我们可以发现, 假如我们二分答案, 只有在mid大于等于第k大元素时query(mid)的结果才会大于等于k, 这个过程是单增的可以二分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">// 求第k大元素(k可灵活) -&gt; 树状数组 + 二分</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        string op;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;Pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">size</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cout &lt;&lt; st.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>                <span class="hljs-built_in">add</span>(st.<span class="hljs-built_in">top</span>(), <span class="hljs-number">-1</span>);<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;PeekMedian&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">size</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-comment">// 计算中值k</span><br>                <span class="hljs-type">int</span> sz = st.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-type">int</span> k;<br>                <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">1</span>) k = (sz + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> k = sz / <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">// 二分答案, 找第k个元素的元素值</span><br>                <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = N;<br>                <span class="hljs-keyword">while</span>(l &lt; r)<br>                &#123;<br>                    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) &gt;= k) r = mid;<br>                    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                cout &lt;&lt; l &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>            st.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-built_in">add</span>(x, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing244> 有 n 头奶牛，已知它们的身高为 1∼n 且各不相同，但不知道每头奶牛的具体身高。</p><p>现在这 n 头奶牛站成一列，已知第 i 头牛前面有 Ai 头牛比它低，求每头奶牛的身高。</p></blockquote><p>这道题就更意识流了, 没有告诉你每头奶牛对应的值, 只是告诉你范围在[1, n]和每头奶牛左边比其低的个数. </p><p>首先要从边界考虑, 我从右往左思考, 第n头奶牛右边包含所有的牛, 那么a[n] + 1一定代表其名次, 并且由于范围是[1, n]并且不重样, 那么第n头奶牛的值就是a[n] + 1.</p><p>我们继续考虑n - 1, 其名次其实是受n影响的, 也就是说a[n - 1]  + 1不一定可以代表n - 1的名次的, 但是有一种方法可以让我们确定n - 1的名次, 那就是树状数组 + 二分, 这里该算法做到的是 : </p><ul><li>树状数组维护区间[1, n], 表示区间上未被使用的值有多少个, 从右往左遍历, 和上题一样二分答案, 找到第a[i] + 1大的值, 这个值就是第i头的值 , 一旦确定了第i头的值, 就把该值从tr中删去, 这样在以后的遍历中, i右边的牛就不会再影响到结果了.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 树状数组 + 二分</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, n) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">int</span> rk = a[i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>        <span class="hljs-keyword">while</span>(l &lt; r) <br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) &gt;= rk) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(l, <span class="hljs-number">-1</span>);<br>        ans[i] = l;<br>    &#125;<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>作用依旧是单点修改 + 区间查询, 但是相比于树状数组只能对数值进行维护, 线段树可以维护各种区间的性质, 比如最大值, 最小值, 最长连续子序列和等等.</p><ul><li>pushup : 用子节点信息更新当前节点</li><li>build : 在一段区间上初始化线段树</li><li>modify : 修改</li><li>query : 查询</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r)<br>    &#123;<br>        tr[u] = &#123;l, r, a[l]&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tr[u] = &#123;l, r&#125;;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, tr[u].l, mid);<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, tr[u].r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].sum;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x) <br>    &#123;<br>        tr[u].sum += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, x, y) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 差分</title>
    <link href="/2025/03/17/%5B%E7%AE%97%E6%B3%95%5D%20%E5%B7%AE%E5%88%86/"/>
    <url>/2025/03/17/%5B%E7%AE%97%E6%B3%95%5D%20%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>普通的差分其实很好理解, 就是将一次区间的加减操作换成了两个点的操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设数组大小为n, 其对时间复杂度的贡献发生在区间操作很多时, 假定操作数为m, 那么差分就可以将时间复杂度O(nm)降到O(n), 一般不可以降到O(1), 因为差分完要强绑定一次前缀和(除非你就是要差分数组).</p><p>对于差分的深入理解, 可以把其看作一种积分和求导的过程 : </p><ul><li>差分数组(b) -&gt; 原数组(a) -&gt; 前缀和数组(s),  你可以把这种过程看作一种<strong>积分</strong>(从前往后累加).</li><li>差分数组 &lt;- 原数组 &lt;- 前缀和数组,  你可以把这种过程看作一种<strong>求导</strong>(从后往前累减).</li></ul><p>虽然他们数值不同, 但他们同根同源, 你可以理解为是一种事物的不同观察方式, 每种观察方式都有一些特殊的作用和关联. 在比较基础的算法题中, 一般都是站在差分数值的角度去想如何积分成原数组, 但在一些差分题中也会要求你站在原数组角度去求导成差分数组, 接下来给出例题.</p><blockquote><p><acwing4262> 空调 : 给出一个原数组x, 再给出一个目标数组y, 你可以选择x中任意的一段区间加减一, 求x转变为y的最小操作数.</p></blockquote><p>我们可以感觉到这道题确实是在进行大量的区间操作, 和差分脱不了干系, 但是并不是让我们求出原数组的什么, 而是求区间操作的最小操作数, 而差分数组中的每次加减就是一次区间操作, 那么这道题其实是希望我们把原数组求导成差分数组, 用差分数组得到答案.</p><p>将题目变形一下会更好理解, 题目要求是x-&gt;y的区间操作, 我们可转变为x - y -&gt; 0的区间操作, 就是将两个数组相减, 然后求得到的数组d变为0的操作数, 我们还可以将思路逆转一下, 0 -&gt; d的区间操作也一定等同于他, 就是说我们可以把d看作是一个原数组, 对其求导得到差分数组, 差分数组就是我们要的答案.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; b[i]; <span class="hljs-comment">// 读入x</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-comment">// 读入y直接 x - y</span><br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        b[i] -= x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i -- ) b[i] -= b[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 求导</span><br>    <br>    <span class="hljs-comment">// 因为差分数组一定是一加一减, 并且sum(+) + sum(-)一定等于0, 那么操作次数其实就是看正数总和就行</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i ++ )<br>        <span class="hljs-keyword">if</span>(b[i] &gt; <span class="hljs-number">0</span>) sum += b[i];<br>    cout &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing4889> 给定 𝑛 次操作，每次操作会让区间 [𝑠𝑖,𝑡𝑖] 区间减 𝑐𝑖，并且给定 𝑚 次付费操作，其中第 𝑖 个操作可以让区间 [𝑎𝑖,𝑏𝑖] 加上 𝑝𝑖，代价为 𝑚𝑖，求让全集非负的最小代价。</p></blockquote><p>这题就是很正常的思路, 是从差分数组求积分变为原数组的过程, 不过加入了空调, 需要通过dfs得到最小代价.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[<span class="hljs-number">200</span>]; <span class="hljs-comment">// 所有牛栏的降温需求</span><br><span class="hljs-type">int</span> b[<span class="hljs-number">200</span>]; <span class="hljs-comment">// 枚举的空调的降温</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a, b, p, m;  <span class="hljs-comment">// 范围, 降温, 花销</span><br>&#125;nodes[<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">// 空调只有10个枚举用不用就行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; m)<br>    &#123;<br>        <span class="hljs-comment">// 将两个差分数组对比, 符合条件就和ans比较</span><br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) a[i] = b[i] + a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i] &lt; p[i] &amp;&amp; p[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ans = <span class="hljs-built_in">min</span>(ans, sum);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不选</span><br>    <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, sum);<br>    <span class="hljs-comment">// 选</span><br>    <span class="hljs-built_in">insert</span>(nodes[u].a, nodes[u].b, nodes[u].p, b);<br>    <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, sum + nodes[u].m);<br>    <span class="hljs-built_in">insert</span>(nodes[u].a, nodes[u].b, -nodes[u].p, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> s, t, c;<br>        cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(s, t, c, p);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) p[i] += p[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, p, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; c;<br>        nodes[i] = &#123;a, b, p, c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing5526> 给定一个序列 𝑎𝑖，每次操作可以选择一个位置 𝑝，令从 𝑎𝑝 开始的每个数都加上一个以 1 或者 -1 为公差的从 1&#x2F;-1 开始的等差数列。最小化让序列归零的操作次数。</p></blockquote><p>这题也是让我们求区间操作的次数的, 如果我们做过第一题应该可以很敏锐地察觉到这应该是求导到差分数组, 但是和第一题不一样的是, 我们的区间操作所构成的结果是一个从1开始公差为1等差数列而不是1! 这时我们应当认识到, 是我们的操作做了积分.</p><p>假设我们的操作本来就是对一个区间加减一, 现在是差分数组 : </p><ul><li>1  0  0  0  0  0  (边界)</li></ul><p>然后我们对其积分, 变成原数组 : </p><ul><li>1  1  1  1  1  1  (边界)</li></ul><p>我们再对其积分, 变成前缀和数组 : </p><ul><li>1  2  3  4  5  6  (边界)</li></ul><p>我们发现, 只要积分两次, 那么我们普通的差分操作就会变成题目中的等差数列区间操作.</p><p>我们的目的是a -&gt; 0, 那么也可以翻转成 0 -&gt; a, 这个过程是通过等差数列区间操作实现的.</p><p>那么只要我们把a求导两次, 就可以把这种操作转化成普通的差分操作.</p><p>由于本题操作区间一定到最右, 所以右边的边界问题就不用考虑了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; s[i];  <span class="hljs-comment">// s</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i -- ) s[i] -= s[i - <span class="hljs-number">1</span>];<span class="hljs-comment">// s -&gt; a</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i -- ) s[i] -= s[i - <span class="hljs-number">1</span>];<span class="hljs-comment">// a -&gt; b</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) ans += <span class="hljs-built_in">abs</span>(s[i]); <span class="hljs-comment">// 正负操作都算</span><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 链表相关</title>
    <link href="/2025/03/04/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/03/04/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>将一个链表的前k个节点反转, 返回反转后的头节点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    k--;<br>    ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>    ListNode* next = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(k --)<br>    &#123;<br>        cur-&gt;next = prev;<br>        prev = cur;<br>        cur = next;<br>        next = next-&gt;next;<br>    &#125;<br>    cur-&gt;next = prev;<br>    head-&gt;next = next;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表反转的每个操作需要关联三个节点, prev, cur, next, 这里没有做长度判断, list长度最少为2.</p><blockquote><p><lc148><code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = head;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 记录 slow 的前一个节点</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 断开 slow 的前一个节点和 slow 的连接</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode dummy; <span class="hljs-comment">// 用哨兵节点简化代码逻辑</span><br>        ListNode* cur = &amp;dummy; <span class="hljs-comment">// cur 指向新链表的末尾</span><br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>                cur-&gt;next = list1; <span class="hljs-comment">// 把 list1 加到新链表中</span><br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 注：相等的情况加哪个节点都是可以的</span><br>                cur-&gt;next = list2; <span class="hljs-comment">// 把 list2 加到新链表中</span><br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = list1 ? list1 : list2; <span class="hljs-comment">// 拼接剩余链表</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果链表为空或者只有一个节点，无需排序</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 找到中间节点，并断开 head2 与其前一个节点的连接</span><br>        <span class="hljs-comment">// 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]</span><br>        ListNode* head2 = <span class="hljs-built_in">middleNode</span>(head);<br>        <span class="hljs-comment">// 分治</span><br>        head = <span class="hljs-built_in">sortList</span>(head);<br>        head2 = <span class="hljs-built_in">sortList</span>(head2);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(head, head2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是对链表进行归并排序, 每个链表的中点用快慢指针法最优找出, 然后分治划分空间, 回溯时左右两个区间的链表一定都是升序的, 排序问题就演变为合并升序链表.</p><blockquote><p><lc138>复制随机链表</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cachedNode.<span class="hljs-built_in">count</span>(head)) &#123;<br>            Node* headNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = headNew;<br>            headNew-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            headNew-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cachedNode[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个是递归做法, 实际就是用一个哈希表保存所有原链表和新链表节点的对应, 如果原节点和新节点已有对应, 那么就是直接返回保存的新节点, 假如还没有新节点, 就造一个新节点.</p><blockquote><p><lc146>LRC缓存, 存储键值对, 有容量限制, 超出容量删除使用最少的节点, 要求查询和插入都是O(1).</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>&#123;<br>        <span class="hljs-type">int</span> key, val;<br>        ListNode* next;<br>        ListNode* prev;<br>        <br>        <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v)<br>            :<span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v)<br>        &#123;<br>            next = prev = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        cap = capacity;<br>        cnt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 把查询的节点头插回前面</span><br>        <span class="hljs-keyword">auto</span> node = mp[key];<br>        <span class="hljs-type">int</span> ret = node-&gt;val;<br>        <span class="hljs-built_in">push_front</span>(node-&gt;key, node-&gt;val);<br>        <span class="hljs-built_in">erase</span>(node);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!mp.<span class="hljs-built_in">count</span>(key))  <span class="hljs-comment">// 新插入</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt == cap) <br>            &#123;<br>                <span class="hljs-type">int</span> tmp = head-&gt;prev-&gt;key;<br>                <span class="hljs-built_in">erase</span>(head-&gt;prev), cnt--;<br>                <span class="hljs-comment">// 把mp中的对应删除</span><br>                mp.<span class="hljs-built_in">erase</span>(tmp);<br>            &#125;<br>            <span class="hljs-built_in">push_front</span>(key, value);<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 修改值</span><br>        &#123;<br>            mp[key]-&gt;val = value;<br>            <span class="hljs-keyword">auto</span> node = mp[key];<br>            <span class="hljs-built_in">push_front</span>(node-&gt;key, node-&gt;val);<br>            <span class="hljs-built_in">erase</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head)<br>        &#123;<br>            ListNode* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(key, value);<br>            newnode-&gt;next = newnode;<br>            newnode-&gt;prev = newnode;<br>            head = newnode;<br>            mp[key] = newnode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(key, value);<br>        newnode-&gt;next = head;<br>        newnode-&gt;prev = head-&gt;prev;<br>        head-&gt;prev-&gt;next = newnode;<br>        head-&gt;prev = newnode;<br>        head = newnode;<br><br>        <span class="hljs-comment">// 头插完顺便插入map</span><br>        mp[key] = newnode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(ListNode* cur)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cur-&gt;prev-&gt;next = cur-&gt;next;<br>        cur-&gt;next-&gt;prev = cur-&gt;prev;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    <span class="hljs-type">int</span> cnt;<br>    ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, ListNode*&gt; mp; <span class="hljs-comment">// key, 对应list中的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是维护一个双向链表和一个哈希表, 哈希表和双向链表的插入都是O(1)(最优情况下), 利用双向链表做类似队列的操作,  哈希表存key和链表节点的映射, 查找时用哈希表O1找到链表节点, 将该节点从当前位置移到队头, 就可以使使用少的节点都往后排, 删除时就删队尾就行.</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非暴力沟通 读书摘录</title>
    <link href="/2025/03/01/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/"/>
    <url>/2025/03/01/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>非暴力沟通帮助我们重新构建表达自己和聆听他人的方式, 使我们的言行不再只是出于自动化反应, 而是牢固地建立在觉察感受和需要的基础上, 做出有意识的回应, 我们既能诚实清晰地表达自己, 也能带着尊重与同理心关注他人, 从而在任何交流中听见自己和他内心深处的呼声.</li><li>由衷的给予和接受, 是人类天性所乐见的.</li></ul><h3 id="疏离生命的语言"><a href="#疏离生命的语言" class="headerlink" title="疏离生命的语言"></a>疏离生命的语言</h3><h4 id="道德评判-作比较-推卸责任-要求-贴标签"><a href="#道德评判-作比较-推卸责任-要求-贴标签" class="headerlink" title="道德评判  作比较 推卸责任 要求 贴标签"></a>道德评判  作比较 推卸责任 要求 贴标签</h4><ul><li>疏离生命的语言让我们陷入充满评判的对与错的世界, 这时候我们关注的往往只是好与坏, 正常还是不正常, 负责还是不负责, 聪明还是愚蠢等等.</li><li>我们一心都在分析和追究自己和他人有什么问题, 却不曾思索自己和他人有什么需要没有得到满足.</li><li>我们在分析和评判时, 其实都是在表达自身的价值观和需要, 但这样的表达方式却是悲剧性的, 引发的是对方的防卫和抗拒. 就算他人遵从了我们, 很有可能是处于恐惧, 内疚或羞愧, 而非发自内心.</li><li>重要的是不要把”价值判断”和”道德评判”混为一谈. </li><li>当我们将行动的原因归咎于外部因素时, 我们便试图推卸自己的责任.</li></ul><h3 id="观察而非评论"><a href="#观察而非评论" class="headerlink" title="观察而非评论"></a>观察而非评论</h3><ul><li>非暴力沟通并不要求我们保持完全客观, 不做任何评论. 他只是强调, 我们要区分观察与评论.</li><li>即使是像”厨师”这样所谓正向或者看上去中性的标签, 也会妨碍我们全面地看到一个人.</li><li>不带评论的观察提倡我们在描述观察时, 清楚地说出特定的时间和情景.</li></ul><h3 id="感受连结需要"><a href="#感受连结需要" class="headerlink" title="感受连结需要"></a>感受连结需要</h3><ul><li><p>我们要学会区感受和想法, 感受不是动词, 名词, 行为, 那其实是想法, 表述一个想法的效果远没有表达感受来得直接.</p></li><li><p>感受源自我们如何看待他人的言行以及我们当时的需要和期待.</p></li><li><p>利用内疚感来推动他人的基本机制, 是通过把自己的感受归咎于他人实现的, 那么改变也只是为了避免愧疚, 而非出自真心.</p></li><li><p>人们更善于分析对方的错, 而非清晰地表达自己的需要.</p></li><li><p>我们既不再为他人的感受承担责任, 又能全然地为自己的意愿, 感受和行为负责.</p></li></ul><h3 id="请求而非要求"><a href="#请求而非要求" class="headerlink" title="请求而非要求"></a>请求而非要求</h3><ul><li>除了使用正向语言, 我们提出的请求越具体越好.</li><li>人们习惯于使用含糊, 抽象的语言将自己的愿望暗示给他人, 却不提及希望对方采取哪些具体的行动.</li><li>要让他人明白我们提出是真正的请求, 最重要的沟通方式是即便在他人拒绝时我们也能同理他们的感受和需要.</li><li>选择请求意味着, 我们首先同理他人为什么没有说是, 而不是要说服他们必须答应我们.</li></ul><h3 id="同理"><a href="#同理" class="headerlink" title="同理"></a>同理</h3><ul><li><p>同理意味着, 以尊重的态度来了解他人的体验, 不去做什么, 只是在哪里.</p></li><li><p>如果一个人需要同理, 我们却试图通过安慰或建议来”搞定”对方的问题, 他人往往会感到沮丧. 所以在给予安慰或建议前, 先核实那是不是对方想要的.</p></li><li><p>事实上, 试图分析问题无法让我们与他人同在. 如果我们只是关心别人的话是否符合我们的理论, 我们是在审视他们, 而没有与他们同在.</p></li><li><p>同理的核心是”临在”, 全然地与他人以及他们当下的体验同在.</p></li><li><p>当我们对他人表达同情时, 就不是在同理他们, 这其实不利于接下来的沟通的.</p></li><li><p>腾出”他人如何看待我”这个想法的空间给天赐之福.</p></li><li><p>同理可以帮助我袒露内心, 平息潜在的暴力, 让乏味变为有趣, 对不和沉默有所应对.</p></li><li><p>痛苦阻碍聆听, 同理舒缓痛苦. 当人们心烦意乱时, 往往需要先得到同理, 才有可能听进去别人的话, 重要的是居于他们足够多的同理, 让他们感受自己的痛苦被看见且理解了.</p></li></ul><h3 id="爱自己"><a href="#爱自己" class="headerlink" title="爱自己"></a>爱自己</h3><ul><li>我们若用暴力或类似暴力的方式对待自己, 就很难真正做到善待他人.</li></ul><h3 id="愤怒"><a href="#愤怒" class="headerlink" title="愤怒"></a>愤怒</h3><ul><li>非暴力沟通并不鼓励我们忽视, 否定或压抑愤怒, 而是通过了解让我们愤怒的核心本质来充分且诚挚地表达自己.</li><li>导致我们愤怒的是那些指责的想法, 它切断了我们和需要的连结.</li><li>暴力之所以产生, 都是因为人们误以为自己的痛苦是由他人造成的, 他人应当受到惩罚.</li><li>如果我们满脑子的实非对错, 评判和分析, 认为别人不好, 贪婪, 不负责任, 说谎, 作弊, 污染环境, 要钱不要命或做了不对的事……不管我们说的和事实有多贴近, 他人并不太可能对我们的需要有兴趣.</li><li>指责和评判使人倾向于自我保护, 并变得更有攻击性, 日后也不可能关心我们的需要.</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在当今的文化中, 人们已经习惯了基于买卖, 有偿或估值来运作的关系, 以至于对于纯粹的施与受, 我们多半会感到不适.</p>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>非暴力沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 不等式 | 同余 + 破换成链</title>
    <link href="/2025/02/28/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E4%B8%8D%E7%AD%89%E5%BC%8F%20%20%E5%90%8C%E4%BD%99%20+%20%E7%A0%B4%E6%8D%A2%E6%88%90%E9%93%BE/"/>
    <url>/2025/02/28/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E4%B8%8D%E7%AD%89%E5%BC%8F%20%20%E5%90%8C%E4%BD%99%20+%20%E7%A0%B4%E6%8D%A2%E6%88%90%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><acwing5439>给定 𝑛 个整数 ℎ𝑖，每次操作会使 ℎ𝑖←ℎ𝑖+𝑎𝑖，求能否在若干次操作后使得 ℎ𝑖 的排名（从大到小）为 𝑡𝑖+1(就是前面有ti个)，如果可以，求最小操作次数，否则输出-1。</p></blockquote><p>这个关键在维护一个区间集, 利用给出的目标排名确定不等式, 每个不等式成立都会给出一个区间, 然后加到这个区间集中</p><p>最后得到的区间集如果成立, 就是符合所有不等式的答案</p><ul><li><p>设经过的天数为x</p></li><li><p>不等式中按照顺序每个不等式都是这样的形式 : <code>h1 + x * a1 &gt; h2 + x * a2</code></p></li><li><p>可以转化为 : <code>x &lt; (h1 - h2) / (a2 - a1)</code></p></li><li><p>于是就要判断<code>a2 - a1</code>, 是否大于0 : </p><ul><li><p><code>&gt; 0</code>  :  <code>x &lt; (h1 - h2) / (a2 - a1)</code> , 小于缩右区间.</p></li><li><p><code>&lt; 0</code> : <code>x &gt; (h1 - h2) / (a2 - a1)</code>, 大于缩左区间.</p></li><li><p><code>= 0</code> : 这时比较h1和h2, 如果h1 &gt; h2, 则 <code>x * 0 &lt; (h1 - h2)</code>永远成立, 如果h1 &lt; h2, 则<code>x * 0 &lt; (h1 - h2)</code>永远无解.</p><p>无解的话则排名不可能实现, 直接退出就行.</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> h[N], a[N], rk[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; h[i];   <span class="hljs-comment">// 高度</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];   <span class="hljs-comment">// 增量</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)                <br>    &#123;<br>        <span class="hljs-type">int</span> w;<br>        cin &gt;&gt; w;<br>        rk[w + <span class="hljs-number">1</span>] = i;  <span class="hljs-comment">// i目标的目标排名</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> A = h[rk[i]] - h[rk[i + <span class="hljs-number">1</span>]];<br>        <span class="hljs-type">int</span> B = a[rk[i + <span class="hljs-number">1</span>]] - a[rk[i]];<br>        <span class="hljs-comment">// 我们对于边界只取整数</span><br>        <span class="hljs-comment">// x &lt; w -&gt; x &lt;= ceil(w) - 1  (x &lt; 1.1 -&gt; x &lt;= 1)</span><br>        <span class="hljs-keyword">if</span>(B &gt; <span class="hljs-number">0</span>) r = <span class="hljs-built_in">min</span>(r, (<span class="hljs-type">int</span>)<span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)A / B) - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// x &gt; w -&gt; x &gt;= floor(w) + 1  (x &gt; 1.1 -&gt; x &gt;= 2)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(B &lt; <span class="hljs-number">0</span>) l = <span class="hljs-built_in">max</span>(l, (<span class="hljs-type">int</span>)<span class="hljs-built_in">floor</span>((<span class="hljs-type">double</span>)A / B) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            r = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt;= r) cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p><acwing6131>给定一个序列 𝑎𝑖，每次操作可以让序列中一个元素加一或者减一，求让所有元素减去某个数 𝑥 之后可以被 𝑚 整除的最小操作数。</p></blockquote><p>这道题的关键在于整除可以转化为同余关系, 在同余下对元素的加减一可以被视为一个循环.</p><p>由题可得, <code>a - x ≡ 0 (mod m)</code> , 所以<code>a ≡ x(mod m)</code>.</p><p>现在问题就转化为了求使ai全部变成x要的最小操作数.</p><p>这种问题有常规解法, 就是排序取中位数, 然后两边可以用前缀和求.</p><p>但这道题是建立在同余的前提下的, 我们其实无法准确判断中位数到底是哪个, 因为每个a的循环的, 到达同一个数可以是加也可以是减, 所以我们无法按照中位数的来决定每个a必定是加还是减.</p><p>于是我们就要遍历每个点, 把每个点都当作中位数进行一次判断, 这种操作在长度为n的数组的中很难实现, 所以可以把数组复制到后面, 使长度变成2n, 这样就可以固定一定区间长度, 移动区间来进行判断.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i], a[i] %= m; <span class="hljs-comment">// 由于a和x同余m, 所以可以先都 % m</span><br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">begin</span>() + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 破环成链</span><br>    <span class="hljs-comment">// 这里至于为什么加m, 其实比较模糊</span><br>    <span class="hljs-comment">// 可以理解为是为了保证a升序, 之后的前缀和计算可以正确进行</span><br>    <span class="hljs-comment">// 我的感觉就是由于所有a都是在0到m-1之间循环, 虽然不确定在正确答案中是向上加还是向下减, </span><br>    <span class="hljs-comment">// 但是还是一定只有两个方向, 这样复制数组再整体加m的做法其实就是促成一个加一个减.</span><br>    <span class="hljs-built_in">rep</span>(i, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] = a[i - n] + m;<br>    <span class="hljs-comment">// 记录前缀和</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) pre[i] = a[i] + pre[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1E18</span>;<br>    <span class="hljs-comment">// 枚举环上每个点</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> l = i, r = i + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 偶数的时候，[mid, r] - [l, mid - 1];</span><br>            res = pre[r] - <span class="hljs-number">2</span> * pre[mid - <span class="hljs-number">1</span>] + pre[l - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 奇数的时候，[mid + 1, r] - [l, mid - 1]; </span><br>            res = pre[r] - pre[mid] - pre[mid - <span class="hljs-number">1</span>] + pre[l - <span class="hljs-number">1</span>];<br>        &#125;<br>        ans = std::<span class="hljs-built_in">min</span>(ans, res);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++线程库使用详解</title>
    <link href="/2025/02/27/C++%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/02/27/C++%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需要传入回调函数, 如果有参数紧跟在后面</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_hello, <span class="hljs-number">1</span>)</span></span>;  <br><span class="hljs-comment">// 当然lambda也可以当作回调函数传进去</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from lambda thread!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><span class="hljs-comment">// 也可以创建时传入回调函数</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(calculate_sum, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, print_result)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><ul><li><p>为什么需要线程等待?</p><p>目的在于<strong>接收信息和同步</strong>.</p><p> join中并没有实际和接收信息相关的操作, 信息交流是靠其他几种线程间通信的方式来实现的. 关键在于如果不用join, 将无法安全使用线程间通信得来的信息, 因为如果不等待子线程运行结束, 主线程和子线程并发运行, 主线程没有办法确定什么时候子线程会得到结果并发送过来, 简单来说就是无法实现同步.</p></li><li><p>可以通过joinable()函数来确定线程是否可join而未被分离.</p></li></ul><h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t<span class="hljs-number">1.</span><span class="hljs-built_in">detach</span>();<br></code></pre></td></tr></table></figure><p>线程分离就是为了实现和线程等待相反的目的, 也就是不需要同步的情况, 当代码不需要和主线程互通有无的时候便可以调用detach, 让线程自己干自己的去.</p><hr><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>这里线程间通信的定义其实很广泛, 可以细化为线程间权限申请, 数据交互, 函数调用等.</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>互斥锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mutex mtx;<br>mtx.<span class="hljs-built_in">lock</span>();<br><span class="hljs-comment">//....</span><br>mtx.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ul><li>RAII风格的锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mutex mtx;<br>&#123;<br><span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 离开作用域自动调用析构函数解锁</span><br> <span class="hljs-comment">// ... 使用lock_guard需要控制作用域   </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Predicate&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure><p>条件变量需要和互斥锁绑定, 并且需要条件撑腰, 在等待时是否原先持有的锁, 被唤醒时重新取回拥有的锁并进行之后的代码, 有两种方式判断条件 : </p><ul><li>直接套在while循环里, 只有符合条件才能离开循环, 这里循环不是意味着要频繁判断, wait本身是阻塞的, 而是为了避免虚假唤醒的情况, 可以理解为系统问题.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex mtx;                    <span class="hljs-comment">// 互斥量</span><br>std::condition_variable cv;         <span class="hljs-comment">// 条件变量</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-keyword">while</span> (!ready) &#123;               <span class="hljs-comment">// 使用while循环避免虚假唤醒</span><br>    cv.<span class="hljs-built_in">wait</span>(lck);               <span class="hljs-comment">// 等待通知</span><br>&#125;<br><span class="hljs-comment">// ... 另一个线程</span><br>cv.<span class="hljs-built_in">notify_all</span>(); <br>cv.<span class="hljs-built_in">notify_one</span>();<br></code></pre></td></tr></table></figure><ul><li><p>使用wait的第二个参数, 传入一个返回值为bool类型的回调函数, 官方称其为谓词.</p><p>谓词只在第一次触发wait和被唤醒之后发生, 如果谓词返回值为true, 则继续后面的代码, 反之继续阻塞挂起.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;  <span class="hljs-comment">// 捕获this,使之可以使用成员函数和变量</span><br>    <span class="hljs-keyword">return</span> stop || !taskQueue.<span class="hljs-built_in">empty</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>其实底层就是对C风格互斥锁和条件变量的封装.</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>这是一个非常宽泛的概念, 我们知道一个进程的不同线程间数据块,堆都是共享的, 所以在其中申请的资源都是共享内存, 锁也是为了应对使用共享内存的情况而被设计的.</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>其实就是STL中的queue, 这个容器其实非常强大, 因为其是线程安全的, 例如我们就可以直接在生产者线程中将产物push进queue, 然后直接在消费者线程中从queue中取出, 这其中没有任何线程安全问题!</p><h3 id="future和promise"><a href="#future和promise" class="headerlink" title="future和promise"></a>future和promise</h3><p>future可以得到未来从其他线程传来的一个结果. </p><p>这里只介绍future在线程中的普通用法, 一般和promise共用.</p><ul><li>future : 未来, 用于表示在未来这里会获取一个结果.</li><li>promise : 承诺, 可以和future关联, 承诺会设置future要获取的结果.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::promise&lt;<span class="hljs-type">int</span>&gt; prom;  <br>std::future&lt;<span class="hljs-type">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">// 将promise和future关联</span><br><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;prom]() &#123; <span class="hljs-comment">// 捕获prom传入线程</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 模拟计算</span></span></span><br><span class="hljs-params"><span class="hljs-function">    prom.set_value(result); <span class="hljs-comment">// promise将结果传递给future</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-type">int</span> value = fut.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 阻塞直到获取结果</span><br>t.<span class="hljs-built_in">join</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>async  : <code>async</code> 是 <strong>asynchronous</strong> 的缩写，表示“异步”的意思. 不过异步这个意义很宽泛, 很多都可以被视为异步. 有些异步相对复杂, 比如异步I&#x2F;O, 有些有十分简单, 比如我们现在学的async.</p><p>其实它的实际功效就是上面future + promise + thread的统合, 可以理解为<strong>和future强绑定的thread</strong>.</p><p>可以向async中传入一个回调函数, async会直接在一个新线程中运行它, 会返回一个future对象, 新线程运行结束会将结果设置到future对象中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args &gt;<br>std::future&lt;std::<span class="hljs-type">invoke_result_t</span>&lt;F, Args...&gt;&gt; <br>  <span class="hljs-built_in">async</span>(F&amp;&amp; f, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><ul><li>f : 用于确定async的启动策略, 一般写<code>std::launch::async</code>, 代表强制任务在新线程中执行.</li><li>args : 可变参数, 传入回调函数需要的参数.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 std::async 启动一个异步任务</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, []() &#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 模拟计算</span><br>    <span class="hljs-keyword">return</span> result;   <span class="hljs-comment">// 返回结果</span><br>&#125;);<br><span class="hljs-comment">// 获取结果（会阻塞直到任务完成）</span><br><span class="hljs-type">int</span> value = fut.<span class="hljs-built_in">get</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="共享内存-vs-消息队列-vs-future"><a href="#共享内存-vs-消息队列-vs-future" class="headerlink" title="共享内存 vs 消息队列 vs future"></a>共享内存 vs 消息队列 vs future</h3><p>这三个其实都可以做到线程间传递数据, 但是应用场景不同.</p><ul><li>共享内存 : 用于多数据, 需求复杂的情况, 需要互斥锁和条件变量维护.</li><li>消息队列 : 适合生产者消费者模型, 简单易用, 线程安全, 但是需要排队, 可能需要条件变量配合.</li><li>future : 只传递单数据, 简单易用, 并且线程安全不需要考虑额外内容.</li></ul><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>原子操作本身和线程间通信没关系, 只是它本身就是为了服务多线程环境的一种语法, 可以减少线程间通信的发生, 取消部分资源对互斥锁的使用, 毕竟它是原子的, 根本不需要锁.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::atomic&lt;<span class="hljs-type">int</span>&gt; x&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 初始化原子变量</span><br>x.<span class="hljs-built_in">store</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 使用 store 进行赋值</span><br><span class="hljs-type">int</span> value = x.<span class="hljs-built_in">load</span>();  <span class="hljs-comment">// 返回原子变量 x 的值</span><br><span class="hljs-type">int</span> old1 = x.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 先返回 x 的值，然后将其加 1</span><br><span class="hljs-type">int</span> old2 = x.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 先返回 x 的值，然后将其减 1</span><br><span class="hljs-type">int</span> old_value = x.<span class="hljs-built_in">exchange</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 将 x 的值设为 20，返回原来的值</span><br><span class="hljs-comment">// 如果当前值等于 expected，则将其替换为 desired，返回是否成功</span><br><span class="hljs-type">bool</span> success = x.<span class="hljs-built_in">compare_exchange_strong</span>(expected, desired); <br><span class="hljs-type">int</span> old3 = x.<span class="hljs-built_in">fetch_and</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位与操作</span><br><span class="hljs-type">int</span> old4 = x.<span class="hljs-built_in">fetch_or</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位或操作</span><br><span class="hljs-type">int</span> old5 = x.<span class="hljs-built_in">fetch_xor</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位异或操作</span><br></code></pre></td></tr></table></figure><p>需要注意的atomic的模板类必须是普通类型, 还有一种情况是 : 在一个自定义类型中全是普通类型允许填入, 术语叫做POD.</p><hr><h2 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h2><p>这是 C++11 引入的一个命名空间，用来提供一些和当前线程相关的操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep_for</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::duration&amp; d)</span></span>; <span class="hljs-comment">// 使当前线程挂起指定的时间</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 休眠2秒</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep_until</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::time_point&amp; t)</span></span>;  <span class="hljs-comment">// 使进程挂起到指定的时间</span><br><span class="hljs-keyword">auto</span> wakeup_time = std::chrono::system_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3秒后</span><br>std::this_thread::<span class="hljs-built_in">sleep_until</span>(wakeup_time);  <span class="hljs-comment">// 休眠直到指定时间</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 一个请求, 表示当前线程愿意让出cpu的时间片, 假如线程间的优先度不同可以使用</span><br>std::this_thread::<span class="hljs-built_in">yield</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="thread的移动语义"><a href="#thread的移动语义" class="headerlink" title="thread的移动语义"></a>thread的移动语义</h2><p>线程对象不可复制, 因为线程本身就不好复制, 从底层来讲thread类的拷贝构造函数本身就是删除的.</p><p>但是thread类可以被移动, 其实就相当于转移控制权, 可以使用move转换.</p><p>假如我们想把多个线程存入一个vector中, 可以使用emplace_back在vector中直接构建, 也可以选择在外部构建然后用move移动进去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(task)</span></span>;  <span class="hljs-comment">// 创建一个线程对象 t</span><br>threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(t));<br></code></pre></td></tr></table></figure><hr><h2 id="简易线程池"><a href="#简易线程池" class="headerlink" title="简易线程池"></a>简易线程池</h2><p>AI生成仅供学习 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span> numThreads) &#123;<br>        <span class="hljs-comment">// 启动指定数量的工作线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>            workers.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; task;<br>                    &#123;<br>                        std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(queueMutex);<br>                        condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;<br>                            <span class="hljs-keyword">return</span> stop || !taskQueue.<span class="hljs-built_in">empty</span>();<br>                        &#125;); <span class="hljs-comment">// 直到return 返回 ture才能进行</span><br>                        <br>                        <span class="hljs-comment">// 如果线程池停止且任务队列为空，退出线程</span><br>                        <span class="hljs-keyword">if</span> (stop &amp;&amp; taskQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br><span class="hljs-comment">// 取出队列不能拷贝, 要移动</span><br>                        task = std::<span class="hljs-built_in">move</span>(taskQueue.<span class="hljs-built_in">front</span>()); <br>                        taskQueue.<span class="hljs-built_in">pop</span>();<br>                    &#125;<br>                    <span class="hljs-comment">// 执行任务</span><br>                    <span class="hljs-built_in">task</span>();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 提交任务</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f)</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (stop) &#123;<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;ThreadPool is stopped&quot;</span>);<br>            &#125;<br>            taskQueue.<span class="hljs-built_in">push</span>(std::forward&lt;F&gt;(f)); <span class="hljs-comment">// 完美转发到队列中</span><br>        &#125;<br>        condition.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 传入一个任务, 就激活等待中的一个线程</span><br>    &#125;<br><br>    <span class="hljs-comment">// 停止线程池</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stopPool</span><span class="hljs-params">()</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex)</span></span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        condition.<span class="hljs-built_in">notify_all</span>();<br><br>        <span class="hljs-keyword">for</span> (std::thread&amp; worker : workers) &#123;<br>            worker.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>        <span class="hljs-keyword">if</span> (!stop) &#123;<br>            <span class="hljs-built_in">stopPool</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::thread&gt; workers;           <span class="hljs-comment">// 工作线程</span><br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; taskQueue;  <span class="hljs-comment">// 任务队列</span><br>    std::mutex queueMutex;                      <span class="hljs-comment">// 任务队列互斥锁</span><br>    std::condition_variable condition;          <span class="hljs-comment">// 条件变量</span><br>    std::atomic&lt;<span class="hljs-type">bool</span>&gt; stop&#123;<span class="hljs-literal">false</span>&#125;;              <span class="hljs-comment">// 是否停止线程池</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">// 创建一个包含4个线程的线程池</span><br>    <span class="hljs-comment">// 提交几个任务给线程池执行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        pool.<span class="hljs-built_in">enqueue</span>([i] &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is being executed by thread &quot;</span> <br>                      &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 停止线程池</span><br>    pool.<span class="hljs-built_in">stopPool</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于对线程库的进一步封装"><a href="#关于对线程库的进一步封装" class="headerlink" title="关于对线程库的进一步封装"></a>关于对线程库的进一步封装</h2><p>通过对线程库的使用我们可以发现, 一旦我们生成thread对象, 线程就已经开始了, 这其实不利于我们对每个线程做精细化处理与记录线程的状态, 我们可以对线程库做进一步封装, 让我们可以随时控制线程的开始与结束并记录线程的状态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 一个Thread对象记录的就是一个新线程的详细信息</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadFunc = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> std::string &amp;name = std::string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _tid; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">bool</span> _joined;<br>    std::shared_ptr&lt;std::thread&gt; _thread;<br>    <span class="hljs-type">pid_t</span> _tid;<br>    ThreadFunc _func;<br>    std::string _name;<br>    <span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated; <span class="hljs-comment">// 记录产生的线程个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated = <span class="hljs-number">0</span>;<br><br>Thread::<span class="hljs-built_in">Thread</span>(ThreadFunc func, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _started(<span class="hljs-literal">false</span>), _joined(<span class="hljs-literal">false</span>), _tid(<span class="hljs-number">0</span>), _func(std::<span class="hljs-built_in">move</span>(func)), _name(name)<br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br>Thread::~<span class="hljs-built_in">Thread</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_started &amp;&amp; !_joined)<br>        _thread-&gt;<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">sem_t</span> sem;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>    _thread = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">thread</span>([&amp;]()&#123;<br>        _tid = CurrentThread::<span class="hljs-built_in">tid</span>();<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<br>        _func(); <span class="hljs-comment">// 在这里真正执行传入的回调函数</span><br>    &#125;));<br><br>    <span class="hljs-comment">// 确保子线程tid已经确定</span><br>    <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _joined = <span class="hljs-literal">true</span>;<br>    _thread-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = ++_numCreated;<br>    <span class="hljs-keyword">if</span> (_name.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        _name = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用智能指针控制thread, 直到我们使用start()才会时线程真正开始, 并且也记录了线程的运作状态与线程id.</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 前缀和|滑动窗口|合并区间</title>
    <link href="/2025/02/25/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E5%89%8D%E7%BC%80%E5%92%8C%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%20%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2025/02/25/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E5%89%8D%E7%BC%80%E5%92%8C%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%20%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><blockquote><p><lc560>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。子数组是数组中元素的连续非空序列。O(nlogn)  </p></blockquote><p>这道题的关键在于如何以O(1)的复杂度发现和为k的子数组个数, 重点在于子数组一定连续, 连续的一段区间的和可以用前缀以O(1)求得, 问题在于如何知道这样的数的个数.</p><p>对于运算到第i处的前缀per[i], 前面可以和其相减得到k的per, 有或没有, 有多少都是问题, 那么就可以进行per值的存储, 要把其数量也一并记录, 那么用map就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(nums.size() + <span class="hljs-number">10</span>)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">// &lt;前缀和, 出现的次数&gt;</span><br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            pre[i] = nums[i];<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) pre[i] += pre[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(pre[i] - k)) ans += mp[pre[i] - k];<br>            mp[pre[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote><p><lc239>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回 <em>滑动窗口中的最大值</em> 。</p></blockquote><p>标准例题, 深入理解的关键在于这里的滑动窗口是一个固定值, 就要把控制窗口的变量和队列的操作分清楚.</p><ul><li><p>队列 : 本题中要维护的是一个单减队列, 就是为了保证队头一定是最大值, 为了实现这个目的, 只要新元素比队尾元素小就要弹出队尾元素, 直到遇到大于等于的.</p></li><li><p>窗口 : 窗口的移动在遍历中实现, 可以想到只要<code>i - k &gt;= 0</code>, 每次向后移动一格就一定会离开一个加入一个.</p></li><li><p>问题的关键在于队列会提前弹出部分元素, 所以队列的实际大小和原窗口是匹配不上的, 也就是说, 即使<code>i - k &gt;= 0</code>, 如果队头还没有到应该弹出的时间, 就不能弹出, 而到了应该弹出的时候就必须弹出.</p></li><li><p>问题就转化成了 : <strong>随着窗口的移动, 如何确定队头所在的元素是否离开了区域?</strong></p><p>其实只需要对比当前要离开的元素是否和队头元素值相等就行了, 因为如果是其他值, 就一定是还没轮到队头, 不然不可能会出现这个队头存在的情况.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 将k范围的内容先入队, 求最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        &#123;<br>            <span class="hljs-comment">// 把小的都去掉, 因为不会影响最大值, 当前最大值就一定在队头</span><br>            <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">size</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &lt; nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(i - k  &gt;= <span class="hljs-number">0</span> &amp;&amp; dq.<span class="hljs-built_in">front</span>() == nums[i - k]) dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">if</span>(i - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ret.<span class="hljs-built_in">push_back</span>(dq.<span class="hljs-built_in">front</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><blockquote><p><lc56>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p></blockquote><p>例题, 核心在于区间需要排序, 我们需要在左端点从小到达排列的前提下去分析才能有效.</p><p>剩下的其实就是控制住当前区间的左右端点[nl, nr], 对新加入的区间[l, r]进行分析 : </p><ul><li>加入l &gt; nr, 那么区间根本不相交, 这是一个新的区间, 于是将大权转移.</li><li>l &lt;&#x3D; nr, 那么区间相交, 接着就是看右端点还需不需要更新 : <ul><li>r &gt; nr,  新的右边界更大, 右边界主权转移.</li><li>r &lt;&#x3D; nr, 说明这个新区间完全被包含在原区间中, 不做调整.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; a = intervals;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> nl = <span class="hljs-number">-1</span>, nr = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> l = a[i][<span class="hljs-number">0</span>], r = a[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(l &gt; nr)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nr != <span class="hljs-number">-1</span>)<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;nl, nr&#125;;<br>                    ret.<span class="hljs-built_in">push_back</span>(v);<br>                &#125;<br>                nl = l, nr = r;<br>            &#125; <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nr &lt; r) nr = r;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;nl, nr&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : ret)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[<span class="hljs-number">0</span>] == nl) <br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) ret.<span class="hljs-built_in">push_back</span>(v);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(8)</title>
    <link href="/2025/02/23/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)/"/>
    <url>/2025/02/23/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第14章 多线程编程</p></blockquote><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>线程是轻量级的进程, 想要理解线程的关键, 首先要理解线程和进程之间的区别.</p><p>一个进程在创建之初其实就可以看作是一个主线程, 其创建出的线程其实和其本质无很大差别, 其实就多了一个线程共享资源罢了, 我们要明晰的是一个进程创建的不同线程之间, 什么是共享的, 什么是独立的.</p><p>线程间共享的 : </p><ul><li>进程地址空间中的代码段, 数据段, 堆</li><li>文件描述符</li><li>信号处理</li><li>环境变量</li><li>进程id</li></ul><p>线程间独立的 : </p><ul><li>线程id</li><li>进程地址空间中的栈</li><li>寄存器状态</li><li>信号掩码(会继承但独立)</li><li>线程局部存储(TLS)</li><li>errno</li></ul><p>只有理解了这些, 我们才可以分析出线程相比于进程, 我们还需要关心什么, 例如 : </p><ul><li>数据段 + 文件描述符共享 -&gt; 需要锁来限制共享内存的访问</li><li>信号处理共享 + 信号掩码独立 -&gt; 可以创建一个线程单独管理信号.</li></ul><hr><h2 id="线程创建及使用"><a href="#线程创建及使用" class="headerlink" title="线程创建及使用"></a>线程创建及使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span>*thread,<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>*attr,<span class="hljs-type">void</span>*(*start_routine)(<span class="hljs-type">void</span>*),<span class="hljs-type">void</span>*arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>*retval)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread,<span class="hljs-type">void</span>**retval)</span></span>;<br></code></pre></td></tr></table></figure><hr><h2 id="线程同步-线程间通信"><a href="#线程同步-线程间通信" class="headerlink" title="线程同步(线程间通信)"></a>线程同步(线程间通信)</h2><p>和线程同步相关的要点也有三种 : </p><h3 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h3><p>进程间通信中已经将了System V信号量l, POSIX信号量的理念和使用方法也相似, 还是可以理解为一种可计数的高级互斥锁.</p><p>POSIX信号量的使用会更加方便一些 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜semaphore.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem,<span class="hljs-type">int</span> pshared,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>sem : 就是标定唯一的信号量的一个标准, 直接创建即可<code>sem_t sem;</code>;</li><li>pshared : 用于指定信号量类型, 如果为0代表是进程局部的信号量, 不为0可以实现进程间共享, 不过这个信号量一般用于线程间通信, 所以用0即可.</li><li>value : 设置信号量的值, 和System V中semctl的作用一致.</li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>这个就是常用的普通锁, 只能被一个线程持有.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex,<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span>*mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>可以用宏的方式替代init : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <br></code></pre></td></tr></table></figure><p>init的第二个参数用于设置互斥锁属性, 一般是NULL.</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond,<span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span>*cond_attr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond,<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>这个名称起的比较晦涩, 但是确实是和”条件”有关, 这个东西是和互斥锁绑定使用的, 你可以理解为互斥锁只负责确保当前只有一个线程可以持有锁, 也就是只用一个线程可以访问共享资源. 而条件变量是在<strong>确保这个共享资源属于可用状态</strong>, <strong>可用状态的判断是靠条件实现的</strong>, 更具体的说就是通过if判断是否触发<code>pthread_cond_wait</code>函数.</p><p>以生产者消费者模型为例, 生产者将产物存入共享内存中, 消费者从共享内存中取出产物, 那么互斥锁可以保证同时只能由一个生产者或消费者访问共享内存, </p><ul><li>但是如果共享内存满了, 生产者再去生产就是浪费, </li><li>如果内存为空, 消费者去取也是徒劳.</li></ul><p>这时条件变量就可以发挥作用 : </p><ul><li>当共享内存满了, 可以将生产者挂起, 直到共享内存有产物被取走为止,</li><li>当共享内存为空, 可以将消费者挂起, 直到共享内存不为空为止.</li></ul><h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h4><p>函数使用和互斥锁相似, init的第二个参数还是设置为NULL就行, 并且也可以用下面的代码替代 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br></code></pre></td></tr></table></figure><ul><li>我们通过条件判断触发pthread_cond_wait, 这个函数会将线程挂起, 并且释放当前持有的锁.</li><li>在我们认为可以满足条件的地方触发pthread_cond_signal, 这个函数会选择一个挂起的线程并唤醒他, 被唤醒的线程会重新持有互斥锁并且继续执行pthread_cond_wait后面的代码.</li></ul><h4 id="CS模型代码案例"><a href="#CS模型代码案例" class="headerlink" title="CS模型代码案例"></a>CS模型代码案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_cond_t</span> cond_var = PTHREAD_COND_INITIALIZER;<br><span class="hljs-type">int</span> shared_data = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 生产者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">while</span> (shared_data != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 条件判断</span><br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex);  <span class="hljs-comment">// 等待条件变量</span><br>    &#125;<br>    <br>    shared_data = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 生产数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产数据: %d\n&quot;</span>, shared_data);<br>    <br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_var);  <span class="hljs-comment">// 唤醒消费者, 这时条件一定满足</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">// 释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">while</span> (shared_data == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex);  <span class="hljs-comment">// 等待条件变量</span><br>    &#125;<br>    <br>    shared_data = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 消费数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费数据: %d\n&quot;</span>, shared_data);<br>    <br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_var);  <span class="hljs-comment">// 唤醒生产者, 这时条件一定满足</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">// 释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> producer_thread, consumer_thread;<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;producer_thread, <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;consumer_thread, <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(producer_thread, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(consumer_thread, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程同步机制包装类"><a href="#线程同步机制包装类" class="headerlink" title="线程同步机制包装类"></a>线程同步机制包装类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOCKER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCKER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜exception＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜semaphore.h＞</span><br><br><span class="hljs-comment">/*封装信号量的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sem</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化信号量*/</span><br>    <span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sem_init</span>(＆m_sem,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/*构造函数没有返回值，可以通过抛出异常来报告错误*/</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁信号量*/</span><br>    ～<span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-built_in">sem_destroy</span>(＆m_sem);<br>    &#125;<br><br>    <span class="hljs-comment">/*等待信号量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_wait</span>(＆m_sem)==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*增加信号量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">post</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_post</span>(＆m_sem)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">sem_t</span> m_sem;<br>&#125;;<br><br><span class="hljs-comment">/*封装互斥锁的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">locker</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化互斥锁*/</span><br>    <span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_mutex_init</span>(＆m_mutex,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁互斥锁*/</span><br>    ～<span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>    &#125;<br><br>    <span class="hljs-comment">/*获取互斥锁*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_lock</span>(＆m_mutex)==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*释放互斥锁*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_unlock</span>(＆m_mutex)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>&#125;;<br><br><span class="hljs-comment">/*封装条件变量的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cond</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化条件变量*/</span><br>    <span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_mutex_init</span>(＆m_mutex,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_cond_init</span>(＆m_cond,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/</span><br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁条件变量*/</span><br>    ～<span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>        <span class="hljs-built_in">pthread_cond_destroy</span>(＆m_cond);<br>    &#125;<br><br>    <span class="hljs-comment">/*等待条件变量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(＆m_mutex);<br>        ret=<span class="hljs-built_in">pthread_cond_wait</span>(＆m_cond,＆m_mutex);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(＆m_mutex);<br>        <span class="hljs-keyword">return</span> ret==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*唤醒等待条件变量的线程*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(＆m_cond)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>    <span class="hljs-type">pthread_cond_t</span> m_cond;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="不可重入函数"><a href="#不可重入函数" class="headerlink" title="不可重入函数"></a>不可重入函数</h2><p>不可重入函数不能在多线程环境下使用, 因为其一般会使用到静态变量, 比如inet_ntoa等.</p><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>我们在上文已经知道线程之间信号处理共享并且信号掩码会继承但独立, 那么我们就可以设置一个单独的信号处理线程.</p><p>相关函数如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_sigmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>*newmask,<span class="hljs-type">sigset_t</span>*oldmask)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigwait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>*set,<span class="hljs-type">int</span>*sig)</span></span>;<br></code></pre></td></tr></table></figure><p>构建流程如下 : </p><ul><li>在主线程构建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码.</li><li>在信号处理线程中调用sigwait来等待信号并处理之.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜errno.h＞</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> handle_error_en(en,msg) do&#123;errno=en;perror(msg);exit(EXIT_FAILURE);&#125;while(0)</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">sig_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">sigset_t</span>* set = (<span class="hljs-type">sigset_t</span>*)arg;<br>    <span class="hljs-type">int</span> s, sig;<br>    <span class="hljs-keyword">for</span>(;;)<br>    &#123;<br>        <span class="hljs-comment">/*第二个步骤，调用sigwait等待信号*/</span><br>        s = <span class="hljs-built_in">sigwait</span>(set, &amp;sig);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;sigwait&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Signal handling thread got signal%d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> thread;<br>    <span class="hljs-type">sigset_t</span> set;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-comment">/*第一个步骤，在主线程中设置信号掩码*/</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;set);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGQUIT);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGUSR1);<br>    s = <span class="hljs-built_in">pthread_sigmask</span>(SIG_BLOCK, &amp;set, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;pthread_sigmask&quot;</span>);<br>    s = <span class="hljs-built_in">pthread_create</span>(&amp;thread, <span class="hljs-literal">NULL</span>, &amp;sig_thread, (<span class="hljs-type">void</span>*)&amp;set);<br>    <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;pthread_create&quot;</span>);<br>    <span class="hljs-built_in">pause</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程局部存储-TLS"><a href="#线程局部存储-TLS" class="headerlink" title="线程局部存储(TLS)"></a>线程局部存储(TLS)</h2><p>线程局部存储（TLS）是一种允许线程拥有独立数据的技术。这意味着每个线程都可以访问同名变量的不同实例，而这些变量在不同线程中不会互相干扰。TLS 在多线程环境中提供了一种为每个线程分配私有存储空间的机制。</p><p>简单来说可以理解为 : </p><ul><li><strong>TLS中的数据像线程的私有全局变量, 避免在各种函数间频繁传入常用的数据降低效率</strong>.</li></ul><p>在 POSIX 系统中，如果你使用 <code>pthread_key_create()</code> 来创建线程局部存储（TLS）键并且关联某些数据，那么你还需要提供一个销毁函数，这个销毁函数会在线程退出时自动调用，用来释放线程局部存储的数据。</p><p>销毁过程：</p><ul><li>在 <code>pthread_key_create()</code> 时，你可以指定一个销毁函数（destructor），这个函数会在线程退出时被调用。</li><li><code>pthread_key_delete()</code> 用于显式地删除一个 TLS 键，销毁相关的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">pthread_key_t</span> t_key;  <span class="hljs-comment">// 定义 TLS 键</span><br><span class="hljs-comment">// 初始化（通常在程序启动时调用）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_tls</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_key_create</span>(&amp;t_key, [](<span class="hljs-type">void</span>* ptr) &#123;<br>        <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// 线程退出时自动释放资源</span><br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 设置线程局部值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_tls_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    *ptr = value;<br>    <span class="hljs-built_in">pthread_setspecific</span>(t_key, ptr);<br>&#125;<br><span class="hljs-comment">// 获取线程局部值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_tls_value</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">pthread_getspecific</span>(t_key);<br>    <span class="hljs-keyword">return</span> ptr ? *ptr : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然以上是操作系统提供的TLS使用, 在实际使用中, GCC和C++11都有提供对应的TLS使用方式</p><ul><li>GCC : <strong><code>__thread</code></strong> 将该关键字置于变量前方, 就可以将该变量作为线程局部资源使用.</li><li>C++11 : <strong><code>thread_local</code></strong> 将该关键字置于变量前方, 也可以实现相同的效果.</li></ul><p>需要注意的一点是<code>__thread</code>只作用于POD类型变量, 而<code>thread_local</code>都可以, 因此更推荐使用<code>thread_local</code>.</p><p>在性能方面 : <code>__thread</code> &gt; <code>thread_local</code> &gt; <code>pthread_key_t</code>.</p><hr><h2 id="浅谈线程设计的初衷"><a href="#浅谈线程设计的初衷" class="headerlink" title="浅谈线程设计的初衷"></a>浅谈线程设计的初衷</h2><p>线程设计的初衷就是在于和多核CPU搭配实现同时并行处理多个任务, 我们可以简单理解线程的合理数量应当和CUP核数相当, 数量太少显示不出线程的优势, 数量太多其额外开销其实会非常多并且还吃力不讨好.</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被讨厌的勇气 读书摘录(2)</title>
    <link href="/2025/02/22/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/"/>
    <url>/2025/02/22/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/</url>
    
    <content type="html"><![CDATA[<ul><li>当人能够感觉到”与这个人在一切可以无拘无束”的时候, 才能体会到爱.</li><li>人究竟为什么要寻求别人的认可呢? 其实, 很多情况下都是因为赏罚教育的影响.</li><li>如果一味地寻求别人的认可, 在意别人的评价, 那最终就会活在别人的人生中.</li><li>我们必须从”这是谁的课题”这一观点出发, 把自己的课题和他人的课题分离开来.</li><li>基本上, 一切人际关系矛盾都起源于对别人的课题妄加干涉或自己的课题被别人妄加干涉.</li><li>可以把马带到水边, 但不能强迫其喝水, 能够改变自己的只有自己.</li><li>正因为是关系紧密的家人, 才更有必要有意识地去分离课题.</li><li>如果不分界限把自己的希望强加给他人, 那就变成粗暴的”干涉”了.</li><li>别人如何评价你的选择, 那是别人的课题, 你根本无法左右.</li><li>不干涉别人的课题, 也不让别人干涉自己的课题.</li><li>要想构筑良好的人际关系也需要保持一定的距离, 如果距离太近, 贴在一起, 那就无法与对方正面对话.</li><li>分离课题并不是以自我为中心, 相反, 干涉别人的课题才是以自我为中心的想法.</li><li>选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其享乐主义, 当然, 这其实是为了让自己接受不自由生活而捏造出的一种人生谎言.</li><li>把改变自己当成操纵他人的手段是一种极其错误的想法.</li><li>人际关系之卡总是掌握在自己手中, 如果执着于认可欲求, 那便是把人际关系之卡抛给了别人.</li><li>我们应该思考的不是他人为我做了什么, 而是我能为他人做什么, 并积极地加以实践.</li><li>对人而言, 最大的不幸就是不喜欢自己.</li><li>是否真正做出了贡献, 从原理上根本无从了解, 只要能够产生”我对他人有用”的主观感受就行.</li><li>所有的问题行为, 都是一种”廉价的优越性追求”.</li><li>普通不等于无能, 我们根本没必要特意炫耀自己的优越性.</li><li>如果感觉能够看得到过去也能预测未来, 那就证明你没有认真的活在此时此刻, 而是生活在模糊而微弱的灯光中.</li><li>聚焦此时此刻是认真而谨慎地做好现在能做的事情.</li><li>人生最大的谎言, 就是不活在此时此刻.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务编程 读书笔记(7)</title>
    <link href="/2025/02/22/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)/"/>
    <url>/2025/02/22/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第13章 多进程编程</p></blockquote><p>本章主要是讨论创建进程, 进程替换, 进程等待, 进程间通信, 最后一个占大头.</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; <br></code></pre></td></tr></table></figure><p>这个只需要记住返回值的判断 : </p><ul><li><p><code>&lt; 0</code> : fork失败.</p></li><li><p><code>== 0 </code>: 属于子进程.</p></li><li><p><code>&gt; 0</code> : 属于父进程.</p></li></ul><p>子进程继承父进程的文件描述符表, 但是父进程设置的信号回调都回取消.</p><hr><h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>**environ;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*file,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*file,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[],<span class="hljs-type">char</span>*<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><hr><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><ul><li>子进程退出之后, 父进程读取其退出状态之前, 子进程都处于僵尸态, 这会占据内核资源, 需要调用wait释放子进程.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/wait.h＞</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*stat_loc)</span></span>;  <span class="hljs-comment">// 等待任一进程</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">int</span>*stat_loc,<span class="hljs-type">int</span> options)</span></span>;  <span class="hljs-comment">// 等待指定进程</span><br></code></pre></td></tr></table></figure><p>默认都是阻塞的, 但是waitpid如果options设置了WHOHANG, 就会变成非阻塞.</p><p>当一个进程结束时, 会向父进程发送SIGCHLD信号, 我们可以捕获这个信号, 在信号回调函数中使用非阻塞waitpid.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">handle_child</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-type">int</span> stat;<br><span class="hljs-keyword">while</span>((pid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,＆stat,WNOHANG))＞<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">/*对结束的子进程进行善后处理*/</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>一种最经典的进程间通信就是管道, 这里不再详述.</p><p>接下来详述三种无关联进程间的通信方式, 这里需要注意虽然是无关进程, 但都是同一主机下的进程, 是依靠主机单独在内核中开辟出一些内容物实现的.</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>我们首先要理解信号量是干什么的 : </p><p>它主要用来<strong>控制对共享资源的访问</strong>,  与其说它是进程间的一种通信方式, 不如说它<strong>可以管控进程间对共享内存的访问</strong>, 其有一个信号量资源, 进程可以调用函数将信号量进行加减操作, 当信号量归0时, 会限制之后需要访问共享内存的进程(挂起), 可以理解为这是<strong>一个有计数功能的专门针对共享资源的高级锁</strong>.</p><p>信号量的核心理念是对信号量进行处理, <strong>在设计共享资源的代码前后, 分别设置P操作和V操作</strong>,  P代表passeren(进入), 会减少信号量; V代表vrijgeven(退出), 会增加信号量. PV操作都有对应的函数可以触发. 你可以类比为P操作就是加锁, V操作就解锁.</p><p>关于信号量的系统函数有两套 : </p><ul><li>System V 信号量 : 早期信号量, 设置复杂, 但是老牌系统都在使用, 只适合多线程环境.</li><li>POSIX 信号量 : 比较简单易用, 适合多线程环境.</li></ul><p>我们先来学习System V信号量 : </p><h4 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sem.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key,<span class="hljs-type">int</span> num_sems,<span class="hljs-type">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来创建一个新的信号量集. </p><ul><li><p>key用来标识一个全局唯一的信号量集, 就是一个唯一关键字, 一般用ftok生成.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>num_sems是要设置的信号量的数目, 一般就一个. </p></li><li><p>最后一个一般0666, 设置访问权限.</p></li></ul><h4 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sem.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id,<span class="hljs-type">int</span> sem_num,<span class="hljs-type">int</span> command,...)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数是用来对建立的信号量集进行设置的函数, </p><ul><li>sem_id : semget的返回值</li><li>sem_num : 信号量集中的索引, 设置为0代表选择信号集中的第一个.</li><li>command : 用来设置进行什么操作, SETVAL代表设置信号集, 后面加要设置的值.</li></ul><p>由于刚建立默认的信号量为0, 无法使用, 必须通过这个函数设置信号量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CONCURRENT 1   <span class="hljs-comment">// 同一时刻只允许一个进程访问共享内存</span></span><br><span class="hljs-built_in">semctl</span>(sem_id, <span class="hljs-number">0</span>, SETVAL, MAX_CONCURRENT);<br></code></pre></td></tr></table></figure><p>假如我们要共享的不是内存而是线程池, 那么这里就大有可为了, 可以根据当前线程池中线程的数量设置信号量, 可以对访问线程数进行限制.</p><h4 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id,<span class="hljs-keyword">struct</span> sembuf*sem_ops,<span class="hljs-type">size_t</span> num_sem_ops)</span></span>;<br></code></pre></td></tr></table></figure><p>这函数用来进行实际的pv操作, sembuf的结构需要细致了解一下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_num;  <span class="hljs-comment">// 信号量的索引</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_op; <span class="hljs-comment">// 操作的数量</span><br><span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_flg;     <span class="hljs-comment">// 额外的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个参数还是如果为0默认选第一个.</li><li>sem_op : p操作就是-1, v操作就是1.</li><li>sem_flg : 一般推荐加上SEM_UNDO, 这个参数的作用是设置回滚操作, 也就是说p操作完, 如果在触发v操作前进程崩溃了, 也会将p操作改变的值恢复回去.</li></ul><p>一般这样配置 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义信号量操作结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> p = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, SEM_UNDO&#125;;  <span class="hljs-comment">// wait 操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SEM_UNDO&#125;;   <span class="hljs-comment">// post 操作</span><br></code></pre></td></tr></table></figure><h4 id="示例：System-V-信号量控制并发数量"><a href="#示例：System-V-信号量控制并发数量" class="headerlink" title="示例：System V 信号量控制并发数量"></a>示例：System V 信号量控制并发数量</h4><p>假设我们有一个资源池，最多允许 3 个进程并发访问，我们会将信号量的初始值设置为 3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CONCURRENT 3</span><br><br><span class="hljs-comment">// 定义信号量操作结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> p = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, SEM_UNDO&#125;;  <span class="hljs-comment">// wait 操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SEM_UNDO&#125;;   <span class="hljs-comment">// post 操作</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;semfile&quot;</span>, <span class="hljs-number">65</span>);   <span class="hljs-comment">// 创建 IPC 键</span><br>    <span class="hljs-type">int</span> sem_id = <span class="hljs-built_in">semget</span>(key, <span class="hljs-number">1</span>, IPC_CREAT | <span class="hljs-number">0666</span>);  <span class="hljs-comment">// 获取信号量</span><br><br>    <span class="hljs-comment">// 设置初始信号量值为 3，表示允许 3 个进程并发访问</span><br>    <span class="hljs-built_in">semctl</span>(sem_id, <span class="hljs-number">0</span>, SETVAL, MAX_CONCURRENT);<br><br>    <span class="hljs-comment">// 模拟进程访问资源</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;p, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 尝试获取信号量</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop p&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 访问共享资源</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process %d is accessing shared resource.\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 模拟工作</span><br><br>    <span class="hljs-comment">// 释放信号量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;v, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) &#123;  <br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop v&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process %d finished accessing shared resource.\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存也是SystemV和POSIX各有一套函数, 这里使用POSIX的. </p><p>简单来说就是向内核申请一块共享内存, 然后通过映射函数(mmap)将这块内存映射到进程的虚拟地址空间上, 使得进程操作这块内存可以像平常一样.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/stat.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜fcntl.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shm_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*name, <span class="hljs-type">int</span> oflag, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shm_unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br></code></pre></td></tr></table></figure><p>这个是用于申请创建共享内存的函数 : </p><ul><li>name : 名字自己起, 最好是”&#x2F;name”这种格式.</li><li>oflag : 用于指定创建方式, O_RDONLY &#x2F; O_RDWR &#x2F; O_CREAT </li><li>mode : 一般是0666</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数通常要搭配shm_open使用, 它用于设定文件大小为length.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>start : 允许用户使用某个特定的地址作为这段内存的起始地址, 设置为NULL自动选择地址.</li><li>length : 内存段的长度.</li><li>port : 设置内存段的访问权限.</li><li>flags : 控制内存段内容被修改后程序的行为.</li><li>fd : 被映射文件对应的文件描述符, 这个通过shm_open生成.</li><li>offset : 设置从文件的何处开始映射.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(6)</title>
    <link href="/2025/02/19/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)/"/>
    <url>/2025/02/19/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第10章 信号</p><p>第11章 定时器</p><p>第12章 libevent</p></blockquote><p>网络服务器一般有三种事件需要处理 : IO事件, 信号事件, 定时器事件.</p><p>这三种事件都可以通过epoll函数来进行统一处理.</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h4 id="信号有什么作用"><a href="#信号有什么作用" class="headerlink" title="信号有什么作用?"></a>信号有什么作用?</h4><p>其实主要是为了处理一些特殊事件, 比如中断系统调用, 触发定时器信号, 管道读写失败发出的信号. 比如说中断进程, 在服务器上直接中断一般不是一个合理的做法, 一般会捕获中断信号, 在做出中断的准备后(如关闭连接, 释放内存, 记录日志)在进行中断进程.</p><h4 id="最重要的两个信号捕获函数"><a href="#最重要的两个信号捕获函数" class="headerlink" title="最重要的两个信号捕获函数"></a>最重要的两个信号捕获函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-function"><span class="hljs-type">_sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span>　sig, _sighandler_t_handler)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction*act, <span class="hljs-keyword">struct</span> sigaction*oact)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p>❑对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</p><p>❑系统异常。比如浮点异常和非法内存段访问。</p><p>❑系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</p><p>❑运行kill命令或调用kill函数。</p><p>服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止。</p><h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a>统一事件源</h4><p>听起来比较高端, 但其实就是把信号事件注册到epoll上, 让epoll可以通过if在处理IO事件的同时可以一并处理信号事件.</p><p>最基础的做法就是 : </p><ul><li>用signal或sigaction把需要捕获的信号获取</li><li>设置一个管道, 在信号回调函数中将信号转发给管道写端.</li><li>将管道的读端的读事件注册进内核事件表中.</li><li>在epoll_wait所在的循环中对管道的读端额外进行监视.</li></ul><p>你可以理解为对于IO事件, epoll通过将sockfd注册进事件表进行监视; 对于信号事件, epoll通过将管道读端注册进内核事件表进行监视.</p><p>以下是一个统一事件源的代码 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><br><span class="hljs-comment">/* 信号处理函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-type">int</span> save_errno = errno;<br>    <span class="hljs-type">int</span> msg = sig;<br>    <span class="hljs-built_in">send</span>(pipefd[<span class="hljs-number">1</span>], (<span class="hljs-type">char</span>*)&amp;msg, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* 将信号值写入管道，以通知主循环 */</span><br>    errno = save_errno;<br>&#125;<br><br><span class="hljs-comment">/* 设置信号的处理函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;<br>    <span class="hljs-built_in">memset</span>(&amp;sa, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">sizeof</span>(sa));<br>    sa.sa_handler = sig_handler;<br>    sa.sa_flags |= SA_RESTART;<br>    <span class="hljs-built_in">sigfillset</span>(&amp;sa.sa_mask);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">sigaction</span>(sig, &amp;sa, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is %d\n&quot;</span>, errno);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd);<br><br>    <span class="hljs-comment">/* 使用 socketpair 创建管道，注册 pipefd[0] 上的可读事件 */</span><br>    ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">setnonblocking</span>(pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">addfd</span>(epollfd, pipefd[<span class="hljs-number">0</span>]);  <br><br>    <span class="hljs-comment">/* 设置一些信号的处理函数 */</span><br>    <span class="hljs-built_in">addsig</span>(SIGHUP);<br>    <span class="hljs-built_in">addsig</span>(SIGCHLD);<br>    <span class="hljs-built_in">addsig</span>(SIGTERM);<br>    <span class="hljs-built_in">addsig</span>(SIGINT);<br><br>    <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!stop_server) &#123;<br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> ((number &lt; <span class="hljs-number">0</span>) &amp;&amp; (errno != EINTR)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br><br>            <span class="hljs-comment">/* 如果就绪的文件描述符是 listenfd，则处理新的连接 */</span><br>            <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);<br>                <span class="hljs-built_in">addfd</span>(epollfd, connfd);<br>            &#125;<br>            <span class="hljs-comment">/* 如果就绪的文件描述符是 pipefd[0]，则处理信号 */</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;<br>                <span class="hljs-type">int</span> sig;<br>                <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>                ret = <span class="hljs-built_in">recv</span>(pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i) &#123;<br>                        <span class="hljs-keyword">switch</span> (signals[i]) &#123;<br>                            <span class="hljs-keyword">case</span> SIGCHLD:<br>                            <span class="hljs-keyword">case</span> SIGHUP:<br>                                <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-keyword">case</span> SIGTERM:<br>                            <span class="hljs-keyword">case</span> SIGINT:<br>                                stop_server = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close fds\n&quot;</span>);<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中比较重点的是 : </p><ul><li><code>ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);</code> 通过socketpair激活pipefd对应的管道</li><li><code>addfd(epollfd, pipefd[0]);</code>  将管道读端注册进内核事件表</li><li><code>addsig</code>函数将需要捕获的信号进行捕获</li><li><code>else if ((sockfd == pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN))</code> 在循环中额外对信号事件做处理.</li></ul><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>其实就是服务器有可能需要有定时触发的机制存在, 所以需要用到Linux中的定时机制.</p><p>Linux提供了三种定时方法，它们是：</p><p>❑socket选项SO_RCVTIMEO和SO_SNDTIMEO。</p><p>❑SIGALRM信号。</p><p>❑I&#x2F;O复用系统调用的超时参数。</p><p>这里比较重要的就是信号触发, SIGALRM是通过调用alarm函数传入触发时间来传出的, 很多定时器都基于这个实现.</p><p>定时器就是一个结构体, 里面一般包含了超时时间和回调函数, 我们在回调函数中处理定时任务.</p><p>最重要的如何实现定时触发, 一般是通过循环调用alarm实现每隔一段时间向系统发送一个SIGALRM信号, 通过统一事件源对SIGALRM信号做对应处理, 一般会调用一个心搏函数(tick), 对所有时间已经超时的定时器调用其回调函数执行定时任务.</p><p>这里还要思考的一个问题是, 定时任务有可能会很多, 我们需要一个容器来装载这些定时器, 考虑到一定是离超时时间越近的会越先被处理, 那么这个用来存储的容器就有一个需要排序的需求, 超时时间越小就越靠前.</p><p>这里有三种容器可供选择 : 链表, 时间轮, 时间堆.</p><ul><li><p>链表 : 从链表的性质判断, 如果要保持链表有序, 插入效率O(N), 删除和执行的效率都是O(1).</p><p>其实这个效率已经不错了, 虽然在理论上不一定比后两种强, 但是考虑到定时器事件在一般情况下需求量很小, 由于链表没有多余操作反而效率会高, 因此libevent也是依据情况在链表和时间堆直接进行选择的.</p></li><li><p>时间轮 : 你可以理解为这是一个环状的哈希表, 每收到一次定时信号就触发环上的一块, 轮转触发.</p></li><li><p>时间堆 : 这就是一个小根堆, 你甚至可以直接用C++的priority_queue来实现这个时间堆, 其插入效率O(lgn), 删除和执行都是O(1), 在理论上确实优于链表.</p></li></ul><hr><h2 id="Libevent-—-高性能I-O框架库"><a href="#Libevent-—-高性能I-O框架库" class="headerlink" title="Libevent — 高性能I&#x2F;O框架库"></a>Libevent — 高性能I&#x2F;O框架库</h2><p>其实就是一个对我们之前学的I&#x2F;O复用函数和信号和定时器进行分装的一个库.</p><p>它实现了 : 统一事件源 &#x2F; 可移植性 &#x2F; 对并发编程的支持.</p><p>使用方法和epoll有类似的地方, 但是简化了大量的步骤, 并且可以用非常接近的使用方法设置IO事件&#x2F;信号事件&#x2F;定时器事件的回调函数.</p><ul><li><p>event_base_new(); </p><p>用于创建一个event_base对象, 你可以理解为这就是一个Reactor实例(基于IO复用的事件处理器).</p></li><li><p>event_new(…) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span>* <span class="hljs-built_in">event_new</span>(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-comment">// 对应的Reactor实例</span><br>                        <span class="hljs-type">evutil_socket_t</span> fd,<span class="hljs-comment">// 对应事件的文件描述符</span><br>                        <span class="hljs-type">int</span> events,<span class="hljs-comment">// 要注册的事件</span><br>                        event_callback_fn callback,<span class="hljs-comment">// 事件回调函数</span><br>                        <span class="hljs-type">void</span> *arg);<span class="hljs-comment">// 事件回调函数需要的参数</span><br></code></pre></td></tr></table></figure><p>这个函数用于注册事件,  三种事件都可以在这个函数中处理 : </p><ul><li><p>fd : 文件描述符, IO事件就是对应socket, 信号事件是对应信号枚举, 定时器事件设置为-1.</p></li><li><p>events : 主要用于描述事件</p><p><code>EV_READ</code>：表示关注文件描述符上的读事件。</p><p><code>EV_WRITE</code>：表示关注文件描述符上的写事件。</p><p><code>EV_SIGNAL</code>：表示关注特定信号事件。</p><p><code>EV_TIMEOUT</code>：表示关注超时事件（定时器）。</p><p><code>EV_PERSIST</code>：表示该事件在触发后不会自动移除，必须手动移除事件。</p><p><code>EV_ET</code>：表示使用边缘触发模式（Edge Triggered）。</p></li><li><p>callback :  需要放入一个event_callback_fn类型的回调函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(*回调函数名)(<span class="hljs-type">evutil_socket_t</span>,<span class="hljs-type">short</span>,<span class="hljs-type">void</span>*arg);  <span class="hljs-comment">// 所有回调函数形式必须是这样</span><br></code></pre></td></tr></table></figure></li><li><p>arg : 用于存放callback需要的参数, 你可以和线程创建相类比.</p></li></ul></li><li><p>event_add(…)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">event_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *ev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用于激活base中的这个事件, event_new负责注册事件, 这个负责激活事件.</p><ul><li>ev : 用event_new构建出来的事件处理器.</li><li>tv : 一个时间参数, IO和信号填NULL就行, 定时器事件需要在这里填入所确定的延时.</li></ul></li><li><p>event_base_dispatch(base); </p><p>这个函数就是触发事件处理器开始循环监视的参数, 进程将阻塞在这里.</p></li><li><p>event_free(struct event *ev);</p></li></ul><p>  释放事件结构体.</p><ul><li><p>event_base_free(struct event_base *base);</p><p>释放事件处理器结构体.</p></li></ul><p>还要注意的是这里的事件被event_new出来并没有被激活, 只有在event_add后才算被激活, 只有激活的事件才会在event_base_dispatch中被处理, 另外如果没有给事件设置<code>EV_PERSIST</code>属性, 事件在触发一次后就会自动被删除, 必须重新add, 但是如果有这个属性, 那么在触发后会依旧处于激活状态, 除非手动event_del.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(5)</title>
    <link href="/2025/02/16/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)/"/>
    <url>/2025/02/16/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第九章 I&#x2F;O复用(1)</p></blockquote><p>本节主要描述三个IO复用函数, select &#x2F; poll &#x2F; epoll.</p><p>这里对select &#x2F; poll只做简要描述, 对epoll做详尽描述.</p><p>所谓I&#x2F;O复用, 就是使程序可通过一些函数<strong>同时监听多个文件描述符</strong>(如socket), 可以即使并发对这些文件描述符上的事件进行处理.</p><p>要注意的一点是I&#x2F;O复用函数本身是<strong>阻塞</strong>的, 它属于同步IO的范畴, 其被广泛使用是因为其同时监听的特性可以大幅提升处理效率.</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/select.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set*readfds, fd_set*writefds, fd_set*exceptfds, <span class="hljs-keyword">struct</span> timeval*timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>nfds : 指定被监听的文件总数.</p></li><li><p>fd_set : 一个整型数组, 其实就是用来存储文件描述符的</p><ul><li>readfds &#x2F; writefds &#x2F; exceptfds 分别对应可读可写异常事件对应的文件描述符集合.</li></ul></li><li><p>timeout : 用来告诉程序select阻塞等待了多久, 是输出型参数.</p></li></ul><hr><h3 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h3><p>我们需要认识哪些情况下文件描述符可以被认为是可读、可写或者出现异常.</p><p>下列情况下socket可读：</p><p>❑socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</p><p>❑socket通信的对方关闭连接。此时对该socket的读操作将返回0。</p><p>❑监听socket上有新的连接请求。</p><p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p><p>下列情况下socket可写：</p><p>❑socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p><p>❑socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p><p>❑socket使用非阻塞connect连接成功或者失败（超时）之后。</p><p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p><hr><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜poll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd*fds, <span class="hljs-type">nfds_t</span> nfds,<span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>nfds其实就是一个整数, 用来记录fds的大小.</p></li><li><p>timeout记录了poll的阻塞超时值, 设置为-1则始终处于阻塞, 0则立即返回.</p></li><li><p>fds需要细讲, 它是一个pollfd类型的数组, pollfd的结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span><br>&#123;<br><span class="hljs-type">int</span> fd;<span class="hljs-comment">/*文件描述符*/</span><br><span class="hljs-type">short</span> events;<span class="hljs-comment">/*注册的事件*/</span><br><span class="hljs-type">short</span> revents;<span class="hljs-comment">/*实际发生的事件，由内核填充*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>fd : 就是要监视的文件描述符.</li><li>events : 这里由用户填入关心的事件.</li><li>revents : 这里会返回实际发生的事件, 由内核填充. 这里返回的事件只会和用户关心的事件有关. &lt;输出型参数&gt;</li></ul><p>在poll中事件用enum列举了出来 : </p><ul><li>POLLIN : 数据可读.</li><li>POLLOUT : 数据可写.</li><li>POLKLERR : 错误.</li><li>POLLHUP : 文件描述符被挂起.</li><li>POLLNVAL : 文件描述符没有被打开.</li><li>……</li></ul></li></ul><p>​和select相比, 可以理解为select只关心读写异常这三个事件, 而poll可通过在fds数组中设置实现对事件的关心和监视.</p><h4 id="poll使用方式"><a href="#poll使用方式" class="headerlink" title="poll使用方式"></a>poll使用方式</h4><p>我们首先要明确的就是这I&#x2F;O复用函数监视的是事件, 不是fd, <strong>是fd上发生的事件</strong>, 这个事件一般是就绪读和就绪写事件.</p><p>我们使用poll首先要设置fds数组 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化 pollfd 数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> fds[MAX_CLIENTS + <span class="hljs-number">1</span>]; <span class="hljs-comment">// +1 用于服务器 socket</span><br><span class="hljs-type">int</span> nfds = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前监视的文件描述符数量</span><br><br><span class="hljs-comment">// 将服务器 socket 添加到 pollfd 数组中</span><br>fds[<span class="hljs-number">0</span>].fd = server_fd;<br>fds[<span class="hljs-number">0</span>].events = POLLIN; <span class="hljs-comment">// 监视可读事件</span><br><br><span class="hljs-comment">// 初始化客户端文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;<br>    fds[i].fd = <span class="hljs-number">-1</span>; <span class="hljs-comment">// -1 表示未使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后将其传入poll函数, 程序运行到这里就会阻塞监听设置fd上的事件了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds, nfds, <span class="hljs-number">-1</span>); <span class="hljs-comment">// -1 表示无限等待</span><br></code></pre></td></tr></table></figure><p>监听的事件发生后就会返回, 然后我们就需要遍历fds, 查看里面的revents, 如果什么都没有发生为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查所有文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>    <span class="hljs-keyword">if</span> (fds[i].revents == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 没有事件发生</span><br>    &#125;<br>    <span class="hljs-comment">// 不为0说明事件发生, 下面可以开始处理事件逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="epoll系列函数"><a href="#epoll系列函数" class="headerlink" title="epoll系列函数"></a>epoll系列函数</h3><p>没错, epoll不是一个函数, 而是一系列函数, 包括epoll_create &#x2F; epoll_ctl &#x2F; epoll_wait函数等.</p><p>你可以理解为其是poll函数的升级版, 它把类似设置fds的行为利用函数在内核中实现, 并且还增加了很多提升效率的功能, 可以说是前两个函数的上位替代, 唯一不足的就是这个函数是Linux专属, 存在跨平台的问题.</p><h4 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>size用于提示事件表具体有多大, 无需准确, 这只是一个提示.</li></ul><p>重要的是这个函数的返回值, 调用该函数会在内核创建一个事件表, 就类似于poll需要自己创建的fds, 函数返回值是<strong>这个事件表的文件描述符</strong>, 一般被叫做epid, 这个返回值会被用作下一个函数<strong>epoll_ctl的第一个参数</strong>.</p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event*event)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>epfd : 用于指定对哪个内核事件表进行操作, 由epoll_create生成.</p></li><li><p>op : 指定操作类型, 三种, EPOLL_CTL_ADD(注册事件) &#x2F; EPOLL_CTL_MOD(修改事件) &#x2F; EPOLL_CTL_DEL(删除事件).</p></li><li><p>fd : 指定fd;</p></li><li><p>event : 用于存放事件类型和事件发生后可能需要的数据.</p><p>epoll_event的结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span><br>&#123;<br><span class="hljs-type">__uint32_t</span> events;<span class="hljs-comment">/*epoll事件*/</span><br><span class="hljs-type">epoll_data_t</span> data;<span class="hljs-comment">/*用户数据*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>events : 和poll中使用方法一致, 事件类型还是那些, 只不过前面要加一个”E”, 另外还加入了两个特殊事件EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键，我们将在后面讨论它们.</li><li>data : 这是一个联合体, 这里其实就是ptr和fd二选一, 我们在poll的pollfd结构体中由一个fd, 这里的fd与之效用相同, 都是为了在事件发生时可以及时使用到事件发生对应socket的fd. 这里ptr其实就是给出一个选择可以自定义一个结构体, 可以不只存入fd, 还可以存入其他需要的信息(例如提前分配的缓冲区的指针, 缓冲区大小).</li></ul><p>epoll_data_t结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span><br>&#123;<br><span class="hljs-type">void</span>*ptr;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">uint32_t</span> u32;<br><span class="hljs-type">uint64_t</span> u64;<br>&#125;<span class="hljs-type">epoll_data_t</span>;<br></code></pre></td></tr></table></figure></li></ul><p>epoll_ctl成功返回0, 失败返回-1并设置errno.</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>这个函数才是epoll真正的执行函数, 前面两个函数都是再进行前置条件的设置, 调用epoll_wait才会开始阻塞进行实际的监视.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,<span class="hljs-keyword">struct</span> epoll_event*events,<span class="hljs-type">int</span> maxevents,<span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>我们看它的参数其实和poll函数非常相似.</p><ul><li>epfd : 选择进行监视的内核事件表.</li><li>events : 这个参数和epoll_ctl中event类型一致, 但是<strong>用法不一样</strong>, 在epoll_ctl中的event是只是单独一个, 目的是为了注册一个fd对应的事件. 在这里events是一个数组, 这是一个<strong>输出型参数</strong>, 用于<strong>存储所有触发了的事件</strong>.</li><li>maxevents : 最多监听多少个事件.</li><li>timeout : 同poll.</li></ul><p>一旦内核事件表中的事件已就绪, epoll_wait将会退出阻塞, 返回就绪的事件个数, 我们便可以去循环遍历events, 对其中的fd进行对应的读写操作.</p><hr><h3 id="poll和epoll的对比"><a href="#poll和epoll的对比" class="headerlink" title="poll和epoll的对比"></a>poll和epoll的对比</h3><p>我们可以感觉到epoll其实是讲poll中许多设置的细节分配到函数中, 并且将这些操作在内核中执行, 使之更加高效.</p><p>另外poll中的fds参数其实兼顾了输入与输出, 这就导致在输出时需要循环判断之前设置的所有事件, 其时间复杂度为O(N). 但epoll中输入由epoll_ctl中的event完成, 输出由epoll_wait中的events完成, events中只包含已就绪的事件, 而不需要再像poll一样循环判断, 其时间复杂度为O(1), 我们可以从下面的代码中直观看出 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*如何索引poll返回的就绪文件描述符*/</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i)<br>&#123;<br><span class="hljs-keyword">if</span>(fds[i].revents &amp; POLLIN)<span class="hljs-comment">/*判断第i个文件描述符是否就绪*/</span><br>&#123;<br><span class="hljs-type">int</span> sockfd=fds[i].fd;<br><span class="hljs-comment">/*处理sockfd*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*如何索引epoll返回的就绪文件描述符*/</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd,events,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">/*仅遍历就绪的ret个文件描述符*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>&#123;<br><span class="hljs-type">int</span> sockfd=events[i].data.fd;<br><span class="hljs-comment">/*sockfd肯定就绪，直接处理*/</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h3><p>根据名字来分析没什么意义, 这里大可以理解为普通模式和高效模式, select和poll都限定普通模式, epoll可以选择普通模式和高效模式, 高效(ET)模式优势在于<strong>减少epoll_wait触发事件的次数从而提高整体效率</strong>, 劣势在于编程难度提高并且兼容性下降(其实不太有).</p><p>认识LT和ET的差别之前, 我们需要认识到, 数据会被内核接收缓冲区接收, 用户要将其通过recv等操作读到用户自己定义的缓冲区中进行处理, 而用户缓冲区和内核接收缓冲区是有本质大小区别的, 用户自己定义的缓冲区不能太大, 因为太大会占用过多内存导致效率下降, 而内核接收缓冲区比较大, 也就是说接收到的数据量有可能很多, 一次读取(recv)可能根本无法读完, LT和ET模式便是在处这种情况的方式上有所差异.</p><p>LT和ET的差别在于 : </p><ul><li>LT模式下, 每次只读满用户缓冲区大小的数据就退出, 通过epoll_wait多次触发事件来读完.</li><li>ET模式下, 一个事件只能被epoll_wait触发一次, 也就是说每次要循环读取数据到用户缓冲区, 直到内核接收缓冲区读完.</li></ul><p>在实操中,  ET模式是对单个fd对应的监听事件设置的, 触发ET模式需要我们对epoll_wait的第四个参数<code>struct epoll_event*event</code>,  其中<code>epoll_event</code>中的events进行设置, 和添加监视读事件一样添加<code>EPOLLET</code>这个参数, 相当于把当前fd监听的事件附加一个ET属性. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> enable_et)</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<span class="hljs-comment">// 监视读就绪事件</span><br>    <span class="hljs-keyword">if</span> (enable_et)<br>    &#123;<br>        event.events |= EPOLLET;<span class="hljs-comment">// 开始ET模式</span><br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);  <span class="hljs-comment">// 将这个事件加进内核事件表中</span><br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数便是向内核事件表注册一个监听fd读事件并且依据enable_et来决定是否使用ET模式的函数, 在我们下面的例子中要用到.</p><p>接下来将展示书中的一份代码, 用于展示LT和ET模式的区别, 本质是一个TCP服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> enable_et)</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<br>    <span class="hljs-keyword">if</span> (enable_et)<br>    &#123;<br>        event.events |= EPOLLET;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lt</span><span class="hljs-params">(epoll_event *events, <span class="hljs-type">int</span> number, <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> listenfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span> (sockfd == listenfd)<br>        &#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>            <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">close</span>(sockfd);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">et</span><span class="hljs-params">(epoll_event *events, <span class="hljs-type">int</span> number, <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> listenfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span> (sockfd == listenfd)<br>        &#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>            <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>                <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK))<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">close</span>(sockfd);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">close</span>(sockfd);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">lt</span>(events, ret, epollfd, listenfd);       <span class="hljs-comment">// LT模式对应的处理方式</span><br>        <span class="hljs-comment">// et(events, ret, epollfd, listenfd);  // ET模式对应的处理方式</span><br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里建议好好分析以下代码再看下面每个函数的作用.</p><ul><li><p>int setnonblocking(int fd)</p><p>这个函数用途是将socket读写操作设置为非阻塞, LT设不设置都行, 因为只读一次并且调用时已经处于读就绪情况. 而ET必须要设置, 因为我们可以看到ET模式下要一直循环读取直到errno为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>才会停止, 如果不是非阻塞读不到数据就卡住了.</p></li><li><p>void addfd(int epollfd, int fd, bool enable_et)</p><p>这个函数就是把注册一个和fd相关的事件到内核事件表上, 可以选择是否开启ET模式.</p></li><li><p>main函数</p><p>很简易地实现了实现了一个TCP连接的接收, 需要注意的是在实现listen操作后, 我们利用addfd把listenfd注册到了内核事件表中, 然后进入到epoll_wait的无限循环中, epoll_wait会对listenfd上的读就绪事件做出反应并触发下面的lt&#x2F;et函数.</p></li><li><p>lt &#x2F; et 函数</p><p>这个函数会接收epoll_wait输出的就绪事件数组, 并遍历进行事件处理.</p><p>通过分析每个事件对应的fd, 判断是listenfd中的建立连接请求事件(sockfd &#x3D;&#x3D; listenfd), 还是普通socket的读就绪事件(events[i].events &amp; EPOLLIN).</p><p>如果是建立连接的请求, 先通过accept得到普通的socketfd, 然后利用addfd将其加入内核事件表中, 根据调用的是lt还是et选择是否启用ET模式, 在这之后epoll_wait也会对这些普通socketfd的读就绪事件做出反应.</p><p>如果是普通读, 则调用recv进行数据读取与处理, 这里LT模式只读取一次就退出, ET模式要持续循环读取直到内核缓冲区被读完.</p></li></ul><p>这里用户缓冲区设置为10, 这里设置的偏小, 但是便于测试, 通过测试我们可以发现确实ET模式下事件的触发次数要少很多 : </p><p><img src="/../img/image/1.png"></p><h4 id="为什么-non-blocking-I-O-和-I-O复用-要同时使用"><a href="#为什么-non-blocking-I-O-和-I-O复用-要同时使用" class="headerlink" title="为什么 non-blocking I&#x2F;O 和 I&#x2F;O复用 要同时使用?"></a>为什么 non-blocking I&#x2F;O 和 I&#x2F;O复用 要同时使用?</h4><p>主要是因为如果输入输出函数是阻塞的话, 就有可能会触发阻塞, 一旦在一个socket事件上触发阻塞, 就无法再处理其他socket上的事件了.尤其是再epoll开ET模式的情况下, 需要利用循环反复读取做到一次性读出数据, 而退出循环的方式就是依靠非阻塞I&#x2F;O的返回值来实现的, 如果不使用非阻塞, 就一定会在读完后触发阻塞.</p><hr><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>这也是类似ET一样可以设置的一个事件属性, 原因是因为一个socket注册的事件可能被触发多次, 如果在<strong>多线程环境</strong>下, 就会出现<strong>两个线程同时操作一个socket</strong>的局面, 这是万万不可的, 一个socket的读事件就应当被一个线程包揽, 不然数据的连贯性就缺失了, 进而处理基本必定失败. </p><p>这一点可以使用epoll的EPOLLONESHOT事件避免.</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p><p>书中的示例代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fds</span> &#123;<br>    <span class="hljs-type">int</span> epollfd;<br>    <span class="hljs-type">int</span> sockfd;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> oneshot)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-keyword">if</span> (oneshot) &#123;<br>        event.events |= EPOLLONESHOT;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset_oneshot</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = ((fds*)arg)-&gt;sockfd;<br>    <span class="hljs-type">int</span> epollfd = ((fds*)arg)-&gt;epollfd;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;foreiner closed the connection\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EAGAIN) &#123;<br>                <span class="hljs-built_in">reset_oneshot</span>(epollfd, sockfd);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get content:%s\n&quot;</span>, buf);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++) &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);<br>                <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>                <span class="hljs-type">pthread_t</span> thread;<br>                fds fds_for_new_worker;<br>                fds_for_new_worker.epollfd = epollfd;<br>                fds_for_new_worker.sockfd = sockfd;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;thread, <span class="hljs-literal">NULL</span>, worker, (<span class="hljs-type">void</span>*)&amp;fds_for_new_worker);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实内容和上一个例子大差不差, 多的就是普通读改为使用多线程, 并且读完要调用reset_oneshot重新设置EPOLLONESHOT这一事件属性, 这样可以保证同一时间只有一个线程读取一个socket.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(4)</title>
    <link href="/2025/02/15/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/"/>
    <url>/2025/02/15/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第八章 高性能服务器程序框架</strong></p></blockquote><p>本章意在抛出一些核心的概念, 实操基本没有, 但是这些概念的理解我认为相对重要, 我会以口语化的形式简要描述.</p><h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><ul><li>C&#x2F;S模型 : 客户端&#x2F;服务端, 最基础的服务器模型, 资源集中在服务端, 主要是客户端向服务端申请资源.</li><li>p2p模型 : 每个主机都可以是客户端和服务端, 每个主机上都会存有一定的资源, 每个主机利用洪泛向每个点申请资源.</li></ul><hr><h2 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h2><p><img src="/../img/image/2.png"></p><ul><li>I&#x2F;O处理单元 : 用于处理客户连接, 实现负载均衡, 可以用主线程实现, 也可以直接用Nginx.</li><li>逻辑单元 : 一般是一个进程或线程, 一般用于处理核心逻辑, 也可进行数据的收发(依事件处理模式而定).</li><li>网络存储单元 : 就是数据库, 比如mysql.</li><li>请求队列 : 就是以上三者之间通信方式的抽象, 一般用池实现, 里面存放已经建立好的TCP连接.</li></ul><hr><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>其实就在确定数据在收发时是阻塞还是非阻塞, 是同步还是异步.</p><ul><li><p>阻塞和非阻塞属于<strong>数据准备</strong>阶段, 是系统IO操作的<strong>就绪状态</strong>.</p></li><li><p>同步和异步属于<strong>数据读写</strong>阶段, 是<strong>应用程序和内核的交互方式</strong>.</p></li><li><p>阻塞 : 在IO操作就绪时, 进程将被阻塞, 等待IO数据收发.</p></li><li><p>非阻塞 : 在IO操作就绪时, 会立即做出判断, 给出返回值, 退出函数, 通过返回值判断收发是否正常.</p></li><li><p>同步I&#x2F;O : 读写操作在IO事件发生之后, 由应用程序本身完成.</p><p>阻塞IO &#x2F; IO复用 &#x2F; SIGIO信号 都属于同步IO</p></li><li><p>异步I&#x2F;O : 读写操作由内核完成, 应用程序只是提前设置缓冲区位置和IO操作完成后的通知函数.</p></li></ul><hr><h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><p>服务器程序通常需要处理三类事件：I&#x2F;O事件、信号及定时事件。</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>这是一种同步IO模式, 其中线程分为主线程和工作线程, 主线程负责监视socket是否有信息发送过来, 工作线程负责读写以及核心逻辑.</p><p>简略步骤如下 : </p><ul><li>主线程通过epoll注册socket的读就绪事件. </li><li>主线程调用epoll_wait等待注册的socket发来消息.</li><li>某个socket可读时, 将其分发给工作线程.</li><li>工作线程进行读取并处理核心逻辑, 如果需要回复, 就用ekpoll注册写就绪事件.</li><li>主线程也会调用epoll_wait等待写事件.</li><li>当socket可写时, 主线程再将其分发给一个工作进程进行写操作.</li></ul><p><img src="/../img/3.png"></p><h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>一种异步IO模式, 基础思想与Reactor模式一直, 但是利用异步IO的机制减去了工作线程的读写工作, 读写工作由内核实现, 只需要设置通知函数唤醒工作线程.</p><p><img src="/../img/image/4.png"></p><hr><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>这个名字真的很高端, 但实际有更简单的理解.</p><p>这是一个逻辑单元内部的高效编程手法, 可以简单理解为把一个事务分解成多个执行的阶段, 用enum把这些状态列举出来, 再用switch通过判断当前事务状态来分别调用对应的处理函数. </p><p>比如我们要对HTTP请求进行读取和分析, http报文有请求行&#x2F;请求报头&#x2F;请求正文三个部分, 由于TCP传输一次传输可能不完整, 我们可能读不完全, 我们可以把状态分为请求行读取, 报头读取, 正文读取, 在不同的状态执行不同的读写操作和处理操作. 并且我们也应当设置合理的状态转移, 比如当前状态为请求行读取, 在相关操作处理完后, 那么状态就应当被转化为报头读取.</p><p>下面是完整的代码, 确实非常冗长, 上面这一段算是我最精简的概括了, 其实经过求证其实也没有多大必要去详细记住, 因为现在有很多的http库可以解决这方面的问题, 我们主要是重在理解这个概念.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 4096 <span class="hljs-comment">/* 读缓冲区大小 */</span></span><br><br><span class="hljs-comment">/* 主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CHECK_STATE</span> &#123;<br>    CHECK_STATE_REQUESTLINE = <span class="hljs-number">0</span>,<br>    CHECK_STATE_HEADER<br>&#125;;<br><br><span class="hljs-comment">/* 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LINE_STATUS</span> &#123;<br>    LINE_OK = <span class="hljs-number">0</span>,<br>    LINE_BAD,<br>    LINE_OPEN<br>&#125;;<br><br><span class="hljs-comment">/* 服务器处理HTTP请求的结果：NO_REQUEST表示请求不完整，需要继续读取客户数据；GET_REQUEST表示获得了一个完整的客户请求；BAD_REQUEST表示客户请求有语法错误；FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；INTERNAL_ERROR表示服务器内部错误；CLOSED_CONNECTION表示客户端已经关闭连接了 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HTTP_CODE</span> &#123;<br>    NO_REQUEST,<br>    GET_REQUEST,<br>    BAD_REQUEST,<br>    FORBIDDEN_REQUEST,<br>    INTERNAL_ERROR,<br>    CLOSED_CONNECTION<br>&#125;;<br><br><span class="hljs-comment">/* 为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *szret[] = &#123;<span class="hljs-string">&quot;I get a correct result\n&quot;</span>, <span class="hljs-string">&quot;Something wrong\n&quot;</span>&#125;;<br><br><span class="hljs-comment">/* 从状态机，用于解析出一行内容 */</span><br><span class="hljs-function">LINE_STATUS <span class="hljs-title">parse_line</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> &amp;checked_index, <span class="hljs-type">int</span> &amp;read_index)</span> </span>&#123;<br>    <span class="hljs-type">char</span> temp;<br>    <span class="hljs-comment">/* checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节，read_index指向buffer中客户数据的尾部的下一字节。buffer中第0～checked_index字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨个分析 */</span><br>    <span class="hljs-keyword">for</span> (; checked_index &lt; read_index; ++checked_index) &#123;<br>        <span class="hljs-comment">/* 获得当前要分析的字节 */</span><br>        temp = buffer[checked_index];<br>        <span class="hljs-comment">/* 如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行 */</span><br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-string">&#x27;\r&#x27;</span>) &#123;<br>            <span class="hljs-comment">/* 如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据，那么这次分析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析 */</span><br>            <span class="hljs-keyword">if</span> ((checked_index + <span class="hljs-number">1</span>) == read_index) &#123;<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            &#125;<br>            <span class="hljs-comment">/* 如果下一个字符是“\n”，则说明我们成功读取到一个完整的行 */</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer[checked_index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-comment">/* 否则的话，说明客户发送的HTTP请求存在语法问题 */</span><br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>        <span class="hljs-comment">/* 如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((checked_index &gt; <span class="hljs-number">1</span>) &amp;&amp; buffer[checked_index - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\r&#x27;</span>) &#123;<br>                buffer[checked_index - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析 */</span><br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>&#125;<br><br><span class="hljs-comment">/* 分析请求行 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_requestline</span><span class="hljs-params">(<span class="hljs-type">char</span> *temp, CHECK_STATE &amp;checkstate)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *url = <span class="hljs-built_in">strpbrk</span>(temp, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-comment">/* 如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题 */</span><br>    <span class="hljs-keyword">if</span> (!url) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *url++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-type">char</span> *method = temp;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 仅支持GET方法 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The request method is GET\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    url += <span class="hljs-built_in">strspn</span>(url, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-type">char</span> *version = <span class="hljs-built_in">strpbrk</span>(url, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!version) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *version++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    version += <span class="hljs-built_in">strspn</span>(version, <span class="hljs-string">&quot;\t&quot;</span>);<br><br>    <span class="hljs-comment">/* 仅支持HTTP/1.1 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(version, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    <span class="hljs-comment">/* 检查URL是否合法 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(url, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">7</span>;<br>        url = <span class="hljs-built_in">strchr</span>(url, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!url || url[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The request URL is:%s\n&quot;</span>, url);<br><br>    <span class="hljs-comment">/* HTTP请求行处理完毕，状态转移到头部字段的分析 */</span><br>    checkstate = CHECK_STATE_HEADER;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><br><span class="hljs-comment">/* 分析头部字段 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_headers</span><span class="hljs-params">(<span class="hljs-type">char</span> *temp)</span> </span>&#123;<br>    <span class="hljs-comment">/* 遇到一个空行，说明我们得到了一个正确的HTTP请求 */</span><br>    <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(temp, <span class="hljs-string">&quot;Host:&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 处理“HOST”头部字段 */</span><br>        temp += <span class="hljs-number">5</span>;<br>        temp += <span class="hljs-built_in">strspn</span>(temp, <span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the request host is:%s\n&quot;</span>, temp);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 其他头部字段都不处理 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I can not handle this header\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><br><span class="hljs-comment">/* 分析HTTP请求的入口函数 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_content</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> &amp;checked_index, CHECK_STATE &amp;checkstate, <span class="hljs-type">int</span> &amp;read_index, <span class="hljs-type">int</span> &amp;start_line)</span> </span>&#123;<br>    LINE_STATUS linestatus = LINE_OK; <span class="hljs-comment">/* 记录当前行的读取状态 */</span><br>    HTTP_CODE retcode = NO_REQUEST; <span class="hljs-comment">/* 记录HTTP请求的处理结果 */</span><br><br>    <span class="hljs-comment">/* 主状态机，用于从buffer中取出所有完整的行 */</span><br>    <span class="hljs-keyword">while</span> ((linestatus = <span class="hljs-built_in">parse_line</span>(buffer, checked_index, read_index)) == LINE_OK) &#123;<br>        <span class="hljs-type">char</span> *temp = buffer + start_line; <span class="hljs-comment">/* start_line是行在buffer中的起始位置 */</span><br>        start_line = checked_index; <span class="hljs-comment">/* 记录下一行的起始位置 */</span><br><br>        <span class="hljs-comment">/* checkstate记录主状态机当前的状态 */</span><br>        <span class="hljs-keyword">switch</span> (checkstate) &#123;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: &#123; <span class="hljs-comment">/* 第一个状态，分析请求行 */</span><br>                retcode = <span class="hljs-built_in">parse_requestline</span>(temp, checkstate);<br>                <span class="hljs-keyword">if</span> (retcode == BAD_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER: &#123; <span class="hljs-comment">/* 第二个状态，分析头部字段 */</span><br>                retcode = <span class="hljs-built_in">parse_headers</span>(temp);<br>                <span class="hljs-keyword">if</span> (retcode == BAD_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retcode == GET_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> GET_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析 */</span><br>    <span class="hljs-keyword">if</span> (linestatus == LINE_OPEN) &#123;<br>        <span class="hljs-keyword">return</span> NO_REQUEST;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is:%d\n&quot;</span>, errno);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">char</span> buffer[BUFFER_SIZE]; <span class="hljs-comment">/* 读缓冲区 */</span><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>        <span class="hljs-type">int</span> data_read = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> read_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 当前已经读取了多少字节的客户数据 */</span><br>        <span class="hljs-type">int</span> checked_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 当前已经分析完了多少字节的客户数据 */</span><br>        <span class="hljs-type">int</span> start_line = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 行在buffer中的起始位置 */</span><br><br>        <span class="hljs-comment">/* 设置主状态机的初始状态 */</span><br>        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 循环读取客户数据并分析之 */</span><br>            data_read = <span class="hljs-built_in">recv</span>(fd, buffer + read_index, BUFFER_SIZE - read_index, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (data_read == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reading failed\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data_read == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;remote client has closed the connection\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            read_index += data_read;<br><br>            <span class="hljs-comment">/* 分析目前已经获得的所有客户数据 */</span><br>            HTTP_CODE result = <span class="hljs-built_in">parse_content</span>(buffer, checked_index, checkstate, read_index, start_line);<br>            <span class="hljs-keyword">if</span> (result == NO_REQUEST) &#123; <span class="hljs-comment">/* 尚未得到一个完整的请求 */</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == GET_REQUEST) &#123; <span class="hljs-comment">/* 得到一个完整的、正确的HTTP请求 */</span><br>                <span class="hljs-built_in">send</span>(fd, szret[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>(szret[<span class="hljs-number">0</span>]), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 其他情况表示发生错误 */</span><br>                <span class="hljs-built_in">send</span>(fd, szret[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>(szret[<span class="hljs-number">1</span>]), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说这里有两个状态机, 分为主状态机和从状态机, 从状态机用于解析出一行的内容, 主状态机用于根据当前状态选择不同的处理函数.</p><hr><h2 id="提高服务器性能的其他建议"><a href="#提高服务器性能的其他建议" class="headerlink" title="提高服务器性能的其他建议"></a>提高服务器性能的其他建议</h2><h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>以空间换时间, 即“浪费”服务器的硬件资源, 以换取其运行效率, 这就是池（pool）的概念。</p><p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。</p><p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。</p><ul><li><p>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</p></li><li><p>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程。</p></li><li><p>连接池通常用于服务器或服务器机群的内部永久连接。每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。</p></li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>应当避免不必要的数据复制, 这就在要求我们善用内核处理函数, 例如sendfile, splice, tee等, 这些函数都是在内核空间中直接进行, 避免了向用户空间的拷贝. 当然共享内存也是一个很有用的手段.</p><h3 id="上下文切换和锁"><a href="#上下文切换和锁" class="headerlink" title="上下文切换和锁"></a>上下文切换和锁</h3><p>我们知道进程切换和线程切换也是会导致系统开销的, 使工作线程的数量保持在一个合理的范围内也是一个必要的行为. </p><p>另外还有锁, 锁会带来大量的系统开销, 所以要善用读写锁等锁机制.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被讨厌的勇气 读书摘录(1)</title>
    <link href="/2025/02/15/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2025/02/15/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li>如果一味地关注过去的原因, 企图仅仅靠原因去解释事务, 那就会陷入决定论.</li><li>事实上我们会从经历中发现符合自己目的的因素. 决定我们自身的不是过去的经历, 而是我们自己赋予经历的意义.</li><li>但关键是经历本身不会决定什么. 我们给过去的经历”赋予了什么样的意义”, 这直接决定了我们的生活. 人生不是别人赋予的, 而是由自己选择的, 是自己选择自己如何生活.</li><li>如果不能感到幸福的话, 就不可以一直这样, 不可以止步不前, 必须不断向前迈进.</li><li>之所以无法改变, 是因为自己下了”不改变的决心”. 即使有些人有各种不满, 但却拿不出改变生活方式的勇气, 反而拒绝去改变, 牺牲当下本可以享受的乐趣, 维持痛苦的现状.</li><li>应该去做–这一简单的课题摆在眼前, 但却不断扯出各种不能做的理由, 你难道不认为这是一种很痛苦的生活方式吗?</li><li>借助权势来抬高自己的人终究是活在他人的价值观和人生中, 这是必须重点强调的地方.</li><li>弱势具有特权, 有些人以自己的不幸作为武器来支配对方, 其实就是在借助不幸来显示自己的特别, 想要用不幸这一点来压住别人. 这种人是可悲且令人无语的, 因为他在”使用”不幸的同时, 就会永远需要不幸, 进而永远无法抛开不幸.</li><li>健全的自卑感不是来自与别人的比较, 而是来自与”理想的自己”.</li><li>我们应当积极看待自己与别人的差异, 但是, 我们虽然不同但是平等.</li><li>s那就是无论认为自己多么正确, 也不要以此为理由去责难对方.</li><li>“我是正确的”这种坚信意味着坚持”对方是错误的”, 最终会演变为权力之争.</li><li>追求优越性不是通过与他人的竞争来完成的.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(3)</title>
    <link href="/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第七章 Linux服务器程序规范</strong></p></blockquote><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h3><p>一个非常强大的日志管理工具，它是现代 Linux 和 Unix 系统中默认的日志守护进程之一.</p><p>它负责收集、存储和转发来自操作系统和应用程序的日志消息.</p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>一个用于向rsyslog系统发送日志进行存储的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜syslog.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">syslog</span><span class="hljs-params">(<span class="hljs-type">int</span> priority, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*message,...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>priority用来描述这个日志消息的类别级别等信息.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 消息类别</span><br>LOG_USER（值 <span class="hljs-number">1</span>）: 用户应用程序消息<br>LOG_DAEMON（值 <span class="hljs-number">3</span>）: 守护进程消息<br>LOG_SYSLOG（值 <span class="hljs-number">4</span>）: 系统日志相关消息<br>LOG_LOCAL0 到 LOG_LOCAL7（值 <span class="hljs-number">16</span> 到 <span class="hljs-number">23</span>）: 用户定义的本地类别<br><span class="hljs-comment">// 消息级别</span><br>LOG_EMERG（<span class="hljs-number">0</span>）：紧急情况，系统无法使用<br>LOG_ALERT（<span class="hljs-number">1</span>）：需要立即采取行动<br>LOG_CRIT（<span class="hljs-number">2</span>）：临界情况<br>LOG_ERR（<span class="hljs-number">3</span>）：错误<br>LOG_WARNING（<span class="hljs-number">4</span>）：警告<br>LOG_NOTICE（<span class="hljs-number">5</span>）：普通但需要注意的消息<br>LOG_INFO（<span class="hljs-number">6</span>）：一般信息<br>LOG_DEBUG（<span class="hljs-number">7</span>）：调试信息<br></code></pre></td></tr></table></figure><p>这些信息用”|”运算符连接.</p><p>类别可以不填, 默认为LOG_USER, 也可以在openlog中设置.</p></li><li><p>后面用来填写要保存的日志信息, 是一个模板和可变参数, 可以这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;This is a simple log message.&quot;</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *username = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;User %s has logged in.&quot;</span>, username);<br></code></pre></td></tr></table></figure></li></ul><h3 id="openlog-closelog"><a href="#openlog-closelog" class="headerlink" title="openlog &#x2F; closelog"></a>openlog &#x2F; closelog</h3><p>其实就是使用syslog要用到的构造和析构函数. </p><p>openlog不写使用syslog会隐式调用该函数, closelog必须显式调用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜syslog.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">openlog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*ident,<span class="hljs-type">int</span> logopt,<span class="hljs-type">int</span> facility)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closelog</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_PID 0x01<span class="hljs-comment">/*在日志消息中包含程序PID*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_CONS 0x02<span class="hljs-comment">/*如果消息不能记录到日志文件，则打印至终端*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ODELAY 0x04<span class="hljs-comment">/*延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_NDELAY 0x08<span class="hljs-comment">/*不延迟打开日志功能*/</span></span><br></code></pre></td></tr></table></figure><p>facility参数可用来修改syslog函数中的默认设施值, 可以提前设置日志类别 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">openlog</span>(<span class="hljs-string">&quot;MyApp&quot;</span>, LOG_PID | LOG_CONS, LOG_USER);<br><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;This is an info message.&quot;</span>);<br><span class="hljs-built_in">closelog</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="uid-euid"><a href="#uid-euid" class="headerlink" title="uid &#x2F; euid"></a>uid &#x2F; euid</h3><ul><li><p><strong><code>uid</code></strong> 是进程的真实用户 ID，标识启动进程的用户。</p></li><li><p><strong><code>euid</code></strong> 是进程的有效用户 ID，决定进程的权限级别。</p><p>euid存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</p></li><li><p><strong><code>getuid</code></strong> 和 <strong><code>geteuid</code></strong> 用于获取 <code>uid</code> 和 <code>euid</code>，常用于权限检查、权限切换和调试。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uid_t</span> uid=<span class="hljs-built_in">getuid</span>();<br><span class="hljs-type">uid_t</span> euid=<span class="hljs-built_in">geteuid</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;userid is%d,effective userid is:%d\n&quot;</span>,uid,euid);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用 : 根据当前用户的权限执行不同的操作 &#x2F; 用于调试和日志记录.</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>将以root身份启动的进程切换为以一个普通用户身份运行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">switch_to_user</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> user_id,<span class="hljs-type">gid_t</span> gp_id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*先确保目标用户不是root*/</span><br><span class="hljs-keyword">if</span>((user_id==<span class="hljs-number">0</span>)＆＆(gp_id==<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">/*确保当前用户是合法用户：root或者目标用户*/</span><br><span class="hljs-type">gid_t</span> gid=<span class="hljs-built_in">getgid</span>();<br><span class="hljs-type">uid_t</span> uid=<span class="hljs-built_in">getuid</span>();<br><span class="hljs-keyword">if</span>(((gid!=<span class="hljs-number">0</span>)||(uid!=<span class="hljs-number">0</span>))＆＆((gid!=gp_id)||(uid!=user_id))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">/*如果不是root，则已经是目标用户*/</span><br><span class="hljs-keyword">if</span>(uid!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br><span class="hljs-comment">/*切换到目标用户*/</span><br><span class="hljs-keyword">if</span>((<span class="hljs-built_in">setgid</span>(gp_id)＜<span class="hljs-number">0</span>)||(<span class="hljs-built_in">setuid</span>(user_id)＜<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都有自己的pid, 也会有自己的pgid, pgid是自己所在的进程组id.</p><p>每个进程组都有一个首领进程, 首领进程的pid将会被用作进程组的id, 作用仅限于此.</p><p>一个进程组中的进程有共同作用, 如果一个接收了SIGINT信号, 其他几个也会一并退出.</p><p>父子进程就默认属于同一个进程组, 但也可以通过setsid来改变.</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话（session）.</p><p>通过会话，操作系统可以更高效地管理进程组和终端交互，并为用户提供强大的作业控制功能。</p><h4 id="会话的作用"><a href="#会话的作用" class="headerlink" title="会话的作用"></a><strong>会话的作用</strong></h4><p>（1）<strong>终端管理</strong></p><ul><li>会话与终端关联，决定了哪些进程组可以访问终端。</li><li>每个会话有一个前台进程组（Foreground Process Group），只有前台进程组中的进程可以从终端读取输入、向终端输出，并接收终端的控制信号（如 <code>Ctrl+C</code> 发送的 <code>SIGINT</code>）。</li></ul><p>（2）<strong>作业控制</strong></p><ul><li>会话支持作业控制（Job Control），允许用户在前台和后台之间切换任务。</li><li>例如，Shell 可以将一个作业（如管道命令）放到前台或后台运行。</li></ul><p>（3）<strong>信号管理</strong></p><ul><li>会话可以统一管理信号。</li><li>例如，当终端断开连接时，会话首进程会收到 <code>SIGHUP</code> 信号，通常会导致会话中的所有进程终止。</li></ul><p>（4）<strong>资源管理</strong></p><ul><li>会话可以统一管理资源。</li><li>例如，当会话首进程终止时，操作系统会向会话中的所有进程发送 <code>SIGHUP</code> 信号，终止整个会话。</li></ul><h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">char</span>*<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span>*buf,<span class="hljs-type">size_t</span> size)</span></span>;  <span class="hljs-comment">// 获取当前的工作目录</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path)</span></span>;<span class="hljs-comment">// 改变当前工作目录</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chroot</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path)</span></span>;<span class="hljs-comment">// 改变根目录</span><br></code></pre></td></tr></table></figure><h3 id="服务器程序后台化-守护进程"><a href="#服务器程序后台化-守护进程" class="headerlink" title="服务器程序后台化(守护进程)"></a>服务器程序后台化(守护进程)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">daemonize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid＜<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid＞<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/</span><br>    <span class="hljs-built_in">umask</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*创建新的会话，设置本进程为进程组的首领*/</span><br>    <span class="hljs-type">pid_t</span> sid = <span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span> (sid＜<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">/*切换工作目录*/</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">chdir</span>(<span class="hljs-string">&quot;/&quot;</span>))＜<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span><br>    <span class="hljs-built_in">close</span>(STDIN_FILENO);<br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">close</span>(STDERR_FILENO);<br>    <span class="hljs-comment">/*关闭其他已经打开的文件描述符，代码省略*/</span><br>    <br>    <span class="hljs-comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span><br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用daemon函数, 将该函数所在的进程变为守护进程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> nochdir,<span class="hljs-type">int</span> noclose)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>nochdir用于指定是否改变当前目录, 0则设置”&#x2F;“为根目录.</li><li>noclose设置为0时, 三个标准都会被默认重定向到&#x2F;dev&#x2F;null文件.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(2)</title>
    <link href="/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第六章 高级IO函数</strong></p></blockquote><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>fd[0]对应读端, fd[1]对应写端</p></li><li><p>默认阻塞, 可设置为非阻塞</p></li><li><p>双端都存在引用计数功能, 写端引用计数为0读端read返回0, 读端引用计数为0写端write会失败并发出SIGPIPE信号</p></li><li><p>多用于父子进程间通信, 一边关闭读端, 一边关闭写端.</p></li></ul><hr><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup &#x2F; dup2"></a>dup &#x2F; dup2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li>文件描述符 : 用来标定已打开文件的整数, 进程中默认打开的三个操作符是stdio(0), stiout(1), stderro(2).</li><li>文件描述符以进程为单位, 每个进程都有一套独立的文件描述符, 从0开始, 进程开始就会使用0,1,2三个文件描述符, 分别代表输入&#x2F;输出&#x2F;报错.</li><li>Linux下一切皆文件, 我们很多的行为都可以被解释为文件操作, 比如fork, socket, 只要有文件描述符, 我们就可以控制其读写.</li><li>可以创建文件描述符的操作 : open&#x2F;pipe&#x2F;socket&#x2F;accept&#x2F;fork等.</li><li>每次创建文件描述符时选择的值都是<strong>从0开始当前进程中最小的未使用值</strong>.</li></ul><p>dup&#x2F;dup2的作用主要就是<strong>重定向文件描述符的输入输出</strong>. </p><p>dup的主要操作为 : 将一个新的文件描述符(和创建逻辑一致)重定向到fd, 返回这个新文件描述符.</p><p>dup2就是在dup的基础上, 可以指定这个新的文件描述符, 如果这个新的文件描述符已被占用, 就先关闭该描述符再重定向.</p><p>其实在实际使用中”新的文件描述符”一般都是三种标准文件描述符, 即将标准输入输入重定向到fd.</p><p>dup的使用比较意识流, 我们先看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br>    <span class="hljs-built_in">bzero</span>(&amp;server, <span class="hljs-built_in">sizeof</span>(server));<br>    server.sin_family = AF_INET;<br>    server.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;server.sin_addr);<br><br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-built_in">sizeof</span>(server));<br>    ret = <span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client);<br><br>    <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: accept() failed.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">dup</span>(connfd);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(connfd);<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个简易的TCP网络代码, dup在这里的作用是把标准输出重定向到网络套接字, 过程如下 : </p><ul><li><code>close(STDOUT_FILENO);</code>关闭标准输入</li><li><code>dup(connfd);</code>选取从0开始当前进程中最小的未使用值, 那就是刚刚关闭的标准输出(1), 因此标准输出被重定向到了connfd.</li><li><code>printf(&quot;Hello World\n&quot;);</code>中的输出将被改为输出到connfd中, 其实就类似于使用了send将”Hello World\n”发送了出去.</li></ul><p>加入换用dup2, 可以把close+dup替换为如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dup2</span>(connfd, STDOUT_FILENO);<br></code></pre></td></tr></table></figure><p>dup2的使用一般比dup要方便直观不少, 所以日常中基本都是使用dup2.</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>将标准输入输出从重定向到打开的文件.</li><li>将标准输入输出从重定向到网络套接字. </li><li>将标准输入输出从重定向到管道.</li><li>利用子进程会继承父进程文件描述符的特性, 在fork前使用dup2可以使后续的子进程重定向到相同的位置而无需多余操作, 在fork后使用dup2可以使父子进程输入输出到不同的文件, 这里的可操作空间很大. 如果不使用dup2可能还要创建多余的文件句柄等.</li></ul><hr><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv &#x2F; writev"></a>readv &#x2F; writev</h3><p>后面的v指代vector, 作用在于输入输出到多个缓冲区(这里的缓冲区可以理解为内存).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/uio.h＞</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec*vector,<span class="hljs-type">int</span> count)</span>；</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec*vector,<span class="hljs-type">int</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>相比于普通的read : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>read只能读入一个缓冲区的内容, count代表buf的size.</p><p>readv可以读入多个缓冲区的内容, 多个缓冲区都被存在struct iovec中, count代表缓冲区的个数.</p><p>write和writev同理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> header_buf[BUFFER_SIZE];<br>...<br><span class="hljs-type">char</span>*file_buf;<br>...<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> iv[<span class="hljs-number">2</span>];<br>iv[<span class="hljs-number">0</span>].iov_base = header_buf;            <span class="hljs-comment">// 指向缓冲区的指针</span><br>iv[<span class="hljs-number">0</span>].iov_len = <span class="hljs-built_in">strlen</span>(header_buf);<span class="hljs-comment">// 缓冲区的size</span><br>iv[<span class="hljs-number">1</span>].iov_base = file_buf;<br>iv[<span class="hljs-number">1</span>].iov_len = file_stat.st_size;<br>ret = <span class="hljs-built_in">writev</span>(connfd,iv,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>在发送http回复时我们就可以将报头部分和文件部分存入iv中, 就可以实现将多个缓冲区中的内存发送, 而不必要将这两个部分合并再用write发送, 我们可以发现这可以避免不必要的拷贝和内存消耗.</p><hr><h3 id="内存的用户空间和内核空间"><a href="#内存的用户空间和内核空间" class="headerlink" title="内存的用户空间和内核空间"></a>内存的用户空间和内核空间</h3><ul><li>用户空间 : 用户程序运行的内存区域，包含应用程序的代码、数据和堆栈。用户程序在此空间运行，<strong>无法直接访问硬件或内核资源</strong>，必须通过系统调用请求内核协助.</li><li>内核空间 : 操作系统内核运行的内存区域，负责管理硬件、进程调度、内存分配等核心功能。只有内核代码能直接访问此区域，具有<strong>最高权限</strong>（如操作硬件、修改页表).</li><li>用户态和内核态的转换 : <ul><li>这两种状态是CPU的运行状态, 一般处于用户态, 可以通过一些方式进入内核态.</li><li>内核态拥有最高权限.</li><li>内核态可以访问所有内存空间, 包括磁盘, 网络设备等, 用户态只可访问内存空间. </li><li>进入内核态的方式 : 系统调用(fork, open, read等), 硬件中断, 异常.</li></ul></li></ul><hr><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>一种专用于文件网络传输的send.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sendfile.h＞</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span>*offset, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>out_fd : 要输出到的socketfd, 这里必须是socket的fd.</li><li>in_fd : 要输入的文件fd, 这里必须是真正文件的fd.</li><li>offset : 要从in_fd偏移量为多少的位置开始读, 默认为0.</li><li>count : 要读取的大小.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sendfile</span>(sockfd, filefd, <span class="hljs-literal">NULL</span>, stat_buf.st_size);<br></code></pre></td></tr></table></figure><p>该函数的优势在于传输文件时不需要将其从磁盘搬到用户空间再发送, 而是直接在内核空间中就将磁盘中的数据发送到网络套接字中, 实现了<strong>零拷贝</strong>.</p><hr><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap &#x2F; munmap"></a>mmap &#x2F; munmap</h3><p>一个用于申请一段内存空间将文件映射到该空间中的函数, 这个空间可以作为进程间通信的贡献内存. munmap用于释放该空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>start : 允许用户使用某个特定的地址作为这段内存的起始地址, 设置为NULL自动选择地址.</li><li>length : 内存段的长度.</li><li>port : 设置内存段的访问权限.</li><li>flags : 控制内存段内容被修改后程序的行为.</li><li>fd : 被映射文件对应的文件描述符.</li><li>offset : 设置从文件的何处开始映射.</li></ul><hr><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>用于两个文件描述符之间的数据移动, 所谓移动就是说读取完就没有了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">off_t</span> *off_in, <span class="hljs-type">int</span> fd_out, <span class="hljs-type">off_t</span> *off_out, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>fd_in : 执行输入的文件描述符.</li><li>off_in : 对应偏移量的指针, 一般设NULL.</li><li>fd_out : 接收输入的文件描述符.</li><li>off_out : 同上.</li><li>len : 输入数据的长度.</li><li>flags : 控制数据如何移动.</li></ul><p>splice可以在内核空间中实现不同文件描述符之间的信息传输, 而和管道结合可以将这种信息传输扩展到进程间通信, 而不只是在一个进程内传输, 由此可以实现<strong>高效的进程间通信</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> pipe_fds[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 管道文件描述符</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> *message = <span class="hljs-string">&quot;Hello from parent process to child process using splice!&quot;</span>;<br>    <span class="hljs-type">ssize_t</span> bytes_spliced;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipe_fds) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程：将数据写入管道</span><br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭管道的读端</span><br><br>        <span class="hljs-comment">// 将数据写入管道</span><br>        bytes_spliced = <span class="hljs-built_in">splice</span>(STDOUT_FILENO, <span class="hljs-literal">NULL</span>, pipe_fds[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, BUFFER_SIZE, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (bytes_spliced == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice to pipe failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process wrote data to pipe: %zd bytes\n&quot;</span>, bytes_spliced);<br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭管道的写端</span><br><br>        <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 子进程：从管道中读取数据</span><br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭管道的写端</span><br><br>        <span class="hljs-comment">// 通过管道读取数据并将其输出</span><br>        <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>        bytes_spliced = <span class="hljs-built_in">splice</span>(pipe_fds[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, STDOUT_FILENO, <span class="hljs-literal">NULL</span>, BUFFER_SIZE, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (bytes_spliced == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice from pipe failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process received data from pipe: %zd bytes\n&quot;</span>, bytes_spliced);<br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭管道的读端</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中父进程向子进程发送消息, 子进程可以接收到父进程中的消息, 并且由于splice一切都在内核空间中进行, 非常高效.</p><hr><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>用于两个文件描述符之间的数据复制, 和splice用法一致, 但是数据读取后会留下了, 下次读取还在.</p><hr><h3 id="struct-stat"><a href="#struct-stat" class="headerlink" title="struct stat"></a>struct stat</h3><p>用于用于描述文件或文件系统对象的结构体. 使得进程可以通过stat, fstat, lstat获得文件的基本信息.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br>    <span class="hljs-type">dev_t</span>     st_dev;         <span class="hljs-comment">/* 文件所在设备的 ID */</span><br>    <span class="hljs-type">ino_t</span>     st_ino;         <span class="hljs-comment">/* Inode 号 */</span><br>    <span class="hljs-type">mode_t</span>    st_mode;        <span class="hljs-comment">/* 文件类型和权限 */</span><br>    <span class="hljs-type">nlink_t</span>   st_nlink;       <span class="hljs-comment">/* 硬链接数 */</span><br>    <span class="hljs-type">uid_t</span>     st_uid;         <span class="hljs-comment">/* 所有者的用户 ID */</span><br>    <span class="hljs-type">gid_t</span>     st_gid;         <span class="hljs-comment">/* 所有者的组 ID */</span><br>    <span class="hljs-type">dev_t</span>     st_rdev;        <span class="hljs-comment">/* 设备 ID（如果是设备文件） */</span><br>    <span class="hljs-type">off_t</span>     st_size;        <span class="hljs-comment">/* 文件大小（字节数） */</span><br>    <span class="hljs-type">blksize_t</span> st_blksize;     <span class="hljs-comment">/* 文件系统 I/O 的块大小 */</span><br>    <span class="hljs-type">blkcnt_t</span>  st_blocks;      <span class="hljs-comment">/* 文件占用的块数 */</span><br><br>    <span class="hljs-comment">/* 时间戳 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_atim;  <span class="hljs-comment">/* 最后访问时间 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_mtim;  <span class="hljs-comment">/* 最后修改时间 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_ctim;  <span class="hljs-comment">/* 最后状态变更时间 */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_atime st_atim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后访问时间（秒） */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_mtime st_mtim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后修改时间（秒） */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_ctime st_ctim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后状态变更时间（秒） */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;   <span class="hljs-comment">// 用路径寻找文件信息,  statbuf都是输出型参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<span class="hljs-comment">// 用文件fd寻找文件信息</span><br></code></pre></td></tr></table></figure><p>使用方法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_buf;<br><span class="hljs-built_in">fstat</span>(filefd, &amp;stat_buf);  <br>...<br><span class="hljs-built_in">sendfile</span>(connfd,filefd,<span class="hljs-literal">NULL</span>,stat_buf.st_size);  <span class="hljs-comment">// 这里sendfile的就会用到需要传输的文件大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(1)</title>
    <link href="/2025/02/10/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2025/02/10/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第五章  Linux网络编程基础API</strong></p></blockquote><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><h3 id="什么是大小端字节序"><a href="#什么是大小端字节序" class="headerlink" title="什么是大小端字节序?"></a>什么是大小端字节序?</h3><p>这里以32位机举例, 32位机CPU一次可以装载4字节,  那么这4个字节不同的排序方式就对应了不同的字节序 : </p><ul><li>大端字节序 : 顺着排, 0x12345678 将被排序为 12  34  56  78.</li><li>小端字节序 : 逆着排, 0x12345678 将被排序为 78  56  34  12.</li></ul><h3 id="为什么要分大小端"><a href="#为什么要分大小端" class="headerlink" title="为什么要分大小端?"></a>为什么要分大小端?</h3><p>其实更多还是因为<strong>历史原因</strong>,  早期都是按照大端字节序来设计的, 因为顺着排更符合人类的阅读习惯, 早期网络协议设计都是按大端设计的, 并且网络协议一旦实施就不好改了, 所以直到现在网络传输的字节序都是大端字节序, 因此大端字节序又称为网络字节序.</p><p>后来人们发现小端字节序更符合CPU的运算逻辑, 使用小段字节序编码可以让CPU运行更加高效, 因此之后的主机大都采用小端字节序, 因此小段字节序又称为主机字节序.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>; <span class="hljs-comment">// host to network long </span><br></code></pre></td></tr></table></figure><p>以上为long类型端口从主机字节序转为网络字节序的函数.</p><hr><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="shutdown关闭socket"><a href="#shutdown关闭socket" class="headerlink" title="shutdown关闭socket"></a>shutdown关闭socket</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> howto)</span></span>;<br></code></pre></td></tr></table></figure><p>shoudown类似于进阶版的close, close是直接断开读写, shoudown可以分别关闭读端写端.</p><p>howto为选项 : </p><ul><li>SHUT_RD : 只关闭写端.</li><li>SHUT_WR : 只关闭读端.</li><li>SHUT_RDWR : 双端关闭.</li></ul><p>应用场景 : 半双工实现, 客户端收到EOF可以直接关闭读端, 写端不关闭可以继续处理没有处理完的事务.</p><p>其实就是读端和写端都会占用资源, close只能同时释放, showdown可以根据具体情况选择只读不写&#x2F;只写不读, 提前释放部分资源.</p><h3 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h3><ul><li><p>SO_REUSEADDR : 强制使用处于TIME_WAIT状态的连接占用的socket地址.</p><ul><li>TIME_WAIT作用 : TCP连接发送的数据可能滞后, 如果崩溃立即重启, 可能接收到旧数据包造成混乱.</li></ul><p>SO_REUSEADDR作用 : </p><ol><li>可以避免服务器崩溃后进入TIME_WAIT状态, 配合systemd可以实现快速重启服务.</li><li>支持多个进程同时绑定同一个端口(仅限UDP), 用于视频影音等高并发用多个进程同时处理发送到同一个端口上的信息.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 表示启用设置</span><br>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-keyword">sizeof</span>(reuse));<br></code></pre></td></tr></table></figure></li><li><p>SO_RCVBUF&#x2F;SO_SNDBUF : 用于修改TCP发送和接收缓冲区的大小.</p><p>缓冲区大小最小为256字节, 大小会按设置的大小的两倍计算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> bufsize = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 标定新的缓冲区大小</span><br><span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCV, &amp;bufsize, <span class="hljs-built_in">sizeof</span>(bufsize))<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>在现实生活中我们习惯<strong>用域名代替IP地址, 用服务名代替端口号</strong>, 使用网络信息API便可以<strong>实现&lt;域名+服务名&gt;到&lt;IP+port&gt;的双向转化</strong>, 便于我们socket等操作的进行. 主要是两大函数<code>getaddrinfo</code>和<code>getnameinfo</code>, 这两个函数<strong>线程安全并且支持各种地址族和协议类型</strong>, 可以使socket进行动态设置以实现<strong>动态实时处理与跨平台性</strong>.</p><h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>这个函数可以通过主机名获得IP地址, 通过服务名获得端口号.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *node,                   <span class="hljs-comment">// 主机名 / 字符串形式的IP地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *service,<span class="hljs-comment">// 服务名</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo *hints, <span class="hljs-comment">// 传入一些必要的信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">struct</span> addrinfo **res<span class="hljs-comment">// 存储返回结果, 输出型参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> &#123;<br>    <span class="hljs-type">int</span>              ai_flags;        <span class="hljs-comment">// 地址信息标志</span><br>    <span class="hljs-type">int</span>              ai_family;       <span class="hljs-comment">// 地址族 (AF_INET, AF_INET6 等)</span><br>    <span class="hljs-type">int</span>              ai_socktype;     <span class="hljs-comment">// 套接字类型 (SOCK_STREAM, SOCK_DGRAM 等)</span><br>    <span class="hljs-type">int</span>              ai_protocol;     <span class="hljs-comment">// 协议类型 (IPPROTO_TCP, IPPROTO_UDP 等), 默认为0即可</span><br>    <span class="hljs-type">size_t</span>           ai_addrlen;      <span class="hljs-comment">// 地址长度</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span> *ai_addr;         <span class="hljs-comment">// 指向套接字地址的指针</span><br>    <span class="hljs-type">char</span>            *ai_canonname;    <span class="hljs-comment">// 完整主机名</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *ai_next;         <span class="hljs-comment">// 下一个地址信息链表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以利用获取的信息直接建立socket : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints, *res;<br><span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(hints));<br>hints.ai_family = AF_UNSPEC;   <span class="hljs-comment">// 支持 IPv4 和 IPv6</span><br>hints.ai_socktype = SOCK_STREAM; <span class="hljs-comment">// TCP</span><br><br><span class="hljs-comment">// 获取目标主机的地址信息</span><br><span class="hljs-type">int</span> status = <span class="hljs-built_in">getaddrinfo</span>(<span class="hljs-string">&quot;www.example.com&quot;</span>, <span class="hljs-string">&quot;http&quot;</span>, &amp;hints, &amp;res);<br><span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用返回的地址信息创建套接字并进行连接</span><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);<br><span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-built_in">freeaddrinfo</span>(res);<br><span class="hljs-built_in">freeaddrinfo</span>(hints);  <span class="hljs-comment">// addrinfo类型需要释放内存</span><br></code></pre></td></tr></table></figure><h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>通过socket地址返回主机名&#x2F;服务名, 和getaddrinfo是相反的作用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen, <span class="hljs-comment">// 目标网络地址结构体</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *host, <span class="hljs-type">size_t</span> hostlen,<span class="hljs-comment">// 返回的主机名, 输出型参数</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *serv, <span class="hljs-type">size_t</span> servlen,<span class="hljs-comment">// 返回的服务名/端口号, 输出型参数</span></span><br><span class="hljs-params">                <span class="hljs-type">int</span> flags<span class="hljs-comment">// 确定函数行为</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> sa;<br>   <span class="hljs-type">char</span> host[NI_MAXHOST], service[NI_MAXSERV];<br>   <br>   <span class="hljs-comment">// 构造一个IPv4地址，假设是127.0.0.1，端口是80</span><br>   sa.sin_family = AF_INET;<br>   sa.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">80</span>);<br>   <span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;(sa.sin_addr));<br><br>   <span class="hljs-comment">// 获取主机名和服务名</span><br>   <span class="hljs-type">int</span> result = <span class="hljs-built_in">getnameinfo</span>((<span class="hljs-keyword">struct</span> sockaddr*)&amp;sa, <span class="hljs-built_in">sizeof</span>(sa),<br>                            host, NI_MAXHOST, service, NI_MAXSERV, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Host: %s\n&quot;</span>, host);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Service: %s\n&quot;</span>, service);<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(4)</title>
    <link href="/2025/02/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(4)/"/>
    <url>/2025/02/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(4)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>我们对规律与和谐的了解, 往往局限于那些我们已经掌握的事例; 但许多貌似彼此冲突的因素也能导致和谐的结果, 但许多规律我们固然尚未认识可是确实存在且更加神奇美妙.</p></li><li><p>其实幸福的人应该永远生活在此刻, 好好利用每件落到我们身上的琐事, 就像青草坦然接受每颗落在它身上的最细小的露珠那样, 别把时间用于挽回从前失去的机会, 并美名其曰承担责任.</p></li><li><p>若是能在宁静而有益的清晨之气中, 回想每日所做善事, 培养对美德的热爱和对邪恶的憎恨, 那么人心里原始的兽性, 就会像森林里被砍掉的新芽那样, 不会茁壮成长.</p></li><li><p>在渴望探索和了解万物的同时, 我们要牢记万物均是神秘和未经探索的.</p></li><li><p>我们需要看见我们突破自己的局限, 在我们从未涉足的原野自由自在的生活.</p></li><li><p>然而我们总是以为, 若是将我们农场的篱笆拆掉, 垒上石墙, 我们的生活便自此有了边界, 我们的命运也已经注定.</p></li><li><p>每个人都是其心灵领地的主人, 然而有些人明明毫不尊重自己, 却表现得很爱国, 捡起芝麻丢了西瓜. 他们热爱可以供他们造坟的土地, 却对那使他们的泥身充满生气的灵魂毫不关心. 爱国主义是他们脑里的蛆虫.</p></li><li><p>但人生的目标并非让自己持有这种敌视社会的态度, 而是始终能够做他自己, 遵从自己的原则, 无论这种遵从会让他对社会产生什么样的态度, 如果有幸遇到一个正义的政府, 他是不会产生敌意的态度的.</p></li><li><p><strong>我们很容易不知不觉就习惯某条固定的路线, 为我们自己踏出一条路来.</strong></p></li><li><p>大地的表面是柔软的, 人类的脚能够踩得它陷进去, 精神的道路也是如此. 所以世上的道路一定是非常破烂和尘土飞扬的, 传统和习俗的车辙也肯定是很深的!</p></li><li><p>如果人自信地朝着梦想的方向前进, 努力去过上他事先设想的生活, 他将会取得普通人想象不到的成功. 他会把某些东西甩在身后, 将会跨越无形的界线; 他的周围和内心将会得到新的解释, 赋予他更大的自由, 他将会过上一种更为高尚的生活.</p></li><li><p>如果你在空中修建了几座楼阁, 你的心血未必会白费, 那就是它们应该在的地方, 现在请把基础摆到它们下面去.</p></li><li><p>好像只有愚蠢是最安全的, 我却独想逾规越矩!</p></li><li><p>**至于未来或者前景, 我们应该抱着开放的态度, 顺其自然, 别明确的限定我们将来应该是什么模样.**至于过去或者从前, 应该将其抛在身后.</p></li><li><p>人们热爱的纯洁就像笼罩大地的迷雾, 而不像超乎那迷雾之上的蓝天.</p></li><li><p>如果适合我们的环境尚未出现, 我们又能用什么来取代它呢? 我们可别在虚造的环境里翻了船.</p></li><li><p>与其用花言巧语去美化事物, 倒不如说出事物的真相. 对大多数人来说, 我们并没有处于正确的地方, 而是出现在错误的位置. 由于天性的缺点, 我们虚构了一种情况, 把自己放进那情况里, 于是同时存在着两种情况, 想要走出来就加倍地难.</p></li><li><p>大多数人以为他们不要靠镇上的接济, 但他们往往是靠虚伪狡诈的手段来生活, 这是更应该遭到鄙视的.</p></li><li><p>去找旧东西吧, 回去找它们, 事物不会改变, 变的是我们.</p></li><li><p>别如此迫切地谋求发展, 别让自己受到许多外界因素摆布, 那本来是供你玩弄的; 那完全是在浪掷光阴.</p></li><li><p>我喜欢去掂量, 去摸索, 去接近那些让我产生最强烈最正确兴趣的东西.</p></li><li><p>我只会踏上我有能力去走的道路, 在那条道路上, 没有任何力量可以阻止我前行. 尚未打好地基就去修建拱门这种事情, 并不能给我带来满足感. 社会的沼泽和流沙也是如此, 可是年纪很大的孩子才能明白这个道理.</p></li><li><p>我们为何要长久地坐在走廊里, 空谈着那些无聊而陈腐的道德观, 而不去从事实际而有用的工作?</p></li><li><p>大多数人既不曾深入得到低下六英尺之处, 也不曾跳得多高, 我们不知道我们身在何处. 此外, 我们有大半时间是昏睡着的, 然而我们却自以为很聪明, 在表面上建立起秩序.</p></li><li><p>当今世上新奇的东西层出不穷, 可是我们依然忍受着难以置信的愚钝.</p></li><li><p>我们内心的生活就像河水, 也许它今年会涨得前所未有的高, 漫上干燥的坡地; 甚至可能造成灾害, 淹死我们所有的麝鼠.</p></li><li><p>早晨只是时间的流逝, 而不是真正的破晓. 导致我们闭上双眼的阳光, 对我们来说就是黑暗, 只有在我们醒着时, 天才是真正的破晓. 日出未必意味着光明, 太阳也无非是一颗晨星而已.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款53-55 杂项讨论</title>
    <link href="/2025/01/31/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE53-55%20%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <url>/2025/01/31/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE53-55%20%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学到这里, Effective C++至此也算是告一段落了, 还剩下一些杂七杂八的讨论, 我们将在本文逐一列举.</p></blockquote><h2 id="条款53-不要忽视编译器的警告"><a href="#条款53-不要忽视编译器的警告" class="headerlink" title="条款53 : 不要忽视编译器的警告"></a>条款53 : 不要忽视编译器的警告</h2><ul><li>我们应严肃对待编译器发出的警告信息, 努力在你的编译器最高警告级别下争取无警告的荣誉.</li><li>同时也不要过度依赖编译器的报警能力, 有些可能导致运行崩溃的错误编译器无法准确检测.</li></ul><hr><h2 id="条款54-让自己熟悉包括Tr1在内的标准程序库"><a href="#条款54-让自己熟悉包括Tr1在内的标准程序库" class="headerlink" title="条款54 : 让自己熟悉包括Tr1在内的标准程序库"></a>条款54 : 让自己熟悉包括Tr1在内的标准程序库</h2><p>Tr1其实是早期的实验标准库, 如今已经废弃, 许多功能都已经正式并入标准库中, 例如 : </p><ul><li>智能指针</li><li>functional</li><li>bind</li><li>unordered_set &#x2F; unordered_map</li><li>type_traits</li></ul><p>这些技术其实在现在都已经成熟并且被广泛运用, 成为了我们必须学习的一部分.</p><hr><h2 id="条款55-让自己熟悉Boost"><a href="#条款55-让自己熟悉Boost" class="headerlink" title="条款55 : 让自己熟悉Boost"></a>条款55 : 让自己熟悉Boost</h2><p>Boost 是 C++ 社区广泛使用的<strong>高质量开源库集合</strong>，旨在扩展 C++ 标准库功能，并推动新特性进入 C++ 标准。其特点包括：</p><ol><li><strong>高质量代码</strong>：经过严格代码审查和跨平台测试。</li><li><strong>与标准兼容</strong>：多个 Boost 组件（如智能指针、正则表达式）已被纳入 C++11 及后续标准。</li><li><strong>模块化设计</strong>：可按需引入单个头文件或编译库，减少依赖。</li><li><strong>跨平台支持</strong>：兼容主流操作系统和编译器。</li></ol><p>Boost 是 C++ 开发者的重要工具库，提供丰富的扩展功能，涵盖系统编程、算法、并发等领域。对于需要高性能和现代编程范式的项目，Boost 能显著提升开发效率和代码健壮性。</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款49-52 内存分配</title>
    <link href="/2025/01/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE49-52%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2025/01/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE49-52%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49 : 了解new-handler的行为"></a>条款49 : 了解new-handler的行为</h2><h2 id="条款50-了解new和delete的合理替换时机"><a href="#条款50-了解new和delete的合理替换时机" class="headerlink" title="条款50 : 了解new和delete的合理替换时机"></a>条款50 : 了解new和delete的合理替换时机</h2><h2 id="条款51-编写new和delete时需固守常规"><a href="#条款51-编写new和delete时需固守常规" class="headerlink" title="条款51 : 编写new和delete时需固守常规"></a>条款51 : 编写new和delete时需固守常规</h2><h2 id="条款52-：写了placement-new也要写placement-delete"><a href="#条款52-：写了placement-new也要写placement-delete" class="headerlink" title="条款52 ：写了placement new也要写placement delete"></a>条款52 ：写了placement new也要写placement delete</h2><blockquote><p>条款49-52中详细讲述了定制new和delete的实现, 加上前面所讲述的智能指针及资源管理类, 让我们对内存管理有了比较深刻的认知. 但是这部分有些内容经查证已经相对过时, 所以我将统合这四个条款, 先对内存分配有一个初步的认识, 然后再简单讲解一下定制new和delete的编写, 之后再讨论一下各种内存分配的方式.</p></blockquote><h3 id="内存分配的整体认知"><a href="#内存分配的整体认知" class="headerlink" title="内存分配的整体认知"></a>内存分配的整体认知</h3><p>相比于java等编程语言以垃圾回收功能津津乐道, 但其实际也会带来运行效率下降的弊端, C++因此并没有纳入垃圾回收的机制, 将内存分配的任务交给了程序员自己, 所以学习内存分配是成为一个优秀C++程序员的所必须的. 为了实现更好的内存分配, 诸如智能指针, allocator等的各种资源管理类如雨后春笋般产生, 当然在此之外C++本身就可以对new进行定制, 这种做法虽然原始, 但是也有一定的用武之地.</p><p>先让我们了解一下内存分配的流程 : </p><ul><li>C : 内存申请(malloc) -&gt; …(使用) -&gt; 释放内存(free)</li><li>C++ : 内存申请 -&gt; 构造 -&gt; …(使用) -&gt; 析构 -&gt; 释放内存</li></ul><p>上面展示了C&#x2F;C++内存分配的流程, 其实内存申请和释放在底层都是调用malloc和free, 但是在C++中对其进行了封装, 因为其OOP的特性, 在new中不仅申请了内存, 还进行了对应的构造, 简单来说就是先调用malloc申请了一块内存, 然后在这片内存上调用对应对象的构造函数, delete也是同理不再赘述.</p><hr><h3 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h3><ul><li><p>什么是定制new和delete?</p><p>即对new和delete运算符进行重载, 包括new和delete的使用以及运算符重载学到这里我们应当都已经非常熟悉.</p></li><li><p>为什么要定制new和delete?</p><p>根本原因就是标准版本的new和delete提供的服务太少, 只有申请和构造, 析构和销毁, 因此定制可以实现更多的操作.</p><p>书中这里用了一个条款来解释, 我这里简单提炼一下定制new和delete主要可以做到的提升 : </p><ul><li>提前检测运用new或delete上的错误.</li><li>强化分配的效能, 可以引入内存池提升分配和释放的效率.</li><li>收集统计数据, 加入日志功能, 记录内存分配情况, 便于信息分析.</li></ul></li><li><p>如何实现定制new和delete?</p><p>主要就是学会new和delete的运算符重载, 但是其中还是有一些门道, 我们不妨来回顾一下new是如何使用的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass* myclass = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>假设有一个MyClass类, 其构造需要传入一个int, 这段代码便可以实现申请内存 + 构造的全过程, 但是我们还可以通过下面的代码实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));    <span class="hljs-comment">// ::operator new</span><br>MyClass* myclass = <span class="hljs-built_in">new</span>(ptr) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// placement new</span><br></code></pre></td></tr></table></figure><p>这和上面代码实现的效果是一样的, 里面的两个语法::operator new(全局分配函数)和placement new(定位new), 都是C++基础中应该学到过的, 其实也就分别对应了申请内存和构造, 于是我们可以对内存分配流程做出如下的对应 : </p><ul><li>内存申请(::operator new) -&gt; 构造(placement new) -&gt; …(使用) -&gt; 析构(placement delete) -&gt; 释放内存(::operator delete)</li></ul><p>那么定制new和delete就变成了定制::operator new和placement new(及对应deltete版本)了, 定制方法也很简单 : </p><ul><li><p>重载operator new, <strong>不同的参数对应不用的功能</strong>, 只传入一个size对应::operator new, 不仅传入size还传入ptr对应placement new, 也许这样设定你会觉得很怪, 但是事实就是这样, 我们通过代码来认识 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定制 ::operator new</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// 进行参数检测, 日志记录, 调用内存池等</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);  <span class="hljs-comment">// 可以仍然使用标准的 ::operator new, 当然也可以自己malloc</span><br>&#125;<br><br><span class="hljs-comment">// 定制 placement new 操作符</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* ptr)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-comment">// 进行日志记录等操作</span><br>    <span class="hljs-keyword">return</span> ptr;  <span class="hljs-comment">// 不进行内存分配，只是返回已分配的内存地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然这种运算符重载如果放在类外就是作用于全局, 放在类内就是类专属, 我们应当有所认知.</p></li></ul></li></ul><hr><h3 id="申请内存失败的处理方式"><a href="#申请内存失败的处理方式" class="headerlink" title="申请内存失败的处理方式"></a>申请内存失败的处理方式</h3><p>我们知道malloc是可能出错的, 内存不足等问题都有可能发送, malloc出错会返回一个nullptr, 在标准库中new会抛出<code>std::bad_alloc</code>这个异常, 因此我们在自己的<code>operator new</code>中如果使用malloc, 当其返回一个nullptr时也应抛出一个<code>bad_alloc</code>.</p><p>当然书中也提出应该有更优秀的处理方式, 不应该只是抛出异常, 在条款49中便提出标准库内置了一个错误处理函数<code>new_handler</code>, 可以通过<code>set_new_handler(handler)</code>这个函数来设置, 参数是一个函数指针, 也就是我们可以自己写回调函数并将其设置为<code>new_handler</code>, 在发生内存失败时可以自动调用该函数. 我们可以在其中记录日志, 使用内存池机制(如果用了内存池的话), 决定是否抛出异常(如果申请失败无所谓的话可以不抛出异常).</p><p>但是真的有必要吗?</p><p>其实new_handler在实际运用中已经很少使用, 根本原因还是在现代内存大小已经不再是问题, 也就是说内存申请失败几乎不可能出现, 只在极少嵌入式设备中可能有需要了. 而且如果真的出现了申请内存失败那只能说明问题很大, 不是硬件有问题就是代码哪里出现了严重的内存泄露, 这不是写一个new_handler可以解决的了, 因此其实在现代背景下还是老实抛出异常就行了.</p><hr><h3 id="浅谈内存分配"><a href="#浅谈内存分配" class="headerlink" title="浅谈内存分配"></a>浅谈内存分配</h3><p>关于内存分配我认为学好智能指针的使用是最关键的, 因为其可以很大程度上保证我们的代码不会内存泄漏, 只要不发生内存泄漏, 内存大小一般不会是问题.</p><p>我们对于内存分配的关注点应该放在如何避免内存泄漏和提升效率上, 内存泄漏有智能指针避免, 提速可以通过<strong>引入内存池</strong>来缓解, 内存池这里不再详述, 简单来说就是申请和释放内存其实是有一定花销的, 不断的一小块一小块地申请内存然后构造其实是效率远低于直接申请一大块内存, 然后根据需求分配这块内存的, 而内存池就是做到了后者.</p><p>至于如何引入, 可以通过上文的定制new和delete的重载函数中引入, 也可以通过自定义的allocator(分配器)来引入, allocator也是一种相对有用的内存分配技术, 如果感兴趣可以自己搜索学习.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>内存分配在现代主要还是依赖智能指针, 可以有效避免内存泄露.</li><li>如果想对内存分配做更细致的处理, 例如提速或记录日志等, 可以尝试定制new和delete, 使用allocator, 引入内存池.</li><li>内存分配失败的情况在当下非常少见, 可以写简单的失败处理机制, 但没必要投入过多精力.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款48 模板元编程(TMP)</title>
    <link href="/2025/01/22/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE48%20%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B(TMP)/"/>
    <url>/2025/01/22/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE48%20%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B(TMP)/</url>
    
    <content type="html"><![CDATA[<h2 id="条款48-认识template元编程"><a href="#条款48-认识template元编程" class="headerlink" title="条款48 : 认识template元编程"></a>条款48 : 认识template元编程</h2><blockquote><p>在条款47我们主要了解了萃取器这种模板元编程, 也初步进入了模板元编程的世界. 在本条款中, 我们将继续认识模板元编程, 认识其必要性和应用场景, 相比于条款47讲的还算比较深入,本条款真的就只是简介, 因为其体量确实非常庞大, 甚至可以单独作为一个学科研究.</p></blockquote><p><code>Template metaprogramming</code>, 模板元编程, 简称TMP, 是<strong>编写template-based C++程序并执行于编译期的过程</strong>.</p><hr><h3 id="模板元编程的效用"><a href="#模板元编程的效用" class="headerlink" title="模板元编程的效用"></a>模板元编程的效用</h3><p>我们目前可以用在条款47中学到的萃取器的知识来理解模板元的效用 : </p><ul><li>它让某些事情更容易, 这些事情原本比较困难甚至不可能.(例如针对迭代器类型进行可靠的条件编译)</li><li>它将工作期从运行期移至编译期, 大大提高了运行效率, 有更小的可执行文件, 更短的运行期, 更少的内存消耗.</li></ul><p>假设我们使用萃取器时不采用重载或<code>if constexpr</code>这种模板元编程, 而是就是在运行期通过判断迭代器类型来条件判断, 我们看看最后的效果怎样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(<span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) ==<br>      <span class="hljs-built_in">typeid</span>(std::random_access_iterator_tag)) &#123;<br>     iter += d;                                     <br>  &#125;                                                 <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">while</span> (d--) ++iter; &#125;             <br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">while</span> (d++) --iter; &#125;                    <br>  &#125;                                                 <br>&#125;<br></code></pre></td></tr></table></figure><p>这里还是用萃取器提取出类型, 利用<code>typeid</code>在运行期进行条件判断, 但是这种方法不仅不高效(对应效用2), 而且不可行(对应效用1).</p><ul><li><p>不高效 : 这个很容易理解, 利用模板元编程在编译期即可实现的效果, 这样却要在运行期花时间判断.</p></li><li><p>不可行 : 这段代码在一些情况下甚至都无法通过编译, 如果我们像下面这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::list&lt;<span class="hljs-type">int</span>&gt;::iterator iter;<br><span class="hljs-built_in">advance</span>(iter, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这样使用非常合理, 但是会运行崩溃, 因为list的迭代器是双向迭代器, 而非随机访问迭代器, 所以<code>iter += d;</code>这段代码根本无法通过编译! 也许你会认为因为条件判断, 如果是list的迭代器, 这句代码永远不会触发, 但是我们应当知道 : </p><ul><li><strong>编译器必须确保所有源码都有效, 纵使是不会执行起来的代码.</strong></li></ul></li></ul><p>至此我们应该已经可以理解到部分模板元编程可以达到的效用了.</p><hr><h3 id="模板元编程中的”hello-world-”"><a href="#模板元编程中的”hello-world-”" class="headerlink" title="模板元编程中的”hello world!”"></a>模板元编程中的”hello world!”</h3><p>我们可以了解模板元编程中的一个入门编程, 它相当于初入编程的”hello world”, 即<strong>在编译期计算阶乘</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;                 <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;                   <br>  <span class="hljs-keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                          <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;            <span class="hljs-comment">// 全特化</span><br>  <span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们通过代码应该可以推导出一个递归的过程, 并且这个过程是通过模板在编译期来实现的! 于是我们就可以这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value &lt;&lt; std::endl;   <span class="hljs-comment">// 直接打印出120</span><br>  std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;               <span class="hljs-comment">// 直接打印出3628800</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以和普通递归求阶乘进行对比 : </p><ul><li>普通递归 : 运行期实现, 可以通过用户输入动态计算任意数的阶乘.</li><li>模板元递归 : 编译期实现, 只可以得到预先设置的数的阶乘.</li></ul><p>简单来说就是前者耗费运行期时间但是灵活, 后者不费运行期时间但是不可变.</p><p>当然使用enum是一个比较原始且可读性较差的做法, 在C++11已经引入constexpr : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> value = n * Factorial&lt;n - <span class="hljs-number">1</span>&gt;::value;  <span class="hljs-comment">// constexpr代替enum</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="三个应用场景案例"><a href="#三个应用场景案例" class="headerlink" title="三个应用场景案例"></a>三个应用场景案例</h3><ul><li><p>确保度量单位正确.</p><p>在科学工程中, 我们可以提前确定度量单位的结合正确, 可以进行早期的错误侦测.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 定义不同的单位类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Time</span> &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Time&quot;</span>; &#125;;<span class="hljs-comment">// 时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Length</span> &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Length&quot;</span>; &#125;;<span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 计算单位的乘法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Unit1, <span class="hljs-keyword">typename</span> Unit2&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>;<br><br><span class="hljs-comment">// 两个长度相乘得到面积</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>&lt;Length, Length&gt; &#123;   <span class="hljs-comment">// 全特化</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">struct</span> Area &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Area&quot;</span>; &#125;; <span class="hljs-comment">// 定义面积类型</span><br>&#125;;<br><br><span class="hljs-comment">// 时间与长度相除，得到速度</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>&lt;Length, Time&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">struct</span> Velocity &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Velocity&quot;</span>; &#125;; <span class="hljs-comment">// 定义速度类型</span><br>&#125;;<br><br><span class="hljs-comment">// 打印单位名称</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Unit&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;TypeName: &quot;</span> &lt;&lt; Unit::name &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 计算长度与时间的组合，得到速度</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MultiplyUnits&lt;Length, Time&gt;::type unit1;<br><span class="hljs-built_in">printType</span>&lt;unit1&gt;();  <span class="hljs-comment">// 输出: Unit: Velocity</span><br><br><span class="hljs-comment">// 计算长度与长度的组合，得到面积</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MultiplyUnits&lt;Length, Length&gt;::type unit2;<br><span class="hljs-built_in">printType</span>&lt;unit2&gt;();  <span class="hljs-comment">// 输出: Unit: Area</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中就可以根据向<code>MultiplyUnits</code>中传入的类型在编译期进行判断其结果的类型.</p></li><li><p>优化矩阵运算.</p><p>在条款44中我们编写过矩阵, 假如我们进行下面的运算 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10000</span>&gt; BigMatrix;<br>BigMatrix m1, m2, m3, m4, m5;              <br>BigMatrix result = m1 * m2 * m3 * m4 * m5; <br></code></pre></td></tr></table></figure><p>如果这些在运行期完成, 将会产生内存巨大的临时对象和不低的时间成本, 但假如用模板元编程就可能消除临时对象并合并循环, 大大降低成本, 具体细节书中没有给出, 这里就不再细讲.</p></li><li><p>可以生成客户定制之设计模式实现品.</p><p>这里的命题就更加广阔了, 简单理解就是许多设计模式都和类与模板有关, 可以利用模板元编程根据需求将一些设计模式的行为从运行期搬到编译期中, 不仅实现了定制, 还提高了运行效率.</p></li></ul><hr><h3 id="现代模板元编程"><a href="#现代模板元编程" class="headerlink" title="现代模板元编程"></a>现代模板元编程</h3><p>随C++11, C++14, C++17的引入, 模板元编程的语法日渐丰富, 这一领域虽然有些晦涩难懂, 但是其确实有其价值所在, 并且越来越被重视. 我们虽然不一定要完全掌握, 但是可以逐步了解一下模板元编程的语法, 例如constexpr, if constexpr, SFINAE技术, 模板元函数等等.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>模板元编程可将工作由运行期移往编译期, 因而得以实现早期错误侦测和更高的执行效率.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款47 萃取器</title>
    <link href="/2025/01/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE47%20%E8%90%83%E5%8F%96%E5%99%A8/"/>
    <url>/2025/01/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE47%20%E8%90%83%E5%8F%96%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="条款47-请使用traits-classes表现类型信息"><a href="#条款47-请使用traits-classes表现类型信息" class="headerlink" title="条款47 : 请使用traits classes表现类型信息"></a>条款47 : 请使用traits classes表现类型信息</h2><blockquote><p>traits classes(萃取器类), 如你所见萃取器其实是一个模板类, 在C++中萃取器是一个神奇且有趣的存在, 它被广泛引用于标准库STL的编写中, 我们将在本条款中了解萃取器的功能及实现, 初步踏入模板元编程的世界.</p></blockquote><h3 id="模板元编程的初步认知"><a href="#模板元编程的初步认知" class="headerlink" title="模板元编程的初步认知"></a>模板元编程的初步认知</h3><p>很多人在第一次听到”模板元编程”时一定觉得非常高大上, 但是实际上我们可以简单认知其为<strong>针对模板类型在编译期执行的代码</strong>, 目前我们写的代码大都是在运行期执行的, 但是由于模板的引入, 我们便可以针对模板类型(T)进行各种操作, 譬如根据不同的类型选择不同的执行代码和计算逻辑, 这些行为都会在编译期执行. 而我们本条款要学习的萃取器便属于模板元编程的一部分.</p><hr><h3 id="在-STL源码剖析-中学习"><a href="#在-STL源码剖析-中学习" class="headerlink" title="在 STL源码剖析 中学习"></a>在 <em>STL源码剖析</em> 中学习</h3><p>本条款其实只是对萃取器的简介, 让你认识萃取器这个存在, 想要真正掌握它, 还是建议阅读<em>STL源码剖析</em>, 其中第二章用了整整一章的内容来详述萃取器相关的内容, 我也是因为提前阅读过<em>STL源码剖析</em>, 才对本条款的阅读没有什么障碍的.</p><hr><h3 id="萃取器"><a href="#萃取器" class="headerlink" title="萃取器"></a>萃取器</h3><p>顾名思义, 萃取器是用来萃取的, 其作用是<strong>从模板类型中萃取出类型信息</strong>, 另外萃取器是一种<strong>技术</strong>, 是一个可以实现萃取功能的类, 并且同时也需要被萃取类的帮助才行. </p><p>我们先来介绍书中的典例 - 迭代器 :</p><p>迭代器大家都熟知, 并且迭代器有五种迭代器类别 : <strong>只读迭代器, 只写迭代器, 单向读写迭代器, 双向读写迭代器, 随机读写迭代器</strong>, 这五种迭代器类型有明确的继承关系, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_iterator_tag</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">output_iterator_tag</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">forward_iterator_tag</span>: <span class="hljs-keyword">public</span> input_iterator_tag &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bidirectional_iterator_tag</span>: <span class="hljs-keyword">public</span> forward_iterator_tag &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">random_access_iterator_tag</span>: <span class="hljs-keyword">public</span> bidirectional_iterator_tag &#123;&#125;;<br></code></pre></td></tr></table></figure><p>另外STL库中还有许多模板函数, advance函数便是其中之一, 其声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span>;<br></code></pre></td></tr></table></figure><p>其接收一个迭代器类型参数和一个距离类型参数, 意在实现<code>iter += d</code>这种操作, 也就是让iter按d发生变化, 这是迭代器的基本功能. 但是不同的迭代器所能实现的操作有所差别 : </p><ul><li>只读只写迭代器和单向读写迭代器只能正向且一次一步读写(++). </li><li>双向读写迭代器可以双向一次一步读写(++, –).</li><li>随机读写迭代器可以跳跃读写(+&#x3D; x, -&#x3D; x).</li></ul><p>这就导致advance希望根据迭代器类别去实现不同的操作, 就像下面一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(判断iter是否是随机读写迭代器) &#123;<br>        iter += d;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断iter是否是双向读写迭代器) &#123;<br>        <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (d--) ++iter;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (d++) --iter;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断iter是否是迭代器) &#123;<br>        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 反向是违规的</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance not supported for input iterators.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (d--) ++iter;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>当然这只是我们的幻想, 直接判断迭代器类型这种技术在C++17才出现, 我们在后面也会讲解, 但是我们先看看前人是如何解决这个问题的.</p><p>解决方法自然就是用<strong>萃取器</strong>了, 我们先要知道萃取器要做到什么, 在本例中就是<strong>从迭代器类型IterT中得到迭代器的类别</strong>, 这里不要混淆了, 迭代器类型是专属于某些大类的迭代器(如vector, deque的iterator), 迭代器类别就是我们上面说的五种类别, 也就是我们要从迭代器类型中提取出的东西. </p><p>重点在于如何提取出来, 实际过程非常复杂, 但又缺一不可, 我在这里经过总结将其分为两个部分 : 准备阶段和使用阶段.</p><hr><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>在这一阶段, 我们需要做的工作有 : </p><ul><li><p><strong>为需要提取出相关信息的迭代器配置对应的标签</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; ... &gt;                  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;  <span class="hljs-comment">// 这里便配置了需要的标签</span><br>    ...<br>  &#125;:<br>&#125;;<br></code></pre></td></tr></table></figure><p>本例中我们对deque(双端队列)的迭代器进行操作, 使用typedef对其<code>iterator_category(迭代器类别)</code>进行了声明, 这其实就是在说明deque的迭代器是可以随机读写的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; ... &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag iterator_category;<br>    ...<br>  &#125;:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>在list中也是如此, list不支持随机读写, 只能双向读写, 因此它声明的是<code>bidirectional_iterator_tag</code>.</p></li><li><p><strong>准备一个萃取器类, 使其可以提取出迭代器中的对应标签.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span> &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> IterT::iterator_category iterator_category;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>提取的原理其实很简单, 这里需要萃取器类和被萃取类有一个<strong>共识</strong>, <strong>代表迭代器类别的标签名为<code>iterator_category</code></strong>, 这样只要向萃取器类中传入一个迭代器类型, 就可以通过<code>typedef typename IterT::iterator_category iterator_category;</code>这段代码将原本迭代器类型中的<code>iterator_category</code>, 赋给自己的<code>iterator_category</code>, 这样就实现了迭代器类别的提取.</p><p>当然我们可以发现这种萃取器只对typedef了<code>iterator_category</code>的自定义类型生效, 但在实际使用中普通指针也是类似迭代器的形式, 例如普通数组<code>int* arr</code>, 这里int*就可以当作是一种指针迭代器类, 它也可以做到随机读写访问. 因此我们可以使用模板的偏特化, 使其兼容指针迭代器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span>&lt;IterT*&gt;   <span class="hljs-comment">// 模板偏特化</span><br>&#123;<br>  <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="hljs-comment">// 直接设置普通指针的迭代器类型为随机读写迭代器</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="使用阶段"><a href="#使用阶段" class="headerlink" title="使用阶段"></a>使用阶段</h3><p>在准备阶段做出了萃取器后, 我们将要通过在advance函数中使用萃取器来达到我们原先希望的效果, 使用方法如下 : </p><ul><li>建立一个控制函数, 依旧是接受迭代器和距离.</li><li>建立一组特化函数, 除了接收迭代器, 距离, 还有迭代器类型.</li><li>在控制函数中利用萃取器萃取出迭代器类别, 将迭代器类别传入特化函数.</li><li>依靠<strong>重载解析</strong>机制, 将调用对应迭代器类型的特化函数.</li></ul><p>光看比较难以理解, 我们通过代码来分析 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//-------------特化函数-------------//</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::random_access_iterator_tag)</span>    <span class="hljs-comment">// 针对:random_access_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  iter += d;   <span class="hljs-comment">// 直接+=</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::bidirectional_iterator_tag)</span>    <span class="hljs-comment">// 针对bidirectional_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">while</span> (d--) ++iter; &#125;     <br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">while</span> (d++) --iter;&#125;       <span class="hljs-comment">// 可逐次++/--</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::input_iterator_tag)</span>   <span class="hljs-comment">// 针对input_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span> ) &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance&quot;</span>);    <br>  &#125;<br>  <span class="hljs-keyword">while</span> (d--) ++iter;   <span class="hljs-comment">// 只可逐次++</span><br>&#125;<br><br><span class="hljs-comment">//-------------控制函数-------------//</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span>           <span class="hljs-comment">// 控制函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 调用特化函数  </span><br>  <span class="hljs-built_in">doAdvance</span>(iter, d,                                              <br>    <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-built_in">iterator_category</span>()); <span class="hljs-comment">// 这里是最重点的地方                       </span><br>&#125;   <br></code></pre></td></tr></table></figure><p>我们先聚焦于控制函数, 调用特化函数应该都能理解, 重点在于 : </p><ul><li><strong>typename std::iterator_traits<IterT>::iterator_category()</strong></li></ul><p>这是<strong>特化函数的第三个参数</strong>, 这段代码如何理解?</p><ul><li><p>其中<code>typename</code>是为了防止编译器混淆, 确定后面的是一个类型(见条款42).</p></li><li><p><code>typename std::iterator_traits&lt;IterT&gt;::iterator_category</code>是一个类型, <strong>代表<code>iterator_traits</code>从<code>IterT</code>中取出的迭代器类别的类型</strong>.</p></li><li><p>后面加上**()**, 代表这是一个匿名变量, 这个参数本身没有任何用处, 所以使用匿名变量完全可行, <strong>其作用只在于传递一个类型, 触发内部的重载机制, 选择到正确的特化版本</strong>.</p></li></ul><p>再去分析特化函数, 上面给出了三个版本, <strong>第三个参数的类型分别是对应的迭代器类别</strong>, 这里连参数都没写在语法上是可行的, 因为确实不会用到, 没有写的必要. 这里要强调的一点是虽然没有<code>forward_iterator</code>的版本, 但是因为其和<code>input_iterator</code>的操作实质上是一样的, 这里会直接通过<strong>继承</strong>调用到其基类<code>input_iterator</code>的代码, 因此不需要多写.</p><hr><h3 id="现代C-中萃取器的使用方式"><a href="#现代C-中萃取器的使用方式" class="headerlink" title="现代C++中萃取器的使用方式"></a>现代C++中萃取器的使用方式</h3><p>先前我们介绍的使用方式是<strong>基于重载机制</strong>, 实现在编译期即可通过不同的迭代器类别选取不同的特化版advance.</p><p>一切的根本目的就是为了<strong>在编译期实现条件选择</strong>, 现在C++17中引入了<code>if constexpr</code>语法, 使得我们可以用类似if的语句实现编译器的条件选择, 就不需要再使用重载了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> category = <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category; <span class="hljs-comment">// 还是要先萃取出迭代器类别</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;category, std::random_access_iterator_tag&gt;)</span> </span>&#123;<br>        iter += d;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;category, std::bidirectional_iterator_tag&gt;) &#123;<br>        <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (d--) ++iter;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (d++) --iter;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;category, std::input_iterator_tag&gt;) &#123;<br>        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance not supported for input iterators.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (d--) ++iter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过标准库内置的<code>is_same_v</code>来判断两个类别是否相等, 其他均和普通if语句的操作一致.</p><hr><h3 id="更多类型信息可供提取"><a href="#更多类型信息可供提取" class="headerlink" title="更多类型信息可供提取"></a>更多类型信息可供提取</h3><p>在本条款中只针对<code>iterator_category</code>进行了提取, 但是事实上萃取器可以提取出更多的类型信息, 在<em>STL源码剖析</em>中主要提出了五种信息, 分别是 : value_type(迭代器所指对象的类型), difference_type(两个迭代器之间的距离类型), reference_type(迭代器所指对象的类型的引用), pointer_type(迭代器所指对象的类型的指针), iterator_category(迭代器类别).</p><p>这里<code>value_type</code>尤为常用, 像上文一样既然可以通过<code>iterator_category</code>来选取不同版本的代码, 那么也可以根据<code>value_type</code>(对象类型)来选取不同版本的代码, 所以说萃取器提供了非常灵活多样的编译期条件选取方式.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>可以使用萃取器技术提取出模板类型中的类型信息, 利用重载或C++17中的<code>if constexpr</code>实现编译期的条件选择.</li><li>实现萃取需要双方约定相同的类型信息名称.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
      <tag>萃取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款46 友元非成员函数</title>
    <link href="/2025/01/14/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE46%20%E5%8F%8B%E5%85%83%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2025/01/14/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE46%20%E5%8F%8B%E5%85%83%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款46-需要类型转换时请为模板定义友元非成员函数"><a href="#条款46-需要类型转换时请为模板定义友元非成员函数" class="headerlink" title="条款46 : 需要类型转换时请为模板定义友元非成员函数"></a>条款46 : 需要类型转换时请为模板定义友元非成员函数</h2><blockquote><p>本条款是条款24的延申讨论, 在引入模板的前提下, 如果我们想实现某些隐式类型转换的操作, 会需要比以往多一些额外的操作, 让我们通过本条款来理解.</p></blockquote><h3 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h3><p>还记得条款24中的<code>Rational</code>吗, 这是一个有理数类, 内部包含分子和分母, 可以由int隐式转换而来, 当时条款24中讨论的核心是如何让<code>Rational</code>支持混合运算, 就像下面这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result;          <br>result = oneHalf * <span class="hljs-number">2</span>;                 <br>result = <span class="hljs-number">2</span> * oneHalf;   <span class="hljs-comment">// 混合类型的乘法运算                          </span><br></code></pre></td></tr></table></figure><p>没有了解的可以看我往期的博客, 总之讨论最后的结果就是<code>operator*重载</code>不可以是成员函数(因为有this指针干扰), 要使用非成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果我们想写一个泛型的<code>Rational</code>, 我们会很自然地写出下面的版本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">const</span> T&amp; numerator = <span class="hljs-number">0</span>,     <br>           <span class="hljs-type">const</span> T&amp; denominator = <span class="hljs-number">1</span>);  <span class="hljs-comment">// 这个构造函数允许隐式类型转换</span><br><br>  <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <br>  <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;         <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,<br>                            <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>但很可惜, 当我们写出<code>result = oneHalf * 2;</code>这样的语句时根本无法通过编译, 其本质问题在于<strong>template的实参推导出了问题</strong>, 因为<strong>template实参推导过程中不将隐式类型转换纳入考虑</strong>, 2不能再像条款24中一样从int隐式转换为<code>Rationa</code>, 编译器只能试图从int中提取出T, 但这显然是不行的, 所以只能编译失败.</p><hr><h3 id="类内定义友元函数"><a href="#类内定义友元函数" class="headerlink" title="类内定义友元函数"></a>类内定义友元函数</h3><p>书中指出了解决方法 : </p><ul><li><strong>将这个非成员函数声明为友元.</strong></li></ul><p>我们在这里声明友元不是为了访问<code>Rational</code>中的<code>non-public</code>成分, 仅仅只是为了<strong>在类内部声明一个非成员函数</strong>, 这样在编译时<strong>这个非成员函数就会提前知道T是什么类型</strong>, 而不需要再通过template实参推导出, 前面的问题就迎刃而解了, 下面是新一版代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 声明友元模板函数</span><br>    <span class="hljs-keyword">typename</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs); <br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                <br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码在部分情况下是可以运行的, 也就是参数类型都是<code>Rational&lt;T&gt;</code>的情况下, 形如 <code>result = oneHalf * 2;</code>这样的语句依旧无法通过编译, 因为<strong>还是无法进行隐式转换</strong>! 我们知道Rational的隐式转换是通过其构造函数实现的, 但是当前情况是<code>operator*重载</code>被定义在类外, 由于template的存在, <code>Rational</code>和该函数没有任何联系, 该函数自然不能知道<code>Rational</code>的构造函数, 因此无法进行隐式转换.</p><p>解决方法也很简单 : </p><ul><li><strong>在类内定义友元函数</strong>.</li></ul><p>这种做法的本质是<strong>通过友元把一个非成员函数搬到了类内, 在类内接触到构造函数使之可以隐式类型转换</strong>. 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),      <br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());  <br>&#125;    <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样代码就可以正常运行了, 混合类型的运算也可以应对!</p><p>另外, 书中提出 : </p><ul><li><strong>在一个class template内, template名称可被用来作为”template和其参数”的简写</strong>.</li></ul><p>简单来说就是<code>Rational&lt;T&gt;</code>可以之间被替换为<code>Rational</code>, 仅限模板类内 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),      <br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());  <br>&#125;   <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这便是最简单可以达到目的的版本了!</p><hr><h3 id="令friend函数调用辅助函数"><a href="#令friend函数调用辅助函数" class="headerlink" title="令friend函数调用辅助函数"></a>令friend函数调用辅助函数</h3><p>在此基础上, 作者还提出了一点优化, 因为我们在条款30中说过, friend函数也会被在底层化为inline函数, 这在对于本例确实是优化, 因为这个函数只有一行, 但是假如这个函数很长就会带来代码膨胀的问题, 于是我们可以”<strong>令friend函数调用辅助函数</strong>“来避免这一问题.</p><p>在本例中确实没什么必要, 这里只是举个例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;                                                                         <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                      </span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,      <span class="hljs-comment">// 辅助函数, 代码可以非常长</span></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span>     </span><br><span class="hljs-function"></span>&#123;                                                         <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),   <br>                     lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span><br>  <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,<br>                              <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)   <br>  &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs); &#125;                      <span class="hljs-comment">// 这里直接在友元函数中调用辅助函数</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的代码非常巧妙, 我们可以知道辅助函数也是一个模板函数, 在这个函数里是无法进行隐式转换的, 但是实际效果依然可以隐式转换, 它支持各种混合运算! 因为所有的隐式转换都在<code>友元operator*重载</code>中进行, 在传给辅助函数时类型已经转换完毕!</p><hr><h3 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h3><p>我们可以再理一遍逻辑, 在引入模板的前提下 : </p><ul><li>为了支持混合运算, 运算符重载必须是非成员模板函数(成员模板函数有this干扰).</li><li>非成员模板函数实参推导过程中不将隐式类型转换纳入考虑.</li><li>因此要将其声明定义在类内, 本质是非成员函数, 不使用模板但达到模板类似的效果.</li><li>声明友元可以实现上述的需求.</li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>当我们希望一个模板类的运算可以支持”<strong>所有参数之隐式类型转换</strong>“时, 将那些函数定义为”<strong>class template内部的friend函数</strong>“.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款45 运用成员函数模板接受所有兼容类型</title>
    <link href="/2025/01/13/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE45%20%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/13/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE45%20%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="条款45-运用成员函数模板接受所有兼容类型"><a href="#条款45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45 : 运用成员函数模板接受所有兼容类型"></a>条款45 : 运用成员函数模板接受所有兼容类型</h2><blockquote><p>本条款中我们将会以智能指针为例, 介绍如何通过成员函数模板使一个模板类可以接受所有兼容类型.</p></blockquote><p>我们先来构建一个简单的继承体系 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span>: <span class="hljs-keyword">public</span> Top &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span>: <span class="hljs-keyword">public</span> Middle &#123; ... &#125;;<br>Top *pt1 = <span class="hljs-keyword">new</span> Middle;                   <span class="hljs-comment">// Middle*隐式转换为Top*</span><br>Top *pt2 = <span class="hljs-keyword">new</span> Bottom;                   <span class="hljs-comment">// Bottom*隐式转换为Top*</span><br><span class="hljs-type">const</span> Top *pct2 = pt1;  <span class="hljs-comment">// Top*隐式转换为const Top*</span><br></code></pre></td></tr></table></figure><p>在本例中, <code>Top</code>是最初始的基类, 依次派生出<code>Middle</code>和<code>Bottom</code>, 通过隐式转换, 各种指针类型是可以合理地进行隐式转换的. 但当我们想用智能指针代行管理事务时, 再想这样的转换就比较麻烦了, 当然标准库中的智能指针已经解决了这种问题, 我们现在要讨论的就是标准库是如何实现智能指针之间的隐式转换的, 我们期待的效果如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:                             <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(T *realPtr)</span></span>;    <span class="hljs-comment">// 通过资源指针进行初始化</span><br>  ...<br>&#125;;<br><br>SmartPtr&lt;Top&gt; pt1 = <span class="hljs-built_in">SmartPtr</span>&lt;Middle&gt;(<span class="hljs-keyword">new</span> Middle);   <br>SmartPtr&lt;Top&gt; pt2 = <span class="hljs-built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="hljs-keyword">new</span> Bottom); <br>SmartPtr&lt;<span class="hljs-type">const</span> Top&gt; pct2 = pt1; <br></code></pre></td></tr></table></figure><p>这段代码是无法通过编译的, 因为就算是<code>Top</code>和<code>Middle</code>有联系, <code>SmartPtr&lt;Top&gt;</code>和<code>SmartPtr&lt;Middle&gt;</code>也没有任何联系, 它们是无法隐式转换的, 但是我们可以通过成员函数模板, 具体说是写一个泛化copy构造函数来创造这种联系.</p><hr><h3 id="泛化copy构造函数"><a href="#泛化copy构造函数" class="headerlink" title="泛化copy构造函数"></a>泛化copy构造函数</h3><p>我们先来写一个成员函数模板中的<strong>泛化copy构造函数</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;                       <span class="hljs-comment">// 泛化copy构造函数</span><br>  <span class="hljs-built_in">SmartPtr</span>(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other);       <br>  ...                 <br>&#125;;<br></code></pre></td></tr></table></figure><p>这个模板函数接受用一个<code>SmartPtr&lt;U&gt;</code>类型的参数去构造一个<code>SmartPtr&lt;T&gt;</code>类型的对象, 现在还只是声明, 我们应该考虑如何定义内部逻辑, 正常逻辑应该是先看<code>U*</code>是否可以隐式转换为<code>T*</code>, 如果可以转换也就可以进行智能指针之间的转换, 我们来看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">  <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other)</span>         </span><br><span class="hljs-function">  : heldPtr(other.get()) &#123;</span>...&#125;            <span class="hljs-comment">// 关键代码</span><br>    <br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> heldPtr; &#125;<br>  ...<br><span class="hljs-keyword">private</span>:                                     <br>  T *heldPtr;                                <br>&#125;;<br></code></pre></td></tr></table></figure><p>这里直接将参数other中的<code>heldPtr</code>取出, 赋值给当前对象的<code>heldPtr</code>. 其实在这里就进行了检查 : </p><ul><li><code>other.get()</code>取出的指针类型为<code>U*</code>, 如果<code>U*</code>可以隐式转换为<code>T*</code>, 那么可以进行智能指针之间的转换.</li><li>如果不可以隐式转换, 编译错误, 会被系统拦截.</li></ul><p>至此, 通过泛化copy构造函数这个成员函数模板, 只要<code>U*</code>可以隐式转换为<code>T*</code>, 那么<code>SmartPtr&lt;U&gt;</code>也可以隐式转换为<code>SmartPtr&lt;T&gt;</code>.</p><hr><h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3><p>成员函数模板的效用不只局限于构造函数, 也可以支持赋值操作, 其不改变语言规则, 但是可以帮助你让class在构造和赋值操作上可以兼容更多类型, 让我们在使用模板类型时可以像使用非模板类型时一样自然流畅. 我们可以了解一下标准库中<code>shared_ptr</code>的简略版本, 看看其对成员函数模板的使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y * p)</span></span>;                         <span class="hljs-comment">// 泛化构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;                 <span class="hljs-comment">// 泛化copy构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(weak_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;          <span class="hljs-comment">// 通过weak_ptr构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(unique_ptr&lt;Y&gt;&amp; r)</span></span>;<span class="hljs-comment">// 通过unique_ptr构造</span><br>  <span class="hljs-comment">// 赋值</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                                    <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r);      <span class="hljs-comment">// 泛化赋值重载</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                                     <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&lt;Y&gt;&amp; r);            <span class="hljs-comment">// 用unique_ptr赋值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>在本例中,  构造函数中只有泛化copy构造函数没有explicit, 说明其他构造函数都不应当支持隐式类型转换, 也就是说T和Y的类型应当一致. 另外成员模板函数并<strong>不改变语言规则</strong>, 就算我们写了泛化的拷贝构造函数和赋值重载, 依旧不影响普通的拷贝构造和赋值重载, 如果我们没有写, 编译器还是会自动生成, 所以如果想要控制构造的方方面面, 我们应当<strong>同时声明普通版本和泛化版本</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">shared_ptr</span>(shared_ptr <span class="hljs-type">const</span>&amp; r);                 <span class="hljs-comment">// 普通拷贝构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                </span><br><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;            <span class="hljs-comment">// 泛化拷贝构造</span><br><br>  shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr <span class="hljs-type">const</span>&amp; r);      <span class="hljs-comment">// 普通赋值重载</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                               <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r); <span class="hljs-comment">// 泛化赋值重载</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>使用成员函数模板可以生成”可接受所有兼容类型”的函数.</li><li>当我们声明泛化拷贝构造和赋值重载时, 也应该声明其普通版本.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款44 防止代码膨胀</title>
    <link href="/2025/01/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE44%20%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80/"/>
    <url>/2025/01/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE44%20%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80/</url>
    
    <content type="html"><![CDATA[<h2 id="条款44-将与参数无关的代码抽离templates"><a href="#条款44-将与参数无关的代码抽离templates" class="headerlink" title="条款44 : 将与参数无关的代码抽离templates"></a>条款44 : 将与参数无关的代码抽离templates</h2><blockquote><p>我们知道代码重复和过度的inline都可能导致代码膨胀, 而在模板中会发生比较隐晦的代码重复, 我们应当尽力去避免代码重复的情况发生, 而最核心的方法就是将与参数无关的代码抽离templates, 让我们通过本条款进行了解.</p></blockquote><p>在本条款中我们将会了解 : </p><ul><li>在模板中什么情况下会发生代码膨胀?</li><li>如何缓解这种代码膨胀?</li><li>在缓解代码膨胀后如何知道该操作什么数据?</li></ul><hr><h3 id="代码膨胀"><a href="#代码膨胀" class="headerlink" title="代码膨胀"></a>代码膨胀</h3><p>举个例子, 假设你想为固定尺寸的正方矩形编写一个template, 该矩形指出逆矩阵运算 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,           <span class="hljs-comment">// 矩阵的元素类型是T</span><br>         std::<span class="hljs-type">size_t</span> n&gt;        <span class="hljs-comment">// 矩阵的固定尺寸为n, 这是非类型模板参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> &#123;         <br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 求逆功能</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在使用这个类型时 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; sm1;      <span class="hljs-comment">// SquareMatrix&lt;double, 5&gt;类型</span><br>...<br>sm<span class="hljs-number">1.</span><span class="hljs-built_in">invert</span>();                 <br><br>SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; sm2;     <span class="hljs-comment">// SquareMatrix&lt;double, 10&gt;类型</span><br>...<br>sm<span class="hljs-number">2.</span><span class="hljs-built_in">invert</span>(); <br></code></pre></td></tr></table></figure><p>我们应该已经注意到, 只要T和n有不同, 在实际上编译器就会重新编译出一份代码. 在本例中, 仅仅只是在尺寸上有差别, 但还是在底层编译出了两份除了尺寸不一样但是其他都相近的代码, 这就造成了实际意义上的代码膨胀.</p><p>你也许会觉得这样无可厚非, 这就是模板机制导致的, 但是细想<code>invert()</code>这个函数, 对矩阵求逆的过程基本都是相同的, 只是矩阵的尺寸有差别罢了, 我们可以通过某些手法将<code>invert()</code>抽离出来, 使其不必频繁编译, 这便是我们接下来要介绍的解决方法.</p><hr><h3 id="将实现类和功能类分离"><a href="#将实现类和功能类分离" class="headerlink" title="将实现类和功能类分离"></a>将实现类和功能类分离</h3><p>我们可以把一个类拆分, 把功能函数拆分出来作为基类, 实现类作为子类.</p><p>让我们直接给出例子, 根据例子来介绍 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                   <span class="hljs-comment">// 基类 - 功能类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> &#123;               <br><span class="hljs-keyword">protected</span>:   <span class="hljs-comment">// 这里是protected, 不对外公开, 只给派生类调用</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>; <span class="hljs-comment">// 这里实际是用函数参数替代掉了SquareMatrixBase的模板参数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;    <span class="hljs-comment">// 派生类 - 实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;   <span class="hljs-comment">// 见条款33, 避免遮掩</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;   <span class="hljs-comment">// 调用模板基类的成员函数, 见条款43</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<code>SquareMatrix</code>是实现类, 也就是我们正常使用的类型, 它的情况还是和上面一致, 只要T和n有不同, 还是会生成一份额外的代码, 但是不同的是<strong>它把大量的实际代码移到了功能类中(这里只显示了invert, 实际可以有很多功能函数), 使本身的代码量骤减, 大大减少了额外代码的生成</strong>.</p><p>这里<code>SquareMatrixBase</code>是功能类, 他负责给派生类提供相应的功能, 我们从派生类<strong>private继承</strong>自它便可看出. 它只有一个T模板参数, 也就是说它<strong>只对”矩阵元素对象的类型”参数化, 不对”矩阵的尺寸”参数化</strong>, 也就是说只要T相同, 就算派生类的n是任何数字, 都将使用同一份代码 , 不会再编译出多份代码, 我们也可以认为<strong>实际上是用函数参数替代掉了SquareMatrixBase的模板参数</strong>. </p><hr><h3 id="数据操作问题"><a href="#数据操作问题" class="headerlink" title="数据操作问题"></a>数据操作问题</h3><p>在解释这个问题之前, 我们应该再引入一个前提, 就是<strong>SquareMatrix应该是有一个存储数据的成员变量的</strong>, 这应当很容易理解, 在最初版<code>SquareMatrix</code>中就可以是这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,         <br>         std::<span class="hljs-type">size_t</span> n&gt;       <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> &#123;         <br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;            <br>    <br><span class="hljs-keyword">private</span>:<br>  T data[n * n];              <span class="hljs-comment">// 存储矩阵数据的成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在最初版中, <code>invert()</code>可以直接对data进行操作, 但是当我们把实现类和功能类分离后, <strong>data肯定还是在实现类中</strong>, 因为控制数据应当是实现类的职责, 并且这样子便于动态内存的分配; <strong>但是invert()到了功能类, 无法直接对data进行修改</strong>, 功能类函数该如何实际修改data中的数据, 这便是我们要解决的问题.</p><p>其实解决方式也很简单, <strong>在SquareMatrixBase中存储一个指向data的指针</strong>就好了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-built_in">SquareMatrixBase</span>(T *pMem)     <br>  :<span class="hljs-built_in">pData</span>(pMem) &#123;&#125;                    <span class="hljs-comment">// 在构造函数中接受传入的资源指针</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataPtr</span><span class="hljs-params">(T *ptr)</span> </span>&#123; pData = ptr; &#125;     <span class="hljs-comment">// 重新设置资源指针</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>;       <span class="hljs-comment">// 内部直接用pData这个指针对资源进行调整</span><br><br><span class="hljs-keyword">private</span>:<br>  T *pData;                                    <span class="hljs-comment">// 指向资源</span><br>&#125;;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SquareMatrix</span>()                             <br>  : <span class="hljs-built_in">SquareMatrixBase</span>&lt;T&gt;(data) &#123;&#125;          <span class="hljs-comment">// 向基类构造传入资源指针</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br><span class="hljs-keyword">private</span>:<br>  T data[n*n];<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以自行决定实现类中数据内存的分配方式, 在上文中<code>T data[n*n];</code>是将数据存储在了对象内部, 也就是栈上. 我们也可以通过动态分配内存的方式将数据存入堆上(通过new来分配内存) : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SquareMatrix</span>()                          <br>  : <span class="hljs-built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="hljs-number">0</span>),            <br>    <span class="hljs-built_in">pData</span>(<span class="hljs-keyword">new</span> T[n*n])                    <span class="hljs-comment">// 向基类构造传入new出来的指针</span><br>  &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setDataPtr</span>(pData.<span class="hljs-built_in">get</span>()); &#125;      <br>  ...                                     <br><br><span class="hljs-keyword">private</span>:<br>  std::unique_ptr&lt;T&gt; pData;           <span class="hljs-comment">// 使用智能指针管理内存</span><br>&#125;; <br></code></pre></td></tr></table></figure><hr><h3 id="类型参数导致的代码膨胀"><a href="#类型参数导致的代码膨胀" class="headerlink" title="类型参数导致的代码膨胀"></a>类型参数导致的代码膨胀</h3><p>我们可以发现上文都对非类型参数(n)导致的代码膨胀提供的解决方案, 但是类型参数(T)也同样会导致代码膨胀, 不同的T也会产生不同的编译版本, 有些类型在底层其实是非常相近甚至相同的, 例如int和long, 各种指针类型之间. </p><p>假设T是一个指针类型, 所有指针类型都有着相同的二进制表述, 其实编译出来的代码基本一致, 只是指针类型不一样而已. 那么我们就可以在模板函数中将这些指针转换为<code>void*</code>, 然后调用操作<code>void*</code>指针类型的函数, 由后者完成实际函数, 也可以达到类似防止代码膨胀的效果, 标准库中的vector, list等都用过这种方式, 以下是list在底层的类似实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListBase</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back_impl</span><span class="hljs-params">(<span class="hljs-type">void</span>* value)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 `void*` 实现通用逻辑</span><br>        *(pdata + size) = value;<br>        size++;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span>* pData;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> : <span class="hljs-keyword">private</span> ListBase &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T* value)</span> </span>&#123;<br>        <span class="hljs-comment">// 转换为 `void*`，调用底层通用逻辑</span><br>        <span class="hljs-built_in">push_back_impl</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(value));<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span>* data[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 用 `void*` 存储所有指针类型</span><br>&#125;;<br><br><span class="hljs-comment">// `list&lt;int*&gt;` 和 `list&lt;const int*&gt;` 都调用相同的底层代码</span><br>List&lt;<span class="hljs-type">int</span>*&gt; list1;<br>List&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>*&gt; list2;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>使用模板会有隐含的代码膨胀产生, 我们可以通过将一些功能函数抽离出来作为基类, private继承给派生类来避免代码膨胀.</p></li><li><p>因非类型模板参数(n)造成的代码膨胀, 往往可消除, 可以用<strong>函数参数或class成员变量</strong>替换掉非类型模板参数.</p></li><li><p>因类型模板参数(T)造成的代码膨胀, 往往可降低, 可以让<strong>底层二进制表述完全相同的类型(如指针)共享功能函数</strong>.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款43 模板基类的继承</title>
    <link href="/2025/01/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE43%20%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/01/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE43%20%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款43-学习处理模板化基类内的名称"><a href="#条款43-学习处理模板化基类内的名称" class="headerlink" title="条款43 : 学习处理模板化基类内的名称"></a>条款43 : 学习处理模板化基类内的名称</h2><blockquote><p>在本条款中我们将探讨继承与模板共同使用时的注意事项, 有些我们通过学习继承得来的直觉在这里可能不再适用, 当我们从Object Oriented C++ 跨进 Template C++, 继承就不像以前那样畅行无阻了.</p></blockquote><h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>我们先引入一个例子, 假设我们要写一个程序, 他能够传送信息到若干不同公司去, 大部分公司传输的信息不需要加密, 少部分公司传输的信息需要加密. 那么在实际编写中就是写一个<code>MsgSender</code>模板类, 模板参数是公司类型, 针对需要加密信息的公司进行全特化. 我们通过代码来理解.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 两个公司类, 传递信息都不需要加密</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgInfo</span> &#123; ... &#125;;                  <span class="hljs-comment">// 用来保存信息的类</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span>  <span class="hljs-comment">// 发送不加密的信息</span></span><br><span class="hljs-function">  </span>&#123;<br>    std::string msg;<br>    create msg from info;<br><br>    Company c;<br>    c.<span class="hljs-built_in">sendCleartext</span>(msg);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设我们想要在<code>MsgSender</code>的前提下再加入日志志记的功能, 继承它可能是一个最高效的方式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>: <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  ...                                    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// 信息发送前进行记录日志</span><br><br>    <span class="hljs-built_in">sendClear</span>(info);           <span class="hljs-comment">// 错误! 这里根本无法通过编译 </span><br>      <br>    <span class="hljs-comment">// 信息发送后进行记录日志</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种继承方式在<code>Object Oriented C++</code>领域中是没有任何问题的, 但是一旦加上了模板, 在事实上你会发现这个代码根本无法通过编译, 这就是我们本条款需要解决的问题.</p><hr><h3 id="问题核心"><a href="#问题核心" class="headerlink" title="问题核心"></a>问题核心</h3><p>开门见山地指出问题核心 : <strong>模板类存在特化这种操作</strong>, 因此普通模板类有的函数, 特化版本却不一定有. </p><p>我们假设还有一个公司Z, 它要求自己传送的信息必须加密, 我们看看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyZ</span> &#123;                             <span class="hljs-comment">// 要求发送加密信息</span><br><span class="hljs-keyword">public</span>:                                    <br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                          <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;                <br><span class="hljs-keyword">public</span>:                                  <br>  ...                                     <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123; ... &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们发现, 当我们对MsgSender进行全特化后, 这个特化版本中并没有<code>sendClear</code>! 然而LoggingMsgSender中使用到了sendClear这个函数, 那么当LoggingMsgSender继承到的是这个特化版本时, 报错也就在所难免了.</p><hr><h3 id="深入探讨"><a href="#深入探讨" class="headerlink" title="深入探讨"></a>深入探讨</h3><p>这种现象出现的本质在于, 在派生类中使用到的基类的功能, 因为特化的存在, 在一些版本有这种功能, 另外一些版本就可能没有, 所以C++可以选择的方式解决方案有两种 : </p><ul><li>假定继承而来的基类<strong>没有</strong>这些功能, 除非程序员明确指出有, 会在编译期报错.</li><li>假定继承而来的基类<strong>有</strong>这些功能, 程序员自行承担继承错误基类的风险, 会在运行期报错.</li></ul><p>在事实上C++选择了前者, 因为这样更加规范, 起码不会在运行中产生错误.</p><p>而其对应做出的行为就是 : <strong>C++不进入templatized base classes(模板基类)观察</strong>, 也就是C++不会去模板基类中找用到的成员, 除非程序员指定, 我们接下来将会介绍指定方法.</p><hr><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>其实就是在程序员通过自己的分析后, 明确告诉它有对应的功能, 总共有三种方式 : </p><ul><li><p>在基类函数前加上<code>this-&gt;</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ...<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(info);                <span class="hljs-comment">// 编译通过</span><br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>使用using声明式.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>: <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;   <span class="hljs-comment">// 提前告诉编译器基类中存在sendClear</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ...<br>    <span class="hljs-built_in">sendClear</span>(info);    <span class="hljs-comment">// 编译通过               </span><br>    ...<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>明确指出函数位于基类内.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(info);      <span class="hljs-comment">// 编译通过</span><br>    ...                                       <br>&#125;   <br></code></pre></td></tr></table></figure><p>这种方式并不推荐, 因为其会关闭虚函数的绑定行为, 如果sendClear是虚函数的话, 将会强制使用当前基类的版本.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>继承模板基类后, 想要使用继承而来的成员, 必须通过<code>this-&gt;</code>或<code>using声明式</code>指定.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款42 typename</title>
    <link href="/2025/01/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE42%20typename/"/>
    <url>/2025/01/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE42%20typename/</url>
    
    <content type="html"><![CDATA[<h2 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42 : 了解typename的双重意义"></a>条款42 : 了解typename的双重意义</h2><blockquote><p>本条款中我们将了解typename的两种使用场景, 对typename的内涵及使用加深认知.</p></blockquote><h3 id="template声明式"><a href="#template声明式" class="headerlink" title="template声明式"></a>template声明式</h3><p>在template的声明中, <code>template&lt;class T&gt;</code>和<code>template&lt;typename T&gt;</code>都是被允许的, 这两种写法并没有任何差别, C++对这两种写法一视同仁, 但是在真正使用中, 作者还是建议在传入自定义类时用class, 在传入任意类型(包括int等)时用typename, 这样会增加代码的可读性.</p><hr><h3 id="针对嵌套从属类型名称的应用"><a href="#针对嵌套从属类型名称的应用" class="headerlink" title="针对嵌套从属类型名称的应用"></a>针对嵌套从属类型名称的应用</h3><p>先让我们认识<strong>嵌套从属类型名称</strong>的定义 : </p><ul><li>从属 : 依赖于某个template参数.</li><li>嵌套 : 在class内呈嵌套状.</li><li>从属嵌套类型名称 : 在class内呈嵌套状且依赖于某个template参数的类型名称.</li></ul><p>我们通过下面的代码来理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;                           </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span>              </span><br><span class="hljs-function"></span>&#123;                                               <br>  <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>     <span class="hljs-function">C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;  <span class="hljs-comment">// 这里的C::const_iterator便是从属嵌套类型名称</span><br>     ++iter;                                    <br>     <span class="hljs-type">int</span> value = *iter;                        <br>     std::cout &lt;&lt; value;                        <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是无法通过编译的, 我们只有在前头加上typename才可以通过编译, 这是因为编译器起初并不确定<code>C::const_iterator</code>是一个类型名称, 所以当你明确指明其是一个类型名称之后, 编译器就可以正常运作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>; <span class="hljs-comment">// 这样就可以了</span><br></code></pre></td></tr></table></figure><ul><li><p>所以为什么编译器无法确定这是一个类型名称呢? </p><p>其实是为了代码的严谨性, 我们举一个极端一点的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">C::const_iterator* x;<br></code></pre></td></tr></table></figure><p>当我们写下这样的代码时, 编译器并不知道<code>const_iterator</code>是C中的类型还是成员变量, 如果它是成员变量的话, 那么这其实是一个乘法运算式, *是乘号; 如果他是类型, 那么这其实就是一个定义式, *代表着指针. 这两种情况都完全合法, 因此需要程序员明确指出其究竟是什么才行.</p></li></ul><hr><h3 id="两个例外"><a href="#两个例外" class="headerlink" title="两个例外"></a>两个例外</h3><p>在一般情况下, typename必须作为嵌套从属类型名称的前缀词, 这一规则的例外是, typename不可出现在<strong>继承语句和初始值列表</strong>中, 这是C++中定死的, 没有必要去了解为什么, 记住就行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested &#123; <span class="hljs-comment">// 继承语句不可加typename </span><br><span class="hljs-keyword">public</span>:                                 <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">  : Base&lt;T&gt;::Nested(x)                  // 初始值列表不可加typename</span><br><span class="hljs-function">  &#123;</span>                                    <br><br>    <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;      <span class="hljs-comment">// 这里可以加</span><br>    ...                               <br>  &#125;                                    <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="typename和typedef的组合使用"><a href="#typename和typedef的组合使用" class="headerlink" title="typename和typedef的组合使用"></a>typename和typedef的组合使用</h3><p>我们知道了typename会与嵌套从属类型名称绑定, 并且其实在一些情况下嵌套从属类型名称是很长的, 我们会习惯把typedef与typename组合, 将一个类型的书写长度缩短, 我们通过下面的例子了解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workWithIterator</span><span class="hljs-params">(IterT iter)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;<br>  <span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这是这个组合的经典用法, 在STL标准库中就有大量的使用.</p><p>这里通过typedef将<code>typename std::iterator_traits&lt;IterT&gt;::value_type</code>这个如此长的类型缩短到<code>value_type</code>, 不用想也一定会减少大量的代码量. 至于为什么会有这么长的类型, 这与<code>iterator_traits</code>的萃取功能有关, 简单来说就是<code>IterT</code>是一个迭代器类型,而<code>iterator_traits</code>可以根据<code>iterT</code>通过<code>value_type</code>萃取出迭代器所指向资源的真实类型T. 我们将在条款47中再作讨论这部分内容, 如果想深入学习的话也可以去<code>STL源码剖析</code>中研读.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>typename作为template参数时, 和class意义完全相同.</li><li>typename必须作为嵌套从属类型名称的前缀词, 除非在继承语句和初始值列表中.</li><li>将typedef和typename组合可以减小代码复杂度.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款41 隐式接口和编译期多态</title>
    <link href="/2025/01/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE41%20%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/"/>
    <url>/2025/01/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE41%20%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="条款41-了解隐式接口和编译期多态"><a href="#条款41-了解隐式接口和编译期多态" class="headerlink" title="条款41 : 了解隐式接口和编译期多态"></a>条款41 : 了解隐式接口和编译期多态</h2><blockquote><p>从本条款开始, 我们将开始讨论模板与泛型编程, templates最初知识为了建立类型安全的泛用容器, 但在不断的发展中泛型编程的观念逐渐成型, 使得我们拥有了将写出的代码和其所处理的对象类型彼此独立的技术. 在本条款中我们将了解两个泛型编程中的核心概念–隐式接口和编译期多态.</p></blockquote><p>在面向对象编程中, <strong>显示接口和运行期多态</strong>是我们主要研究的对象 : </p><ul><li>显示接口 : 函数的签名式(函数名称, 参数类型, 返回类型).</li><li>运行期多态 : 在运行期通过对象的动态类型进行动态绑定, 可以使相同的代码展现出多态的效用.</li></ul><p>而在templates及泛型编程的世界, 底层逻辑和面向对象有根本的不同, 但也不是毫不相干, 在其中显示接口和运行期多态仍然存在, 但是重要性降低, <strong>隐式接口和编译期多态</strong>是其中的重中之重.</p><p>我们先来举一个例子, 帮助我们理解上面两个新概念 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) &#123;<br>      <span class="hljs-function">Widget <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>      temp.<span class="hljs-built_in">normalize</span>();<br>      temp.<span class="hljs-built_in">swap</span>(w);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个没有实际意义的<code>Widget</code>类, 只是为了促进我们的理解, 接下来我们将会写一个<code>doProcessing</code>的模板版本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) &#123;<br>     <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>     temp.<span class="hljs-built_in">normalize</span>();<br>     temp.<span class="hljs-built_in">swap</span>(w);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与原版的实现相似, 但是在实际编译中会有很大的差别, 我们比较直观的一个感受就是<strong>类型T至少应该有operator&gt;重载, operator!&#x3D;重载, 拷贝构造函数, normalize成员函数, swap成员函数(由上至下)</strong>, 不然编译肯定会报错, 这便是<strong>隐式接口</strong>最简单的一个理解.</p><ul><li>隐式接口在定义上是模板函数中的部分<strong>有效表达式</strong>.</li></ul><p>简单来说就是<strong>类型T必须可以做到表达式中的行为</strong>, <strong>如果做不到那便是隐式接口不匹配</strong>, 编译便无法通过, 在本例中的有效表达式便是<code>w.size() &gt; 10 &amp;&amp; w != someNastyWidget</code>, <code>T temp(w)</code>等. </p><p>并且由于其是隐式接口, 也可以通过<strong>隐式转换</strong>来进行匹配, 这么说比较晦涩, 举个例子就是<code>w.size() &gt; 10</code>这个表达式是应当返回一个bool类型的参数的, 但如果你的operator&gt;重载返回的是int类型, 并且以1作为true, 0作为false, 那么在编译中完全可以将int隐式转换为bool类型, 进而继续接下来的判断.</p><ul><li>编译期多态 : “以不同的template参数(T)具现化出来的function templates”会导致调用不同的函数.</li></ul><p>用术语来讲, 编译期多态基于<strong>模板具现化和函数重载解析</strong>, 但其实很容易理解, 白话讲就是<strong>在编译期根据不同的类型可以调用不同且对应的成员函数</strong>, 其效果与运行时多态在运行期动态绑定的行为相似, 因此被称为编译期多态.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>classes 和 templates 都支持接口和多态, templates不只有classes拥有的显示接口和运行时多态, 也有自己独有的隐式接口和编译期多态.</li><li>隐式接口基于有效表达式, 编译器多态基于模板具现化和函数重载解析.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款40 多重继承</title>
    <link href="/2025/01/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE40%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/01/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE40%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款40-明智而审慎地使用多重继承"><a href="#条款40-明智而审慎地使用多重继承" class="headerlink" title="条款40 : 明智而审慎地使用多重继承"></a>条款40 : 明智而审慎地使用多重继承</h2><blockquote><p>相比于java选择单继承+接口类多继承的方式, C++选择了更加直接的方式, 其允许多重继承存在. 不可否认的是确实大多数情况下单继承都可以胜任, 但是同样不可否认的是多重继承也一定有其用武之地. 在本条款中, 我们将认识多重继承, 了解辅助其实现的虚继承机制, 并且知晓多重继承的主要应用场景.</p></blockquote><p>多重继承的意思是<strong>继承一个以上的基类</strong>, 一般来说<strong>我们不希望这些基类在继承体系中又有更高级的继承</strong>, 这样会带来菱形继承的问题, 并且为了解决这种问题, 我们还要祭出虚继承这一机制来克服, 接下来我们将会逐一简单介绍菱形继承和虚继承机制.</p><hr><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>简而言之就是派生类继承的多个基类中, 含有共同的父类. 如下图所示 : </p><p><img src="/../img/image/001.png"></p><p>如此这般, 假设<code>IOFile</code>中有成员, 那么<code>InputFile</code>和<code>OutputFile</code>中也会继承相应的成员, 那么File就继承到了两份相同的成员. 那么如何处理这种情况就是C++要解决的问题, 如何解决有两派观点 : </p><ul><li><p>File中就是有两份成员, 这是最直观的逻辑, 所以调用时都必须指定明确的基类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">File f;<br>cout &lt;&lt; f.InputFile.a &lt;&lt; endl;  <span class="hljs-comment">// 假设IOFile中有成员变量a</span><br>cout &lt;&lt; f.OutputFile.a &lt;&lt; endl;<br>cout &lt;&lt; f.a &lt;&lt; endl; <span class="hljs-comment">// 编译错误!</span><br></code></pre></td></tr></table></figure></li><li><p><code>IOFile</code>只有一个文件名称, 所以继承自<code>IOFile</code>的成员不应当重复.</p></li></ul><p><strong>C++默认使用第一种方案, 毕竟这是最直观的逻辑, 但同时也提供了虚继承机制以支持第二种方案.</strong></p><hr><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>简而言之就是对存在菱形继承的基类们在继承时前加virtual, 那么以后就不会出现继承两份的情况了, C++在底层会解决所有问题.</p><p>图示如下 : </p><p><img src="/../img/image/002.png"></p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputFile</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> File &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputFile</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> File &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOFile</span>: <span class="hljs-keyword">public</span> InputFile,<br>              <span class="hljs-keyword">public</span> OutputFile<br>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>具体实现细节我们不再详述, 但是我们有必要再次明确虚继承的劣势 : </p><ul><li>使用虚继承产生的对象会<strong>体积更大, 访问速度更慢</strong>.</li><li>派生类必须为从虚继承而来的基类中的成员变量进行<strong>手动初始化</strong>.</li></ul><p>这对我们的代码编写和实际运行都有一定影响.</p><p>对于虚继承, 我们建议要<strong>尽量避免使用</strong>, 如果有必要也<strong>不要在虚基类中添置成员变量等数据</strong>.</p><hr><h3 id="多重继承的使用情景"><a href="#多重继承的使用情景" class="headerlink" title="多重继承的使用情景"></a>多重继承的使用情景</h3><p>上面的两个知识都运用在特殊情况下, 然而我们平时不会想也不建议出现菱形继承的情况. 熟练使用多重继承可以在一些情景下达到事半功倍的效果, 有一种情况最为常见, 如果我们<strong>希望某个类public继承自某个接口类, 并且private继承某个协助其实现的class</strong>, 我们接下来也会举出一个这样的例子 : </p><p>假设我们有一个塑模人的接口类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPerson</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IPerson</span>();<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个对人塑模的抽象基类, 我们希望使用工厂函数创造出一些可以被当作<code>IPerson</code>来使用的对象, 这些对象的静态类型是<code>IPerson</code>, 动态类型是<code>IPerson的派生类</code>, 工厂函数通过各种需求和条件生成对应的对象, 另外附加一点, 这个工厂函数要生成一个Person需要一个存储在数据库中的唯一id, 需要从用户处获取, 然后便可通过id获取Person的基本信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;IPerson&gt; <span class="hljs-title">makePerson</span><span class="hljs-params">(DatabaseID personIdentifier)</span></span>;  <span class="hljs-comment">// 工厂函数, 需要一个数据库id</span><br><br><span class="hljs-function">DatabaseID <span class="hljs-title">askUserForDatabaseID</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 向用户获取id的功能函数</span><br><br><span class="hljs-function">DatabaseID <span class="hljs-title">id</span><span class="hljs-params">(askUserForDatabaseID())</span></span>;  <span class="hljs-comment">// 用获取到的id创建DatabaseID对象</span><br><span class="hljs-function">std::shared_ptr&lt;IPerson&gt; <span class="hljs-title">pp</span><span class="hljs-params">(makePerson(id))</span></span>;  <span class="hljs-comment">// 将该对象传入工厂函数生成需求对象</span><br></code></pre></td></tr></table></figure><p>有了这些前戏, 我们就需要提供<code>IPerson</code>的派生类了, 我们假设这个class名为<code>CPerson</code>, 其必须继承自<code>IPerson</code>, 当然我们自然可以从无到有从写所有<code>IPerson</code>传来的接口函数, 但是假如我们有现成的一个可以帮助我们实现的类, 继承它可能是最好的选择 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInfo</span> &#123;<span class="hljs-comment">// 这个类被用来协助以各种格式打印从数据库中调出的数据</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PersonInfo</span><span class="hljs-params">(DatabaseID pid)</span></span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">PersonInfo</span>();<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">theName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">theBirthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 传出字符串的前缀</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// 传出字符串的后缀</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span>;                       <span class="hljs-comment">// 默认前缀, 可重写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;]&quot;</span>;                       <span class="hljs-comment">// 默认后缀, 可重写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::theName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">// 这个函数将会通过传入的数据库id调出且生成加工后的name</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> value[Max_Formatted_Field_Value_Length];  <span class="hljs-comment">// 缓存区</span><br>  std::<span class="hljs-built_in">strcpy</span>(value, <span class="hljs-built_in">valueDelimOpen</span>());  <span class="hljs-comment">// 写入前缀</span><br><br>  <span class="hljs-comment">// 中间可能会很长, 会实现利用id从数据库中调用name的操作</span><br> <br>  std::<span class="hljs-built_in">strcat</span>(value, <span class="hljs-built_in">valueDelimClose</span>());  <span class="hljs-comment">// 写入后缀</span><br><br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我们便可写出一个public继承自<code>IPerson</code>, private继承自<code>PersonInfo</code>的<code>CPerson</code>派生类, 他<strong>通过PersonInfo提供的功能实现了IPerson继承来的接口</strong>, 这种多重继承确实是<strong>最合理最高效最简洁</strong>的做法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPerson</span>: <span class="hljs-keyword">public</span> IPerson, <span class="hljs-keyword">private</span> PersonInfo &#123;     <span class="hljs-comment">// 采用多重继承</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CPerson</span><span class="hljs-params">(    DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                      </span><br><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> PersonInfo::<span class="hljs-built_in">theName</span>(); &#125;                     <span class="hljs-comment">// 直接取用PersonInfo的功能调出name字符串</span><br>                                                        <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                 </span><br><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> PersonInfo::<span class="hljs-built_in">theBirthDate</span>(); &#125;<span class="hljs-comment">// 同理</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>当前name()传出的字符串是<code>[name]</code>这种风格, 当然你也可以根据需求改变信息的格式, 我们可以通过重写<code>PersonInfo</code>虚函数的方式改变格式 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPerson</span>: <span class="hljs-keyword">public</span> IPerson, <span class="hljs-keyword">private</span> PersonInfo &#123;   <br>    ...<br><span class="hljs-keyword">private</span>:                                                <br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>; &#125;    <span class="hljs-comment">// 这里重写虚函数</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&gt;&quot;</span>; &#125;   <span class="hljs-comment">// 传出的格式改为 : &lt;name&gt;</span><br>&#125;; <br></code></pre></td></tr></table></figure><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>请把多重继承当作成一个工具, 它可以将不同的类以不同的方式结合到一起, public继承意味着”is-a”, private继承意味着”is-implemented-in-terms-of”, 当然如果你有一个单继承的设计方案可以达到相同的效果, 那么还是应当选用单继承. 多继承只是在一些情况下是最合理最高效最简洁的做法.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>多继承会比单继承复杂, 并且有可能会导致菱形继承, 引发对虚继承的需求.</li><li>虚继承会增加大小, 速度, 初始化等成本, 如果虚继承建议虚基类不要带任何数据.</li><li>多继承确实有其用武之地, 一种常见情况是”某个类public继承自某个接口类, 并且private继承某个协助其实现的class”.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>Effectiv C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款38-39 复合和private继承</title>
    <link href="/2024/12/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE38-39%20%E5%A4%8D%E5%90%88%E5%92%8Cprivate%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE38-39%20%E5%A4%8D%E5%90%88%E5%92%8Cprivate%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款38-通过复合塑膜出has-a或”根据某物实现出”"><a href="#条款38-通过复合塑膜出has-a或”根据某物实现出”" class="headerlink" title="条款38 : 通过复合塑膜出has-a或”根据某物实现出”"></a>条款38 : 通过复合塑膜出has-a或”根据某物实现出”</h2><blockquote><p>在条款32中我们认识了public继承意味着is-a, 本条款将会认识两个新的关系, 均可通过”复合”这一操作实现出来.</p></blockquote><hr><h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><p>所谓<strong>复合</strong>, 就是<strong>某种类型的对象内含其他类型的对象,</strong> 其实非常容易理解, 我们通过代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123; ... &#125;;           <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  std::string name;              <span class="hljs-comment">// 复合std::string</span><br>  Address address;               <span class="hljs-comment">// 复合Address</span><br>  PhoneNumber voiceNumber;       <span class="hljs-comment">// 复合PhoneNumber</span><br>  PhoneNumber faxNumber;          <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Person</code>类便是复合了<code>Address</code>和<code>PhoneNumber</code>两个类.</p><hr><h3 id="两种意义"><a href="#两种意义" class="headerlink" title="两种意义"></a>两种意义</h3><p>使用复合手法在不同领域的对象上, 有不同的意义, 我们先来定义两个领域 : </p><ul><li>应用域 : 当一个内置对象的目的是”<strong>这个类能做到什么(what)</strong>“, 它属于应用域, 上面的地址和电话便是如此.</li><li>实现域 : 当一个内置对象的目的是”<strong>这个类如何做到(how)</strong>“, 它属于实现类.</li></ul><p>在设置不同域的对象其代表的意义也不同, 让我们看下面两种意义 : </p><ul><li><p><strong>has-a(有一个)</strong> </p><p>当对象属于应用域, 如果A复合了B, 则代表A有一个B, A可以做出B的所有行为, 但不强制, 例如人有一个家.</p></li><li><p><strong>is-implemented-in-terms-of(根据某物实现出)</strong> </p><p>当对象属于实现域, 如果A复合了B, 则代表A根据B实现出来, A想要实现自己的功能要借助B的功能, 例如标准库中的unordered_set根据HashTable实现出来.</p><p>我如果不想用HashTable实现set, 也可以用list来实现, 书中给出的例子是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;                 <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">member</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  std::list&lt;T&gt; rep;                 <span class="hljs-comment">// 复用list实现另一个版本的set.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是Set就可以依靠list提供的机能来实现自己的功能 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">bool</span> Set&lt;T&gt;::<span class="hljs-built_in">member</span>(<span class="hljs-type">const</span> T&amp; item) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(rep.<span class="hljs-built_in">begin</span>(), rep.<span class="hljs-built_in">end</span>(), item) != rep.<span class="hljs-built_in">end</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Set&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> T&amp; item)<br>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">member</span>(item)) rep.<span class="hljs-built_in">push_back</span>(item);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Set&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> T&amp; item)<br>&#123;<br>  <span class="hljs-keyword">typename</span> std::list&lt;T&gt;::iterator it =               <br>    std::<span class="hljs-built_in">find</span>(rep.<span class="hljs-built_in">begin</span>(), rep.<span class="hljs-built_in">end</span>(), item);        <br>  <span class="hljs-keyword">if</span> (it != rep.<span class="hljs-built_in">end</span>()) rep.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::<span class="hljs-type">size_t</span> Set&lt;T&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> rep.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>public继承的意义完全不同.</li><li>在应用域中, 复合意味着<code>has-a</code>. 在实现域, 复合意味着<code>is-implemented-in-terms-of</code></li></ul><hr><h2 id="条款39-明智而审慎地使用private继承"><a href="#条款39-明智而审慎地使用private继承" class="headerlink" title="条款39 : 明智而审慎地使用private继承"></a>条款39 : 明智而审慎地使用private继承</h2><blockquote><p>通过本条款, 你将明晰private继承在继承体系中充当了什么样的角色, 其与public继承和复合又有怎样的区别.</p></blockquote><p>没错, private继承也有其所意味的东西, 但是这个意义我们已经了解过了, 那就是<strong>is-implemented-in-terms-of</strong>.</p><p>没错, private继承和复合除开在底层的实现细节不同, 它们可以实现相同的目的, 虽然有着不同的限制.</p><p>我们还是先回忆一下private继承会发生什么 : </p><ul><li>编译器<strong>不会自动将该派生类对象隐式转换为基类对象</strong>, 也就是说基类参数接口将无法接受该对象.</li><li>所有从基类继承而来的属性在派生类中<strong>都是private的</strong>, 纵使它们原来是public&#x2F;protect.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>...<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;    <br>    ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// 如果是private继承Person</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;   <span class="hljs-comment">// 按常理所有人都可以吃</span><br><br>Person p;                                  <span class="hljs-comment">// p is a Person</span><br>Student s;                                 <span class="hljs-comment">// s is a Student</span><br><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">eat</span>(s);   <span class="hljs-comment">// 错误! 无法隐式转换为基类</span><br>cout &lt;&lt; s.<span class="hljs-built_in">speak</span>() &lt;&lt; endl;   <span class="hljs-comment">// 错误! public已经转为private</span><br></code></pre></td></tr></table></figure><p>我们可以看出private继承和<code>is-a</code>的关系完全不沾边, 最终的实际效果其实就是<code>is-implemented-in-terms-of</code>(根据某物实现出).</p><p>若B private继承 自A, 说明A需要采用B中备妥的某些特性, A不需要传递B的什么接口, 而是希望使用B的一部分功能实现, 可以是直接使用, 也可以是有目的的重写, 我们可以肯定的是这样至少要比我们单独实现一份需求的功能来得方便.</p><hr><h3 id="什么时候使用private继承"><a href="#什么时候使用private继承" class="headerlink" title="什么时候使用private继承"></a>什么时候使用private继承</h3><p>既然我们知道private继承和复合都可以实现<code>is-implemented-in-terms-of</code>的效果, 那么应该选哪个呢? </p><p>答案是如果可以选复合, 最好优先选择复合, 毕竟private继承有时十分晦涩, 会大大降低代码的可读性, 我们对private继承的使用应当是<strong>明智而审慎</strong>的.</p><p>接下我们将说明什么情况下可以选用private继承 : </p><ul><li><p><strong>涉及protected成员&#x2F;virtual函数时</strong>. 当我们希望继承并重写一些virtual函数或是使用一些protected成员时, 如果我们<strong>不希望它们将基类接口或成员暴露出去</strong>, 就可以采用private继承, 因为其有天然转换为private的属性.</p><p>以下是书中的一个例子, <code>Widget</code>想利用<code>Timer</code>中的计时机制来实现一些定时触发的机制, 它希望重写其中的<code>onTick()</code> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// Timer每过一段时间就会触发一次onTick()</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<span class="hljs-comment">// private继承</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 重写Timer中的onTick(), 使其可以定时查看Widget的数据...</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样用户就不可能在外部调用到任何的<code>onTick</code>函数(包括基类和派生类的), 毕竟这只是为了实现内部的功能.</p></li><li><p><strong>有极大的空间要求时</strong>. 我们有时会面对一些空间十分有限的情况, 我们会非常希望去节省空间, 那么有一项技术值得我们研究 : </p><p>先引入一些前提, 我们有些时候会有创建并使用一些<strong>空类</strong>的需求, 目的在于用作类型标识, 占位符, 空对象之类的需求, 这样的需求始终存在并且在现代C++的重要性逐步提升, 比如通过类型表示进行类型推导, 实现在编译期即可进行判断的技术.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类型标识空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeB</span> &#123;&#125;;<br><br><span class="hljs-comment">//通过 if constexpr 在编译时确定类型并执行不同的行为, 提高了运行期效率</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identifyType</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;T, TypeA&gt;)</span> </span>&#123;   <span class="hljs-comment">// is_same_v是C++17引入的判断类型是否相同的类型特征</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TypeA\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, TypeB&gt;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TypeB\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown type\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">identifyType</span>(TypeA&#123;&#125;);  <span class="hljs-comment">// 输出 &quot;TypeA&quot;</span><br>    <span class="hljs-built_in">identifyType</span>(TypeB&#123;&#125;);  <span class="hljs-comment">// 输出 &quot;TypeB&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而使用这些空类符合”is-implemented-in-terms-of”的意味, 假设我们就是为了做类型标识, 那么如果我们想赋予一个类对应的类型标识来达到分类的效果, 我们可以让这个类复合或private继承空类来实现, 在这种情况下我们建议优先选择private继承, 这样可以通过继承的类型在编译器做出更多的操作, 并且也减小了对象大小, 这就是所谓的<strong>EBO(空白基类最优化)</strong>.</p><p>简单来说就是复合会增加对象大小(就算是空类也会), 而private继承<strong>完全不会增加大小, 而且还给了我们在编译期的可操作空间</strong>, 我们可以做到以下编译期类型识别的效果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空类型标识基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeB</span> &#123;&#125;;<br><br><span class="hljs-comment">// 派生类，通过private继承不同的空基类来在编译期区分类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">private</span> TypeA &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> : <span class="hljs-keyword">private</span> TypeB &#123;&#125;;<br><br><span class="hljs-comment">//通过 if constexpr 在编译时确定类型并执行不同的行为</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identifyType</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_base_of_v&lt;TypeA, T&gt;)</span> </span>&#123;   <span class="hljs-comment">// is_base_of_v是C++17引入的判断基类类型的类型特征</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is of TypeA\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_base_of_v&lt;TypeB, T&gt;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is of TypeB\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown type\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    AnotherClass b;<br><br>    <span class="hljs-built_in">identifyType</span>(a);  <span class="hljs-comment">// 输出: Object is of TypeA</span><br>    <span class="hljs-built_in">identifyType</span>(b);  <span class="hljs-comment">// 输出: Object is of TypeB</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="复合的优势"><a href="#复合的优势" class="headerlink" title="复合的优势"></a>复合的优势</h3><p>在上文我们讲了两种建议使用private继承的情况, 那么除此之外我们还是推荐能使用复合就使用复合, 其优势在于 : </p><ul><li>可读性高.</li><li>使用复合对象可以<strong>防止派生类重写其virtual函数</strong>. (private继承不可, 因为就算是private继承也可以重写private的virtual函数, 然后通过基类指针调用, 见条款35)</li><li>使用复合就可以<strong>使编译依存性降至最低</strong>, 如果继承必须可见定义, 而复合只需声明即可. (详见条款31)</li></ul><hr><h3 id="“public继承-复合”替代private继承"><a href="#“public继承-复合”替代private继承" class="headerlink" title="“public继承 + 复合”替代private继承"></a>“public继承 + 复合”替代private继承</h3><p>我们还可以通过”public继承 + 复合”替代一些场景下private继承的作用, 虽然这样会麻烦一些, 但值得我们考量, 我们将上文的Timer案例重写一下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    ...<br>  &#125;;<br>   WidgetTimer timer;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子中我们创建一个WidgetTimer的内部类, 其public继承自Timer, 其重写了onTick(), 并且我们立马在下面创建一个对应的复用对象, 我们可以发现这个private继承的效果类似, 并且也可以体现上述复合的优势.</p><p>当然这只适用于部分情况, private继承肯定还是有用武之地的.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>private继承意味着<code>is-implemented-in-terms-of</code>. </li><li>任何时候都优先选择复合, 除非一些特殊情况下.</li><li>private继承可以支持<code>EBO</code>, 并且在C++17中可以继承类型标识空类来实现编译期逻辑判断.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款36-37 两个绝不</title>
    <link href="/2024/12/20/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE36-37%20%E4%B8%A4%E4%B8%AA%E7%BB%9D%E4%B8%8D/"/>
    <url>/2024/12/20/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE36-37%20%E4%B8%A4%E4%B8%AA%E7%BB%9D%E4%B8%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="条款36-绝不重新定义继承而来的non-virtual函数"><a href="#条款36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36 : 绝不重新定义继承而来的non-virtual函数"></a>条款36 : 绝不重新定义继承而来的non-virtual函数</h2><p>本条款很容易理解, 援引以前的条款就可以说明为什么 : </p><ul><li><p>条款34中就提到过 : non-virtual函数意味着<strong>接口 + 强制性实现继承</strong>, 它不应当被改变. </p></li><li><p>重新定义继承而来的non-virtual函数会触发条款33中所说的<strong>遮掩</strong>机制.</p></li><li><p>触发遮掩机制其实是对条款32中”<strong>public意味着is-a</strong>“这个定理的破坏.</p></li></ul><p>如果你这么做了, 还可能会出现以下奇怪的效果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B &#123;  <span class="hljs-comment">// D派生自B</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 这个定义遮掩了B中的mf()</span><br>&#125;;  <br><br><span class="hljs-comment">//--------------------------------------------//</span><br><br>D x;                              <span class="hljs-comment">// 创建一个D对象</span><br><br>B *pB = &amp;x;                       <br>pB-&gt;<span class="hljs-built_in">mf</span>();                         <span class="hljs-comment">// 调用B::mf()</span><br><br>D *pD = &amp;x;                       <br>pD-&gt;<span class="hljs-built_in">mf</span>();    <span class="hljs-comment">// 调用D::mf()</span><br></code></pre></td></tr></table></figure><p>我们可以看到通过同一个对象D调用的<code>mf()</code>居然效果不同, 这也很容易理解, 毕竟non-virtual并没动态绑定, 只是依据当前对象的静态类型来调用的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>任何情况下都不应重新定义一个继承来的non-virtual函数.</li></ul><hr><h2 id="条款37-绝不重新定义继承而来的缺省参数值"><a href="#条款37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37 : 绝不重新定义继承而来的缺省参数值"></a>条款37 : 绝不重新定义继承而来的缺省参数值</h2><blockquote><p>先缩小本条款的范围, 通过条款36我们首先应该知道不应该修改继承来的non-virtual函数, 所以本条款的讨论范围将局限在”继承一个带有缺省参数的virtual函数”.</p></blockquote><p>首先明确本条款的核心知识 : </p><ul><li><strong>virtual函数本身是动态绑定的, 但是缺省参数值是静态绑定的.</strong></li></ul><p>简单理解就是virtual函数会根据对象的当前类型进行动态绑定, 而缺省值无法改变, 只和一开始定义的静态类型相关.</p><p>我们来看代码来理解 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;; <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// Shape默认缺省值为Red</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 这是一个糟糕的写法!</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// Shape默认缺省值为Green, 但是有用吗?</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 无缺省值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里设计了一个Shape基类, 派生出三角和圆, 我们来看调用时会发生什么 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以下的静态类型都是基类</span><br>Shape* ps;                       <br>Shape* pc = <span class="hljs-keyword">new</span> Circle;         <br>Shape* pr = <span class="hljs-keyword">new</span> Rectangle;      <br><br>pc-&gt;<span class="hljs-built_in">draw</span>();<br>pr-&gt;<span class="hljs-built_in">draw</span>();<br></code></pre></td></tr></table></figure><p>这样子调用看上去没有任何问题, 实际上也确实依靠动态绑定调用到了派生类对应的draw(), 但根据测试<code>pc-&gt;draw()</code>中color缺省值是Red而非Green, 这便是因为我们上述的理由, 缺省值看的是静态类型, 也就是Shape.</p><ul><li><p>为什么C++会设计成会这样?</p><p>其实是因为动态绑定缺省值的花销实在过大, C++为了效率做了这般取舍.</p></li></ul><hr><h3 id="由此引发出的另一个问题"><a href="#由此引发出的另一个问题" class="headerlink" title="由此引发出的另一个问题"></a>由此引发出的另一个问题</h3><ul><li><strong>当静态类型是派生类时, 将无法获取基类的缺省值!</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这样可以使用基类的缺省值</span><br>Shape* pc = <span class="hljs-keyword">new</span> Circle;            <br>pc-&gt;<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-comment">// 这样不行!</span><br>Circle* cc = <span class="hljs-keyword">new</span> Circle;<br>cc.<span class="hljs-built_in">draw</span>();    <span class="hljs-comment">// 错误, 自己没有缺省值, 并且也调不到基类的缺省值</span><br></code></pre></td></tr></table></figure><p>于是这样的机制似乎在逼迫我们要把所有含缺省值的virtual函数都手动填上和基类一样的缺省值, 就像下面的代码一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;; <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 都加上和基类相同的缺省值</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 都加上和基类相同的缺省值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>只有这样你才可以确保在任何使用场景下你的缺省值都可以正常生效.</p><p>但是这样值得吗? 显然是不值得的, 这里包含了<strong>代码重复和代码相依性</strong>两大弊病, 只要你想修改基类中的缺省值, 那么其他所有的派生类就都要修改, 这是我们非常不希望看到的, 还好我们有一个现成的解决方法.</p><hr><h3 id="藉由NVI手法解决上述问题"><a href="#藉由NVI手法解决上述问题" class="headerlink" title="藉由NVI手法解决上述问题"></a>藉由NVI手法解决上述问题</h3><p>没错, 就是我们条款35详细介绍的NVI手法(没看过的可以看我往期博客的对应部分, 这将很影响下文的理解), 我们<strong>让非虚函数接口有缺省值, 如果有缺省情况, 把这个缺省值传入具体实现的虚函数</strong>就可以了! 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span>           <span class="hljs-comment">// 非虚函数接口(包含缺省值), 见条款35</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">doDraw</span>(color);                                  <span class="hljs-comment">// 具体实现的虚函数接受color</span><br>  &#125;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 见条款35</span><br>&#125;;                                                  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// 这样就不必再加缺省值了!  </span><br>  ...                                                <br>&#125;;<br><br><span class="hljs-comment">//-----------------------//</span><br><br>Circle* cc = <span class="hljs-keyword">new</span> Circle;<br>cc.<span class="hljs-built_in">draw</span>();                 <span class="hljs-comment">// 这样的调用也被允许了!</span><br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝对不要重新定义一个继承而来的缺省参数值, 因为它是静态绑定的.</li><li>再想让virtual函数携带缺省值是, 不妨使用NVI手法, <strong>让非虚接口替虚函数携带缺省值</strong>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款34 接口继承和实现继承</title>
    <link href="/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34 : 区分接口继承和实现继承"></a>条款34 : 区分接口继承和实现继承</h2><blockquote><p>作为class的设计者, 我们有时希望派生类只继承成员函数的接口, 有时又希望同时继承接口和实现, 有时又希望能够重写所继承的实现,  因此我们的选择是多样的, 这里大有可以探讨的地方, 本条款将带我们区分不同的继承方法, 并对其做出建议</p></blockquote><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><p>首先让我们明晰各种继承方式的区别, 大体有三种继承方式 : </p><ul><li><p>接口继承 : <strong>pure virtual函数</strong>实现, 强制派生类<strong>继承接口</strong>.</p><p>这种方式的通过强制继承接口确保必需功能的实现.</p></li><li><p>接口 + 缺省实现继承 : <strong>virtual函数</strong>实现, 派生类可以选择重写, <strong>继承基类提供的接口和缺省实现</strong>.</p><p>这种方式可以灵活选择是继承缺省版本还是重写.</p></li><li><p>接口 + 强制实现继承 : <strong>non-virtual函数</strong>实现, 派生类<strong>继承接口和唯一实现</strong>.</p><p>这种方式就是给整个继承体系增加了一个固定的工具函数, 该函数不可重写.</p></li></ul><p>简单来说就是继承会继承接口, 但是否继承一份实现是看具体情况而定的.</p><hr><h3 id="纯虚函数也可以被定义"><a href="#纯虚函数也可以被定义" class="headerlink" title="纯虚函数也可以被定义"></a>纯虚函数也可以被定义</h3><p>在前面的条款中应该有提过纯虚函数定义的问题, 这里再着重研究一下 : </p><ul><li><strong>纯虚函数可以被定义</strong>, 但调用它的唯一途径是调用时<strong>明确指出其class名称</strong>.</li></ul><p>就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;...&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shape::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;draw&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Shape* ps = <span class="hljs-keyword">new</span> Rectangle;<br>ps-&gt;Shape::<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 这样便可以调用纯虚函数</span><br></code></pre></td></tr></table></figure><p>有了该定义, 便可以为上述的第二种继承方式提供<strong>更平常更安全的缺省实现</strong>.</p><hr><h3 id="“使用纯虚函数并定义”来替换普通虚函数的使用"><a href="#“使用纯虚函数并定义”来替换普通虚函数的使用" class="headerlink" title="“使用纯虚函数并定义”来替换普通虚函数的使用"></a>“使用纯虚函数并定义”来替换普通虚函数的使用</h3><p>先来引入前提, <strong>普通虚函数的重写并没有强制性, 并且在没有重写的情况下会自动继承缺省版本</strong>, 这点在实际应用中被认为是有风险的. 因为自动使用某些功能总是有可能超出使用者的预期的, 有些时候往往可能只是我们忘记重写, 本身并不希望使用缺省, 但实际却还是调用到了缺省, 这很有可能<strong>和我们想要实现的目的不一致, 但是在语法上是正确的, 我们不一定会意识到我们的错误</strong>. 书中举出了一个飞机公司的例子, 一开始有两种型号的飞机A和B, 新加入一个型号的飞机C,  其默认的飞行方式和AB都不同, 如果我们忘记重写fly函数, 自动调用的缺省函数可能不会符合我们的预期 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airport</span> &#123; ... &#125;;                     <span class="hljs-comment">// represents airports</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// fly的缺省行为</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br>  ...                                   <span class="hljs-comment">// 忘记重写C的fly, 调用的缺省行为也可能不符合我们的预期</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>理解起来并没有那么麻烦, 就是使用<code>virtual</code>函数并没有强制性检查, 程序员的疏忽可能导致错误.</p><p>于是我们提出了一个新的方式替代<code>virtual</code>函数(第二种继承方案) : </p><ul><li><strong>使用pure virtual函数并定义,  在想要使用缺省版本时显示指定缺省版本</strong>.</li></ul><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数声明fly</span><br>  ...<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span>     </span><br><span class="hljs-function"></span>&#123;                                                  <br>  <span class="hljs-comment">// 用纯虚函数的定义当作缺省版本</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;   <span class="hljs-comment">// 在想要调用缺省版本时显示调用</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 这里强制我们重写fly, 不想调用缺省版本就只能老实重写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们可以用更安全地方式实现普通<code>virtual</code>函数的作用, <strong>利用纯虚函数必须重写的机制来让我必须在缺省和重写中做出选择, 而没有”忘了”这种选项</strong>.</p><hr><h3 id="继承方式的选择"><a href="#继承方式的选择" class="headerlink" title="继承方式的选择"></a>继承方式的选择</h3><p>具体选择还是依靠我们的需求来决定, 每种继承方式应用的场景我们都应明晰, 最后做出明智的判断, 最后作者还给出了几点提醒: </p><ul><li>除非你的<code>class</code>没有多态用途, 不要将所有函数声明为<code>non-virtual</code>.</li><li>除非你要写接口类, 不要将所有函数声明为<code>virtual</code>, 这是不想思考的体现.</li><li><code>virtual</code>函数是有成本的, 但是考虑到80-20法则(程序有80%的时间花费在20%的代码身上), 有80%的<code>virtual</code>函数不会对效率产生冲击, 这需要我们合理考量.</li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p><code>pure virtual</code>函数只确保接口继承, 但是也可以进行定义.</p></li><li><p><code>virtual</code>函数在接口继承的同时可以选择是否继承实现, 可以用”使用纯虚函数并定义”的方式来替换以提高安全性.</p></li><li><p><code>non-virtual</code>函数在接口继承的同时继承一份强制性实现.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款33 继承, 重载与作用域</title>
    <link href="/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33 : 避免遮掩继承而来的名称"></a>条款33 : 避免遮掩继承而来的名称</h2><blockquote><p>本条款并非和继承有关, 而是在讨论由继承引发的作用域问题, 其有可能破坏条款32所确定的法则, 因此我们在其之后介绍本条款。</p></blockquote><p>我们知道在不同作用域下如果有相同名称的事物, 无论其功能或类型, 都是局部优先的. 继承的父子类也是类似, 不管是不是虚函数, 亦或是纯虚函数都完全没有关系, 都遵守相同名称局部优先的原则, 我们来看看一下的代码 :  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析代码我们可以发现, 派生类的函数都将覆盖基类相同名称的函数, 但没有什么原则上的问题.</p><p>但是如果加入重载, 事情就变得有些复杂了, 我们来看看接下来的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// mf1的重载</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;  <span class="hljs-comment">// mf3的重载</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们经过测试发现, 派生类调用<code>mf1</code>将只能调用到<code>Derived</code>中的<code>mf1()</code>, <code>mf3</code>也是如此, 而基类中的重载版本将无法再获取(除非用<code>Base::</code>). 以下我们将会介绍两种应用于不同情况下的解决办法.</p><hr><h3 id="using声明式"><a href="#using声明式" class="headerlink" title="using声明式"></a>using声明式</h3><p>让我们回顾条款32 : “<strong>public意味is-a</strong>“ , 也就是说派生类可以干出所有<code>Base</code>可以干的事, 但是在这种情况下, 基类可以使用<code>mf1(int)</code>, 而派生类却不可, 这便是打破了这个规则. 因此我们可以再在派生类重写对应的重载, 亦或是直接接受父类的重载版本, 就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::mf1;       <br>  <span class="hljs-keyword">using</span> Base::mf3;      <span class="hljs-comment">// 所有Base中的mf1和mf2在Derived中都可见</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如此便可<strong>避免遮掩继承而来的名称</strong>.</p><hr><h3 id="转交函数"><a href="#转交函数" class="headerlink" title="转交函数"></a>转交函数</h3><p><code>public</code>继承可以通过<code>using</code>暴露所有基类的名称及其对应的重载版本, 但当然也会有<code>private</code>继承(具体细节在条款39中讲解)有类似的需求, 但<code>private</code>继承不一定需要继承所有基类的重载版本, 可能只是某个被遮掩的版本, 于是我们可以通过<strong>转交函数</strong>, 来缩小获取的范围, 让我们看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>  ...                                   <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">private</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123; Base::<span class="hljs-built_in">mf1</span>(); &#125;                     <span class="hljs-comment">// 转交给基类, 选取其中的无参数版本</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>mf1</code>就只会有基类无参数版本的<code>mf1</code>对应的功能, 而使用不到带<code>int</code>的重载版本.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>派生类中的名称会遮掩基类中的名称.</li><li><code>public</code>继承必须接受所有基类中所有被遮掩的名称, 故用<code>using</code>声明式.</li><li><code>private</code>继承中可能有需要基类中被遮掩物的需求, 可以用转交函数声明调用基类函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款32 public继承</title>
    <link href="/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款32-确定你的public继承塑膜出-is-a-关系"><a href="#条款32-确定你的public继承塑膜出-is-a-关系" class="headerlink" title="条款32 : 确定你的public继承塑膜出 is-a 关系"></a>条款32 : 确定你的public继承塑膜出 is-a 关系</h2><blockquote><p>从本条款开始我们将步入面向对象编程这一重要领域进行讨论, 首先我们将会围绕public继承, 分析public继承的意义与目的, 再举出两个错误的public继承典例.</p></blockquote><h3 id="public继承意味”is-a”-是一种-的关系"><a href="#public继承意味”is-a”-是一种-的关系" class="headerlink" title="public继承意味”is-a”(是一种)的关系"></a>public继承意味”is-a”(是一种)的关系</h3><p>这便是C++面向对象编程的最重要的一个规则, 请把这个规则牢牢记在心中吧, 相信很多人以及对这种认知有所耳闻, 我甚至在学java的多态时都听到过这个概念, 可见此思想影响之深远.</p><p>如果你令B公开继承自A, 那么代表着<strong>B是一种A</strong>,  进而代表着<strong>所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生</strong>. 反之则不然, 需要B的场景并不能用A替代.</p><p>这种规则表面上很容易理解, 但是我们应当多去站在语法和程序本身的角度去理解, 因为我们在生活中的直觉可能会误导我们, 它并不一定是富有逻辑性而且缜密, 这会让我们想当然地去认为xxx是一种xxx.</p><p>让我们通过两个例子来揭露这种错误.</p><hr><h3 id="鸟会飞"><a href="#鸟会飞" class="headerlink" title="鸟会飞?"></a>鸟会飞?</h3><p>直觉来看, 鸟应该是会飞的, 但是当我们想到鸵鸟和企鹅, 事情就开始不对劲了, 我们先来看第一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;                  <span class="hljs-comment">// 鸟会飞</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>:<span class="hljs-keyword">public</span> Bird &#123;            <span class="hljs-comment">// 企鹅是鸟</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们可以看出, 企鹅确实是鸟, 但企鹅确实不会飞, 它本就不应该继承fly()函数, 于是我们就会有下一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>  ...                                      <span class="hljs-comment">// 不在声明fly()函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span>: <span class="hljs-keyword">public</span> Bird &#123;<span class="hljs-comment">// 一个新的派生类, 用来做所有飞鸟的基类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>: <span class="hljs-keyword">public</span> Bird &#123;<br>  ...                                       <span class="hljs-comment">// 这里就继承不到fly()了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>至此逻辑就合理了,  这也在告诫我们应当仔细分析设置在类中的每个成员函数是否合理.</p><hr><h3 id="进一步梳理"><a href="#进一步梳理" class="headerlink" title="进一步梳理"></a>进一步梳理</h3><p>上一个例子因为鸟是否会飞的需求而产生了不同的设计, 但是书中想告诉我们, <strong>世界上并不存在一个”适用于所有软件”的完美设计</strong>, 因为时间在流逝, 需求在变化, 我们的设计一定要符合需求, 假如我们整个体系就是针对飞鸟来建立的, 完全不会与企鹅鸵鸟相关, 那么最开始的设计完全是可行的. 简单来说, <strong>我们要明确需求, 根据需求分析各种不同的情况, 做出符合当前需求的继承设计</strong>, 当然也可以有一定的前瞻性, 但不要与当下的需求相悖.</p><hr><h3 id="正方形是一种矩形"><a href="#正方形是一种矩形" class="headerlink" title="正方形是一种矩形?"></a>正方形是一种矩形?</h3><p>这相比于上一例中由于常识产生的错误不同, 这就是数理方面的真理, 但从最终结果上并不适合<code>public</code>继承, 我们来看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> newHeight)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> newWidth)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// return current values</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addWidth</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 调用这个函数会使这个width增加10, 并且height不加</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> oldHeight = <span class="hljs-built_in">height</span>();<br>  <span class="hljs-built_in">setWidth</span>(<span class="hljs-built_in">width</span>() + <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">height</span>() == oldHeight);          <span class="hljs-comment">// 检察height是否变化</span><br>&#125; <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-keyword">public</span> Rectangle &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>当我们用<code>Square</code>写出如下代码就会发生问题 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Square s;<br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());           <span class="hljs-comment">// 看正方形的性质是否保持</span><br>s.<span class="hljs-built_in">addWidth</span>();   <span class="hljs-comment">// 调用addWidth</span><br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());   <span class="hljs-comment">// 看正方形的性质是否保持</span><br></code></pre></td></tr></table></figure><p>最后一条<code>assert</code>将会触发, 原因很容易理解, <code>addWidth</code>只增加了宽度, 这打破的正方形的性质.</p><p>进一步分析, <code>addWidth()</code>这个函数本身是完全合理的, 因为一个矩形就是可以只增加宽度而不增加长度, 错的是自顾自<code>public</code>继承自它的<code>Square</code>, 因为它假定了正方形是一种矩形, 尽管这在公理上确实是成立的,  但是我们要求的是<strong>正方形可以做出所有矩形可以做出的行为</strong>, 这仿佛就不行了, 因为矩形可以只增加宽度而正方形不可以.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p><code>is-a(是一种)</code>并非是唯一存在于继承中关系, 我们还会再条款38和条款39讨论另外两个常见的关系, <code>has-a(有一个)</code>和<code>is-implemented-in-terms-of(根据某物实现出)</code>, 而我们上文正方形和矩形的关系便可以用<code>has-a</code>来解释. 在学完另外两种关系之后, 我们便应当好好了解这些关系之间的差异, 在继承中做到正确的选择.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>public</code>继承意味”<code>is-a</code>“(是一种)的关系, 若B继承自A, 所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生.</li><li>不要太相信直觉, 当你认为某些事物有 “<code>is-a</code>“的关系, 不妨再看看是否符合上一条的后半句.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(3)</title>
    <link href="/2024/12/11/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/"/>
    <url>/2024/12/11/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>只要紧紧跟随你的天赋, 它每时每刻都将让你看到全新的景色.</p></li><li><p>从事商业需要极具自信, 认真, 机警, 敢于冒险和不知疲倦的精神.</p></li><li><p>当了解某个人的真实性格以后, 我自认为是不可能去改变它的, 无论是让它变得更好还是更坏.</p></li><li><p>我既可以因为看戏而感动, 但我也可以对和我有重要关系的实际事件无动于衷.</p></li><li><p>我们活得太拥挤, 因袭彼此的生活方式, 相互之间磕磕绊绊, 我想我们因此失去了彼此之间的尊重. 对所有热忱的交往来说, 次数再少肯定也是足够的.</p></li><li><p>每个人清醒过来之后都应该了解自己所处的位置, 只有到了失去这个世界之后, 我们才能开始找到我们自己, 才能发现我们所处的位置, 以及我们与万事万物的联系是多么紧密.</p></li><li><p>别让谋生变成苦差事, 而是让它成为娱乐活动. 尽情地享受大地吧, 但别去占有它. 世人往往缺少冒险精神和信仰, 所以他们忙于买卖经营, 过着奴隶般的日子.</p></li><li><p>人们每天只去离家不远的田野和街道, 到了夜里就乖乖回去, 他们到底生命渐渐失去了活力, 因为缺乏新鲜的空气.</p></li><li><p>我既热爱善良的人性, 也热爱野蛮的兽性.</p></li><li><p>打猎是我受过最好的教育, 尽管起初他们只能是玩玩而已, 最后未必能够成为厉害的猎人, 这样他们将来反而不会在这片或其他旷野上滥杀无辜, 不会以同类为渔猎的对象.</p></li><li><p>几乎所有的成虫吃的东西都比幼虫少得多, 饕餮者都是处于幼虫时期的人, 有些民族整个都处在这种阶段, 那些民族的人没有理想和创造力, 有的是出卖了他们的便便大腹.</p></li><li><p>只要坚持茹素, 你将会欢快地迎接白天和黑夜的到来, 生活将如鲜花和芳草般散发着香气, 并且变得更加乐观和高尚, 而且更有仙气—那就是你的成功.</p></li><li><p>也许最让人震惊, 最为真切的事实从来不曾在人与人之间交流过.</p></li><li><p>我认为白水是唯一适合智者的饮料, 酒并非高贵的液体, 一杯咖啡能够冲走清晨的希望, 一杯热茶可以破坏夜晚的美梦.</p></li><li><p>能够污秽人的, 不是吃进嘴里的食物, 而是不知餍足的食欲. 应该受到谴责的不是食物的事务或品质, 而是对口腹之欲的痴迷; 加入你吃东西不是为了维持我们的生命, 也不是为了激发我们的灵感, 而是为了喂饱控制我们的馋虫, 那么你应该感到惭愧.</p></li><li><p>许多烦人的噪音传到远处之后, 人们居然将其当成音乐来倾听, 着对我们低贱的生活来说, 真实莫大的讽刺.</p></li><li><p>饕餮, 贪杯, 好色或嗜睡其实是一回事, 它们无非都是肉体的欲求, 只要看到有人犯了其中之一, 我们便知道他是耽于声色犬马之徒, 污秽与纯洁是不能并存的.</p></li><li><p>智慧和纯洁出自勤奋, 无知与堕落源于懒惰. 对学生来说, 堕落就是思考的懒惰.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款31 编译依存性</title>
    <link href="/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/"/>
    <url>/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款31-将文件间的编译依存关系降至最低"><a href="#条款31-将文件间的编译依存关系降至最低" class="headerlink" title="条款31 : 将文件间的编译依存关系降至最低"></a>条款31 : 将文件间的编译依存关系降至最低</h2><blockquote><p>本条款将带我们认识文件编译依存的问题, 以及解决问题的两个有效手段.</p></blockquote><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>问题的根源来自C++并没有把**”将接口从实现中分离”**这事做得很好, 简单来说, 由于C++本身机制与定位的原因, 为了达到更大的效率和可扩展性, C++引入<code>inline</code>和<code>template</code>等特性, 这些特性无不需要在头文件中发挥作用, 也就代表原本只应该存放声明的头文件会加入太多的实现细目, 也就是所谓的”没有把将接口从实现中分离这事做得很好”.</p><p>这带来的问题是既然<strong>很多定义在头文件里</strong>, 一旦我们要修改这些定义, 那么所有使用了这个头文件的所有客户(头文件)就都需要重新编译, 一环嵌一环, 最后需要的<strong>编译成本就非常高</strong>了, 这在书中被称作**”连串编译依存关系”**.</p><hr><h3 id="进一步解析"><a href="#进一步解析" class="headerlink" title="进一步解析"></a>进一步解析</h3><p><code>inline</code>和<code>template</code>无可厚非, 这是为了效率我们必须要让步的地方, 但是许多<strong>成员变量</strong>也会定义在类的定义式中, 这就有我们处理的余地了, 看看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span> <span class="hljs-comment">// 必须包含下方相关类的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>         <span class="hljs-type">const</span> Address&amp; addr);<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>      std::string theName;        <span class="hljs-comment">// 名称定义</span><br>      Date theBirthDate;          <span class="hljs-comment">// 生日定义</span><br>      Address theAddress;         <span class="hljs-comment">// 地址定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个人的抽象类型, 里面有三种不同类型的成员变量, 我们可以设想到的是, 只要<code>Date</code>和<code>Address</code>的内部定义发生变化, 就一定会连串导致<code>Person</code>重新编译, 然后使用<code>Person</code>的客户也需要重新编译.</p><p>部分语言的解决方式是直接在底层处理成指针, 这样到哪里都是原生指针的大小, 就无需通过引入头文件知道其大小, 于是可能处理成如下定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string* theName;        <br>Date* theBirthDate;   <br>Address* theAddress;<br></code></pre></td></tr></table></figure><p>这样就不需要引入头文件了,  只需要声明有这么一个类就行了, 当然string还是声明头文件吧, 因为标准库的编译一般不会成为编译瓶颈.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>             </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                          <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <br></code></pre></td></tr></table></figure><p>但我们的C++并没有在底层实现这种机制, 也是因为效率和一些设计理念的问题, 但没关系, 我们可以自己仿照这种做法来实现, 这就请我们回忆起条款29中提到的<strong>pimpl idiom</strong>手法(指针指向实现), 我们将在本条款继续深入其使用, <strong>设置接口类和实现类, 做到接口和实现分离</strong>, 以下是接口类的代码, 实现类将在后文补充 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>我们会实现一个<code>PersonImpl</code>封装上文的三个定义, 并且实现对<code>Person</code>中成员函数的定义,  因此<code>Person</code>中就只有这三个类型的声明而无定义了, 就算这三个类发生修改, 也无需重新编译Person, 于此通过接口与实现分离, 降低了编译依存关系.</p><p>额外说一下, <code>shared_ptr</code>并不需要被管理类的头文件, 也是声明即可, 就像正常的指针一样.</p><hr><h3 id="思想内核"><a href="#思想内核" class="headerlink" title="思想内核"></a>思想内核</h3><p><strong>编译依存性最小化</strong>的本质在于<strong>以”声明的依存性”替换”定义的依存性”</strong>, 现实中让头文件<strong>尽可能自我满足</strong>, 万一做不到, 则让它与其它文件内<strong>声明式</strong>相依.</p><p>于是我们可以衍生出三个设计策略 : </p><ul><li>如果可以用<strong>指针或引用</strong>就不要直接用类定义. <strong>类定义需要引入头文件, 但是指针或引用不需要, 只要声明类型即可</strong>.</li><li>如果能够, 尽量<strong>以class声明式替换class定义式</strong>. <strong>当你声明一个函数而用到某个class时, 你并不需要改class的定义</strong>, 纵使函数以<code>by value</code>的方式传递该类型的参数, 就像上面的<code>Person</code>构造一样.</li><li><strong>为接口类和实现类(也就是声明和定义)提供不同的头文件</strong>, 原因很容易理解, 本来分开的目的就是为了在实现类修改时无需接口类再次编译进而扩散影响,  放在一个头文件中到最后还不是一块编译吗?</li></ul><p>这里还需要解释为什么上面的策略都是无需定义, 只要声明就可以了?</p><p>我们可以想开一点, 就是在接口类中真的有没有无所谓, 只要通过声明认为它有就行, 真正用它的是实现类, <strong>一旦任何人调用那些函数, 调用之前定义式一旦得先曝光才行</strong>(就是你调用函数前肯定会传入对应的参数嘛), 所以我们是<strong>将”提供定义式”的义务从接口类头文件转到了”内含该函数调用”的客户文件中</strong>, 这样就可以<strong>将”非必要类型定义”与客户端之间的编译依存性去掉</strong>.</p><p>接下来将会根据思想内核提供两种实现编译依存性最小化的最终方案 : </p><hr><h3 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h3><p>本方案以上文的<strong>pimpl idiom</strong>手法为核心, <code>Handle classes</code>意为使用句柄的类, 这个句柄就是<strong>pimpl idiom</strong>手法的指针, <code>Person</code>类还是和上文一致, <code>PersonImpl</code>类<strong>应当和Person有着完全相同的成员函数, 并且有原本Person预想拥有的成员变量</strong>,  可以理解为<code>PersonImpl</code>才是真正的<code>Person</code>类, 以后所有的修改将在<code>PersonImpl</code>中进行.</p><p>一般来说我们要实现三个文件, 一个<code>Person.h</code>存放供客户使用的接口类, 一个<code>PersonImpl.h</code>存放对应接口类的实现类, 一个<code>Person.cpp</code>实现<code>Person</code>中函数声明的对应定义.  有点麻烦, 可以看代码理解, 接下来将给出两个分别封装接口类和实现类的头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h  存放接口类, 和上文一致</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// PersonImpl.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n) ,_birthDate(b) ,_address(a)<br>    &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp  在该文件实现接口类和实现类的真正关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PersonImpl.h&quot;</span></span><br><br><span class="hljs-comment">// 完成对接口类中声明函数的定义</span><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_shared</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure><p>宏观来说<code>Person</code>更像是一个外壳, 和<code>PersonImpl</code>有藕断丝连的关系, 而<code>PersonImpl</code>才拥有我们的核心代码, 不过对<code>PersonImpl</code>的修改并不需要<code>Person</code>所在头文件重新编译, 因为它和<code>PersonImpl</code>的关系都是声明来的, 在定义上没有任何关联.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span>  <span class="hljs-comment">// 只需包含接口类即可</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, date, addr)</span></span>;<br>cout &lt;&lt; p.<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>本方案核心在于<strong>继承</strong>, 像是<code>java</code>有专属的接口类, <code>C++</code>也可以模拟类似的<strong>抽象基类作为接口类, 而派生类作为实现类</strong>, 也可以达到和上个方案相似的效果, 但是唯一的问题是<strong>客户怎么使用接口类</strong>? 接口类既然是抽象基类, 就绝不可能生成对象, 但是<strong>抽象基类可以有指针和引用</strong>, 由此可以<strong>利用多态机制通过基类指针调用到派生的实现类</strong>, 所以我们虽然写不了构造函数, 但是可以写一个<strong>factory</strong>(工厂)函数来调用派生类的构造函数进而返回派生类的指针, 代码还是三个部分, 我们来逐一阅读 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-comment">// virtual析构函数见条款7</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 工厂函数为create, 通过提供的参数构造不同的派生类</span><br><span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Person&gt;    </span><br><span class="hljs-function"><span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RealPerson.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPerson</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealPerson</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n), _birthDate(b), _address(a)<br>    &#123;&#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RealPerson</span>() &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RealPerson.h&quot;</span></span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function">std::shared_ptr&lt;Person&gt;</span><br><span class="hljs-function"><span class="hljs-title">Person2::create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;RealPerson&gt;(std::<span class="hljs-built_in">make_shared</span>&lt;RealPerson&gt;(name, birthday, addr));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里重点理解<code>create</code>工厂函数, 它的最终目的一定是传出一个派生类的智能指针, 尽管传出指针的静态类型是<code>std::shared_ptr&lt;Person&gt;</code>, 但也会依靠多态机制绑定到正确的派生类类型. 至于是什么派生类可以通过参数值, 读取数据库数据, 环境变量等各种因素影响, 这里是因为只写了<code>RealPerson</code>一个派生类所以就直接返回了, 实际情况可以写更多的判断类型返回不同的派生类指针, 比如男人女人伪人之类的.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;Person&gt; <span class="hljs-title">pp</span><span class="hljs-params">(Person::create(<span class="hljs-string">&quot;李四&quot;</span>, date, addr))</span></span>;<br><br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="两种方案的异同"><a href="#两种方案的异同" class="headerlink" title="两种方案的异同"></a>两种方案的异同</h3><p><code>Handle classes</code>利用<strong>pimpl idiom</strong>手法, 构造出来的是一个实打实的对象, 因此可以通过各种方式调用内部功能, 使用较为简单.</p><p><code>Interface classes</code>利用<strong>继承和多态</strong>, 构造出来的只能说一个指向派生类对象的指针, 因此只可通过指针调用内部功能, 需要额外调用工厂函数, 但是吃到了多态的便利性, 可以有更大的可扩展性.</p><p>二者都实现了声明与定义的分离, 使头文件相依于声明式而非定义式, 解除了接口和实现之间的耦合关系, 从而降低了文件间的编译依存性.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>C++由于专注于运行时效率的提升, 引入<code>inline</code>等各种方式来促成该目的, 再加上<code>template</code>, 这其实给编译带来了过大的负担, 也就是说其实是牺牲了编译时而成全了运行时, 放在现实中其实就是牺牲了程序员的时间成本而成全了客户, 这无可厚非, 但若是因此影响了开发效率就顾此失彼了, 因此我们才要优化编译时间, 才要降低编译依存性, 尽管这可能增加些微的运行时成本, 但这仍是必要的.</p><p>另外我们也应权衡<code>inline</code>, <code>template</code>和以上两种方案的使用, 就让它们出现在最应该出现的地方吧.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>支持”编译依存性最小化”的一般构想是 : 相依于声明式, 不要相依于定义式. 基于此构想的两个手段是<code>Handle classes</code>和<code>Interface classes</code>.</li><li>头文件应该以”完全且仅有声明式”的形式存在, 除非要使用<code>inline</code>或<code>template</code>, 而且就算使用<code>template</code>, 也可以在头文件中实现<code>template</code>的声明, 将定义置入非头文件中,</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>编译依存性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款30 inline</title>
    <link href="/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/"/>
    <url>/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/</url>
    
    <content type="html"><![CDATA[<h2 id="条款30-透彻了解inlining的里里外外"><a href="#条款30-透彻了解inlining的里里外外" class="headerlink" title="条款30 : 透彻了解inlining的里里外外"></a>条款30 : 透彻了解inlining的里里外外</h2><blockquote><p>inline 函数, 多么棒的点子! 本条款将带我们透彻了解inlining的里里外外, 与往常的形式不同, 我会以知识点集的形式把书中对inline的描述列举处理, 可更简单明了的认识inline.</p></blockquote><h2 id="inline的优劣"><a href="#inline的优劣" class="headerlink" title="inline的优劣"></a>inline的优劣</h2><ul><li><code>inline</code>函数, 看起来像函数, 动作像函数, 却比宏好得多, 调用它们<strong>不用蒙受函数调用所带来的额外开销</strong>.</li><li>编译器会对<code>inline</code>函数执行语境相关最优化, 会<strong>提升编译效率</strong>.</li><li>如果内存有限, 过度<code>inlining</code>会造成程序<strong>体积太大</strong>.</li><li><code>inline</code>会带来<strong>代码膨胀</strong>, 进而导致额外的<strong>换页</strong>行为, 降低高速缓存装置的<strong>击中率</strong>.</li><li><strong>如果inline函数的本体很小</strong>, 编译器针对”函数本体”产出的码可能比针对”函数调用”产出的码更小, 反而会促成与上一条相反的情况, 可以导致较小的目标码和较高的高速缓存装置击中率.</li><li><code>inline</code>函数无法随程序库的升级而升级, 简单说如果程序库中有一个<code>inline</code>函数, 如果决定改变该函数, 那么程序库中所有用到该函数的程序就必须重新编译. 如果是<code>non-inline</code>函数,客户端只需要重新连接就好了, 没有那么大的编译负担, 如果是动态库就更没有了.</li></ul><hr><h2 id="inline的特性"><a href="#inline的特性" class="headerlink" title="inline的特性"></a>inline的特性</h2><ul><li><p><strong>inline不是一个强制命令, 它只是对编译器的一个申请!</strong> 编译器可以加以忽略, 大部分编译器将拒绝太过复杂的函数(含循环, 递归, 长度过长)进行<code>inlining</code>. 简而言之, <strong>一个表面看似inline的函数是否真的是inline, 取决于你的建置环境, 主要取决于编译器</strong>.</p></li><li><p><code>inline</code>可以明确提出, 也可以<strong>隐喻提出</strong>.</p></li><li><p>隐喻提出的方式是<strong>将函数定义在class定义式中</strong>. 这便是为什么很多<code>class</code>会将实现简短的函数直接在<code>class</code>定义式中将声明定义一并给出, 其实就是在方便的前提下还隐喻地使用了<code>inline</code>函数, 以达到”没有声明任何<code>inline</code>却处处都是<code>inline</code>“的效果. </p></li><li><p>隐喻<code>inline</code>函数通常是<strong>成员函数</strong>, 也可以是<code>friend</code>函数.</p></li><li><p>所有<code>virtual</code>函数与调用<code>virtual</code>的函数都无法<code>inlining</code>. <code>virtual</code>代表着等待运行时判定, 而<code>inline</code>代表编译时提前替换, 这两种行为是绝对冲突的.</p></li></ul><hr><h2 id="inline的使用"><a href="#inline的使用" class="headerlink" title="inline的使用"></a>inline的使用</h2><ul><li><code>inline</code>函数通常<strong>一定被置于头文件内</strong>, 因为大多数建置环境都在编译过程中进行<code>inline</code>.</li><li><code>templates</code>(泛型类&#x2F;函数)通常也被置于头文件内, 很多程序员认为泛型函数一定都是<code>inline</code>, 但这是错误的, <strong>template的实例化与inline无关</strong>, 不应该这样考量, 还是应该依照代码长度,内容以及环境做具体考量.</li><li><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>, 因为就算它们是空白的, 也有可能在底层被编译器施加很多额外的代码, 例如基类的构造与析构, 这导致它们的实际代码量远比我们看见的要多得多, 令它们<code>inlining</code>很有可能会发生代码膨胀.</li><li>一开始先不要将任何函数声明成<code>inline</code>, 除非你非常笃定它就是<code>inline</code>的典型案例, 当你开始关心效率时, 再分析是否可以<code>inlining</code>.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h2><ul><li>请将大多数的<code>inlining</code>限制在<strong>小型, 被频繁调用</strong>的函数身上.</li><li>通过将函数定义在<code>class</code>定义式中实现隐喻<code>inline</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款29 异常安全性</title>
    <link href="/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款29-为”异常安全”而努力是值得的"><a href="#条款29-为”异常安全”而努力是值得的" class="headerlink" title="条款29 : 为”异常安全”而努力是值得的"></a>条款29 : 为”异常安全”而努力是值得的</h2><blockquote><p>异常安全性是我们每个程序员都要考量的内容, 我们有必要知道我们写出的每个函数保证了怎样的异常安全, 因为一个函数是否会抛出异常不仅会影响我们是否使用该函数的决策, 也会影响部分的编译器优化策略, 让我们通过本条款来充分认识异常安全性.</p></blockquote><p>先了解本条款的例子, 假设有个<code>class</code>用来表现夹带背景图案的GUI界面, 这个<code>class</code>用于多线程环境, 所以它有个互斥器作为并发控制之用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span>;           <span class="hljs-comment">// 用来改变背景图片的成员函数</span><br><br><span class="hljs-keyword">private</span>:<br><br>  Mutex mutex;                    <span class="hljs-comment">// 互斥器</span><br><br>  Image *bgImage;                 <span class="hljs-comment">// 当前的背景图像</span><br>  <span class="hljs-type">int</span> imageChanges;               <span class="hljs-comment">// 背景图像被改变的次数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">lock</span>(&amp;mutex);                      <span class="hljs-comment">// 上锁</span><br><br>  <span class="hljs-keyword">delete</span> bgImage;                    <span class="hljs-comment">// 释放原背景</span><br>  ++imageChanges;                    <span class="hljs-comment">// 更新计数</span><br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);       <span class="hljs-comment">// 修改新背景</span><br><br>  <span class="hljs-built_in">unlock</span>(&amp;mutex);                    <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从异常安全性的角度来看, <code>changeBackground</code>非常糟糕, 它并没有满足”异常安全”的两个必要条件 : </p><ul><li><p><strong>不泄漏任何资源</strong>. </p><p>资源泄漏包括内存&#x2F;文件句柄&#x2F;<code>socket</code>连接&#x2F;锁等泄漏, 这里我们知道<code>new Image(imgSrc)</code>是一定可能有<code>bad_alloc</code>的异常的, 当异常发生, <code>unlock(&amp;mutex)</code>语句将不会执行, 锁并没有得到释放, 也就是说发生了泄漏.</p></li><li><p><strong>不允许数据败坏</strong>.</p><p>数据败坏即数据与预期的有效状态不符, 比如野指针. 这里当<code>new Image(imgSrc)</code>处发生异常, <code>bgImage</code>的原资源已经释放却没有获得新资源, 它的行为是未定义的, 并且<code>imageChanges</code>也增加了一次本不存在的计数, 这都是数据败坏.</p></li></ul><hr><h3 id="利用资源管理类解决资源泄漏"><a href="#利用资源管理类解决资源泄漏" class="headerlink" title="利用资源管理类解决资源泄漏"></a>利用资源管理类解决资源泄漏</h3><p>当我们深谙条款13”<strong>以对象管理资源</strong>“的道理后, 资源泄漏将不再是问题! 资源管理类可以确保资源及时且自动地释放, 并且还减少了我们的代码量, 于是我们就可以用条款14中<code>RAII</code>风格的<code>Lock</code>类来解决本条款的锁泄漏 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                <span class="hljs-comment">// 自动管理锁的释放</span><br>  <span class="hljs-keyword">delete</span> bgImage;<br>  ++imageChanges;<br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);    <span class="hljs-comment">// 一旦触发异常离开函数作用域就会自动触发Lock的析构函数释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>绝大多数异常引发的资源泄漏都可以用资源管理类来解决.</p><hr><h3 id="三种异常安全保证"><a href="#三种异常安全保证" class="headerlink" title="三种异常安全保证"></a>三种异常安全保证</h3><p>这将是本条款的重点, 一个异常安全的函数在避免资源泄漏之后, 为了防止数据败坏, 我们还必须拥有下面三个保证之一, 越往后保证强度越大.</p><ul><li><p><strong>基本承诺</strong> : 异常抛出后, 没有数据泄漏, 没有数据败坏, 所有事物仍然保持有效, 但是不支持完全回滚, 我们不确定数据在该函数中修改成什么样了, 即使这种状态合法, 其实就是符合<strong>两个必要条件但是不做任何处理</strong>. 我们看以下的例子理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i = <span class="hljs-number">10</span>; i ++ )<br>        data.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 如果此处抛出异常，vector 自动管理内存，无泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该例子符合基本承诺, 这个函数向<code>data</code>中插入1到10, 插入动作会抛出异常, 但是<code>vector</code>会自动管理内存, 不会有泄漏与数据败坏, 但是加入我们在插入<code>i = 5</code>时出现异常, 那么异常抛出将不会执行之后的语句, 也就是说这次插入的结果是<code>data</code>尾插了1,2,3,4, 然而出现异常后客户并不会知道内部到底插入了多少, 虽然该状态合法.</p></li><li><p><strong>强烈保证</strong> : 如果异常被抛出, 对象状态不会改变, 与调用该函数前状态一致. 就是说, 没有异常就是完全成功, 抛出异常对象状态会发生<strong>回滚</strong>, 回滚至调用前状态. </p></li><li><p><strong>不抛掷保证</strong> : 承诺绝不抛出异常. 这种函数不可能涉及任何动态内存的分配, 一般只是对<strong>内置类型</strong>进行操作, 如算术类型, 指针, 引用等.并且这种函数我们一般会在其函数定义后添加<code>noexcept</code>关键字, 这代表你向编译器声明这个函数绝不会抛出异常, 编译器就会删去对这个函数的异常处理工作, 实现效率的提升.</p></li></ul><hr><h3 id="实现强烈保证"><a href="#实现强烈保证" class="headerlink" title="实现强烈保证"></a>实现强烈保证</h3><p>我们一般都是由下至上选择安全保证, 不抛掷保证只适用于对内置类型的操作, 比较典型的就是移动构造和移动赋值.</p><p>所以大多数情况下我们更愿意实现强烈保证, 我们来看看将<code>changeBackground</code>修改为强烈保证的步骤 : </p><ol><li>将<code>bgImage</code>这个成员变量用智能指针代替, 这个只是为了实现两个条件中的避免资源泄漏.</li><li>重新改变语句顺序, <strong>不要为了表示某事件的发生而改变对象状态, 除非那件事真的发生了</strong>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br>  ...<br>  std::shared_ptr&lt;Image&gt; bgImage; <span class="hljs-comment">// 改用智能指针</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>  bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));  <span class="hljs-comment">// 以 new Image(imgSrc) 的结果设定为bfImage的内部指针</span><br>     <span class="hljs-comment">// 无需delete原资源, reset内部会帮我们自动调用delete</span><br>  ++imageChanges;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析上述代码, 我们可以很惊喜地发现, 如果<code>new Image(imgSrc)</code>失败, 对象状态将不发生任何改变, <code>reset</code>和<code>++imageChanges</code>都不会触发,  也就是说失败即回滚, 成功即完全, 再加上不会资源泄漏与数据败坏, 其符合强烈保证!</p><hr><h3 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h3><p>上文我们通过<strong>调整语序</strong>来实现了强烈保证, 这确实是最基础的一种解决方法, 其内核在于”<strong>在所有可能抛出异常的动作成功结束前不要改变对象状态</strong>“, 但是这种做法比较费脑, 并且不一定适合某些场景. 然而有一个<strong>一般化的设计</strong>很典型地会导致强烈保证, 这个策略被称为<code>copy and swap</code>.</p><p>使用方法很简单, <strong>为你打算修改的对象做出一个副本, 在那个副本上做任何的修改, 待所有改变成功后再交换原对象和副本</strong>(注意这个做法的前提建立在<code>swap</code>是<code>noexcept</code>的, 这也是为什么条款25一直强调<code>swap</code>不抛异常的重要性). 其内核在于”<strong>修改对象数据的副本, 然后在一个不抛异常的函数中将数据和原件置换</strong>“.</p><p>在看代码之前, 有一个手法很适合实现上述操作, 叫做<strong>pimpl idiom</strong>(pointer to implementation idiom)(指针指向实现), 这个手法在于将所有需要隐藏的成员变量和成员函数包入一个<strong>实现类</strong>, 外部构造一个<strong>接口类</strong>, 该接口类存放该实现类的指针(一般是智能指针)与外放接口. 条款31将详细描述该手法的优势, 在本条款就是将<strong>所有”隶属对象的数据”从原对象放进另一个对象内, 然后赋值原对象一个指针, 指向该对象</strong>, <strong>这样我们copy and swap的对象就仅限于存放数据的对象, 而一切操作都在原对象中进行</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMImpl</span> &#123;                               <span class="hljs-comment">// 实现类</span><br>  std::shared_ptr&lt;Image&gt; bgImage;        <br>  <span class="hljs-type">int</span> imageChanges;                           <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;  <span class="hljs-comment">// 接口类</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  Mutex mutex;<br>  std::shared_ptr&lt;PMImpl&gt; pImpl;  <span class="hljs-comment">// 一个智能指针指向实现类</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;                            <span class="hljs-comment">// 见条款25</span><br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                        <span class="hljs-comment">// 锁的copy and swap是没有意义的</span><br>  <span class="hljs-function">std::shared_ptr&lt;PMImpl&gt; <span class="hljs-title">pNew</span><span class="hljs-params">(<span class="hljs-keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="hljs-comment">// 复制副本</span><br><br>  pNew-&gt;bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));     <span class="hljs-comment">// 对副本进行所有修改</span><br>  ++pNew-&gt;imageChanges;<br><br>  <span class="hljs-built_in">swap</span>(pImpl, pNew);    <span class="hljs-comment">// 只有前面不抛异常才会到这里, 直接进行交换, 内置类型的交换一定不会有异常</span><br>&#125;                                     <br></code></pre></td></tr></table></figure><p>以上便通过<code>copy and swap</code>实现了强烈保证.</p><hr><h3 id="实现强烈保证的最终策略"><a href="#实现强烈保证的最终策略" class="headerlink" title="实现强烈保证的最终策略"></a>实现强烈保证的最终策略</h3><p><code>copy and swap</code>策略是<strong>对对象状态做出”全有或全无”改变</strong>的一个很好办法, 但是它<strong>不等于一个函数有强烈保证</strong>.</p><p>分析起来比较麻烦, 简单说就是<code>copy and swap</code><strong>只确定了内存相关操作的强烈保证, 使对象的局部状态有了一致性</strong>, 即”全有或全无”, 然而有时候对象其实是会对”<strong>非局部性数据</strong>“产生影响的, 例如数据库连接, 网络连接, 锁等, 这些东西不会只因为内存数据的有无而生效或失效, 连接还和连接的对象有关, 锁还和线程分配有关, 它们更偏向于全局状态, 这也是上面代码我没有将<code>Lock ml</code>存入<code>PMImpl</code>的原因.</p><p>再讲一个例子, 假设我在函数中创建的副本上对<strong>数据库</strong>进行了修改, 如果之后发生了异常, 如果我不做任何其他的操作, 那么这个数据库的修改是一直成立的, 并没有因为<code>copy and swap</code>而回滚, 这是完全可以理解的, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123; <span class="hljs-comment">// 修改局部数据与数据库</span><br>    <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData; <span class="hljs-comment">// copy 创建局部状态的副本</span><br><br>    <span class="hljs-comment">// 修改数据库（非局部数据）</span><br>    db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        localDataCopy.<span class="hljs-built_in">push_back</span>(i);   <span class="hljs-comment">// 如果此处发生异常, 前面的数据库修改无法恢复!</span><br>    &#125;<br>    <span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此, 我们可以总结出可以实现强烈保证的大体策略 :</p><ul><li><strong>如果函数有关内存数据的修改, 使用<code>copy and swap</code>策略.</strong></li><li><strong>如果函数有关非局部数据的修改, 自己根据非局部数据的性质进行对应的异常回滚操作.</strong></li></ul><p>例如上文的数据库, 我们就可以利用其<strong>事务</strong>的特性实现异常回滚 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData;<br>    db.<span class="hljs-built_in">beginTransaction</span>(); <span class="hljs-comment">// 开启数据库事务</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 修改数据库数据</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            localDataCopy.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 此刻发生任何异常都会被捕获, 在catch语句中触发回滚</span><br>        &#125;<br><br>        db.<span class="hljs-built_in">commitTransaction</span>(); <span class="hljs-comment">// 所有修改成功后，提交事务</span><br>        std::<span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        db.<span class="hljs-built_in">rollbackTransaction</span>();  <span class="hljs-comment">// 发生异常时，回滚事务</span><br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<code>modifyDataAndDatabase</code>函数也就拥有了强烈保证, 这部分的最终策略是我求证后自创的, 书中没有详细指出如有问题或补充欢迎指出.</p><hr><h3 id="关于嵌套函数的问题"><a href="#关于嵌套函数的问题" class="headerlink" title="关于嵌套函数的问题"></a>关于嵌套函数的问题</h3><p>书中指出, 嵌套函数会确实影响函数本身的异常安全性, 道理也很容易理解, 一个没有强烈保证的函数被嵌入一个函数, 那么这个函数也一定没有强烈保证. 然而<strong>所有嵌套函数都是强烈保证的就能使本函数有强烈保证了吗, 未必!</strong> 让我们看下面的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    ...                <span class="hljs-comment">// 创建副本</span><br>    <span class="hljs-built_in">f1</span>();              <span class="hljs-comment">// 调用 f1 当成调用 modifyDataAndDatabase(localData);</span><br>    <span class="hljs-built_in">f2</span>();              <span class="hljs-comment">// 调用 f2</span><br>    ...                <span class="hljs-comment">// 将修改后的副本交换到原状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们把<code>f1</code>当成上文的<code>modifyDataAndDatabase</code>, 仔细想想有什么问题.</p><p>大佬可能一眼就看出来了, 虽然<code>f1</code>的本身有强烈保证, 但是如果<code>f2</code>抛出了异常, <code>f1</code>中对<code>localData</code>的修改固然可以因为<code>copy and swap</code>回滚, 但是数据库的修改不能呀, 我们在<code>f1</code>中的数据库回滚操作无法延申到<code>f2</code>中! 所以无法实现完全的回滚, 这个函数是没有强烈保证的!</p><p>这种问题书中叫做”<strong>连带影响</strong>“, 即当一个函数对”非局部性数据”有影响时, 其被嵌套在其他函数内部时, 就算本身有强烈保证, 也会因为外部可能的异常连带产生错误. </p><p>这个问题提醒我们一个函数如果想有强烈保证, 不要嵌套影响”非局部数据”的函数, 非要嵌套也要确定其后没有任何异常产生的可能性.</p><hr><h3 id="异常安全性就像怀孕"><a href="#异常安全性就像怀孕" class="headerlink" title="异常安全性就像怀孕 . . ."></a>异常安全性就像怀孕 . . .</h3><p>作者提出, 一位女士若非怀孕, 就是没怀孕, 不可能说她”部分怀孕”; 同理, 一个系统内如果有一个函数不具备异常安全性, 整个系统就不具备异常安全性, 很不幸, C++由于对C的继承, 其很多传统代码其实是不具备异常安全性的, 不过我们应当尽力让我们的代码具备异常安全性, 同时也<strong>应当将自己对函数的安全性定义写成文档, 为我们的客户和后期维护者使用</strong>.</p><hr><h3 id="书中作者难得发出感叹-由此摘录"><a href="#书中作者难得发出感叹-由此摘录" class="headerlink" title="书中作者难得发出感叹, 由此摘录:"></a>书中作者难得发出感叹, 由此摘录:</h3><p>四十年前, 满载goto的代码被视为一种美好实践, 而今我们却致力于写出结构化控制流.</p><p>二十年前, 全局数据被视为一种美好实践, 而今我们却致力于数据的封装.</p><p>十年前, 撰写”未将异常考虑在内”的函数被视为一种美好实践, 而今我们却致力于写出”异常安全码”.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>“以对象管理资源”可以阻止资源泄漏, 调整语序和三种异常保证可能可以阻止数据败坏.</li><li>“基本承诺”诚可贵, “强烈保证”价更高, 若为”不抛掷”, 二者皆可抛.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>异常安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(2)</title>
    <link href="/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/"/>
    <url>/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>假如我们醒来并没有过上比睡前更崇高的生活, 那么白天也就没什么好期待的了.</p></li><li><p>人要是不相信在喧嚣的白日之前, 有者更神圣,更绚丽的时刻, 那么他对生活肯定已经感到绝望, 而他所走的人生之路肯定是江河日下, 越来越黑暗的.</p></li><li><p>只要我清醒着, 心中有光明, 那就是早晨.</p></li><li><p>我们必须学会再次苏醒, 并保持着清醒的状态, 但要借助的不是某些生硬的措施, 而是对黎明的无限期待, 这是在我们睡得最熟时也会也会有的期待.</p></li><li><p>狗屁新闻!最重要的是去了解那些永不过时的东西!</p></li><li><p>大人没能过上有价值的生活, 却自认为更聪明, 因为他们更有经验, 可惜他们的经验其实就是失败.</p></li><li><p>只有持续不断地渗入和浸泡在周围的现实之中, 我们才能理解一切圣洁而高贵的东西.</p></li><li><p>让我们把自己安顿下来, 好好地工作, 用力去踩踏脚下的烂泥, 那由成见,偏见,传统,谎言和表象搅成的烂泥, 直到我们的脚触及更坚硬的底部和安稳的岩石, 也就是我们说的现实, 有了这个立足点, 我们得以在将来的世代能够知道, 谎言和表象的洪水曾经积聚得有多深.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款28 避免返回handles指向对象内部成分</title>
    <link href="/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/"/>
    <url>/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款28-避免返回handles指向对象内部成分"><a href="#条款28-避免返回handles指向对象内部成分" class="headerlink" title="条款28 : 避免返回handles指向对象内部成分"></a>条款28 : 避免返回handles指向对象内部成分</h2><p>让我们先来明确本条款中的两个概念 : </p><ul><li>handle : 即句柄, 号码牌, 可以理解为各种<strong>指针, 引用, 迭代器</strong>.</li><li>内部成分 : <strong>private成员变量和成员函数</strong>.</li></ul><p>有了上面两个概念, 就可以比较直观地理解本条款了, 不过在通读完本条款后, 本条款虽说是<strong>避免返回handles指向对象内部成分</strong>, 但是其实内容着重在解释<strong>在必须返回handles指向对象内部成分的情况下, 会带来什么样的风险</strong>, 以此告诫我们注意. </p><hr><h3 id="降低对象封装性"><a href="#降低对象封装性" class="headerlink" title="降低对象封装性"></a>降低对象封装性</h3><p>书中指出, <strong>返回handles指向对象内部成分</strong>, 随之而来的便是**”降低对象封装性”的风险**, 如果不是有意设计, 我们<strong>不应令public成员函数返回一个handle指向private的成员变量</strong>, 这会使后者的<strong>实际访问级别变为public</strong>, 这是完全可以理解的.</p><p>书中描述了GUI中常有的矩形, 它一般会用左上点和右下点表示 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;                      <span class="hljs-comment">// 坐标点</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>  ...<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RectData</span> &#123;                    <span class="hljs-comment">// 矩形资源类</span><br>  Point ulhc;                        <span class="hljs-comment">// 左上点</span><br>  Point lrhc;                        <span class="hljs-comment">// 右下点</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<span class="hljs-comment">// 资源管理类 见条款13</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  std::shared_ptr&lt;RectData&gt; pData;    <span class="hljs-comment">// 存入智能指针进行管理    </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>客户一般会要求使用矩形的位置信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们用两个函数分别返回左上点和右下点, 这个操作很正常, 但是这给了客户捣乱的方式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Point <span class="hljs-title">coord1</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Point <span class="hljs-title">coord2</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(coord1, coord2)</span></span>;    <br><br>rec.<span class="hljs-built_in">upperLeft</span>().<span class="hljs-built_in">setX</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">// rec的左上点实际被修改为了(50, 0)!</span><br></code></pre></td></tr></table></figure><p>这种情况在条款3中也实际发生过, 就是<strong>通过const成员函数的返回值修改了类的内部数据</strong>, 原因条款3中已经解释过了, 解决方式也很简单, 给返回值也加一个<code>const</code>就好了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>重新整理思路, 封装性在于<strong>数据隐藏</strong>, 在于<strong>限制外部对内部的访问与修改</strong>. 以上函数做到了<strong>访问权的让渡与修改权的禁止</strong>, 访问权让渡是因为有必要的客户需求, 修改权禁止是应为客户没有权限修改内部, 以此在提供必要功能的前提下使对象达到了最好的封装性.</p><hr><h3 id="空悬句柄-dangling-handles"><a href="#空悬句柄-dangling-handles" class="headerlink" title="空悬句柄(dangling handles)"></a>空悬句柄(dangling handles)</h3><p>空悬句柄和C中的野指针很相似, 书中给出了某个函数返回GUI对象的外框(矩形)的例子 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUIObject</span> &#123; ... &#125;; <br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">boundingBox</span><span class="hljs-params">(<span class="hljs-type">const</span> GUIObject&amp; obj)</span></span>;  <span class="hljs-comment">// 返回一个矩形    </span><br><br>GUIObject *pgo;   <br>...                                  <br><span class="hljs-type">const</span> Point *pUpperLeft = &amp;(<span class="hljs-built_in">boundingBox</span>(*pgo).<span class="hljs-built_in">upperLeft</span>());  <span class="hljs-comment">// 这里pUpperLeft是一个空悬句柄                   </span><br></code></pre></td></tr></table></figure><p>我们来解释最后一句代码 : </p><ol><li><code>boundingBox(*pgo)</code> 利用<code>pgo</code>调用<code>boundingBox</code>函数</li><li><code>boundingBox</code>函数返回一个临时矩形对象(这是一个匿名对象, 以下简称<code>temp</code>)</li><li><code>temp</code>调用<code>upperLeft()</code>得到该临时对象的左上点</li><li>取出右上点的地址赋值给<code>pUpperLeft</code></li></ol><p>最后的结果就是<code>pUpperLeft</code>获得了一个来自临时对象的指针, 当控制域离开该行, 这个指针将成为一个野指针, 则称<code>pUpperLeft</code>是一个空悬句柄, 它指向了一个不存在的对象.</p><p>因此书中告诉我们, <strong>返回handles指向对象内部成分总是危险的</strong>, 不管这个<code>handle</code>是否为<code>const</code> 唯一造成危险的事实就是, <strong>有个handle被传出去了</strong>, 因此就有可能出现<strong>handle比其所指对象更长寿</strong>的风险, 这才是问题的核心.</p><p>然而指出这个风险不是说就不应该返回<code>handles</code>, 我们总会有许多需求需要访问内部成分, 这种风险避无可避, 而是在告诫我们时常注意空悬句柄问题, <strong>不要让我们的指针&#x2F;引用&#x2F;迭代器因为比其所指对象更长寿而失效</strong>.</p><p>我们可以再通过一个例子来加深理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) v.<span class="hljs-built_in">erase</span>(it);<br>    ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是非常经典<strong>迭代器失效</strong>问题, 这个例子在遍历<code>v</code>, 将<code>v</code>中等于3的元素删除, 这段代码看似合理, 但是结合我们上面的理解, 在触发<code>erase</code>后, <code>it</code>迭代器指向的对象其实已经被销毁了, 这时<code>++it</code>就变为了未定义的操作, 在<code>vs</code>中甚至会直接报错, 如果我们可以提前发现这个问题, 就可以做出以下改进 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) it = v.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">else</span> ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用<code>erase</code>的返回值对<code>it</code>重新赋值, 使其免于失效.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能避免返回<code>handles</code>指向对象内部成分, 这可以提升对象封装性, 避免<code>dangling handles</code>出现.</li><li>避无可避时谨慎释出内部成分的访问权与修改权, 修改权可用<code>const</code>禁止, 注意<code>dangling handles</code>问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款27 类型转换</title>
    <link href="/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="条款27-尽量少做转型动作"><a href="#条款27-尽量少做转型动作" class="headerlink" title="条款27 : 尽量少做转型动作"></a>条款27 : 尽量少做转型动作</h2><blockquote><p>优良的C++代码很少使用转型, 但是要完全摆脱它们又太过不切实际, 我们应当保证”类型错误”绝无可能发生. 本条款在了解各种转型动作的前提下, 指出了一些有风险的转型操作及其解决方法.</p></blockquote><p>我们先来回顾一下类型转换 : </p><h4 id="旧式C风格转型"><a href="#旧式C风格转型" class="headerlink" title="旧式C风格转型"></a>旧式C风格转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(T)expression;<br><span class="hljs-built_in">T</span>(experssion);<br></code></pre></td></tr></table></figure><h4 id="新式转型"><a href="#新式转型" class="headerlink" title="新式转型"></a>新式转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure><ul><li>static_cast : 强制隐式转换, 适合除常量性移除之外的大部分转换场景.</li><li>const_cast : 唯一可以常量性移除的转换, 而且能且仅能移除常量性.</li><li>dynamic_cast : “安全向下转型”, 可以理解为一个有安全类型检查的可以将基类转为派生类的<code>static_cast</code>.</li><li>reinterpret_cast : 低级转型, 现在很少用了.</li></ul><hr><p>书中提出第一个观点 : 除非你确定转型没有任何风险, 并且旧式转型很方便, 应当<strong>始终理智使用新式转型</strong>, 以下为原因 : </p><ol><li>新式转型<strong>很容易在代码中被识别出来</strong>, 有助于编译器或其他工具识别.</li><li>新式转型<strong>细化了转型动作的目标</strong>, 使得编译器更容易诊断出错误的运用.</li></ol><hr><h4 id="避免做出”对象在C-中如何布局”的假设"><a href="#避免做出”对象在C-中如何布局”的假设" class="headerlink" title="避免做出”对象在C++中如何布局”的假设"></a>避免做出”对象在C++中如何布局”的假设</h4><p>书中提醒我们, <strong>类型转换并不仅仅是“告诉编译器类型的变化”</strong>, 它是会实际产生额外代码的, 而且有可能对当前对象布局做出调整, 例如将基类指针从原本的指向的基类, 改为指向派生类, 我们也许会认为前者和后者的指针地址是一样的, 实际也确实大多数情况都是一样的(包括我测试的), 但是书中说对象布局方式会依照编译器的不同而不同, 确实会发生前后者指针不一样的情况出现, 而且在出现多重继承是这种情况会更多. 所以作者告诫我们, <strong>“由于知道对象如何布局”而设计的转型, 在某些平台行得通, 在其他平台并不一定</strong>.</p><hr><h4 id="避免用类型转换写出似是而非的代码"><a href="#避免用类型转换写出似是而非的代码" class="headerlink" title="避免用类型转换写出似是而非的代码"></a>避免用类型转换写出似是而非的代码</h4><p>在写GUI时会有定义很多的窗口类, 这种应用框架一般会坚持派生类的重写会先调用父类版本, 于是就有了以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;                                <span class="hljs-comment">// base class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123; ... &#125;             <span class="hljs-comment">// 基类窗口重置尺寸</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;          <span class="hljs-comment">// derived class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;                   <span class="hljs-comment">// 派生类重写</span><br>    <span class="hljs-built_in">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();    <span class="hljs-comment">// 先调用父类版本的onResize()</span><br>    ...                                    <br>  &#125;                                          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们起初看可能还像一回事, 但是实际漏洞百出,  <code>static_cast&lt;Window&gt;(*this)</code>这个表达式返回的其实是一个**”<em>this对象值base class成分”的临时拷贝</em>*! <code>static_cast</code>在底层转换类型后进行切分, 然后把切分出来的部分拷贝返回. 也就是说真正调用基类<code>onResize()</code>的是这个临时对象, 而不是当前对象的基类部分, 想要真正使当前对象调用基类<code>onResize()</code>, 应以如下写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;<br>    Window::<span class="hljs-built_in">onResize</span>();                    <span class="hljs-comment">// 这样调用</span><br>    ...                                   <br>  &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="谨慎使用dynamic-cast"><a href="#谨慎使用dynamic-cast" class="headerlink" title="谨慎使用dynamic_cast"></a>谨慎使用dynamic_cast</h4><p>我们之所以需要<code>dynamic_cast</code>, 通常是因为我们手持一个<strong>静态类型是base而动态类型是derived的指针或引用</strong>时, <strong>想要使用只有derived中有的一个普通函数</strong>, 因为其不是虚函数, 所以我们现在无权使用它, 只能依靠<code>dynamic_cast</code>来进行较为安全的转换.</p><p>假设我们的<code>SpecialWindow</code>有一个单独的闪烁功能, 有一个<code>vector</code>中存放了大量的<code>Window</code>, 我们希望遍历该<code>vector</code>, 如果其动态类型是<code>SpecialWindow</code>就调用其闪烁功能, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 特有的blink功能</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;Window&gt; &gt; VPW;  <span class="hljs-comment">// 存放Window智能指针的数组</span><br>VPW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>();  ++iter) &#123;<br>  <span class="hljs-comment">// dynamic_cast转换成功说明是SpecialWindow类型, psw不为空, 判true, 调用blink</span><br>  <span class="hljs-comment">// 转换失败说明不是, psw为nullptr, 判false</span><br>  <span class="hljs-keyword">if</span> (SpecialWindow *psw = <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="hljs-built_in">get</span>()))<br>     psw-&gt;<span class="hljs-built_in">blink</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面算是对<code>dynamic_cast</code>的日常用法做了一个介绍, 但是作者告诉你使用<code>dynamic_cast</code>在很多情况并不必要, <strong>能不使用dynamic_cast就尽量不使用</strong>, 原因在于<code>dynamic_cast</code>为了实现安全性检测和其他一些目的, 效率十分低下, 相比于它的其他几个兄弟效率不只低了一点半点, 除非有<strong>必须是多态情况下用基类使用派生类普通函数的场景</strong>, 我们可以<strong>做出一些让步</strong>来提升我们的效率, 书中给出了两种方法 : </p><ol><li><p><strong>放弃多态需求</strong>, 确保容器内只有需求派生类的指针.具体来说就是<code>VPW</code>内只存<code>shared_ptr&lt;SpecialWindow&gt;</code>, 让<code>blink</code>的调用普遍化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW; <span class="hljs-comment">// 只存派生类智能指针</span><br>VPSW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>(); <span class="hljs-comment">// 直接调用</span><br></code></pre></td></tr></table></figure></li><li><p><strong>将普通函数转为virtual函数</strong>, <strong>略微增加写代码的成本</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 这里什么都不做, 其目的只是为了让SpecialWindow通过多态调用有效果的blink()</span><br>  ...<br>&#125;;                                            <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123; ... &#125;;                 <br>  ...                                          <br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;                                    <br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>();<br>     iter != winPtrs.<span class="hljs-built_in">end</span>();<br>     ++iter)                                  <br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>();  <span class="hljs-comment">// 正常的多态用法</span><br></code></pre></td></tr></table></figure></li></ol><p>最后总结下来就是, <strong>在出现dynamic_cast需求场景时, 如果代码对效率没有太多需求, 直接使用dynamic_cast, 反之则思考是否能做出上面所说的两种让步, 如果前两种让步的代价实在太高再使用dynamic_cast</strong>.</p><p>书中还指出了一种应当杜绝的写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow1</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow2</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow3</span> &#123; ... &#125;;<br>...                    <br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;<br>...<br><br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>&#123;<br>  <span class="hljs-keyword">if</span> (SpecialWindow1 *psw1 =<br>       <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow2 *psw2 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow3 *psw3 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子的代码, 不仅效率低, 而且可维护性差, 最好将这种需求<strong>改写成某种virtual函数</strong>来实现, 不要去依赖<code>dynamic_cast</code>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>尽量避免转型</strong>, 尤其在注重效率的程序中避免<code>dynamic_cast</code>.</li><li>转型并非什么都没做, 会产生实际的花销.</li><li>如果转型是必要的, <strong>可以把转型过程放在一个函数中</strong>, 让客户调用该函数以实现转型, 而不需要将转型写入他们的代码.</li><li>最好使用<code>C++</code>风格的新式转型.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款26 尽可能延后变量定义式的出现时间</title>
    <link href="/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/"/>
    <url>/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款26-尽可能延后变量定义式的出现时间"><a href="#条款26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款26 : 尽可能延后变量定义式的出现时间"></a>条款26 : 尽可能延后变量定义式的出现时间</h2><p>只要你定义了一个变量, 并且其类型带有构造函数或析构函数, 那么当程序控制流到达变量定义式时, 你便得承担构造成本; 当变量离开作用域时, 你便得承担析构成本. 本条款希望我们避免<strong>定义变量但最终并未使用</strong>的情况, 不要白白浪费构造和析构的成本.</p><p>先来看看什么情况下会出现定义变量但最终并未使用 : </p><p>这是一个密码加密的函数, 由于密码本身不能修改, 所以要定义并返回一个<code>encryted</code>来表示<strong>加密后的密码</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  string encrypted;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  ...                        <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到, 当密码的长度小于最小值时, 我们的函数无法提供对应的服务, 所以要抛出一个<code>logic_error</code>异常, 然后就离开该函数了, 也就是说先前构造的<code>encrypted</code>确实没有发挥任何作用.</p><p>没错, <code>encrypted</code>并非完全未被使用, 但是仍然会有未被使用的情况存在, 为了不无端付出构造和析构的成本, 我们应将其<strong>定义式往后移</strong>, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  string encrypted;<br>  ...                     <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设还有一个<code>encrypt</code>函数, 里面通过复杂的算法将<code>password</code>加密, 那么我们应当把<code>password</code>赋值给<code>encrypted</code>, 再把<code>encrypted</code>传进去, 进而使函数修改<code>encrypted</code>实现加密 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  string encrypted;         <br>  encrypted = password;  <span class="hljs-comment">// 赋值             </span><br><br>  <span class="hljs-built_in">encrypt</span>(encrypted);<span class="hljs-comment">// 传入</span><br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就又有可以提升效率的地方了, 这里的行为是<code>defalut</code>构造 + 赋值, 但是我们在条款4就讨论过 : “<strong>通过default构造函数构造出一个对象然后对它赋值比直接在构造是指定初值效率差</strong>“, 就和<code>vector</code>中<code>emplace_back</code>比<code>push_back</code>效率高一个道理, 于是我们可以有以下的改良操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...                                   <br>  <span class="hljs-function">string <span class="hljs-title">encrypted</span><span class="hljs-params">(password)</span></span>;     <br>  <span class="hljs-built_in">encrypt</span>(encrypted);<br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们再回顾本条款的内容 : <strong>尽可能延后变量定义式的出现时间</strong>.</p><p>我们可以理解到”尽可能延后”的真正意义, 在于<strong>我们不应当只延后变量的定义, 直到非得使用该变量的前一刻为止, 甚至应该尝试延后这份定义直到能够给它初值实参为止</strong>. 这样不只能<strong>避免构造非必要对象</strong>, 还能<strong>避免无意义的defalut构造行为</strong>. 更深一层说, 以”具明显意义值初值”将变量初始化, 还可以附带说明变量的目的, <strong>提高代码的可读性</strong>.</p><hr><p>还有一个小问题, 循环怎么办? 我们在循环外定义只需要定义一次, 在循环内需要定义n次, 延后不是代价更大吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  w = 取决于某个i的值;       <span class="hljs-function">Widget <span class="hljs-title">w</span><span class="hljs-params">(取决于某个i的值)</span></span>;<br>  ...                                  ...<br>&#125;                                    &#125;<br></code></pre></td></tr></table></figure><p>我们分析两种写法的成本 : </p><ul><li>循环外 : 1构造 + 1析构 + n赋值</li><li>循环内 : n构造 + n析构</li></ul><p>确实就实际而言, 循环外的做法大体比较高效, 但这建立在: </p><ol><li>你知道赋值比”构造 + 析构”的成本低的情况下.</li><li>你的这部分代码对效率高度敏感.</li></ol><p>否则你应该使用循环内的做法.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能延后变量定义式的出现. 这样有助于<strong>避免浪费, 提升效率, 提高代码可读性</strong>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款25 考虑写出一个不抛异常的swap函数</title>
    <link href="/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款25-考虑写出一个不抛异常的swap函数"><a href="#条款25-考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25 : 考虑写出一个不抛异常的swap函数"></a>条款25 : 考虑写出一个不抛异常的swap函数</h2><blockquote><p>swap 是一个有趣的函数, 原本它只是STL的一部分, 而后成为了异常安全性编程中的脊柱, 有关异常安全性我在条款11中介绍过, 在之后的条款29中也将着重着墨. 由于swap相当有用, 适当的实现非常重要, 好的swap设计可以带来非凡的效率提升.</p></blockquote><p>swap顾名思义, 意为将两对象的值彼此赋予对方, 在现代标准库中的实现是这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        T temp = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// 使用移动拷贝会大大提高效率且不抛出异常</span><br>        a = std::<span class="hljs-built_in">move</span>(b);<br>        b = std::<span class="hljs-built_in">move</span>(temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出这只是简单的移动拷贝而已, 而我们经常会使用一个手法叫做<code>pimpl idiom</code>, 其”<strong>以指针指向一个对象, 内涵真正的数据</strong>“, 这种手法意在将数据管理和操作管理解耦, 可以进行更有效的设计, 而这种类调用标准库的<code>std::swap</code>往往是效率低下的, 书中给出的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetImpl</span> &#123;                          <span class="hljs-comment">// 保存Widget的数据</span><br><span class="hljs-keyword">public</span>:                                    <br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a, b, c;                            <br>  std::vector&lt;<span class="hljs-type">double</span>&gt; v;                  <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                              <span class="hljs-comment">// 日常使用的Widget</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; rhs);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  WidgetImpl *pImpl;                         <span class="hljs-comment">// 一个指针指向数据</span><br>&#125;;           <br></code></pre></td></tr></table></figure><p>如果我们调用标准库中的<code>std::swap</code>, 其消耗是<strong>三次移动拷贝并且还有可能多余地拷贝双方的底层资源</strong>, 有可能产生更大的花销, 所以我们希望自定义的<code>swap</code>可以只交换<code>pImpl</code>的指针即可.</p><p>现在我们现在需要重新拟定一下我们的目标, 其一<strong>确保我们的swap函数不抛异常</strong>, 这是为了其在异常安全性上的功能得以实现; 其二<strong>让其他人调用swap时都能取得我们提供的高效的版本</strong>.</p><hr><p>前者只需我们记得不做有异常风险的举动就行了, 但是在<code>C++11</code>已经推行的当下, 我们还应<strong>必须</strong>给我们的函数贴心地加上<code>noexpect</code>标识符, 用来对编译器保证该函数绝不会抛出异常, <strong>编译器也会回应你的保证, 删去针对该函数的异常处理, 使效率提高</strong>. </p><hr><p>现在开始分析后者, 这里我们要知道一个前提, 大多数用户调用<code>swap</code>其实都是以标准库中的形式来调用的, 也就是说不会通过对象调用<code>swap</code>成员函数, 而是都是<code>swap(lhs, rhs)</code>这样的形式, 现在先研究在<code>C++98</code>版本下如何解决 :</p><p>书中给出的步骤如下:</p><ol><li>像我们先前一样写一个完美的不抛异常的<code>swap</code>成员函数.</li><li>在该<code>class</code>的命名空间下写一个<code>non-member swap</code>函数, 并使它调用该<code>class</code>的成员函数.</li><li>最后如果你的<code>class</code>不是<code>class template</code>(模板类), 为你的<code>class</code>全特化<code>std::swap</code>.</li></ol><p>我们来解释为什么要写三个函数, 即<strong>member + non-member + std全特化</strong> :</p><p>简单来说就是使在客户调用<code>swap(a, b)</code>时, 如果这个函数在<code>WidgetStuff</code>命名空间中, 就会直接匹配<code>non-member</code>版本, 进而调用相同命名空间下的<code>member</code>版本, 不会因为参数不匹配而没有调用到<code>member</code>版本. 而当客户调用标准库<code>swap</code>时, 由于模板全特化, 也会自动调用<code>member</code>版本.这样就极大程度上使得调用到的版本都是我们的特化版本.</p><p>由上面上述构成的最终方案如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span>  </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 下面解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-keyword">template</span>&lt;&gt;                       <span class="hljs-comment">// 对于swap针对Widget类型的全特化</span><br>  <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)<br>  &#123;<br>    a.<span class="hljs-built_in">swap</span>(b);                 <br>  &#125;                                <br>&#125;<br></code></pre></td></tr></table></figure><p>这里要解释一下为什么<code>member</code>版本中要加<code>using std::swap;</code>而不是直接用<code>std::swap(pImpl, other.pImpl)</code>, 因为不必写死只用标准库, <code>pImpl</code>也有可能是有自定义<code>swap</code>函数的类对象, 这样子可以<strong>让编译器优先选择类的自定义swap</strong>, 并且通过<code>using std::swap;</code>暴露了标准库接口, <strong>在没有自定义的情况下最后也会选择标准库版本</strong>.</p><hr><p>以上是<code>C++98</code>版本的解决方法, 但在<code>C++11</code>已经引入的当下, 推出了一个新的机制<strong>参数依赖查找 (ADL, Argument-Dependent Lookup)</strong>, 这个机制简单来说就是在<code>C++98</code>时的函数查找机制都<strong>只是在当前作用域或using声明中查找</strong>,  <strong>而ADL可以通过参数的类型将该类型所在的命名空间纳入查找范围</strong>. 这对我们上述的解决办法有何助益? 答案是我们不需要执行第三步了, 也就是说可以放弃对<code>std::swap</code>的全特化了.</p><p>在C++98的情况下, 如果当前作用域中没有<code>non-member</code>版本, 就一定会回到使用标准库的情况, 所以对<code>std::swap</code>进行全特化是有必要的. 而<code>ADL</code>可以通过参数类型引入作用域, 只要<code>non-member</code>版本和<code>member</code>版本在同一命名空间下, 就一定可以调用成功, 就是说<strong>只要你认真实现了前两步, 就一定不会在发生调用标准库<code>swap</code>的情况</strong>, 我们对标准库swap的需求就已经降低到了只需要默认版本的程度, 不需要任何的特化, 所谓的特化已经成为”98往事”了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 上面已经解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意为了符合<code>C+11</code>版本, 我们新加了<code>noexcept</code>关键字, 添加的原因上文已经说明.</p><hr><p>这次我基于<code>C++11</code>的新增机制对书中条款的解读做出了比较大的变化, 让其更适应2024年的现在, 写了很多原本书中没有的内容, 可能会有自己考虑不周的地方, 欢迎评论指正!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>当std::swap对你的类型效率不高时, 提供swap的member版本和non-member版本, 确定这两个函数不抛出异常, 并且标明noexpect</strong>.</li><li>如果你的版本还在<code>C++98</code>, 可能还要考虑多提供对<code>std::swap</code>的全特化.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款24 类型转换与non-member函数</title>
    <link href="/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款24-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24: 若所有参数皆需类型转换, 请为此采用non-member函数"></a>条款24: 若所有参数皆需类型转换, 请为此采用non-member函数</h2><blockquote><p>虽然令classes支持隐式类型转换是一个坏主意, 但常常有许多意外出现, 有些类型之间的关联实在太强, 我们经常想把它们放在一起用,       例如支持int类型隐式转换为Rational(有理数), 当对便利性的需求非常强烈之后, 也许支持隐式类型转换也未必是坏事.</p></blockquote><p>书中给出了一个<code>Rational</code>类, 它可以由<code>int</code>类型隐式转化而来 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,        <span class="hljs-comment">// 这里没有加explicit</span><br>           <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);     <span class="hljs-comment">// 传入int类型可隐式转换为分母是1的Rational类型</span><br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 获取分子</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 获取分母  // 见条款22</span><br><br><span class="hljs-keyword">private</span>:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们一定希望<code>Rational</code>类型可以和int类型相乘, 所以我们来写一个成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                       <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了以上的函数, 我们看看能通过哪些代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * oneEighth;            <span class="hljs-comment">// fine</span><br>result = result * oneEighth;                      <span class="hljs-comment">// fine</span><br><br>result = oneHalf * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneHalf;                             <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个例子无法通过编译, 原因很容易理解, 让我们重写一下上述两个式子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result = oneHalf.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">2</span>);                    <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2.</span><span class="hljs-keyword">operator</span>*(oneHalf);                    <span class="hljs-comment">// 2还没隐式转换, 怎么可能使用operator*</span><br></code></pre></td></tr></table></figure><p>因此我们有了这样的推论 : <strong>只有当参数被列于参数列内, 这个参数才是隐式转换的合格参与者</strong>.</p><p>至于”被调用之成员函数所隶属的哪个对象”, 即<strong>this对象</strong>, 绝不是隐式转换的合格参与者.</p><p>为了支持这样的混合算术运算, 可行之道拨云见日 : </p><p><strong>让operator*成为一个non-member成员函数</strong>, 即可让编译器在每一个实参上执行隐式类型转换. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><span class="hljs-comment">//-----------------------//</span><br><span class="hljs-function">Rational <span class="hljs-title">oneFourth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>Rational result;<br>result = oneFourth * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneFourth;                           <span class="hljs-comment">// fine</span><br></code></pre></td></tr></table></figure><p>问题解决, 皆大欢喜. 有了以上的经验, 我们在看别人代码时, 就不会奇怪于为什么总是要把双目运算符的重载都放在类外作为<code>non-member</code>定义了, 说明他们也深谙上述的道理, 也许有时并没有隐式转换的需求大家还是这样写, 可能是因为习惯了.</p><hr><p>有人可能认为<code>operator*</code>可以作为友元与<code>Rational</code>类加强联系, 但完全没必要, 除非它要调用<code>Rational</code>的<code>private</code>数据, 不然这样只会降低其封装性(见条款23), 我们<strong>不应当只因函数不该成为member, 就自动让它成为friend</strong>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>如果你需要为某个函数的所有参数进行类型转换, 那么这个函数必须是个<code>non-member</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(1)</title>
    <link href="/2024/12/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2024/12/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>人只有想起自己的无知才能有长进, 但他如此忙碌于运用自己已有的知识, 又如何能想得起来呢?</p></li><li><p>受制于对自己的看法, 受制于他通过自己行动所赢得的名誉.</p></li><li><p>大家好像都选择了相同的生活模式, 好像这种模式是在他们清醒时做出的选择, 然而其实他们并不认为还有其他模式可选, 但聪敏而健康的人记得太阳每天都会升起.</p></li><li><p>所有的改变都是奇迹, 但这种奇迹时时刻刻都在发生.</p></li><li><p>在当前的境况中找到他们的勇气和灵感, 怀着恋人般的怜爱和热情, 珍惜着此时此刻的生活.</p></li><li><p>没有人会因为衣服上有补丁而显得卑贱.然而我敢说, 普遍而言, 人们追求衣服时髦或者至少干净并且没有补丁的心情, 远比追求良知完整无损的心情要迫切.</p></li><li><p>商品的价格就是你用来换它的那部分生命.</p></li><li><p>让群众热切地跟风的时尚其实都是奢靡浪费的人设定的.</p></li><li><p>最好的艺术作品应该表现人如何奋斗着将自己从这种境况中解放出来, 但我们的艺术却只致力于使某种境界变得舒适, 并让人忘记更高级的境界.</p></li><li><p>在用美丽的物品装饰房子之前, 我们必须清理墙壁, 清理我们的生活, 还必须有美丽的家务管理和美丽的生活方式做基础.</p></li><li><p>对于生活, 大学生不应抱着玩乐的态度, 也不应只是研究它, 而是自始至终真诚地去过好它.</p></li><li><p>我盼望每个人都能非常清醒地去发现和追求他自己的生活方式.</p></li><li><p>做好事, 做人们常说的好事, 绝不应成为我人生的主要目标, 而且基本上绝不应刻意为之.与其去做好事, 不如做个好人.</p></li><li><p>人世间最难闻的莫过于变了味的好事.</p></li><li><p>做好事几乎是人人都称赞的美德, 人们不仅称赞他, 还给予他过高的评价; 而高估他的, 正是我们的自私心.</p></li><li><p>我们应该散发出去的, 不是绝望, 而是勇气, 不是病态, 而是健全.</p></li><li><p>所有的健康和成功都对我有益处, 哪怕他可能显得遥不可及; 所有的疾病和失败只会让我感到悲伤和对我有坏处, 哪怕他能引起我的怜悯, 或者让我得到许多同情.</p></li><li><p>我们不要去做管理穷人的官员, 而是要努力成为对这个世界有贡献的人.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款22-23 封装性相关</title>
    <link href="/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款22-将成员变量声明为private"><a href="#条款22-将成员变量声明为private" class="headerlink" title="条款22 : 将成员变量声明为private"></a>条款22 : 将成员变量声明为private</h2><p>本条款中, 作者明确声明, 如果没有必要的原因, 务必将成员变量声明为<code>private</code>, 而非<code>public/protected</code>, 并苦口婆心地列举出了非常多使用<code>private</code>的优势, 让我们逐一阅览 : </p><ul><li><h4 id="保证了语法一致性"><a href="#保证了语法一致性" class="headerlink" title="保证了语法一致性"></a>保证了语法一致性</h4><p>当客户通过对象调用时, 如果将成员变量声明为<code>private</code>, 那么就省去了客户思考要不要加小括号的问题, 只要无脑加括号就行了.</p></li><li><h4 id="对成员变量的处理更加精确"><a href="#对成员变量的处理更加精确" class="headerlink" title="对成员变量的处理更加精确"></a>对成员变量的处理更加精确</h4><p>当你把成员变量声明为<code>public</code>时, 客户拥有对该变量的所有特权, 可读可写, 然而我们一定不希望这样, 如果我们把成员变量声明为<code>private</code>, 通过<code>public</code>函数, 我们希望客户读时就返回一个<code>const reference</code>, 希望写就让客户传入修改值, 在函数内部修改, 如果不希望读写就不暴露在外置接口中.</p></li><li><h4 id="保证了封装性"><a href="#保证了封装性" class="headerlink" title="保证了封装性"></a>保证了封装性</h4><p>书中提出 : <strong>Public意味不封装, 不封装意味不可改变</strong>, 因为成员变量很大程度上是会被广泛使用的, 会出现在无数客户代码中, 如此牵一发而动全身, 就算你以后想改, 可客户就不一定想改了. <code>protected</code>也是同理, <strong>protected成员变量就像public成员变量一样缺乏封装性</strong>, 虽然成员变量并不开放给客户, 但是如果你之下有无数的派生类, 带来的修改难度也是非同一般, 由此可以得出一个结论 : <strong>成员变量的封装性与”成员变量的内容改变所破坏的代码数量”成反比</strong>.</p><p>而当我们使用private成员变量, 我们的修改范围就仅仅只局限在类内, 非常易于事后的修改. <strong>就算外部可以通过函数访问该成员变量, 日后希望对这个变量进行替换或修改, 外部也全然不知. 也就是说, 把成员变量隐藏在函数接口背后, 可以为所有可能的实现提供弹性</strong>.</p><p>书中给出了一个速度收集器的类, 保存每次测量到的速度, 可以返回当前状态下的速度平均值, 雏型如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedDataCollection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; data;<br>  ...<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span></span>;          <span class="hljs-comment">// 将收集到的速度存入data中</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">averageSoFar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 通过某些算法求得平均值并返回</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来假定一个情景, 这个类使用于一个嵌入式模板内, 一开始我们的可使用内存很少, 也不是很要求高效, 于是我们在<code>averageSoFar()</code>中的策略就是遍历<code>data</code>, 求出总和再求平均值. </p><p>当我们技术不断提高, 可使用内存变大了, 对计算效率有了需求, 我们就可以多加一个<code>private</code>成员变量<code>sum</code>额外记录<code>data</code>的总和, 然后修改<code>averageSoFar()</code>中的处理逻辑, 让其直接用<code>sum</code>求平均值, 效率可以从<code>O(N)</code>提到<code>O(1)</code>. </p><p>然而不管我们修改了什么, 外部<code>averageSoFar()</code>的使用者都不会知道.</p><p>这种<strong>把成员变量隐藏在函数接口背后</strong>的方式, 除了以上行为, <strong>还可以使得成员变量被读写时轻松同时其他对象, 验证class的约束条件以及函数的前提和事后条件, 实现在多线程环境中执行同步控制</strong>.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>切记将成员变量声明为<code>private</code>. 这有助于一致性, 访问控制, 允许约束条件获得保证, 提升类的实现弹性.</li><li><code>protected</code>并不比<code>public</code>更具封装性.</li></ul><hr><h2 id="条款23-宁以non-memeber-non-friend替换member函数"><a href="#条款23-宁以non-memeber-non-friend替换member函数" class="headerlink" title="条款23 : 宁以non-memeber non-friend替换member函数"></a>条款23 : 宁以non-memeber non-friend替换member函数</h2><p>本条款告诉我们, 如果一个成员函数没有直接访问成员变量的需求, 那么推荐将其替换为<code>non-memeber</code>且<code>non-friend</code>的函数.</p><p>想理解本条款可以先对封装性有进一步的认知 : </p><p>书中提出, 封装的本质在于<strong>隐藏内部实现和暴露有限接口</strong>, 至于我们为什么推崇封装, 是因为它<strong>使我们能改变的事务只影响有限客户</strong>, 就是说大大降低了我们后期做出改变时的维护成本. </p><p><strong>一个类的封装性和它的数据, 也就是成员变量息息相关</strong>, 愈少的代码可以看到数据, 愈多的数据就可以被封装, 封装性也就越强. </p><p>然而我们通常情况下认为数据以及操作数据的那些函数应该被捆绑在一起, 这样子是在实现所谓的封装, 然而正如我们前面所说, <strong>愈多成员函数可以访问数据, 数据的封装性就越低</strong>.</p><p>成员函数是实现封装的必要手段, 但并不代表我们可以毫无顾虑地增加成员变量, 每有一个函数可以访问到内部数据, 我们的维护成本就会提高一些, 因为你不一定会记得哪个函数有没有在什么不起眼的地方调用了我们的底层数据. 当然如果你预想的成员函数必须调用成员变量, 那完全没有问题. </p><p>书中给出了一个用于管理网络浏览器的类, 其中有一些用来清理的函数, 有的用来清理高速缓冲区, 有的用来清理历史记录, 有的用来移除<code>cookie</code>, 让我们看看书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在大多数情况下是希望同时调用这三个函数的, 于是我们可以写一个统合函数<code>clearBrowser()</code>, 按照习惯我们可能就把它写为成员函数了, 但有了上面的认知, 我们可以直接把它写成一个<code>non-memeber non-friend</code>函数,  代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br>    <span class="hljs-comment">// void clearBrowser(WebBrowser&amp; wb); // 请放弃这种写法</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>  wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们知道<code>clearBrowser</code>内部不会以任何形式直接调用数据,  所以干脆直接把<code>clearBrowser</code>排除在外, 这不只是告诉未来的自己, 也是在告诉将要维护这份代码的其他人, 这个函数从机理上就不可能触及底层数据, 是绝对安全的, 封装性因此得到提升.</p><p>当然还是要把他俩放在<strong>同一个命名空间</strong>内, 不然就真互相找不到了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>书中还提出 : 像是这种<code>clearBrowser</code>不触及底层数据的伪成员函数, 我们一般称其为便利函数, <strong>将所有的便利函数放在多个头文件内但隶属于同一个命名空间, 可以使编写者轻松找到并扩展某些方向的便利函数</strong>, 示例如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<span class="hljs-comment">// 核心机能</span><br>     ...                                <br>&#125;<br><br><span class="hljs-comment">// header &quot;webbrowserclear.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>; <span class="hljs-comment">// 有关内存清理的便利函数</span><br>  ...                                   <br>&#125;   <br><br><span class="hljs-comment">// header &quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关书签日志的便利函数</span><br>&#125;                                       <br><br><span class="hljs-comment">// header &quot;webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关cookie的便利函数</span><br>&#125;                                      <br>...<br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>宁以<code>non-memeber non-friend</code>替换<code>member</code>函数, 如果这个函数没有访问底层数据的必要的话. 这样子可以增加封装性, 包裹弹性和可扩展性.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款21 必须返回对象时, 别妄想返回其reference</title>
    <link href="/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/"/>
    <url>/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    
    <content type="html"><![CDATA[<h2 id="条款21-必须返回对象时-别妄想返回其reference"><a href="#条款21-必须返回对象时-别妄想返回其reference" class="headerlink" title="条款21 : 必须返回对象时, 别妄想返回其reference"></a>条款21 : 必须返回对象时, 别妄想返回其reference</h2><blockquote><p>当程序员领悟了条款20所讲的pass-by-value的种种效率问题之后, 往往会变成十字军战士, 一心一意根除pass-by-value的存在, 然而这却会让他们犯下一些致命的错误, 通过本条款让我们来了解.</p></blockquote><p>阅读完本文章, 我更倾向于把本条款解释为 :</p><ul><li>必须返回<strong>新</strong>对象时, 别妄想返回其reference.</li></ul><p>这样子会更便于理解.</p><p>书中给出了一个有理数类, 用于计算一个有乘积的有理数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,<span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> n, d;  <span class="hljs-comment">// 有理数的分子和分母</span><br><br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们最初的设想, <code>operator*</code>是传值返回的, 这不由得引发我们顾虑, 我们确实是希望其返回一个新的代表<code>lhs</code>和<code>rhs</code>乘积的<code>Rational</code>对象, 但是传值返回的拷贝构造成本也许会很高, 因此有不同的程序员想出了三种不同返回策略, 但无一例外都是错误的, 让我们看书中逐一反驳.</p><hr><h4 id="返回一个pointer-reference指向一个-local-stack-对象"><a href="#返回一个pointer-reference指向一个-local-stack-对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个 local stack 对象"></a>返回一个pointer&#x2F;reference指向一个 local stack 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们的目的是避免调用构造函数, 这样不仅没有避免, 而且<code>result</code>还是一个<code>local</code>对象, 出了作用域就会被销毁, 返回的引用是一个悬挂引用! 我们首先应当知道的, 就是不要让函数返回一个函数内局部变量的<code>reference</code>, 也就是返回引用的生命周期一定要大.</p><hr><h4 id="返回一个reference指向一个heap-allocated对象"><a href="#返回一个reference指向一个heap-allocated对象" class="headerlink" title="返回一个reference指向一个heap-allocated对象"></a>返回一个reference指向一个heap-allocated对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>  <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其一还是会进行构造, 其二这会带来严重的内存泄露, 首先你必须记得在外部要执行delete, 其次当你进行连乘时, 例如<code>a * b * c</code> , 你永远无法获得<code>b*c</code>是new出来的指针, 也就是说必然内存泄露.</p><hr><h4 id="返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象"><a href="#返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象"></a>返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,    <span class="hljs-comment">// 有风险的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)    <br>&#123;<br>  <span class="hljs-type">static</span> Rational result; <br>  result = ...;            <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个原理上看来没有问题, 但是只要使用<code>static</code>对象就一定会伴随着多线程情况下的风险, 这样就显得有弊端了, 除非你可以保证这个代码不会在多线程情况下出问题或是通过锁保证了线程安全, 就像我们条款4中提到的初始化策略一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>    <span class="hljs-keyword">return</span> timekeeper;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会确保这个函数在多线程之前的单线程阶段就都调用过一次来实现初始化.</p><hr><p>看过以上的三种情况后, 最后还是直接返回对象吧!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说即使要承担构造和析构的成本, 也还是推荐直接传值返回, 但是要知道Effective C++已经是十几年前的老书了, 现在伴随着C++11的引入, 带来了<strong>移动语义</strong>的新机制, 这种机制对传值返回带来了极大的优化, 简单来说就是不会有多余的构造和析构了, <strong>编译器会直接在原本要析构的临时对象上直接构建要传出的新对象</strong>, 也就是说传值返回的效率得到了极大的提升, 而这也与本条款的要求不谋而合, 可见Effective C++的条款还是禁得住时间历练的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>绝对不要返回一个<code>pointer/reference</code>指向一个<code>local stack</code>对象, 返回一个<code>reference</code>指向一个<code>heap-allocated</code>对象, 返回一个<code>pointer/reference</code>指向一个<code>local static</code>对象而有可能同时需要多个这样的对象. </p></li><li><p>请优先考虑传值返回吧, 在C++11引入移动语义后它如有神助!</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款20 宁以pass-by-reference-to-const替换pass-by-value</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    
    <content type="html"><![CDATA[<h2 id="条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20 : 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20 : 宁以pass-by-reference-to-const替换pass-by-value</h2><blockquote><p>本条款将告诉我们函数传参时的最佳策略.</p></blockquote><p>我们都知道, <code>pass-by-value</code>(传值传参)是一个费时费力的过程, 它会直接复制一个原件的拷贝, 如果是自定义类就会调用一次拷贝构造来实现复制, 函数结束时还要额外调用一次析构函数, 我们会很有意愿去削减这方面的花销.</p><p>相信我们在别处的很多函数中都看见过<code>pass-by-reference-to-const</code>的存在, 在本书中也极力推荐这种写法, 足矣见得这种写法的高效与广泛, 就像下面这行函数定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><p>reference的底层一般是个指针, 也就是说我们只是用了一个传递指针的花销就实现了参数的传递, 再加上const, 这对我们传入引用的安全性给予了保证,  使得这个写法<strong>兼具了效率与安全</strong>, 是不可多得的好事.</p><p>另外书中还给出了一个好处 : <strong>避免对象切割问题</strong>.</p><p>我们都知道多态中的动态类型是依靠指针和引用来触发的, 简单来说就是也许某个指针或引用的静态类型是基类, 但是动态类型可以通过实际的赋值来改变, 实现动态类型的绑定, 这点可是一个普通的类对象做不到的. 当我们使用<code>pass-by-reference-to-const</code>, 其实也就符合了这种性质, 我们来看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<span class="hljs-comment">// 普通窗口</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 返回窗口名</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 窗口显示函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window &#123;<span class="hljs-comment">// 高级窗口! 它带滚动条!</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 对窗口重写</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面是一对父子类, 下面是分别用两种传值方法的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span>         <span class="hljs-comment">// pass-by-value</span></span><br><span class="hljs-function"></span>&#123;                             <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span>   <span class="hljs-comment">// pass-by-reference-to-const</span></span><br><span class="hljs-function"></span>&#123;                                           <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用以下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<br></code></pre></td></tr></table></figure><p>如果我们调用前者, 答案是只能调用基类的<code>display()</code>, 因为<strong>对象被切割了</strong>, <code>wwsb</code>被强行从派生类被切割成了基类, 这很正常, 传一个对象可没有什么多态的机制.</p><p>如果我们调用后者, 结果很成功, 调用的就是派生类的<code>display()</code>, 因为<code>w</code>虽然静态类型是<code>Window</code>, 但由于引用的对象<code>wwsb</code>类型是<code>WindowWithScrollBars</code>, 所以动态类型绑定为了派生类, 调用就正确了. 说的有些复杂了, 可以宏观理解为<code>pass-by-reference-to-const</code>是虚函数机制实现的必要手段.</p><hr><p>吹了那么久<code>pass-by-reference-to-const</code>, 那么就没有什么情况要用<code>pass-by-value</code>的吗?</p><p>答案是有的, 先看书中给出的最终结论 : <strong>内置类型, STL迭代器, 函数对象推荐用pass-by-value</strong>.</p><p>原因很简单, <code>pass-by-reference-to-const</code>说到底也就是一个指针的花销, <strong>一些内置类型的花销甚至比指针花销还小</strong>, 而<strong>STL迭代器和函数对象内部也就是一个或几个指针</strong>而已, 差不了多少, 当然也有一部分原因是习惯所致.</p><p>有人可能认为只包含小型对象的自定义类型也可以用<code>pass-by-value</code>, 这样的想法是有漏洞的.</p><p>书中给出了三个原因 : </p><ol><li>对象小不代表<strong>构造和析构函数的花销</strong>就不小, 如果你直接<code>pass-by-value</code>一个STL的<code>set</code>, 其内部对象也就是几个指针, 是所谓的”小对象”, 但是构造和析构的开销就不知道大多少倍了.</li><li><strong>某些编译器对待内置类型和自定义类型的态度截然不同</strong>, 编译器很乐意把内置类型对象放进缓存器, 但一个自定义类对象就不会有此般关怀.</li><li><strong>一个类创建完后是需要维护的</strong>, 你现在对象小, 不代表以后就不会根据客户需求加入额外的变量, 除非你在一开始就把框架定死了.</li></ol><p>因此书中才给出了我们上面的最终结论.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽量以pass-by-reference-to-const替换pass-by-value, 前者高效, 安全, 并且有效解决了切割问题.</li><li>以上规则不适用于内置类型, STL迭代器, 函数对象, 它们适合pass-by-value.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款19 设计class犹如设计type</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    
    <content type="html"><![CDATA[<h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19 : 设计class犹如设计type"></a>条款19 : 设计class犹如设计type</h2><blockquote><p>C++ 是面向对象编程语言, 当你定义了一个新class, 也就定义了一个新type. 然而设计一个优秀的class是一项艰巨的任务, 正如设计一个好的type是一项艰巨的任务. 本条款将依照一个好的类型应有的行为来指导我们class的设计, 并一一列举出来.</p></blockquote><p>当我们要设计一个<code>class</code>时, 让我们对自己提出这些问题吧 : </p><ul><li><p><strong>新type的对象应该如何创建和销毁?</strong></p><p>想想<code>class</code>的构造和析构是否可以默认生成 不能的话该怎样编写.</p><p>想想是否要是设计内存的分配函数和释放函数.</p></li><li><p><strong>对象的初始化和对象的赋值该有什么样的差别?</strong></p><p>想想在<code>class</code>构造时需要有什么特殊的步骤, 以及是否需要设置一个<code>init</code>函数辅助构造.</p><p>想想<code>copying</code>时的策略是怎样的. (见条款14)</p></li><li><p><strong>新type的对象如果被 pass-by-value(以值传参) , 意味着什么?</strong></p><p>记住copy构造函数用来定义一个<code>type</code>被 <code>pass-by-value</code> 应当产生的行为.</p></li><li><p><strong>什么是新type的”合法值”?</strong></p><p>想想class的成员变量在你的预期中是否有一个合法的范围, 想想该怎样约束.</p><p>想想是否要设置超出合法范围时触发的检查机制.</p></li><li><p><strong>新type需要配合某个继承图系吗?</strong></p><p>如果其继承自某些既有的<code>class</code>, 你就应当受到那些<code>class</code>设计的束缚, 好好分析那些<code>virtual</code>函数是否要重写, 哪些不用.</p><p>尤其看看析构函数是否为<code>virtual</code>. (见条款7)</p></li><li><p><strong>新type需要什么样的转换?</strong></p><p>想想你的<code>class</code>可以和其他<code>class</code>产生什么可能且合理的转换, 如果有可以考虑实施.</p><p>如果有就写一个类型转换函数或接受其他类型的构造函数, 没有请声明<code>explicit</code>.</p></li><li><p><strong>什么样的操作符和函数对此新type而言是合理的?</strong></p><p>这个属于你的设计私事, 但也必须考虑清楚.</p></li><li><p><strong>什么样的默认成员函数应该驳回?</strong></p><p>将需要驳回的成员函数设置为<code>private</code>或者直接<code>delete</code>掉. (见条款6)</p></li><li><p><strong>谁该取用新type的成员?</strong></p><p>想想哪些成员应设为<code>public</code>, 哪些应设为<code>protected</code>, 哪些应设为<code>private</code>. </p><p>想想哪些<code>classes/functions</code>应是<code>friends</code>. </p></li><li><p><strong>什么是新type的”未声明接口”?</strong></p><p>想想你的<code>class</code>不对外的底层函数可以提供什么样的服务, 是否进行资源运用, 是否需要应对多线程情况, 以此在实现中加上相应的约束条件.</p></li><li><p><strong>新type有多么一般化?</strong></p><p>想想你的<code>class</code>是否要接受泛型编程, 有没有使用泛型编程的必要.</p></li><li><p><strong>真的需要一个新type吗?</strong></p><p>想想真的要定义一个新的class吗? 在你定义<code>derived class</code>时, 如果只是单纯地想添加一些机能, 而不是出于多态考虑, 那么说不定单纯定义一个或多个 <code>non-member</code> 函数或 <code>templates</code>, 更能够达到目标. 就像是<code>STL</code>源码中的<code>priority_queue</code>, 为了使用堆机制其实并没再建立一个专属的堆类, 而是写了几个用于调整堆结构的函数, 再套在<code>vector</code>上就实现了堆的功能.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>class</code>的设计就是<code>type</code>的设计, 在设计一个<code>class</code>之前请确定思考过本条款所提出的所有问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款18 设计正确易用的接口</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款18-让接口容易被正确使用-不易被误用"><a href="#条款18-让接口容易被正确使用-不易被误用" class="headerlink" title="条款18 : 让接口容易被正确使用, 不易被误用."></a>条款18 : 让接口容易被正确使用, 不易被误用.</h2><blockquote><p>C++在接口之海漂浮, 一个好的接口很容易被正确使用, 不容易被误用.</p></blockquote><p>条款18其实是一个很宏观的条款, 让接口变得正确易用, 简单来说就是”<strong>促进正确使用</strong>“和”<strong>阻止误用</strong>“.</p><p>我们先从<strong>阻止误用</strong>的角度考虑, 对接口来说, 是否误用无非就是参数传递的类型对不对, 参数是否合法, 是否符合设计者的设想.</p><p>书中给出了一个日期类, 分别由年月日的成员变量, 我们先来看第一个给出的构造函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样设计在设计者看来很合理, 但是没有任何合法性检查只会带来无穷的隐患, 我们可以从中看出以下问题 : </p><ul><li>客户不一定知道是按月日年的顺序来输入, 如果是我们的日常习惯, 可能会输入年月日.</li></ul><p>如何使用户在编写过程中就知道自己写错了呢? </p><p>书中告诉我们的方法是 : <strong>导入新类型</strong>, 因为问题的根源是年月日的变量类型都是相同的<code>int</code>, 如果设定为不同的类型, 就可以确保输入的正确性了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span> &#123;            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span> &#123;                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>     <span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>         <span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">  :val(d) &#123;</span>&#125;              :<span class="hljs-built_in">val</span>(m) &#123;&#125;                    :<span class="hljs-built_in">val</span>(y)&#123;&#125;<br><br>  <span class="hljs-type">int</span> val;                <span class="hljs-type">int</span> val;                      <span class="hljs-type">int</span> val;<br>&#125;;                      &#125;;                            &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>...<br>&#125;;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>;                      <span class="hljs-comment">// 错误, 不是int!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Day(<span class="hljs-number">30</span>), Month(<span class="hljs-number">3</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 错误, 顺序错了!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 正确, 类型和顺序相对应</span><br></code></pre></td></tr></table></figure><p>当然还有一些数值我们可以提前限制, 比如一年肯定只有12个月, 我们就可以让用户不用直接通过构造传参, 而是用函数返回需求的<code>Month</code>对象, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125; <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125;  <br>  ...                                       <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125; <br>  ...                                      <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>;  <span class="hljs-comment">// 不让用户显式使用构造, 只能通过成员函数内部调用</span><br>&#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month::Mar(), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <span class="hljs-comment">// 这样我们就可以这样调用了</span><br></code></pre></td></tr></table></figure><p> 书中提出<strong>以函数替换对象</strong>也是一种预防客户输入错误的方式.</p><p>当然通过<strong>const限制类型操作</strong>也是一种方式, 这里就不再举例.</p><hr><p>讲完了阻止误用, 那么如何<strong>促进正确使用</strong>呢? </p><p>正确使用, 简单来说就是<strong>符合使用者的习惯</strong>, 使用者的习惯是什么呢? 当然是<strong>使用内置类型</strong>呀, 使用者当然希望可以像使用<code>int</code>一样使用其他自定义的类型.</p><p>因此书中提出: <strong>除非有好理由, 否则应该尽量令你的自定义类型的行为与内置类型一致.</strong></p><p>实际来说就是<strong>用好运算符重载, 有必要时考虑迭代器的设计模式</strong>.</p><hr><p>书中还提出了一个重要观点 : </p><ul><li><strong>任何接口如果要求用户必须记得做某些事情, 就是有者”不正确使用”的倾向.</strong></li></ul><blockquote><p>接下来的内容有关条款13和14, 没有看过的可以看我往期的博客.</p></blockquote><p>让我们回到条款13中提出的<code>createInvestment()</code>工厂函数, 他会返回一个资源的原始指针, 而我们应当用<code>shared_ptr</code>去封装该指针, 这就成了用户必须记得做的事情, 那么为了让该函数返回的内容更易用, 我们可以在直接返回一个智能指针, 函数声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Investment* createInvestment();</span><br><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><hr><p>函数内部实现并非本条款的重点, 但是书中也花了部分篇幅去讲解, 我也会跟着解释清楚, 先看内部的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br>    <br>  ...                                <span class="hljs-comment">// 中间部分实现工厂函数的内存分配步骤</span><br>      <br>  <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到<code>shared_ptr</code>构造的两个参数我们可能会有点懵, 我们来一个个分析 : </p><p>首先我们明确<code>stl</code>中<code>shared_ptr</code>构造的第一个参数是<strong>原始资源类型的指针</strong>, 第二个参数是<strong>删除器函数</strong>.</p><p>先讲第二个参数, 看过条款14的都知道, <code>getRidOfInvestmen</code>t应当是我们提供给<code>shared_ptr</code>在析构时使用的函数, 它存在的意义在于某些类型没有传统的析构, 而是一些特殊的释放函数, 需要我们手动调用, 我们把这些函数放在删除器中, 就可以化手动为自动, 我们这里是假定<code>Investment</code>是有这种需求的类型, 如果不是当然可以不写. 这种由设计者自己定制删除器的行为其实也是在减少客户不必要的释放步骤, 与本条款的理念相符合.</p><p>接下来是第一个参数, 我们应当传入一个原始资源类型的指针, 按道理来说应该是通过<code>new Investment()</code> 返回一个指针直接存进去, 但这里选择先不进行动态分配, 直接存入一个<code>nullptr</code>, 而且由于<code>shared_ptr</code>构造不允许隐式类型转换, 所以要把<code>nullptr</code>强转成<code>Investment*</code>类型, 也就是<code>static_cast&lt;Investment*&gt;(nullptr)</code>了, 因此<code>retVal</code>刚生成时并没有分配到资源, 是在接下来中间部分实现内存分配.</p><p>这里深入一下, 为什么工厂函数中要先构造指针再分配内存, 而不是先分配内存再给指针构造? 这里有两点原因 : </p><ol><li><p>可能需要<strong>通过不同的条件以不同的方式分配内存</strong>, 这是也是工厂函数存在的意义所在.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">(<span class="hljs-type">bool</span> isPremium)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br><br>    <span class="hljs-comment">// 根据条件选择不同的分配方式</span><br>    <span class="hljs-keyword">if</span> (isPremium) &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;PremiumInvestment&gt;();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;RegularInvestment&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析以上代码, 我们可以知道<code>Investment*</code>的静态类型是一个基类指针, 但是通过<code>isPremium</code>和多态机制, 我们可以根据传入的<code>isPremium</code>来选择其动态类型是派生类的<code>PremiumInvestment</code>还是<code>RegularInvestment</code>进而产生不同的内存分配策略, 而这起码要我们先有一个指针对象才行.</p></li><li><p><strong>分配内存是有可能出现异常的</strong>, 如果出现异常先前分配的内存就泄露了, 但如果提前构造指针, 再用<code>make_shared</code>函数获取内存, 就算发生异常也一定是安全的, 因为<strong>指针会调用析构把先前的内存释放</strong>.</p></li></ol><p>也许略微有些跑题, 但是我觉得能看透问题的本质才是最重要的, 因此多下了一些功夫.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>阻止误用的方法包括 : 导入新类型, 以函数替换对象, 利用const限制, 消除客户的资源管理责任, 不要让客户必须记得某些事情.</strong></li><li><strong>促进正确使用的方法包括 : 保证接口的一致性, 与内置类型行为兼容.</strong></li><li>可以通过设定定制的删除器减少客户手动调用释放函数的负担.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款16-17 new 和 delete</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/</url>
    
    <content type="html"><![CDATA[<h2 id="条款16-成对使用new和delete时要采用相同形式"><a href="#条款16-成对使用new和delete时要采用相同形式" class="headerlink" title="条款16 : 成对使用new和delete时要采用相同形式"></a>条款16 : 成对使用new和delete时要采用相同形式</h2><p>直接看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;                     <br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure><p>这个其实没什么好说的, 其实就是相对应就行.</p><hr><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 : 以独立语句将newed对象置入智能指针"></a>条款17 : 以独立语句将newed对象置入智能指针</h2><p>在条款15我们知道C风格API喜欢直接调用原始资源, 那么我们来看一个不用直接调用原始资源的API : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来在某动态分配的Widget上进行某些带有优先权的操作, 所以需要传入一个智能指针和一个优先度, 那么现在<strong>假定去求优先度其实是一个很复杂的过程</strong>, 我们需要额外封装一个函数来返回求得的优先度 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>那么我们设想的调用<code>processWidget</code>的方法可能是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>这里的<code>priority()</code>函数嵌套是没有问题的, 我们日常中也推荐多用这种手法, 但是前面的new就有问题了, 因为<code>shared_ptr</code>不支持隐式转换, 也就是无法通过<code>new</code>出一个<code>Widget*</code>再转换成<code>shared_ptr&lt;Widget&gt;</code>, 那么下面的修改是否合理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>一眼看上去非常合理, 但是还是有一些隐患在其中, 我们知道<code>priority()</code>是一个很复杂的过程, 既然复杂就有可能会抛出异常, 抛出异常本身并不可怕, 我们可以设置对应的处理逻辑, 但是在这样的调用发生异常就有额外的问题了.</p><p>问题核心在于<strong>C++在函数参数的调用上弹性很大, 并不确定实际的调用步骤</strong> , 真正的调用步骤由编译器选择效率最高的步骤.</p><p>我们先来看看按顺序会发生什么 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>shared_ptr</code>构造函数</li><li>调用<code>priority()</code></li></ul><p>虽然我们确定执行 <code>&quot;new Widget&quot;</code> 表达式一定在调用<code>shared_ptr</code>构造函数之前, 但是我们确实不确定<code>priority()</code>的调用时机 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>构造函数</li></ul><p>如果是这样的话, 在priority()调用过程中发生了异常, 就算之后异常得到了处理,<code> &quot;new Widget&quot;</code>得到的资源也很大可能是被泄露了.</p><p>这一切的问题来源于<strong>在”资源被创建”和”资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰</strong>.</p><p>解决方法很简单, 那就是标题 : <strong>坚持以独立语句将newed对象置入智能指针</strong>, 这样就可以杜绝一切异常干扰了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;  <br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <br></code></pre></td></tr></table></figure><p>于是以上操作就没有任何问题了!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>成对使用<code>new</code>和<code>delete</code>时要采用相同形式.</li><li>以独立语句将<code>newed</code>对象置入智能指针.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款15 在资源管理类中提供对原始资源的访问</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 : 在资源管理类中提供对原始资源的访问"></a>条款15 : 在资源管理类中提供对原始资源的访问</h2><blockquote><p>我们将资源存入资源管理类, 为的是可以免去资源管理的麻烦, 但同时我们也希望<strong>可以正常合理地通过资源管理类来使用资源, 就像直接使用资源一样</strong>, 为此我们一定需要在资源管理类中提供对原始资源的访问;</p></blockquote><p>我们先来解答一些疑问 : </p><ul><li><h4 id="为什么要对原始资源进行访问-为什么要获取原始资源的指针"><a href="#为什么要对原始资源进行访问-为什么要获取原始资源的指针" class="headerlink" title="为什么要对原始资源进行访问(为什么要获取原始资源的指针)?"></a>为什么要对原始资源进行访问(为什么要获取原始资源的指针)?</h4><p>有时候需要我们传递原始资源的指针, 因为很多<code>C API</code>都是要求传递原始指针才能运作.</p></li><li><h4 id="如何进行资源访问呢"><a href="#如何进行资源访问呢" class="headerlink" title="如何进行资源访问呢?"></a>如何进行资源访问呢?</h4><p><strong>显式转换</strong> 或 <strong>隐式转换</strong> .</p></li></ul><hr><p><strong>显示转换</strong> : 资源管理类直接提供一个返回原始资源的<code>get()</code>函数, <code>C++</code>提供的智能指针也提供相应的功能.</p><p>书中举了一个有关字体资源管理的例子, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>假设有一个<code>C API</code>可以通过接受字体资源和字体大小来改变字体 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这是函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeFont</span><span class="hljs-params">(FontHandle f, <span class="hljs-type">int</span> newSize)</span></span>;     <span class="hljs-comment">// C风格的API函数</span><br><span class="hljs-comment">// 以下是用户具体使用例子</span><br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br>...<br><span class="hljs-built_in">changeFont</span>(f.<span class="hljs-built_in">get</span>(), newFontSize);<span class="hljs-comment">// 使用f.get()</span><br></code></pre></td></tr></table></figure><hr><p><strong>隐式转换</strong> : <strong>提供operator-&gt;和operator*的重载</strong> 或 <strong>直接提供隐式转换函数</strong></p><p>前者支持将资源管理类指针隐式转换为底部原始指针, 以此可以直接调用资源函数或取出资源成员变量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br>    <br>    <span class="hljs-comment">// 重载 operator-&gt;，返回原始的 FontHandle 指针</span><br>    FontHandle* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">return</span> &amp;f;  <span class="hljs-comment">// 返回 FontHandle 的指针，允许访问 FontHandle 的成员</span><br>    &#125;<br><br>    <span class="hljs-comment">// 重载 operator*，返回对 FontHandle 的引用</span><br>    FontHandle&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">return</span> f;  <span class="hljs-comment">// 返回 FontHandle 的引用，允许访问 FontHandle 的成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们就可以完全将资源管理类当做一个指针看待, <strong>通过*取出原始资源, 通过-&gt;调用原始资源的成员</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(*f, newFontSize);  <span class="hljs-comment">// 假装f是一个指针, 通过解引用调出资源</span><br></code></pre></td></tr></table></figure><hr><p>后者在使用资源管理类时就会默认转换到底部原始指针 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125;        <span class="hljs-comment">// 隐式转换函数</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样直接写f就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(f, newFontSize);<br></code></pre></td></tr></table></figure><p>但是书中并不推荐这样使用, 因为这是一种<strong>完全把资源管理类作为原始资源</strong>的做法, 也就是说<strong>无法再使用有关任何资源管理类自己的操作</strong>, 当我们想进行资源管理类的拷贝赋值等操作时, 由于已经隐式转换为了资源, 这样做几乎不会有好下场, 当然你也可以保证完全不使用也不设计这类操作, 让它单独做好资源管理的本职工作, 也是完全可以使用这种方法的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>API</code> 往往要求访问原始资源, 所以<strong>每个资源管理类都应提供一个取得其原始资源的方法</strong>.</li><li>对于原始资源的访问, 显示转换一般比较<strong>安全</strong>, 但隐式转换对客户比较<strong>方便</strong>, 自己斟酌利弊.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款14 在资源管理类中小心 copying 行为</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="条款14-在资源管理类中小心-copying-行为"><a href="#条款14-在资源管理类中小心-copying-行为" class="headerlink" title="条款14 : 在资源管理类中小心 copying 行为"></a>条款14 : 在资源管理类中小心 copying 行为</h2><blockquote><p>本条款是在我们自己建立资源管理类时要注意的行为, 但是归根结底, 我们为什么要自己建立资源管理类呢 ? 为什么不用 shared_ptr ? 这是我们在本条款中需要首先解决迭代问题.</p></blockquote><p>书中提出, C++提供的智能指针是适配于<code>heap-based</code>资源上的, 其要求不管是自动生成还是手动完成, 该资源<strong>必须要有析构函数</strong>, 然而并非所有的资源都是<code>heap-based</code>的, 简单来说就是有些资源<strong>没有对应的析构函数</strong>, 而是选择了别的方式进行资源的释放, 非常典型的就是<strong>文件句柄</strong>, 其必须要调用<code>close()</code>函数释放, 你如果直接把其交给<code>shared_ptr</code>而不做其他动作, 可以确定的是<code>shared_ptr</code>并不会智能到把<code>close()</code>加到智能函数中, 文件句柄不会被释放, 这样的资源还有很多, 而且大部分都很关键, 比如<strong>锁, 数据库连接, 网络socket</strong>等. 因此我们需要自己建立自己的资源管理类(当然也有些其他的方式).</p><hr><h3 id="怎么建立自己的资源管理类"><a href="#怎么建立自己的资源管理类" class="headerlink" title="怎么建立自己的资源管理类?"></a>怎么建立自己的资源管理类?</h3><p>简单来说还是<strong>遵循RAII原则</strong>, 构造即初始化, 析构即释放资源, 这里的释放资源具体到文件就是调用<code>close()</code>, 具体到锁就是调用<code>unlock()</code>, 我们自己应当考量, 而我们一般称其为 <strong>RAII风格的XXX</strong> .</p><p>书中给出了一段代码, 用于实现<strong>RAII风格的锁</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以实现以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mutex m;                    <span class="hljs-comment">// 设置一个互斥器</span><br>...<br>&#123;                           <span class="hljs-comment">// 这是一块作用域, 可以是一个要求线程安全的函数内部</span><br><span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;m)</span></span>;            <span class="hljs-comment">// 直接用互斥器上锁</span><br>...                     <span class="hljs-comment">// 执行对锁有需求的行为</span><br>&#125;    <span class="hljs-comment">// 离开作用域自动调用析构, 析构中自动unlock</span><br></code></pre></td></tr></table></figure><hr><h3 id="言归正传-当一个RAII对象被复制-会发生什么事"><a href="#言归正传-当一个RAII对象被复制-会发生什么事" class="headerlink" title="言归正传, 当一个RAII对象被复制, 会发生什么事 ?"></a>言归正传, 当一个RAII对象被复制, 会发生什么事 ?</h3><p>以下是可能发生的复制策略 : </p><ul><li><p><strong>禁止复制</strong> : 很多时候我们并不希望资源管理类可以复制, 就像锁, 我们一定不希望多个锁对象控制同一个底层的互斥器, 这有违锁设计的初衷, 所以直接禁止就好了, 这时我们的<code>Uncopyable</code>类就有用了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;        <span class="hljs-comment">// 直接private继承自Uncopyable</span><br><span class="hljs-keyword">public</span>:                                    <br>...                                     <span class="hljs-comment">// 同上   </span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>对底层资源祭出”引用计数法”</strong> : 这个其实就是利用<code>shared_ptr</code>实现资源共享就好了.</p><p>需要注意的就是, <code>shared_ptr</code>还有一个和共享内存无关的性质—<strong>删除器</strong>, 这是一个函数, 可以传入<code>shared_ptr</code>构造函数的第二参数, 如果没有删除器会默认调用析构, 有删除器就调用删除器, 这其实就在一定程度上解决了智能指针只能针对<code>heap-based</code>资源的问题, 让没有析构函数的资源也可以通过调用删除器实现释放, 以下是书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span>       </span><br><span class="hljs-function">  : mutexPtr(pm, unlock)         // 初始化智能指针, 将unlock设置为删除器</span><br><span class="hljs-function">    lock(mutexPtr.get());</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* mtx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mtx) &#123;<br>        mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>        <br>    <span class="hljs-comment">// 不需要写析构函数了, 它可以被删除器替代</span><br>&#125;<br>   <br><span class="hljs-keyword">private</span>:<br>  std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;    <span class="hljs-comment">// 使用 shared_ptr</span><br>&#125;;                     <br></code></pre></td></tr></table></figure><p>请注意如果我们写的资源管理类不希望共享资源, <code>shared_ptr</code>可以共享就带来了隐患, 像是上面的锁, 其实更推荐禁止拷贝的做法, 这种做法只是告诉我们一种其他的做法而已.</p></li><li><p><strong>复制底层资源</strong> : 这其实就是我们常说的深拷贝.</p></li><li><p><strong>转移底部资源的拥有权</strong> : 为了保证资源的独占性, 我们可以选择这种策略.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>复制<code>RAII对象</code>必须一并复制他所管理的资源, 资源的<code>copying</code>行为决定<code>RAII对象</code>的<code>copying</code>行为.</li><li>普遍的<code>copying</code>行为是禁止复制或施行引用计数法.</li><li>文件句柄和锁这类资源可以选择<strong>禁止复制, 支持移动</strong>的策略</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款13 以对象管理资源</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 : 以对象管理资源"></a>条款13 : 以对象管理资源</h2><blockquote><p>所谓资源, 一旦用了它, 将来必须还给系统. 本条款及以后几项条款都致力于实现优秀的资源管理, 严守这些条款, 可以几乎消除资源管理问题.</p></blockquote><p>本条款主要提出<strong>以对象管理资源</strong>的思想, 以及对<code>std</code>内置的<code>auto_ptr</code>和<code>smart_prt</code>的使用策略做了分析.</p><p>书中塑模了一个投资行为, 让我们看看资源该如何处理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span> &#123; ... &#125;;  <span class="hljs-comment">// 一个投资类</span><br><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这是一个工厂函数, 返回一个动态分配的对象, 这里为了简化刻意不写参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Investment *pInv = <span class="hljs-built_in">createInvestment</span>();         <br>  ...                                            <br>  <span class="hljs-keyword">delete</span> pInv;                                  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有资源管理对象, 我们正常行为是请求指针使用后再<strong>手动删除</strong>.</p><p>书中提出了”以对象管理资源”的两个关键想法 : </p><ul><li><strong>获得资源后立即放进管理对象.</strong></li><li>**管理对象运用析构函数确保资源被释放, **这样便可倚赖 C++ 的”<strong>析构函数自动调用机制</strong>“确保资源被释放.</li></ul><p>这两个想法来源于一种资源管理观念 : </p><ul><li><strong>RAII (Resoure Acquisition Is Initialization)</strong> <strong>: 资源取得时机便是初始化时机 .</strong></li></ul><p>那么资源管理类该如何使用与实现呢 ? 不妨看看C++本身给我们提供的两个资源管理类(智能指针)吧. </p><hr><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;  <span class="hljs-comment">// 请求对象的同时直接存入auto_ptr中 </span><br>  ...                                                 <br>&#125;         <br></code></pre></td></tr></table></figure><p>这样我们可以一如既往地使用<code>pInv</code>, 当其离开作用域时, 会经由<code>auto_ptr</code>的析构函数自动删除<code>pInv</code>.</p><p><code>auto_ptr</code>的特性 : 受<code>auto_ptr</code>管理的资源必须绝对没有一个以上的<code>auto_ptr</code>同时指向它.</p><p>也就是说<code>auto_ptr</code>保证独占指向的资源, 如果发生拷贝也会转交使用权, 这种特性使得其在需求共享内存的场面起不到作用, 于是也就有了我们接下来的<code>shared_ptr</code>.</p><hr><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pInv1</span><span class="hljs-params">(createInvestment())</span></span>;<br>  ...    <br>    std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt;  <span class="hljs-title">pInv2</span><span class="hljs-params">(pInv1)</span></span>; <span class="hljs-comment">// 允许指向同一块内存</span><br>  pInv1 = pInv2; <span class="hljs-comment">// 允许赋值同时获得使用权</span><br>&#125;          <br></code></pre></td></tr></table></figure><p><code>share_ptr</code>是”<strong>引用计数型智能指针</strong>“, 其自己内部维护了一个计数器, 用于记录指向同一块资源的指针有多少, 当发生拷贝和赋值时都会使计数器 + 1, 当有指向其的指针离开作用域时都会使计数器 - 1, 当计数器为0时才自动触发真正的析构.</p><hr><p>请注意 : <code>auto_ptr</code>和<code>shared_ptr</code>的析构函数内部调用的都是 <code>delete</code>, 而非 <code>delete[]</code>, 虽然我们可以 <code>new []</code>, 但是这样new出来的指针就请不要存入智能指针了. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spi</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>])</span></span>; <span class="hljs-comment">// 这样是错误的!</span><br></code></pre></td></tr></table></figure><p>至于为什么没有<code>delete[]</code>版本的, 那是因为<code>vector</code>和<code>string</code>几乎总是可以取代动态分配而得的数组, 所以没必要.</p><hr><p>以上专门描述了<code>auto_ptr</code>和<code>shared_ptr</code>, 但是本条款并不专门针对它们, 而是在强调”<strong>以对象管理资源</strong>“的重要性, 有时候我们要使用的资源也许是这些<strong>预制式classes无法妥善管理</strong>的, 就需要我们有<strong>自己制作资源管理类</strong>的能力了, 至于其中要考虑的细节, 在接下来的条款14, 15中会提及.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>为防止资源泄露, 请使用<code>RAII</code>对象, 它们在构造函数中获得资源并在析构函数中释放资源. </li><li>优先使用<code>shared_ptr</code>, <code>auto_ptr</code>次之, 如果效果无法令你满意, 请自己制作资源管理类.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款10-12 拷贝与赋值</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="条款10-令-operator-返回一个-reference-to-this"><a href="#条款10-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10 : 令 operator&#x3D; 返回一个 reference to * this"></a>条款10 : 令 operator&#x3D; 返回一个 reference to * this</h2><blockquote><p>很多类都有重写operator&#x3D;函数的要求,  本质是 &#x3D; 左侧调用 operator&#x3D; 函数, 右侧作为参数传入, 将右侧参数赋值给左侧成员变量, 并且为了实现连锁赋值, 我们还应当使 operator&#x3D; 返回当前赋完值的对象.</p></blockquote><p>本条款的目的是<strong>实现连锁赋值</strong>, 接下来看看如何 令 operator&#x3D; 返回一个 reference to * this : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)     <span class="hljs-comment">// 返回一个引用, 符合右侧参数的类型</span><br>&#123;          <br>    <span class="hljs-comment">// 条款11, 12会告诉我们怎样实现中间的拷贝过程</span><br>    ...<br>    <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                        <span class="hljs-comment">// 返回=左侧的当前对象, 使其可以充当下一次operator=的右侧参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时这个协议不只适用于 &#x3D; , 也同样适用于 +&#x3D;, -&#x3D;, *&#x3D; 等运算符.</p><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>令赋值操作符重载返回一个 reference to * this</li></ul><hr><h2 id="条款11-在-operator-中处理”自我赋值”"><a href="#条款11-在-operator-中处理”自我赋值”" class="headerlink" title="条款11 : 在 operator&#x3D; 中处理”自我赋值”"></a>条款11 : 在 operator&#x3D; 中处理”自我赋值”</h2><blockquote><p>我们设置一个变量w, 令 w &#x3D; w , 这种自我赋值的做法虽然看上去很愚蠢, 但是合法, 这种程度的自由还是应该有的, 可是这在我们手动重载operator&#x3D; 时也会带来相应的麻烦, 有一些我们需要注意的点.</p></blockquote><p>正常来说, 如果我们的类中只有一些普通的本地变量, 其实不必考虑自我赋值的问题, 因为只要把正常情况下的 operator&#x3D; 函数写好(或者你也可以让编译器自动生成), 是没有什么问题的, 问题发生在<strong>需要动态管理内存</strong>时.</p><p>假如我们一个类中有一个成员变量是指针, 该指针指向一块动态分配的内存, 我们创建两个类对象 a 和 b , 其中的指针都指向不同的内存, 当使 a &#x3D; b, 从正常考量来说, b 赋值给 a 应当代表着 a 的指针将指向原先 b 所指向内存, 那么<strong>原先 a 所指向的内存就应当delete掉</strong>, 以完成最后的赋值操作. 书中举了一个指针指向bitmap的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  Bitmap *pb; <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)              <span class="hljs-comment">// 这是一个有隐患的赋值重载</span><br>&#123;<br>  <span class="hljs-keyword">delete</span> pb;                                      <span class="hljs-comment">// delete掉原来指向的动态内存</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);                       <span class="hljs-comment">// 再new一块用来拷贝rhs副本的空间, pb重新接手这块空间 </span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                   <span class="hljs-comment">// 见条款10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很合理, 但是带入自我赋值的情况, 你就会惊奇地发现, new Bitmap(*rhs.pb)用来拷贝的副本 rhs.pb 已经因为 delete pb 被释放了! 我们掉进了”<strong>在停止使用资源之前就意外释放了它</strong>“的陷阱! 虽然自我赋值是愚蠢的操作, 但我们程序员也不能让愚蠢的操作产生愚蠢的错误, 所以我们应当提前判断是否是自我赋值 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <span class="hljs-comment">// 判断是否是自我赋值, 是就直接返回</span><br>  <span class="hljs-keyword">delete</span> pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以对自我赋值的问题完全规避了! </p><hr><p>但是其实由于动态内存的存在, 还催生出了另一个问题, 就是其实new一个对象也会有产生异常的情况出现, 如果申请内存失败, pb就是折了孩子又赔兵, 原先的内存释放了, 新申请的还失败了, 这个问题就是<strong>异常安全性</strong>的问题了, 从原理上来说这和本条款重点针对的自我赋值毫无关联, 但是书中很高兴地告诉我们 : </p><ul><li><strong>让 operator&#x3D; 具备”异常安全性”往往会自动获得”自我赋值安全”的回报.</strong></li></ul><p>因此作者告诉我们可以把焦点放在实现异常安全性上, 对自我赋值问题倾向于不管理. 就是说虽然两个问题毫不相干, 但你解决一个问题却可以顺带解决另一个问题, 何乐而不为呢?</p><p>那么如何实现异常安全性呢? 异常安全性会在条款29着重讲解, 但不妨我们提前了解 : </p><p>简而言之就是 : <strong>不泄露任何资源, 不允许数据败坏, 强烈保证如果函数没有成功就回滚到函数被调用前的状态</strong>.</p><p>放在本例中, 就是<strong>如何确保new失败后pb可以依旧指向原先的内存, 而不是原先的内存被释放</strong>.</p><p>简单思考一下就可以写出如下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  Bitmap *pOrig = pb;               <span class="hljs-comment">// 用一个备份指针记住原先的pb指向的空间先不释放</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// 令左边pb指向右边pb所指向内存的副本</span><br>  <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// 如果new成功了再释放原先指向的空间</span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是异常安全性的问题就解决啦, 我们还可以发现, 确实自我复制安全的问题也被解决了, 因为pb不会被提前释放, 就算是对着自己再复制一遍也完全没有问题, 唯一的变化就是换了块内存而已.</p><p>书中还提出了一种理念相同, 但更推荐的编写方法 : <strong>copy and swap技术</strong>;</p><p>简而言之就是 : <strong>如果对某对象的操作有异常风险, 就直接先copy该对象的副本, 在该对象的副本上做出所有操作, 随后swap原件和副本</strong>.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; W);<br>  ...                       <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 大多数赋值重载最后用的都是这种方法</span><br>&#123;<br>  Widget <span class="hljs-built_in">temp</span>(rhs);             <span class="hljs-comment">// 使用重写的拷贝构造函数直接拷贝副本</span><br>  <span class="hljs-built_in">swap</span>(temp);                   <span class="hljs-comment">// 交换原件和副本</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里可能有些人似懂非懂, 前一个函数很明确要在拷贝目标内存成功后就释放原内存, 这个是怎么实现的呢?</p><p>这里的拷贝构造函数我们需要重写, 实现对 bitmap 的深拷贝, 拷贝完的对象就是 temp , 由于 temp 是一个临时对象, 离开这个函数的作用域就会析构掉, 此时我们交换原对象和目标对象, 那么最后析构掉的就是存在 temp 中的原对象, 而目标对象留在了我们的当前对象中.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>通过实现异常安全性顺便解决自我赋值的问题.</li><li>确保操作多个对象时, 其中多个对象实质上是同一个对象时, 其行为仍然正确.</li></ul><hr><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12 : 复制对象时勿忘其每一个成分"></a>条款12 : 复制对象时勿忘其每一个成分</h2><blockquote><p>copying函数 : 拷贝构造 和 赋值重载(operator&#x3D;) .</p><p>条款10&#x2F;11告诉了我们 operator&#x3D; 如何返回值 和 注意 operator&#x3D; 自我赋值, 本条款会告诉我们 copying函数 在赋值过程中应当注意些什么.</p></blockquote><p>书中提出, 如果我们决定自己实现 copying函数, 编译器会仿佛被冒犯似的, 以一种奇怪的方式回敬 : 当你的代码必然出错时也不会告诉你. </p><p>这也在警告我们, 复制对象时勿忘其每一个成分.</p><p>首先提出的观点是 : </p><ul><li><strong>如果你为class添加一个成员变量, 你必须同时修改copying函数</strong>.</li></ul><p>这点很好理解, 每个成员变量都必须和拷贝构造和赋值拷贝关联.</p><p>接下的观点就涉及继承层面了 : </p><ul><li><p><strong>只要为 derived class 撰写 copying函数, 必须很小心地复制其 base class 成分.</strong></p></li><li><p><strong>你应当让 derived class 的 copying函数 调用相应的 base class函数.</strong></p></li></ul><p>我们来看书中的代码来进一步了解这两句话 : </p><p>书中设定了一个<code>Customer顾客类</code>, 其派生类是<code>PriorityCustomer贵宾类</code>, 贵宾类中local int 变量 <code>priority</code>, 用来确定贵宾的优先度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logCall</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; funcName)</span></span>;  <span class="hljs-comment">// 用来产生一个日志通告</span><br><br><span class="hljs-comment">// Customer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<span class="hljs-comment">// 普通客户</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>  std::string name;<br>&#125;;<br><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>: <span class="hljs-built_in">name</span>(rhs.name)                                 <br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 赋值重载被触发&quot;</span>);<br>  name = rhs.name;                             <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                  <span class="hljs-comment">// 见条款10</span><br>&#125;<br><br><span class="hljs-comment">// PriorityCustomer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span>: <span class="hljs-keyword">public</span> Customer &#123;                  <span class="hljs-comment">// 贵宾客户</span><br><span class="hljs-keyword">public</span>:<br>   ...<br>   <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>   PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> priority;<br>&#125;;<br><br><span class="hljs-comment">// 重点看这个两个函数</span><br>PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br>  priority = rhs.priority;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似<code>PriorityCustomer</code>的构造函数好像复制了每一样东西, 但是其实它所<strong>继承的Customer部分并未进行复制</strong>, Customer部分中的name变量仍旧是未定义的, 当我们再仔细看看operator&#x3D;, 里面的问题是一样的.</p><p>接下来是改进后的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">Customer</span>(rhs)                   <span class="hljs-comment">// 调用 base class 的 copy构造函数</span><br>  , <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br><br>  Customer::<span class="hljs-keyword">operator</span>=(rhs);           <span class="hljs-comment">// 对 base class 成分进行赋值动作</span><br>  priority = rhs.priority;<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样代码就完美了! 再去回味前面提出的两句话, 其实就是在告诉我们<strong>显式且正确处理基类部分的拷贝和赋值</strong>的重要性.</p><p>我们要确保 : </p><ol><li>复制所有的 local 变量.</li><li>调用所有 <code>base classes</code> 内适当的 <code>copying函数</code>.</li></ol><hr><p>很多时候这两个<code>copying函数</code>往往有着近似的实现本体, 这可能会诱使我们用其中一个调用另外一个以实现代码复用的效果, 但是书中告诉我们这样做风险很大, 因为拷贝构造用来初始化新对象, 而赋值重载只能施行于已初始化的对象上, 二者的应用场景就不同, 不然也就不会分成两个默认成员函数了, 所以书中告诉我们 : </p><ul><li><p><strong>你不该令 copy assignment 操作符调用 copy构造函数 .</strong></p></li><li><p><strong>令 copy构造函数 调用 copy assignment 操作符同样无意义.</strong></p></li><li><p><strong>真正明智的做法是将相近代码封装进 init() 函数, 给二者调用.</strong></p></li></ul><hr><h3 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>copying函数</code>应当确保复制 “对象内的所有成员变量” 及 “所有<code>base class</code>成分”.</li><li>不要尝试<code>copying函数</code>相互调用, 应当封装一个共用函数实现代码复用.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款9 绝不在构造和析构函数过程中调用</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款09-绝不在构造和析构函数过程中调用virtual函数"><a href="#条款09-绝不在构造和析构函数过程中调用virtual函数" class="headerlink" title="条款09 : 绝不在构造和析构函数过程中调用virtual函数"></a>条款09 : 绝不在构造和析构函数过程中调用virtual函数</h2><p>开门见山阐释本条款的重点 : <strong>你不该在构造函数和析构函数中调用virtual函数</strong>.</p><p>书中给出了一个例子 : 假如我们要塑膜股市交易订单模型, 订单可以分成买入, 卖出等不同类型的订单, 当我们产生不同类型的订单, 也就是构造不同类型订单对象时, 我们也许会有记录订单日志的需求, 并我们希望订单根据不同的订单类型产生不同的订单日志.</p><p>于是我们可以抽象出以上需求的类构建过程, 一个订单基类, 派生出不同的订单派生类(如买入类, 卖出类), 基类的构造函数调用一个虚函数<code>logTransaction()</code>, 派生类重写出不同的<code>logTransaction()</code>, 就可以实现我们以上的需求.</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                               <span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span>:                                           <br>  <span class="hljs-built_in">Transaction</span>()<br>  &#123;                                                 <br>  ...<br>  <span class="hljs-built_in">logTransaction</span>();                        <span class="hljs-comment">// 订单构建时依据订单动态类型构建对应日志       </span><br>&#125;     <br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 要求派生类重写</span><br>  ...<br>&#125;;                       <br>                                            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;       <span class="hljs-comment">// 买入类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 提供重写版本日志</span><br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">// 卖出类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码看似很完美, 但是真正运行起来是无法实现的!</p><p>当我们创建一个<code>BuyTransaction</code>类对象<code>b</code>时, 并不会调用<code>BuyTransaction</code>重写的<code>logTransaction()</code>, 而是会调用基类<code>Transaction</code>的<code>logTransaction()</code>, 然而我们基类的<code>logTransaction()</code>设置为纯虚函数甚至都没有写, 就更别谈运行了. </p><p>为什么? 书中告诉我们, <strong>在base class构造期间, virtual函数不是virtual函数</strong>, 更细致的说就是<strong>base class构造期间virtual函数绝不会下降到derived class阶层</strong>. 原因很直观, <strong>base class 构造函数执行期间derived class的成员变量一定还未初始化</strong>, 如果此刻就可以通过virtual下降到派生类, 我们怎么确保这个虚函数不会调用派生类的成员变量呢? 太危险了, 所以C++不会让你走这条路.</p><p>而且不止是不能在构造析构函数内调用虚函数, 当然也不能调用包含了虚函数的普通函数, 这是显而易见的, 这就又回到了我们开头说的那句话 : <strong>绝不在构造和析构函数过程中调用virtual函数</strong>, 只要还在过程中, 就不要调用.</p><hr><p>那么我们最开始的需求还有其他实现的方式吗?</p><p>书中提出一种解决办法 : 将<code>logTransaction()</code>改为普通函数, 要求派生类构造函数传递必要的日志信息给基类的构造函数, 基类的构造函数再把接收到的日志信息传入<code>logTransaction()</code>, 这样就可以了!</p><p>我们可以宏观地理解一下, 有助于我们的思维进步. 其实派生类的构造函数是一个<code>自底向上</code>的过程, 一直递归调用到最顶层的基类, 当调用到最顶层后, 我们不好奢求基类再自顶向下调用派生类的重写函数, 不如在一开始自底向上时就把必要的信息传递至基类构造函数, 这样想就非常通顺了.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span>  <span class="hljs-comment">// 接收下层的日志信息</span></span><br><span class="hljs-function">  </span>&#123;<br>  ...<br>  <span class="hljs-built_in">logTransaction</span>(logInfo);<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 此时是普通函数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BuyTransaction</span>(<span class="hljs-type">const</span> std::string&amp; parameters)<br>: <span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>(parameters))             <span class="hljs-comment">// 将log信息传递给上层</span><br>  &#123; ... &#125;                                                 <br>   ...                                                  <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 这里利用一个辅助函数创建一个值传给base class构造函数往往比较方便美观可读</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; parameterss)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝不在构造和析构函数过程中调用<code>virtual</code>函数.</li><li>对象在<code>derived class构造函数</code>开始执行前不会成为一个<code>derived class对象</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款8 析构函数的异常管理</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 : 别让异常逃离析构函数"></a>条款08 : 别让异常逃离析构函数</h2><blockquote><p>日常编程中，常见异常通常由以下原因引发：</p><ol><li><strong>资源管理不当</strong>（如内存泄漏, 文件操作, 连接或断开连接失败）。</li><li><strong>边界和合法性检查不足</strong>（如数组越界、除以零）。</li><li><strong>并发编程问题</strong>（如死锁、数据竞争）。</li><li><strong>类型不匹配或错误的操作</strong>。</li></ol></blockquote><p>本条款主要讨论的是析构函数的异常管理, 为什么会不希望异常逃离析构函数, 因为<strong>析构函数是一个必须执行且有可能失败的函数</strong>, 因为内存泄漏, 文件操作, 连接或断开连接失败等资源管理行为的错误都是很难避免的, 而且由于<strong>析构函数是递归式调用并且可能一次性销毁大量结构</strong>, 同时产生大量异常的概率就提高了, 书中指出, <strong>如果同时存在多个异常, 程序不是结束执行就是导致不明确行为</strong>, 因此对于析构函数的异常管理在所难免.</p><hr><p>书中举出了一个数据库连接的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;  <span class="hljs-comment">// 数据库连接类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回创建出来的静态数据库连接.                                     </span><br>  ...                                      <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 调用此函数关闭与数据库的连接, 这里有抛出异常的隐患         </span><br>&#125;;         <br></code></pre></td></tr></table></figure><p>我们经常会设计一个资源管理类来控制数据库的连接 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;                          <span class="hljs-comment">// 数据库连接管理类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>   db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 调用析构函数时断开数据库连接</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  DBConnection db;   <span class="hljs-comment">// RAII风格, 由DBConn管理DBConnection, 离开作用域自动触发DBConn的析构函数断开连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以写出以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ...<br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// 直接建立DBConnection对象并交由DBConn对象dbc管理</span><br>    ... <span class="hljs-comment">// 进行数据库的CURD, 离开作用域自动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了上面例子的基础, 我们来思考一下如何避免异常抛出吧.</p><p>站在<code>DBConn析构函数</code>的角度, 书中给出了两个一般的方法 : </p><ol><li><p>如果close()抛出异常就利用abort()结束程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>   std::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 直接结束程序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接吞下该异常.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>      <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>      <span class="hljs-comment">// 不做处理, 直接吞下</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两个方法其实都是保底方法, 一个是草率结束进程, 一个是吞掉异常防止扩散, 但其实<code>DBConn析构函数</code>也就能做这么多了.</p><hr><p>现在的问题是<strong>没有办法对”导致close抛出异常”的情况做出反应</strong>, 问题核心在<code>close()</code>函数被<code>DBConn析构函数</code>掌握, 只能其自己管理, 上一层无法干预. 那么由此我们可以将close()函数的使用权上交, 也就是让上一层用户有权决定处理<code>close()</code>报错的方式. </p><p>较佳策略是<strong>重新设计DBConn接口, 使客户有机会对可能出现的问题作出反应</strong>. </p><p>具体做法如下 : </p><ol><li><code>DBConn</code>自己也提供一个close接口, 内部封装上<code>DBConnection</code>的<code>close()</code>.</li><li><code>DBConn</code>自己对<code>DBConnection</code>的<code>close()</code>是否已经触发进行追踪管理, 如果到最后客户都没有自行close成功, 由<code>DBConn析构函数</code>自行完成close的任务.</li></ol><p>我们来看书中给出的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 提供给上层用户的close函数</span></span><br><span class="hljs-function">  </span>&#123;                                       <br>    db.<span class="hljs-built_in">close</span>();<br>    closed = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>      <span class="hljs-comment">// 如果到最后都没有触发close, 就会回到析构函数调用close的老路</span><br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>   <span class="hljs-keyword">try</span> &#123;                                           <br>     db.<span class="hljs-built_in">close</span>();                           <br>   &#125;<br>   <span class="hljs-built_in">catch</span> (...) &#123;                                    <br>     <span class="hljs-comment">// 记录日志, 记录对close的调用失败  </span><br>     ...                                   <span class="hljs-comment">// 直接结束 或 吞下异常</span><br>   &#125;<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  DBConnection db;<br>  <span class="hljs-type">bool</span> closed;<span class="hljs-comment">// 用布尔变量closed来对close()进行追踪管理</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是客户便可做出如下操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 客户自己在认为合适的地方调用close()结束连接, 并用try-catch语句尝试捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能会抛出异常，如果关闭失败</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 客户端捕获从 close() 抛出的异常</span><br>        <span class="hljs-comment">// ... 出现异常时的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只考虑数据库断开连接的场景, 我们可行的具体操作可以是重试关闭或执行数据库回滚, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!success &amp;&amp; attempts &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;正在尝试断开数据库连接, 次数 :  &quot;</span> &lt;&lt; ++attempts &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;已经尝试三次断开数据库连接, 但都出现异常, 断开失败&quot;</span> &lt;&lt; std::endl;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;进行补偿操作, 回滚数据库&quot;</span> &lt;&lt; std::endl;<br>        dbConn.<span class="hljs-built_in">rollback</span>(); <span class="hljs-comment">// 内部调用数据库的回滚函数</span><br>&#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来捋一下流程, 先是客户需要考虑何时调用<code>close()</code>并写出应对异常的代码, 实际运行时如果没有异常就万事大吉, 有异常就触发客户的处理逻辑, 最后析构函数检查客户是否真的成功调用了<code>close()</code>, 如果还是没有调用, 就自己调用, 自己调用如果还出错, 就直接结束程序或吞掉异常.</p><p>至此我们将调用<code>close()</code>的责任从<code>DBConn析构函数</code>的手上移交到了使用<code>DBConn对象</code>的客户手上, 可以更好地避免异常逃离析构函数. 有人可能这样会加大客户的操作负担, 但是根据我们先前的分析, 只有客户才能有办法对”导致close抛出异常”的情况做出反应, 这样做是给客户提供一个根据实际情况回避异常的机会, 至于是否需要就看客户自己了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>析构函数绝对不要吐出异常. 如果分析出一个析构函数有抛出异常的风险, 应当先把异常捕捉下来, 看是否结束程序或吞下异常.</li><li>给客户提供自己处理异常的机会, 让客户可以根据实际情况对异常做出反应.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款7 virtual析构函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 : 为多态基类声明virtual析构函数"></a>条款07 : 为多态基类声明virtual析构函数</h2><blockquote><p>说到多态, 我们应当非常了解其运行时绑定的机制, 简单来说就是我们可以在任何时候根据用户的需求将基类绑定为不同的派生类, 用相同的操作实现不同的效果, 这其中virtual函数起到了至关重要的作用, 每一个含有虚函数的类都会维护一个虚表, 以此实现基类到派生类的动态绑定. </p></blockquote><p>这里书中提到了一个重要又经常发生的问题 : <strong>如果<code>drived class(派生类)</code>对象经由一个<code>base class(基类)</code>指针被删除, 而该base class带着一个non-virtual析构函数, 那么结果是未定义的</strong>.</p><p>这里的结果未定义, 一般情况下是只会调用<code>base class</code>自己的析构函数, 销毁的是该对象的<code>base class</code>部分, 而<code>drived class</code>部分却没有被销毁, 就造成了诡异的”局部销毁”现象.</p><p>而解决这个问题的方法就是 : <strong>给 base class 一个 virtual析构函数</strong>.</p><p>先回忆一下有关派生类析构函数的知识 : <strong>派生类的析构函数会默认先调用上一层的析构函数</strong>. 也就是说是从当前派生类的析构函数开始, 递归式调用上一层的析构函数, 直到到达最深层的基类. </p><p>再思考上面的话, 当<code>base class</code>指针动态绑定<code>drived class</code>对象时, 如果我们想删除这个对象时, 正确的结果应该是调用动态绑定的<code>drived class</code>的析构函数, 这样才能正确地全部销毁, 而想这样调用就只能依赖于虚函数来实现, 也就是我们需要把base class的析构函数设置为virtual, 删除时就会根据虚表找到当前动态类型绑定的析构函数.</p><p>以下是书中的给出的样例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TimeKeeper</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>  ...<br>&#125;;<br>TimeKeeper *ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br>...<br><span class="hljs-keyword">delete</span> ptk;                         <span class="hljs-comment">// 现在, 行为正确</span><br></code></pre></td></tr></table></figure><p>书中告诉我们 : </p><ul><li><strong>virtual 函数的目的是允许 derived class 的实现得以客制化</strong>.</li><li><strong>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数</strong>.</li></ul><hr><p>当然, 无端地将所有的 classes 的析构函数声明为 virtual, 就像从未声明他们为 virtual 一样, 都是错误的.</p><p>如果 class 不含 virtual 函数, 通常表示它并不意图被用作一个 base class, 也就完全不需要声明virtual析构函数.</p><p>我们知道使用虚函数是要带来额外的花销的, 包括维护虚表, 虚指针表等一系列繁杂的动作, 会带来时间成本和空间成本, 而且书中还提到由于对象大小的增加会影响其可移植性.</p><p>所以请记住一个心得 : <strong>只有当 class 内含至少一个 virtual 函数, 才为他声明 virtual析构函数</strong>.</p><hr><p><strong>请不要企图继承我们神圣的STL容器</strong>, 正因为考虑到上面虚函数有关时间, 空间, 可移植性的问题, STL容器并没有考虑被继承的情况, 它们的析构函数都是 non-virtual 的!</p><hr><p>这里书中提到了一个构建抽象类的小窍门 : </p><p>我们一般不希望抽象类被实体化, 它只提供一些接口 : </p><ol><li>被声明为<code>纯虚函数</code>的接口所有派生类必须重写.</li><li>被声明为<code>虚函数</code>的接口提供默认行为同时也允许派生类重写.</li><li>被声明为<code>普通函数</code>的接口可以被所有派生类继承, 使用.</li></ol><p>我们在设计一个抽象类时, 也许并不希望有什么类是必须重写的, 就是不希望有纯虚函数, 只需要提供虚函数和普通函数即可, 然而一个类想要不被实体化, <strong>必须存在一个纯虚函数</strong>, 那么哪里找一个纯虚函数呢? </p><p><strong>如果你拿不定主意, 选析构函数就好了!</strong> 毕竟抽象类一定有多态的需求, 只要有多态的需求, 析构函数就必须是 virtual 的, 已经是虚函数了, 变成纯虚函数也没什么问题, 而且当我们的派生类没有新增动态资源时, 就算我们不手动重写析构函数也没关系! 因为编译器会自动帮我们生成! 这样既满足了必须有一个纯虚函数的要求, 又不需要我们顾及纯虚函数必须重写的问题, 多么完美 !</p><p>不过有一个小细节必须要注意, 所有派生类析构函数最后都会调用到最底层基类的析构函数, 所以我们<strong>需要对纯虚析构函数进行定义</strong>!</p><p>纯虚析构函数真的能定义吗? 答案是能的, 虽然大多数情况下纯虚函数都不用定义, 但是真要定义还是可以的.</p><p>以下是书中的示例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br>AWOV::~<span class="hljs-built_in">AWOV</span>()  <span class="hljs-comment">// 纯虚函数的定义</span><br>&#123;<br>    <span class="hljs-comment">// delete ...</span><br>&#125;                    <br></code></pre></td></tr></table></figure><hr><p>再次重申, 本章的主要观点  <strong>给 base class 一个 virtual析构函数</strong> 只适用于多态用途, 这种<code>base class</code>的设计目的就是为了<strong>用来通过 <code>base class</code> 接口处理 <code>drived class</code> 对象</strong>.</p><p>我们也应当知道很多 class 的设计就不是为了作为 base class 来使用, 也并非所有的 base class 的设计目的是为了多态用途, 就像我们上一个条款的<code>Uncopyable</code>类, 它被作为基类就不是为了多态, 而是为了赋予派生类不可拷贝的属性, 就不需要使用基类接口, 使用也只是使用派生类, 使用 virtual析构函数就没必要了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>请为多态性质的<code>base class</code>设置 virtual析构函数, 反之请不要.</li><li>不要试图继承<code>STL</code>容器.</li><li>想设计抽象类又不知道纯虚函数选谁时, 选析构函数当纯虚函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款5-6 默认成员函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05 了解C++默默编写并调用哪些函数"></a>条款05 了解C++默默编写并调用哪些函数</h2><blockquote><p>编译器会默认为class创建default构造函数, 析构函数, copy构造函数, 赋值操作符重载, 这算是我们C++语言基础学习中的重中之重, 这里就不再过多阐释.</p></blockquote><p>书中提出一点 : 如果我们在实际使用中确实没有使用到某些默认成员函数, 编译器很大可能也不会自动创建对应的默认函数(例如copy构造函数, 赋值操作符重载).</p><hr><p>书中还提出了三种编译器拒绝自动生成赋值操作符重载的情景 : </p><ol><li>内含<code>reference(引用)</code>成员变量的类.</li><li>内含<code>const</code>成员变量的类</li><li>基类将赋值操作符重载声明为private的派生类</li></ol><p>原因都是显而易见的, <code>reference</code>不可改指不同对象, <code>const</code>不可被更改, 派生类基于基类.</p><hr><p>这里额外提一个小点, 就是默认生成的拷贝函数和辅助操作符重载默认都是浅拷贝, 就是只把类类对象的所有值进行复制, 如果有指针, 不会深入拷贝指针指向的内容, 只是单纯把指针本身拷贝.</p><h2 id="条款6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝"></a>条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝</h2><blockquote><p>虽然大多情况下一个类对象应当有外置的构造&#x2F;析构&#x2F;拷贝接口, 但是总会有一些独一无二的东西应当是不可复制的, 就想天下没有第二个你一样, 如果为你自己设计一个类, 你肯定也不希望有一个自动生成的拷贝函数可以拷贝出无数个你吧.</p></blockquote><p>因此, 若不想使用编译器自动生成的函数, 就该明确拒绝.</p><p>所以怎么拒绝呢?</p><ol><li>将该函数写入private中, 并且故意不实现它.</li><li>将该函数后加上<code>= delete</code>.</li></ol><p>假定我们要写一个房产买卖的类<code>HomeForSale</code>, 众所周知每一套房产都是独一无二的.</p><p>我们来看看怎么实现 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员函数</span><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;); <br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;); <span class="hljs-comment">// 这样拷贝函数无法在外部使用就相当于禁用</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 直接声明禁用, 其实在哪声明都可以</span><br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>   ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="设计一个专门为了阻止copying动作的base-class"><a href="#设计一个专门为了阻止copying动作的base-class" class="headerlink" title="设计一个专门为了阻止copying动作的base class"></a>设计一个专门为了阻止copying动作的base class</h4><p>针对某些对象独一无二的情况, 我们可以设计一个专门为了阻止copying动作的base class, 让所有有此需求的类继承自该类, 就可以完全不用在专门处理阻止copying动作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:              <span class="hljs-comment">// 允许构造和析构</span><br>  <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                            <br>  ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                           <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);   <span class="hljs-comment">// 阻止copying</span><br>  Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;     <br>  ...    <span class="hljs-comment">// 自此HomeForSale不需要再进行任何动作就可以实现阻止copying</span><br>&#125;;  <br></code></pre></td></tr></table></figure><p>ed : 也许有人觉得这样子反而多写的, 但在日常情况下<code>Uncopyable</code>完全可以是我们提前备好的, ctrl + v当然方便很多. 再说到为什么是<code>private继承</code>, 在后面的条款中我们会明白, <code>private继承</code>意味着<code>has-a(有一个)</code>的关系, 就是说, 派生类有着基类的部分性质, 而不等于基类, 符合此处<code>HomeForSale</code>和<code>Uncopyable</code>的关系.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住:"></a>请记住:</h3><ul><li>编译器会默认为class创建<code>default构造函数</code>, <code>析构函数</code>, <code>copy构造函数</code>, <code>赋值操作符重载</code>.</li><li>拒绝编译器自动生成的函数, 可以将其写在将该函数写入private中, 并且故意不实现它, 或者直接加上<code>= delete</code></li><li>可以写一些通用类如<code>Uncopyable</code>, 将功能和实现解耦.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款4 初始化</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="headerlink" title="条款04 确定对象被使用前已先被初始化"></a>条款04 确定对象被使用前已先被初始化</h2><blockquote><p>本条讨论如何安全高效地实现初始化, 当然也有一些条件奇葩的初始化值得我们去讨论</p></blockquote><h3 id="普通变量初始化"><a href="#普通变量初始化" class="headerlink" title="普通变量初始化"></a>普通变量初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>cont <span class="hljs-type">char</span> text[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>cin &gt;&gt; d;    <span class="hljs-comment">// 这种也叫初始化</span><br></code></pre></td></tr></table></figure><h3 id="类内变量初始化"><a href="#类内变量初始化" class="headerlink" title="类内变量初始化"></a>类内变量初始化</h3><p>类内变量的初始化一般就是三种, <code>类内设置初始值</code>, <code>缺省值</code> , <code>初始值列表</code>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name = <span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age = <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-type">const</span> string&amp; sex = <span class="hljs-string">&quot;女&quot;</span>) <span class="hljs-comment">// 设置缺省值 (次之)</span><br>    :_name(name.<span class="hljs-built_in">c_str</span>())<br>        ,_age(age)<br>        ,_sex(sex.<span class="hljs-built_in">c_str</span>())<span class="hljs-comment">// 初始化列表 (优先)</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span> : <br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>    <span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">char</span> _sex[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;男&quot;</span>;  <span class="hljs-comment">// 类内设置初始值 (最次)</span><br>&#125;<br><br>Stu s1;  <span class="hljs-comment">// 小红 17 女</span><br><span class="hljs-function">Stu <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;男&quot;</span>)</span></span>;    <span class="hljs-comment">// 张三 35 男 </span><br></code></pre></td></tr></table></figure><p>这里虽然看起来三种方式都可以, 但是只推荐全部使用初始值列表, 当有特别想要设置的默认值时设置缺省值.</p><h3 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3><h4 id="优势描述"><a href="#优势描述" class="headerlink" title="优势描述 :"></a>优势描述 :</h4><p>为了描述初始值列表的优势, 请先阅读以下另一版本的构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age, <span class="hljs-type">const</span> string&amp; sex)<br>&#123;<br>_name = name.<span class="hljs-built_in">c_str</span>();<br>    _age = age;<br>    _sex = sex.<span class="hljs-built_in">c_str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这样子写构造函数其实和我们写初始值列表的最终结果是一样的, 而且相对直观.</p><p><strong>但是</strong>, 该版本在底层每个变量其实是先进行了一次default的构造, 再进行了一次copy操作, 其本质是<code>初始化 + 赋值</code>.</p><p>而<code>初始值列表</code>在底层只进行了一次copy构造, 比前者高效得多, 本质就是<code>初始化</code>.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项 :"></a>注意事项 :</h4><ul><li>最好在初始值列表中初始化所有的成员变量, 这样起码不会忘记没有初始化的变量.</li><li>C++中成员变量的初始化顺序是按照类中声明的次序, 而非初始值列表中的顺序! (如果有继承关系, 基类一定早于派生类初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : _b(b), _a(a) <span class="hljs-comment">// 尽管在初始化列表中是_b在前, 但是依旧是先初始化_a</span><br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a; <span class="hljs-comment">// _a 在 _b 之前声明</span><br>    <span class="hljs-type">int</span> _b; <span class="hljs-comment">// _b 在 _a 之后声明</span><br>&#125;;<br><span class="hljs-comment">// ----------------------------------------------------------//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Purple</span>&#123; <span class="hljs-comment">// 紫色需要类型为红色和蓝色的变量</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Purple</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red) ,<span class="hljs-built_in">b</span>(blue)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;<br>    Blue b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-comment">// Color类存储三种颜色, 并且可以用红蓝配出紫</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Color</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red)<br>        :<span class="hljs-built_in">b</span>(blue)<br>        :<span class="hljs-built_in">purper</span>(r, b)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;           <span class="hljs-comment">//purple p;</span><br>    Blue b; <span class="hljs-comment">//Red r;</span><br>    Purple p; <span class="hljs-comment">//Blue b; 假如是注释中的情况, 将无法编译通过, 因为p需要r,b都初始化完才能初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同编译单元内定义non-local-static对象-的初始化次序"><a href="#不同编译单元内定义non-local-static对象-的初始化次序" class="headerlink" title="[ 不同编译单元内定义non-local static对象 ] 的初始化次序"></a>[ 不同编译单元内定义non-local static对象 ] 的初始化次序</h3><p>初看第一眼根本就不知道是什么东西(再看也不知道), 所以先介绍一下定义:</p><ul><li><p>编译单元 : 可以简单理解为一个单独的<code>.cpp</code>文件或<code>.h</code>文件等, 就是有一定的隔离性.</p></li><li><p><code>local static</code>(局部静态变量) : 生命周期为整个程序, <strong>在局部第一次调用时初始化</strong>, 之后都是用这个.</p></li><li><p><code>non-local static</code>(全局静态变量) : 生命周期也为整个程序, <strong>程序启动时初始化</strong>, 之后都是用这个.(例如全局变量)</p></li></ul><p><code>local static</code>和<code>non-local static</code>的区别简单来看就在于初始化的时机.</p><hr><p>再举一个例子, 如果我在<code>a.h</code>中定义了<code>class A</code>, 在<code>b.h</code>中定义了<code>class B</code>, 又在<code>c.cpp</code>中要求使用类型为A和类型为B的<code>non-local static</code>变量, 那么这两个变量的初始化次序是怎样的?</p><p>答案是<strong>无法判断</strong>, 你看上面的定义, <code>non-local static</code>对象都是在程序启动时初始化, C++根本没有手段判断应该先初始化哪个,所以这就是没有定义的行为!</p><hr><p>说了这么多, 那这样会带来什么隐患呢? </p><p>如果两个编译单元中的类有依赖关系的话, 初始化次序的不确定性就会导致问题!</p><p>假如说B类static变量中使用到了A类static变量的话, 如果在<code>c.cpp</code>中先初始化了B类static变量, 可是A类static变量还没初始化, 那么就只有报错一条路了. </p><hr><p>可能看到这里有人不太理解这种情况有什么应用场景, 那么我在这里引入一个定义 :</p><ul><li>内置型对象 : 这个对象本身并没有太大意义, 目的是为了引出类中的各种功能性函数, 一般是non-local static的.</li></ul><p><strong>进一步解释</strong> : 有些类中会有许多应用实际场景的方法函数, 如果需要使用这些函数, 就需要客户构造一个类对象,再用这个对象使用函数, 那么我们就干脆在类的头文件中声明一个类对象, 要求使用这个头文件的客户必须记得生成一个对应对象, 而这个对象一般是non-local static的. </p><p>假如有一个钟表类, 内部需要用到一个计时器的类, 于是使用了计时器类的内置对象, 当用户创建一个non-local static类型的钟表类对象时, 你无法确定计时器类的内置对象和钟表类对象哪个先初始化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    ....<br>&#125;;<br><span class="hljs-keyword">extern</span> TimeKeeper tk;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(tk.<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里用tk获取当前时间来初始化time</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <span class="hljs-comment">// 如果用户设置一个全局变量的Clock类对象clock, 此时无法确定clock和tk的初始化次序!</span><br>...<br></code></pre></td></tr></table></figure><h4 id="解决方法-以local-static对象替换non-local-static对象"><a href="#解决方法-以local-static对象替换non-local-static对象" class="headerlink" title="解决方法 : 以local static对象替换non-local static对象"></a>解决方法 : 以local static对象替换non-local static对象</h4><p>这个解决方法用到了设计模式中最经典的<code>单例模式</code>的设计思想 : 延迟初始化.</p><p>思路简单来说就是, 既然给出一个non-local static对象有风险的话, 我就不给这个non-local static对象了, 我直接使用一个函数, 当客户有使用内置型对象相应需求的时候, 当真正客户调用这个函数时, 才会使用函数内部的代码自己生成一个local static对象供自己使用, 这样初始化次序就有了保障.</p><p>更通俗易懂地描述一下, 就是虽然不好直接使用内置型对象, 但是可以把函数返回值当成内置型对象来使用,  因为在函数内生成的对象时是local static对象, 没有初始化次序的问题.</p><p>看一看接下来的代码吧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>        <span class="hljs-keyword">return</span> timekeeper;<br>    &#125;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(<span class="hljs-built_in">tk</span>().<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里只是简单地将tk换成了tk(), 从调用对象改为调用函数而已</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <br><span class="hljs-comment">// 设置一个全局变量的Clock类对象clock, 此时一定是clock开始初始化, 当初始化时调用到tk()再进行timekeeper的初始化</span><br>...<br></code></pre></td></tr></table></figure><h4 id="多线程情况下的安全性"><a href="#多线程情况下的安全性" class="headerlink" title="多线程情况下的安全性 :"></a>多线程情况下的安全性 :</h4><p>书中指明, <code>内涵static对象</code>在多线程情况下会带有线程安全的问题, 等待某事发生都会有麻烦.</p><p>如果同时调用tk(), 没办法保证只有一个timekeeper生成, 除非用锁, 但那样花销太大得不偿失.</p><p>所以我们可以在线程的单线程启动阶段<code>手工调用</code>所有的初始化函数(例如tk()), 这样在多线程来临前就可以确保初始化完毕.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>对内置型对象进行手工初始化, C++本身并不会保证正确初始化他们.</li><li>最好使用初始化列表, 并且排序要和类内的声明顺序一致.</li><li>如果有跨编译单元的初始化次序问题, 请以local static对象替换non-local static对象.</li></ul><p>刚开始写博客, 如有错误感谢指正!</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款3 const</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 : 尽可能使用const"></a>条款03 : 尽可能使用const</h2><blockquote><p><code>const</code>(不可被改动), 是一种非常有效且多样的语义约束, 有了这项约束, 我们可以借用编译器之手规范我们的代码, 以免带来意想不到的错误, 毕竟任何的改动都会伴随着一定的风险, 如果可以提前规避, 我们何乐而不为呢? </p></blockquote><p><code>const</code>在实际表现上是多才多艺的, 他可以修饰对象, 对象指针, 甚至成员函数, 接下来逐一介绍 :</p><h3 id="const-修饰变量"><a href="#const-修饰变量" class="headerlink" title="const 修饰变量"></a>const 修饰变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>; <span class="hljs-comment">// 这样子定义的N又被称为常变量, 其实也就是常量了(因为不可被改动)</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 众所周知, arr数组名是一个指针</span><br><span class="hljs-type">char</span>* a = arr;<span class="hljs-comment">// a指针可修改, 指针指向的内容可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = arr;<span class="hljs-comment">// b指针不可修改, 指针指向的内容可修改</span><br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> c = arr;<span class="hljs-comment">// c指针可修改, 指针指向的内容不可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> d = arr;<span class="hljs-comment">// d指针不可修改, 指针指向的内容不可修改</span><br></code></pre></td></tr></table></figure><p>谈到指针就不可避免的就会想到<code> 迭代器</code>, 毕竟<code>迭代器</code>就是指针的封装嘛.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//看看下面两种迭代器的定义, 就可以对应上面指针的情况</span><br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-comment">// 迭代器本身是const的, 也就是说本身不可修改, 相当于指针在*前加const</span><br><span class="hljs-comment">// 此时无法进行 ++iter 等操作</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citer = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 语言自带的const_iterator本身就是为了对迭代器指向的内容设置只读, 本身可以进行运算操作, 相当于在*后加const </span><br></code></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><blockquote><p>先明确<code>const</code>成员函数的意义 : 告知编译器这个函数内部的对象不应被改动.</p><p>不是说明函数本身不可改动!!!</p></blockquote><ul><li>那么对成员函数声明<code>const</code>的意义何在?</li></ul><ol><li><strong>使这个函数接口更容易被理解</strong>, 一个函数是否可以改变类内变量的具体数值会很大程度上影响我们对这个函数的定位判断.</li><li><strong>使操作<code>const</code>对象成为可能</strong>, 首先我们要明晰<code>const</code>对象是什么, 就是类定义出的<code>const</code>对象(例如 const Stu stu(小明, 18);), 当我们声明一个类对象为<code>const</code>时, 这个对象对象只能调用<code>const</code>成员函数, 调用的任何<code>non-const</code>成员函数都无法通过编译的, 因此如果你所设计的类有需求<code>const</code>的情景时, 请设计<code>const</code>成员函数.</li></ol><hr><ul><li>这里书中给出了一个事实 : <strong>两个成员函数如果只是常量性不同(const &#x2F; non-const), 也可以被重载.</strong></li></ul><p>​这其实就告诉我们如果想要适配<code>const</code>版本的话, <strong>non-const版本和const版本各写一个就好了</strong>, 编译器会根据对象是否为<code>const</code>来选择使用哪个函数, 样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <span class="hljs-comment">// 1</span><br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <span class="hljs-comment">// 2</span><br> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;<br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数2</span><br>cout &lt;&lt; ctb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数1</span><br></code></pre></td></tr></table></figure><hr><ul><li>接下来需要介绍两种对<code> 成员函数为const</code>时应有行为的流派概念:</li></ul><h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const :"></a>bitwise const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, 应当<strong>不改变对象中的任何变量</strong>, 也就是物理上没有1bit被改变.</p><h4 id="logical-const"><a href="#logical-const" class="headerlink" title="logical const :"></a>logical const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, <strong>可以改变对象中的某些变量</strong>, <strong>但是不能对对象的主要逻辑产生影响</strong>, 也就是说对象在逻辑上没有被改变, 改变的部分只是起辅助优化作用, 例如修改日志, 对计算结果进行缓存, 记录当前容器大小等, 这些工作对主逻辑并没有任何影响, 却可以大大提高主逻辑的工作效率.</p><hr><ul><li>那么C++实际上是怎么定义<code>const</code>成员函数的行为的呢?</li></ul><p>​C++在<strong>一般情况下的定义按照<code>bitwise const</code>的规则进行</strong>, 也就是说一个<code>const</code>成员函数无法改变对象中任何变量.</p><p>​但是这其中有一个C++本身不好决断的情况需要了解 :</p><p>​还记得上面代码中定义的[]重载函数吗 ? const char&amp; operator[](const std::size_t position) const </p><p>​假如我把返回值改为char&amp; : char&amp; operator[](const std::size_t position) const</p><p>​那么这样就会产生一个奇怪的情况 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc = &amp;<span class="hljs-built_in">cbt</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 返回的指针没有const</span><br>*pc = <span class="hljs-string">&#x27;j&#x27;</span>;<span class="hljs-comment">// &quot;hello&quot;被变成了&quot;jello&quot;!!!</span><br></code></pre></td></tr></table></figure><p>​通过以上的情况我们可以发现, C++虽然确保在<code>const</code>成员函数内部不会改变任何对象, 但是并不会检查返回对象所指向的内容是否是不可改变的, C++可能认为在函数外的行为是程序员的自由吧, 所以我们应当注意这一点.</p><hr><ul><li>那么问题又来了, 既然<code>logical const</code>也有其道理所在, C++是如何解决的呢?</li></ul><p>​C++引入了一个与<code>const</code>相关的摆动场 : <strong>mutable(可变的).</strong></p><p>​<code>mutable</code> 的主要用途是在 <code>const</code> 成员函数中允许对特定成员变量的修改, 这样<code>logical const</code>的诉求就可以满足了。</p><p>​请阅读以下代码 : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">text</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br>        <br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">updateLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!lengthIsValid)<br>&#123;<br><span class="hljs-comment">// 以下两句就是因为mutable得以通过</span><br>length = pText.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 重新更新text的长度</span><br>lengthIsValid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 定义当前length可用</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>string pText;<br><br><span class="hljs-comment">// mutable 关键字可以使某个成员变量在const成员函数被修改</span><br><span class="hljs-comment">// 作用是在不改变内部变量的基础逻辑的情况下, 可以引入少量变量可以被改变, 丰富逻辑</span><br><span class="hljs-comment">// 保证函数的安全, 使用mutable意味着在const成员函数中只能改变mutable变量, 其他变量不会被改变</span><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>​以上代码将<code>lenth</code>和<code>lengthIsValid</code>赋予<code>mutable</code>特性, 使其在<code>const</code>成员函数中可以改变, 从而可以用非常小的代价更新<code>text</code>的长度, 方便其他需要使用text长度的函数, 这两个变量均对<code>text</code>存储字符串的主逻辑没有影响.</p><hr><p>​最后还有一个比较有价值的观点 : 我们知道要适配<code>const</code>版本需要写两个类似的函数, 一个处理<code>const</code>对象, 一个处理<code>non-const</code>对象, 但是我们也应当发现这两个函数其实非常相似, 那么这就带来了一些问题:</p><ol><li><strong>代码重复</strong>, 这会带来阅读性降低, 维护成本提高的负面作用.</li><li>我们在以后的条款学习中会知道, 编译器一般会把成员函数替换为<code>inline</code>函数, 这在一般情况下肯定是更高效的, 但是<code>inline</code>函数中的代码越多, 会带来一系列如代码膨胀之类的问题, 这点我们应当避免.</li></ol><ul><li>书中提出了这样的解决方案 : <strong>令<code>non-const</code>版本调用<code>const</code>版本</strong>.</li></ul><p>​这样子做的前提是两个版本的内容一定相等, 或者说<code>non-const</code>版本不能修改对象内的变量, 毕竟如果修改了那和<code>const</code>版本就一定不一样了, 我们来改写上面[]重载的两个版本.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br>&#123; <br>    <span class="hljs-comment">//我们假定[]重载在返回下标引用之前还要做许多工作, 代码量巨大</span><br>    <span class="hljs-comment">// ...边界检验</span><br>    <span class="hljs-comment">// ...将数据访问的行为加入日志</span><br>    <span class="hljs-comment">// ...检验指向内容数据的完整性</span><br>    <span class="hljs-keyword">return</span> text[position]; <br>&#125;<br><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br>&#123; <br>    <span class="hljs-comment">// 这段代码实现了两次类型转换, 目的是调用const版本的operator[]函数并返回non-const的char&amp;</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> text&amp;&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>    <span class="hljs-comment">/* 我们把这段代码拆分开来解读</span><br><span class="hljs-comment">    return const_cast&lt;char&amp;&gt;(    // 3. 将[]返回结果由const版本通过const_cast转换为non-const版本</span><br><span class="hljs-comment">        static_cast&lt;const text&amp;&gt;(*this)  // 1. 先将this指针通过static_cast转换为const text&amp;</span><br><span class="hljs-comment">        [pos] // 2. const text&amp;类型调用[]重载, 自然使用的是const版本的[]重载</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​经过以上的操作, 无论<code>const</code>版本需要多少行代码, <code>non-const</code>版本都只需要一行代码即可, 相当实用.</p><p>​另外如果在<code>non-const</code>版本虽然和<code>const</code>版本十分相似, 但是还是想要修改一部分的数据, 也可以在调用完重载版本后不返回, 再进行一些修改操作再返回.</p><ul><li>小问题 : 为什么不用<code>const</code>版本调用<code>non-const</code>版本?  因为<code>non-const</code>版本不会限制修改行为, 无法监督<code>const</code>实现.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h2><ul><li>将某些东西声明为<code>const</code>可以帮助编译器检查出错误语法, <code>const</code>可被施加于任何对象, 函数参数, 函数返回值, 成员函数</li><li>C++在<code>const</code>成员函数定义上默认支持<code>bitwise const</code>流派, 但是也通过关键字<code>mutable</code>变相支持了<code>logical const</code>流派</li><li>当<code>non-const</code>版本和<code>const</code>版本等价实质时, 可以用<code>non-const</code>版本调用<code>const</code>版本</li></ul><p>作者 : 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款1-2</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/</url>
    
    <content type="html"><![CDATA[<h3 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01 : 视C++为一个语言联邦"></a>条款01 : 视C++为一个语言联邦</h3><blockquote><p>不像Java对各种资源都进行了整合内聚, C++更像是由四种次语言组合而成的语言联邦, 每种次语言都有自己的规约, 也都有不同的用武之地, 每个都可以给C++这门语言带来独特的优势.</p><ul><li><h4 id="C-C-的基础-包含指针-内置数据类型等基础思想"><a href="#C-C-的基础-包含指针-内置数据类型等基础思想" class="headerlink" title="C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想."></a>C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想.</h4></li></ul></blockquote><ul><li><h4 id="Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态"><a href="#Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态" class="headerlink" title="Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态."></a>Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态.</h4></li><li><h4 id="Template-C-泛型编程"><a href="#Template-C-泛型编程" class="headerlink" title="Template C++  :  泛型编程."></a>Template C++  :  泛型编程.</h4></li><li><h4 id="STL-一套template的程序库-包含各种数据结构与算法"><a href="#STL-一套template的程序库-包含各种数据结构与算法" class="headerlink" title="STL  :  一套template的程序库, 包含各种数据结构与算法."></a>STL  :  一套template的程序库, 包含各种数据结构与算法.</h4><p>  这四个方向我们都应熟识掌握, 但是可以给自己这样一个印象 : C++并不是一个一体的语言, 编程时的思想规范应当随你使用C++的对应部分而改变.</p></li></ul><hr><h3 id="条款02-尽量以cnost-enum-inline-替换-define"><a href="#条款02-尽量以cnost-enum-inline-替换-define" class="headerlink" title="条款02 : 尽量以cnost, enum, inline 替换 #define"></a>条款02 : 尽量以cnost, enum, inline 替换 #define</h3><blockquote><p>由 ‘#’ 引出的语句一般与C的预处理机制相关, 我们很需要预处理机制中的 #include 和 #ifdef, 前者保证库的引入, 后者可以针对不同的环境进行条件编译, 而 #define 却在语言的发展下显得有些与时代脱节了, 现在我们应当有心减少 #define 的使用.</p></blockquote><p>以下列举 #define 所带来的一些问题:</p><ol><li>书写代码时很难自动显示错误</li><li>编译错误时显示的信息并不直观</li><li>#define并不重视作用域, 面向全局生效, 这与我们应当坚持的封装思想相悖</li></ol><p>简而言之, 就是#define可能带来一些不可预料的行为并且无法保证类型安全, 而如今我们由足够多的方法可以安全有效地替代#define的功能, 比如const和enum可以替代#define在常量定义上功能, inline又可以替代#define在宏函数上的功能.</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100 <span class="hljs-comment">// 这个步骤在预处理阶段实现</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-comment">// 这个步骤在编译阶段实现</span><br></code></pre></td></tr></table></figure><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里我们想定义三元色的对应数值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED = 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN = 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE = 3</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED = <span class="hljs-number">1</span>, <br>    GREEN = <span class="hljs-number">2</span>,<br>    BLUE = <span class="hljs-number">3</span><br>&#125;<span class="hljs-comment">// 使用enum枚举类型在增强代码的可读性的同时也提升了可维护性</span><br><br><span class="hljs-comment">//-----------------------------------------------------//</span><br><span class="hljs-keyword">enum</span> Action&#123;<br>    RUN = <span class="hljs-number">0x0001</span>,    <span class="hljs-comment">// 第一位</span><br>    JUMP = <span class="hljs-number">0x0002</span>, <span class="hljs-comment">// 第二位</span><br>    SAY = <span class="hljs-number">0x0004</span>, <span class="hljs-comment">// 第三位</span><br>    SLEEP = <span class="hljs-number">0x0008</span> <span class="hljs-comment">// 第四位</span><br>&#125;<span class="hljs-comment">// 使用enum还可以实现比特级别的状态判断</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">CheckAction</span>(<span class="hljs-type">int</span> action);   <span class="hljs-comment">// 假设我们有这样一个检查运动状态的函数, 那么我们就可以只接受一个int就可以判断复数的状态</span><br><span class="hljs-built_in">CheckAction</span>(RUN | JUMP | SAY);<span class="hljs-comment">// 这里的状态就 跑 + 跳 + 说话</span><br></code></pre></td></tr></table></figure><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入我们想实现的MAX(a, b), 我们可以通过以下实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b)  (a) &gt; (b) ? (a) : (b)</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MAX</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用模板 + inline就可以完全代替宏函数的作用, 首先inline的书写模式更加自然, 另外还保证了类型安全, 规避了#define的危险性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法细节复习(2)</title>
    <link href="/2024/05/06/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(2)/"/>
    <url>/2024/05/06/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>其本质是利用栈上对象出作用域自动析构的特性自动释放堆上的内存.</p><h3 id="weak-ptr-shared-ptr"><a href="#weak-ptr-shared-ptr" class="headerlink" title="weak_ptr &#x2F; shared_ptr"></a>weak_ptr &#x2F; shared_ptr</h3><ul><li><p>weak_ptr : 弱智能指针, 观察者, 不影响引用计数, 作用在于观察一个指针, 并在关键时刻可以通过提升得到使用权.</p></li><li><p>shared_ptr : 强智能指针, 拥有者, 影响引用计数, 确实拥有并可以使用指针.</p></li><li><p>weak_ptr.lock() : 检测观察对象的引用计数, 不为0则将弱智能指针提升为强智能指针, 可以检测指针指向的资源是否还存在.</p></li><li><p>可以很好地接近多线程环境下共享对象的线程安全问题, 主线程掌握shared_ptr, 调用其他线程时将shared_ptr强转成weak_ptr, 也就是说其他线程中都是观测者, 在想要使用时调用lock, 看是否还存在, 存在就提升为shared_ptr.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> w) :<span class="hljs-built_in">x</span>(w) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发testA, x : &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(weak_ptr&lt;A&gt; pw)</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;A&gt; sp = pw.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(sp != <span class="hljs-literal">nullptr</span>) sp-&gt;<span class="hljs-built_in">testA</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;A对象已析构, 不能再访问&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(handler, weak_ptr(p))</span></span>;<br>        t<span class="hljs-number">1.</span><span class="hljs-built_in">detach</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>unique_ptr : 无引用计数, 拥有并独占一个指针.</li><li>拷贝只支持移动拷贝构造, 会转移独占权.</li></ul><h3 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">10</span>))</span></span>;<span class="hljs-comment">// 1</span><br><span class="hljs-keyword">auto</span> sp2 = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-number">10</span>);<span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>普通的shared_ptr构造存在缺陷 : </p><ul><li>shared_ptr存在两部分资源, 一部分是所管理对象new出来的资源, 一部分是存放引用计数new出来的资源, 由于两部分都有可能出错, 如果出现部分成功部分失败就有内存泄漏的风险.</li></ul><p>make_shared可以做到以下改进 : </p><ul><li>将管理对象和引用计数对象包装进一个对象, 只new这个对象, 可以保证全失败或全成功. 以此提高内存分配效率并且防止内存泄露风险.</li></ul><p>make_shared缺点 : </p><ul><li>无法自定义删除器.</li><li>托管的内存会延迟释放, 因为如果有弱智能指针会等到弱指针移除才全部析构.</li></ul><h3 id="deletor-自定义"><a href="#deletor-自定义" class="headerlink" title="deletor(自定义)"></a>deletor(自定义)</h3><p>unique_ptr和shared_ptr等智能指针在要销毁内存时, 其析构函数其实是在调用默认的deletor, 类似如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">unique_ptr</span>() &#123; <span class="hljs-built_in">deletor</span>(ptr); &#125;<br></code></pre></td></tr></table></figure><p>而这个默认的deletor就重载了(), 其默认操作的就<strong>对ptr执行普通的delete</strong>.</p><p>自定义deletor的必要性在于, 有很多资源的释放方式并不是普通的delete, 那么这个这种默认方式就不可以用在这些资源上, 比如数组资源就要 <code>delete []</code>, 文件资源就要fclose, socket要close等.</p><p>因此我们可以通过写一个自定义deletor, 重载(), 就可以实现特殊资源的特殊释放.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDeletor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;MyDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> []ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileDeletor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;MyFileDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;<br>&#125;;<br><br>unique_ptr&lt;<span class="hljs-type">int</span>, MyDeletor&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>]);<br>unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然上面是旧做法, 现在我们可以通过function + lambda快捷实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里使用的是第二种构造函数 unique_ptr(T* ptr, Deleter d); </span><br><span class="hljs-comment">// 这个Deleter要和前面第二个模板参数匹配, 这样就可以推导出lambda表达式的类型.</span><br>unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], <br>[](<span class="hljs-type">int</span>* ptr)-&gt;<span class="hljs-type">void</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;lambda MyDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span>[] ptr;<br>    &#125;);<br><br>unique_ptr&lt;FILE*, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <br>[](FILE* ptr)-&gt;<span class="hljs-type">void</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;lambda MyFileDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;);<br></code></pre></td></tr></table></figure><p>还可以通过decltype + lambda实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span>* ptr)&#123; <span class="hljs-keyword">delete</span>[] ptr; &#125;;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(lambda)</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], lambda)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><h3 id="function-绑定器"><a href="#function-绑定器" class="headerlink" title="function(绑定器)"></a>function(绑定器)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 模板 + 可变参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(Args...)&gt; <span class="hljs-comment">// 函数类型实例化类模板</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(Args...);<br>    <span class="hljs-built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc)&#123;&#125;<br>    <br>    <span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Args... arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> _pfunc(arg...);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    PFUNC _pfunc;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>绑定成员函数必须依赖于一个对象 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fuction&lt;<span class="hljs-built_in">void</span>(Test*, string)&gt; func = &amp;Test::hello;<br>    <span class="hljs-built_in">func</span>(&amp;<span class="hljs-built_in">Test</span>(), <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p><code>[捕获外部变量](形参列表)-&gt;返回值&#123;代码&#125;</code></p><ul><li>[&#x3D;] 以传值方式捕获外部所有变量.</li><li>[&amp;] 以传引用方式捕获外部所有变量.</li><li>[&#x3D;, &amp;a] 除a传引用, 其他变量都传值.</li><li>[a, &amp;b] a传值, b传引用.</li><li>[this] 捕获this指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找第一个小于65的值</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a)&#123;<br>    <span class="hljs-keyword">return</span> a &lt; <span class="hljs-number">65</span>;<br>&#125;);<br><span class="hljs-keyword">if</span>(it != v.<span class="hljs-built_in">end</span>()) cout &lt;&lt; <span class="hljs-string">&quot;find less than 65&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 输出所有奇数</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a)&#123;<br>    <span class="hljs-keyword">if</span>(a &amp; <span class="hljs-number">1</span>) cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;); <br></code></pre></td></tr></table></figure><ul><li><p>可以用fuction类型表示lambda表达式类型.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; cal;<br>cal[<span class="hljs-number">1</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cal[<span class="hljs-number">2</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a - b; &#125;;<br></code></pre></td></tr></table></figure></li><li><p>优先级队列自定义比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2) :<span class="hljs-built_in">a</span>(v1) ,<span class="hljs-built_in">b</span>(v2) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a, b;<br>&#125;;<br><br><span class="hljs-keyword">using</span> FUNC = function&lt;<span class="hljs-built_in">bool</span>(Data&amp;, Data&amp;)&gt;;<br>priority_queue&lt;Data, vector&lt;data&gt;, FUNC&gt; <span class="hljs-built_in">Heap</span>([](Data&amp; d1, Data&amp;d2)&#123;<br>    <span class="hljs-keyword">return</span> d<span class="hljs-number">1.</span>ma &gt; d<span class="hljs-number">2.</span>ma;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shared_ptr</tag>
      
      <tag>functional</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
