<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows API 学习笔记(4) IOCP</title>
    <link href="/2025/09/09/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%20IOCP/"/>
    <url>/2025/09/09/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(4)%20IOCP/</url>
    
    <content type="html"><![CDATA[<blockquote><p>IOCP高性能网络编程</p></blockquote><h3 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h3><p><strong>IOCP(IO Completion Port), IO完成端口</strong>, 是可以将<strong>网络数据收发异步化</strong>的技术.</p><p>如果学过Linux的io_uring, 他们的内核思想很相近, 区别在于IOCP<strong>专注于网络编程和异步</strong>, 而io_uring更加全面, 可以处理并优化各种事务. </p><h3 id="内核理解"><a href="#内核理解" class="headerlink" title="内核理解"></a>内核理解</h3><ul><li>首先想要使用IOCP, 需要通过<code>CreateIoCompletionPort</code>构造IOCP句柄.</li><li>构造句柄的同时, 内部会维护两个队列(任务队列和完成队列)和一个内核区域, 收发任务会将任务投递到任务队列中, 内核从任务队列中取出任务并执行.</li><li>等实际的接收或发送完毕后, 内核会把其推到完成队列中, 我们会开辟多个线程调用<code>GetQueuedCompletionStatus</code>阻塞等待, 从完成队列中取出结果, 并根据结果执行对应的操作.</li><li>这里做到的是真异步, 并且这种异步十分高效, 可以有效提高并发量. (主要体现在于没有多余的阻塞, 建立连接&#x2F;收发数据都在内核中, 可以马上收马上做).</li></ul><blockquote><p>内核思想比较容易理解, 但是实际还有许多复杂的细节, 下面将会介绍一个重要概念和常用API.</p></blockquote><h3 id="重叠I-O"><a href="#重叠I-O" class="headerlink" title="重叠I&#x2F;O"></a>重叠I&#x2F;O</h3><p>IOCP编程中一定会看到<code>WSAOVERLAPPED</code>这个类型, 通常被叫做重叠I&#x2F;O, 这是一个看起来很唬人的概念, 但简单理解你可以认为这就是一个<strong>标识符</strong>, 用于表示<strong>我要使用异步IO, 所有IO操作都在内核执行</strong>, 因此想要使用IOCP, 就<strong>必须为所有收发函数传入该标识符</strong>.</p><p>另外你可以认为其有着一定<strong>存储上下文</strong>的能力, 因此<strong>每次使用都要清空内部</strong>, 便于内核使用.</p><p>至此使用方式就非常明朗了, 就是有使用收发函数时传入一个已经清空的<code>WSAOVERLAPPED</code>对象.</p><h3 id="CreateIoCompletionPort"><a href="#CreateIoCompletionPort" class="headerlink" title="CreateIoCompletionPort"></a>CreateIoCompletionPort</h3><p>创建 IOCP句柄 或将文件&#x2F;套接字句柄关联到现有 IOCP句柄.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateIoCompletionPort</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE FileHandle,           <span class="hljs-comment">// 文件句柄或 socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE ExistingCompletionPort, <span class="hljs-comment">// 已存在的 IOCP，如果为 NULL 则创建新端口</span></span></span><br><span class="hljs-params"><span class="hljs-function">    ULONG_PTR CompletionKey,     <span class="hljs-comment">// 与句柄关联的用户数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD NumberOfConcurrentThreads <span class="hljs-comment">// 线程并发数，0 表示系统决定</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>第二个参数传入IOPC句柄 : <ul><li>如果为nullptr, 那么表示要创建新的端口, 会返回新的IOPC句柄, 并且和第一个参数关联.</li><li>如果为IOPC句柄, 表示将对应文件或socket关联到该句柄上.</li></ul></li></ul><h3 id="GetQueuedCompletionStatus"><a href="#GetQueuedCompletionStatus" class="headerlink" title="GetQueuedCompletionStatus"></a>GetQueuedCompletionStatus</h3><p>获取任务结果的线程用于<strong>阻塞等待 IOCP 完成事件</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetQueuedCompletionStatus</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE CompletionPort,<span class="hljs-comment">// IOPC句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD lpNumberOfBytesTransferred,<span class="hljs-comment">// 完成的 I/O 字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">    PULONG_PTR lpCompletionKey,<span class="hljs-comment">// CreateIoCompletionPort中传入的key</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPOVERLAPPED *lpOverlapped,<span class="hljs-comment">// 重叠 I/O 对象</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwMilliseconds<span class="hljs-comment">// 超时, INFINITE表示永久阻塞</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="WSASend"><a href="#WSASend" class="headerlink" title="WSASend"></a>WSASend</h3><p>Windows的send. (WSA是Windows Socket API的缩写)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WSASend</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    SOCKET s,<span class="hljs-comment">// socket</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSABUF lpBuffers,<span class="hljs-comment">// 发送缓冲区, 可以存在多个, 类比writev</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwBufferCount,<span class="hljs-comment">// 缓冲区个数</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD lpNumberOfBytesSent,<span class="hljs-comment">// 输出实际发送了多少字节</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSAOVERLAPPED lpOverlapped,<span class="hljs-comment">// 重叠 I/O 对象</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>和send使用类似, 但是想使用IOCP需要注意以下亮点 : </p><ul><li>socket必须已经通过<code>CreateIoCompletionPort</code>和IOCP句柄发生关联.</li><li>必须传入重叠 I&#x2F;O 对象.</li></ul><p>下面的recv同理.</p><h3 id="WSARecv"><a href="#WSARecv" class="headerlink" title="WSARecv"></a>WSARecv</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">WSARecv</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    SOCKET s,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSABUF lpBuffers,</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwBufferCount,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD lpNumberOfBytesRecvd,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD lpFlags,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSAOVERLAPPED lpOverlapped,</span></span><br><span class="hljs-params"><span class="hljs-function">    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="AcceptEx"><a href="#AcceptEx" class="headerlink" title="AcceptEx"></a>AcceptEx</h3><p>accept的异步版本, 可以配合IOPC使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">AcceptEx</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    SOCKET sListenSocket,      <span class="hljs-comment">// [in] 监听套接字</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SOCKET sAcceptSocket,      <span class="hljs-comment">// [in] 接受连接的套接字</span></span></span><br><span class="hljs-params"><span class="hljs-function">    PVOID lpOutputBuffer,      <span class="hljs-comment">// [out] 接收缓冲区，AcceptEx 会把客户端和本地地址信息写入其中</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwReceiveDataLength, <span class="hljs-comment">// [in] 预接收数据长度，如果客户端发送了初始数据，会被提前读入缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwLocalAddressLength,<span class="hljs-comment">// [in] 本地地址结构长度，通常 sizeof(sockaddr_in) + 16</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwRemoteAddressLength,<span class="hljs-comment">// [in] 远程地址结构长度，通常 sizeof(sockaddr_in) + 16</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPDWORD lpdwBytesReceived, <span class="hljs-comment">// [out] 实际接收到的字节数（初始数据）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPOVERLAPPED lpOverlapped  <span class="hljs-comment">// [in] OVERLAPPED 结构，用于异步通知 I/O 完成</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br></code></pre></td></tr></table></figure><h3 id="回显服务器"><a href="#回显服务器" class="headerlink" title="回显服务器"></a>回显服务器</h3><p>下面是一个回显服务器, 实现对发送的每个字符进行回显.</p><p>其中几乎所有操作都是异步的, 包括读写和接收新连接.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> WIN32_LEAN_AND_MEAN</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winsock2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mswsock.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;ws2_32.lib&quot;</span>)</span><br><br><span class="hljs-comment">// -------------------- 上下文结构 --------------------</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PER_IO_CONTEXT</span> &#123;<br>    WSAOVERLAPPED overlapped;<br>    WSABUF buf;<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">char</span> acceptBuffer[(<span class="hljs-built_in">sizeof</span>(sockaddr_in) + <span class="hljs-number">16</span>) * <span class="hljs-number">2</span>]; <span class="hljs-comment">// AcceptEx buffer</span><br>    DWORD bytes;<br>    <span class="hljs-type">int</span> operation; <span class="hljs-comment">// 0=RECV, 1=SEND, 2=ACCEPT</span><br>    SOCKET sock;<br>&#125;;<br><br><span class="hljs-comment">// -------------------- 全局变量 --------------------</span><br>LPFN_ACCEPTEX g_lpfnAcceptEx = <span class="hljs-literal">nullptr</span>;<br>SOCKET g_listenSock;<br>HANDLE g_iocp;<br><br><span class="hljs-comment">// -------------------- 投递新的 AcceptEx --------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PostAccept</span><span class="hljs-params">(PER_IO_CONTEXT* ctx)</span> </span>&#123;<br>    <span class="hljs-built_in">ZeroMemory</span>(&amp;ctx-&gt;overlapped, <span class="hljs-built_in">sizeof</span>(ctx-&gt;overlapped));<br>    ctx-&gt;sock = <span class="hljs-built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, WSA_FLAG_OVERLAPPED);<br>    ctx-&gt;operation = <span class="hljs-number">2</span>; <span class="hljs-comment">// ACCEPT</span><br>    ctx-&gt;buf.buf = ctx-&gt;acceptBuffer;<br>    ctx-&gt;buf.len = <span class="hljs-built_in">sizeof</span>(ctx-&gt;acceptBuffer);<br><br>    DWORD bytes = <span class="hljs-number">0</span>;<br>    BOOL ret = <span class="hljs-built_in">g_lpfnAcceptEx</span>(g_listenSock, ctx-&gt;sock, ctx-&gt;buf.buf,<br>        <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sockaddr_in) + <span class="hljs-number">16</span>, <span class="hljs-built_in">sizeof</span>(sockaddr_in) + <span class="hljs-number">16</span>,<br>        &amp;bytes, &amp;ctx-&gt;overlapped);<br>    <span class="hljs-keyword">if</span> (!ret &amp;&amp; <span class="hljs-built_in">WSAGetLastError</span>() != ERROR_IO_PENDING) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] AcceptEx failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-built_in">closesocket</span>(ctx-&gt;sock);<br>        <span class="hljs-keyword">delete</span> ctx;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] AcceptEx posted, socket=&quot;</span> &lt;&lt; ctx-&gt;sock &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// -------------------- IOCP 工作线程 --------------------</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WorkerThread</span><span class="hljs-params">(HANDLE iocp)</span> </span>&#123;<br>    DWORD bytesTransferred;<br>    ULONG_PTR key;<br>    LPOVERLAPPED pol;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        BOOL ok = <span class="hljs-built_in">GetQueuedCompletionStatus</span>(iocp, &amp;bytesTransferred, &amp;key, &amp;pol, INFINITE);<br>        <span class="hljs-keyword">if</span> (!ok) &#123;<br>            <span class="hljs-keyword">if</span> (pol) &#123;<br>                PER_IO_CONTEXT* ctx = (PER_IO_CONTEXT*)pol;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] GetQueuedCompletionStatus error, socket=&quot;</span> &lt;&lt; ctx-&gt;sock<br>                    &lt;&lt; <span class="hljs-string">&quot;, error=&quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-built_in">closesocket</span>(ctx-&gt;sock);<br>                <span class="hljs-keyword">delete</span> ctx;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        PER_IO_CONTEXT* ctx = (PER_IO_CONTEXT*)pol;<br>        <span class="hljs-comment">// 输出调试信息</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] Completion: operation=&quot;</span> &lt;&lt; ctx-&gt;operation<br>            &lt;&lt; <span class="hljs-string">&quot;, bytes=&quot;</span> &lt;&lt; bytesTransferred<br>            &lt;&lt; <span class="hljs-string">&quot;, socket=&quot;</span> &lt;&lt; ctx-&gt;sock &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>        <span class="hljs-keyword">if</span> (ctx-&gt;operation == <span class="hljs-number">2</span>) &#123; <span class="hljs-comment">// ACCEPT 完成</span><br>            SOCKET clientSock = ctx-&gt;sock;<br>            <span class="hljs-comment">// 关联 client 到 IOCP</span><br>            <span class="hljs-built_in">CreateIoCompletionPort</span>((HANDLE)clientSock, g_iocp, (ULONG_PTR)clientSock, <span class="hljs-number">0</span>);<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] Client connected, socket=&quot;</span> &lt;&lt; clientSock &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>            <span class="hljs-comment">// 立即投递 RECV</span><br>            ctx-&gt;operation = <span class="hljs-number">0</span>;<br>            ctx-&gt;buf.buf = ctx-&gt;data;<br>            ctx-&gt;buf.len = <span class="hljs-built_in">sizeof</span>(ctx-&gt;data);<br>            DWORD flags = <span class="hljs-number">0</span>;<br>            ctx-&gt;bytes = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">ZeroMemory</span>(&amp;ctx-&gt;overlapped, <span class="hljs-built_in">sizeof</span>(ctx-&gt;overlapped));<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">WSARecv</span>(clientSock, &amp;ctx-&gt;buf, <span class="hljs-number">1</span>, &amp;ctx-&gt;bytes, &amp;flags, &amp;ctx-&gt;overlapped, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="hljs-built_in">WSAGetLastError</span>() != WSA_IO_PENDING) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] WSARecv failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-built_in">closesocket</span>(clientSock);<br>                <span class="hljs-keyword">delete</span> ctx;<br>            &#125;<br><br>            <span class="hljs-comment">// 投递新的 AcceptEx</span><br>            <span class="hljs-built_in">PostAccept</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PER_IO_CONTEXT</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx-&gt;operation == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// RECV 完成</span><br>            <span class="hljs-keyword">if</span> (bytesTransferred == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 客户端断开</span><br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] Client disconnected, socket=&quot;</span> &lt;&lt; ctx-&gt;sock &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-built_in">closesocket</span>(ctx-&gt;sock);<br>                <span class="hljs-keyword">delete</span> ctx;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] Recv: &quot;</span> &lt;&lt; std::<span class="hljs-built_in">string</span>(ctx-&gt;data, bytesTransferred)<br>                &lt;&lt; <span class="hljs-string">&quot;, socket=&quot;</span> &lt;&lt; ctx-&gt;sock &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br><br>            <span class="hljs-comment">// 投递发送（回显）</span><br>            ctx-&gt;operation = <span class="hljs-number">1</span>;<br>            ctx-&gt;buf.len = bytesTransferred;<br>            DWORD sendBytes = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">ZeroMemory</span>(&amp;ctx-&gt;overlapped, <span class="hljs-built_in">sizeof</span>(ctx-&gt;overlapped));<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">WSASend</span>(ctx-&gt;sock, &amp;ctx-&gt;buf, <span class="hljs-number">1</span>, &amp;sendBytes, <span class="hljs-number">0</span>, &amp;ctx-&gt;overlapped, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="hljs-built_in">WSAGetLastError</span>() != WSA_IO_PENDING) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] WSASend failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-built_in">closesocket</span>(ctx-&gt;sock);<br>                <span class="hljs-keyword">delete</span> ctx;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ctx-&gt;operation == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// SEND 完成</span><br>            <span class="hljs-comment">// 再投递接收</span><br>            ctx-&gt;operation = <span class="hljs-number">0</span>;<br>            ctx-&gt;buf.len = <span class="hljs-built_in">sizeof</span>(ctx-&gt;data);<br>            DWORD flags = <span class="hljs-number">0</span>;<br>            ctx-&gt;bytes = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">ZeroMemory</span>(&amp;ctx-&gt;overlapped, <span class="hljs-built_in">sizeof</span>(ctx-&gt;overlapped));<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">WSARecv</span>(ctx-&gt;sock, &amp;ctx-&gt;buf, <span class="hljs-number">1</span>, &amp;ctx-&gt;bytes, &amp;flags, &amp;ctx-&gt;overlapped, <span class="hljs-literal">NULL</span>);<br>            <span class="hljs-keyword">if</span> (ret == SOCKET_ERROR &amp;&amp; <span class="hljs-built_in">WSAGetLastError</span>() != WSA_IO_PENDING) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] WSARecv failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">WSAGetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                <span class="hljs-built_in">closesocket</span>(ctx-&gt;sock);<br>                <span class="hljs-keyword">delete</span> ctx;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// -------------------- main --------------------</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    WSADATA wsaData;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WSAStartup</span>(<span class="hljs-built_in">MAKEWORD</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), &amp;wsaData) != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] WSAStartup failed\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    g_listenSock = <span class="hljs-built_in">WSASocket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, WSA_FLAG_OVERLAPPED);<br><br>    sockaddr_in addr&#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">8888</span>);<br>    <span class="hljs-built_in">bind</span>(g_listenSock, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-built_in">listen</span>(g_listenSock, SOMAXCONN);<br><br>    <span class="hljs-comment">// 获取 AcceptEx 函数指针</span><br>    DWORD bytes;<br>    GUID guidAcceptEx = WSAID_ACCEPTEX;<br>    <span class="hljs-built_in">WSAIoctl</span>(g_listenSock, SIO_GET_EXTENSION_FUNCTION_POINTER,<br>        &amp;guidAcceptEx, <span class="hljs-built_in">sizeof</span>(guidAcceptEx),<br>        &amp;g_lpfnAcceptEx, <span class="hljs-built_in">sizeof</span>(g_lpfnAcceptEx),<br>        &amp;bytes, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// 关联 listenSock 到 IOCP</span><br>    g_iocp = <span class="hljs-built_in">CreateIoCompletionPort</span>((HANDLE)g_listenSock, <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!g_iocp) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] CreateIoCompletionPort failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 启动工作线程（CPU 核数 * 2）</span><br>    SYSTEM_INFO sysInfo;<br>    <span class="hljs-built_in">GetSystemInfo</span>(&amp;sysInfo);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-type">int</span>)sysInfo.dwNumberOfProcessors * <span class="hljs-number">2</span>; ++i) &#123;<br>        std::<span class="hljs-built_in">thread</span>(WorkerThread, g_iocp).<span class="hljs-built_in">detach</span>();<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[DEBUG] Server running on port 8888...\n&quot;</span>;<br><br>    <span class="hljs-comment">// 预投递若干 AcceptEx</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>        <span class="hljs-built_in">PostAccept</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">PER_IO_CONTEXT</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 主线程阻塞</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br><br>    <span class="hljs-built_in">closesocket</span>(g_listenSock);<br>    <span class="hljs-built_in">WSACleanup</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码如果有统一事件源和异步经验的人读起来可能会更加方便.</p><p>下面说几点不太好理解的地方 : </p><ul><li><p><code>WSAIoctl</code>和<code>g_lpfnAcceptEx</code>的出现主要是因为<code>AcceptEx</code>并不在标准库里, 属于扩展, 这里是用<code>WSAIoctl</code>查找到了扩展库中的函数再匹配对应的<code>g_lpfnAcceptEx</code>以达到<code>AcceptEx</code>的效果.</p><ul><li>其实<code>AcceptEx</code>也并非必须, 完全可以使用accept同步阻塞接收新连接, 然后让收发异步就行. 将accept异步化主要是为例提高<strong>初期并发量</strong>, 让系统可以同时接收非常多的新连接(我这里就是开了5个异步accept, 也就是说同一时间有五个accept任务可被触发完成).</li></ul></li><li><p>我们发现每个任务需要的数据都存在<code>PER_IO_CONTEXT</code>中了, 而任务间数据的传递是依托其顶部的<code>overlapped</code>来的, 具体是通过<code>PER_IO_CONTEXT* ctx = (PER_IO_CONTEXT*)pol;</code><strong>把重叠I&#x2F;O对象指针强转为该结构体指针</strong>来的. </p><p>这是IOCP编程常用的一种数据传递手段, 具体是因为<code>lpOverlapped</code>作为输出参数每个任务都独立存在, 把其放在首位, 正好可以强转出其他的结构体存放每个任务独立需要的数据或缓冲区.</p></li><li><p><code>WorkerThread</code>中执行的代码根据发布任务时存储的任务类型进行选择, 可以有效处理不同类型的事件.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WindowsAPI</tag>
      
      <tag>IOCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows API 学习笔记(2) 线程与内存管理</title>
    <link href="/2025/09/07/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98/"/>
    <url>/2025/09/07/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(2)%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线程与内存管理</p></blockquote><h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><h3 id="CreateThread-OpenThread"><a href="#CreateThread-OpenThread" class="headerlink" title="CreateThread &#x2F; OpenThread"></a>CreateThread &#x2F; OpenThread</h3><p>通过这两个函数获取线程句柄.</p><ul><li>前者可以用C++11的 thread 库代替.</li><li>后者传入对应的线程tid, 返回对应的线程句柄.</li></ul><h3 id="线程句柄的作用"><a href="#线程句柄的作用" class="headerlink" title="线程句柄的作用"></a>线程句柄的作用</h3><ul><li>使用<code>TerminateThread</code>直接终止线程.</li><li>使用<code>WaitForSingleObject</code>等待线程结束.</li><li>使用 <code>SuspendThread/ResumeThread</code>随时挂起和唤醒线程, 一般用来配合分析检测.</li><li>使用<code>GetThreadTimes</code>获取时间, 例如创建时间, CPU占用时间.</li></ul><h3 id="SetThreadAffinityMask"><a href="#SetThreadAffinityMask" class="headerlink" title="SetThreadAffinityMask"></a>SetThreadAffinityMask</h3><p><strong>将某个线程任务绑定到某些CPU核上</strong>, 使得这些CPU优先运行这个任务. </p><p>其作用在于 : </p><ul><li><strong>避免频繁的线程切换</strong>.</li><li>可以有效<strong>缓解缓存失效</strong>, 每个CPU核都有自己的缓存, 会缓存过去运行线程的变量&#x2F;指令, 随意改变线程执行的核会让这些缓存失效.</li></ul><p>使用方法就是传入线程句柄, 传入掩码, 掩码中每有一个1, 任务就会被绑定到其对应的核上.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DWORD_PTR mask = <span class="hljs-number">0x01</span>; <span class="hljs-comment">// 绑定到核心0</span><br><span class="hljs-built_in">SetThreadAffinityMask</span>(hThread, mask);<br></code></pre></td></tr></table></figure><p>适用于<strong>计算密集型&#x2F;低延迟要求</strong>的任务, 比如音视频解码, 金融交易.</p><h3 id="SwitchToThread"><a href="#SwitchToThread" class="headerlink" title="SwitchToThread"></a>SwitchToThread</h3><p>调用该函数, 会使当前线程<strong>主动让出时间片</strong>, 供其他线程使用.</p><ul><li>一些任务如果认为优先级低(就是可以延后执行), 那么可以设置一些节点触发<code>SwitchToThread</code>, 让一些高优先级任务(比如UI界面更新)更有可能拿到时间片.</li></ul><p>自旋锁是让线程自旋一会等待解锁, 可以有效减少线程切换带来的消耗, 用<code>SwitchToThread</code>可以优化其逻辑 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">volatile</span> <span class="hljs-type">bool</span> g_Lock = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpinLockWithYield</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> spinCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">InterlockedCompareExchange</span>(&amp;g_Lock, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>) != <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-comment">// 自旋100次后让出CPU</span><br>        <span class="hljs-keyword">if</span> (++spinCount &gt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-built_in">SwitchToThread</span>(); <span class="hljs-comment">// 减少空转</span><br>            spinCount = <span class="hljs-number">0</span>;<br>        &#125;<br>        _mm_pause(); <span class="hljs-comment">// CPU指令级优化（降低功耗）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原本自选锁会一直在这里自旋, 将持续占用一个CPU核, 我们预计会很快解锁, 但是假如有特殊情况一直拿不到锁, 累计到一定自选次数后, 就可以调用<code>SwitchToThread</code>让出时间片来减少空转.</p><h2 id="内存管理相关"><a href="#内存管理相关" class="headerlink" title="内存管理相关"></a>内存管理相关</h2><p>Windows内存管理也和Linux的那一套非常相似, 进程地址空间 + 分页.</p><h3 id="VirtualAlloc"><a href="#VirtualAlloc" class="headerlink" title="VirtualAlloc"></a>VirtualAlloc</h3><p>这是Windows操作系统底层的内存申请函数, malloc在windows平台底层就会间接调用到该函数. 可以认为是Windows版的mmap.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LPVOID <span class="hljs-title">VirtualAlloc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID lpAddress,       <span class="hljs-comment">// 指定希望分配的虚拟地址（可选）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  SIZE_T dwSize,          <span class="hljs-comment">// 分配大小（按页对齐）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD flAllocationType, <span class="hljs-comment">// 分配类型（提交/保留）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD flProtect         <span class="hljs-comment">// 内存保护属性</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><code>lpAddress</code> : 你可以指定分配的地址, 但是该指针必须页对齐, 不然会失败.</p></li><li><p><code>dwSize</code> : 指定分配大小, 最终结果会按页对齐.</p><ul><li>对齐 : 默认页大小为4KB(4096), 因此在每个页开始处进行访问只需要一次指令, 但是其他地方就要多条指令, 因此<strong>我们希望分配地址是4KB的整数倍</strong>, 也就是所谓的页对齐.</li></ul></li><li><p><code>flAllocationType</code> : 指定分配的类型.</p><ul><li><code>MEM_RESERVE</code> : 保留一段虚拟地址空间, 但先不申请内存, 需要时再COMMIT.</li><li><code>MEM_COMMIT</code> : 提交对于物理地址空间的申请, 会做虚拟到物理的映射.</li><li>RESERVE出来的空间不可被使用, <strong>只是占用使用权</strong>, 要使用时必须COMMIT.</li><li>最常见的做法是填入<code>MEM_RESERVE | MEM_COMMIT</code>, 本质就是申请一块物理空间可以随时使用.</li></ul></li><li><p><code>flProtect</code> : 设置内存保护属性, 防止自己对某些重要内存进行修改.</p></li><li><p>平常大多数情况使用malloc申请内存即可, 只是在<strong>申请大块内存, 有延迟映射需求, 有内存对齐需求, 需要控制内存保护权限</strong>的情况下可以选择使用<code>VirtualAlloc</code>.</p></li><li><p>VirtualFree : 需要配套使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">VirtualFree</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">  SIZE_T dwSize,   <span class="hljs-comment">// 如果 MEM_RELEASE，必须为 0</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD dwFreeType <span class="hljs-comment">// MEM_RELEASE / MEM_DECOMMIT</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="VirtualProtect"><a href="#VirtualProtect" class="headerlink" title="VirtualProtect"></a>VirtualProtect</h3><p>修改已分配内存的保护属性.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">VirtualProtect</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">  SIZE_T dwSize,</span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD flNewProtect,</span></span><br><span class="hljs-params"><span class="hljs-function">  PDWORD lpflOldProtect</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>建议只使用<code>VirtureAlloc</code>出来的句柄设置, 因为其是按页修改保护属性的, <code>malloc</code>出来的并非页对齐.</li><li>默认是<code>PAGE_READWRITE</code>可读写, 可改为<code>PAGE_READONLY</code>只读和<code>PAGE_NOACCESS</code>禁止访问.</li><li>保护熟悉设置一视同仁, 对本进程和其他进程同样有效, 一般是先读写完, 如果想保护数据在后期通过该函数设置只读或禁读.</li></ul><h3 id="VirtualQuery-VirtualQueryEx"><a href="#VirtualQuery-VirtualQueryEx" class="headerlink" title="VirtualQuery &#x2F; VirtualQueryEx"></a>VirtualQuery &#x2F; VirtualQueryEx</h3><p><strong>查询进程虚拟内存状态&#x2F;属性&#x2F;归属的重要函数(可跨进程).</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 当前进程</span><br><span class="hljs-function">SIZE_T <span class="hljs-title">VirtualQuery</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    LPCVOID lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    PMEMORY_BASIC_INFORMATION lpBuffer, <span class="hljs-comment">// 输出内存信息的缓存区</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T dwLength <span class="hljs-comment">// 缓存区结构体的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-comment">// 指定进程</span><br><span class="hljs-function">SIZE_T <span class="hljs-title">VirtualQueryEx</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hProcess, <span class="hljs-comment">// 想要查询内存的进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPCVOID lpAddress,</span></span><br><span class="hljs-params"><span class="hljs-function">    PMEMORY_BASIC_INFORMATION lpBuffer,</span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T dwLength</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>主要用来查询指定内存的状态, 在读写自己或其他内存前使用, 可以有效避免崩溃.</p><p>以下是缓存区的结构 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_MEMORY_BASIC_INFORMATION</span> &#123;<br>  PVOID  BaseAddress;       <span class="hljs-comment">// 内存块的起始地址</span><br>  PVOID  AllocationBase;    <span class="hljs-comment">// 内存块保留时的基地址</span><br>  DWORD  AllocationProtect; <span class="hljs-comment">// 分配时的保护属性</span><br>  SIZE_T RegionSize;        <span class="hljs-comment">// 从 BaseAddress 开始的连续区域大小</span><br>  DWORD  State;             <span class="hljs-comment">// MEM_COMMIT / MEM_RESERVE / MEM_FREE</span><br>  DWORD  Protect;           <span class="hljs-comment">// 当前页的保护属性</span><br>  DWORD  Type;              <span class="hljs-comment">// MEM_PRIVATE / MEM_MAPPED / MEM_IMAGE</span><br>&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;<br></code></pre></td></tr></table></figure><ul><li>一般是读取<code>State</code>和<code>Protect</code>, 地址可以用来读取内存, 但是仅限本进程, 跨进程需要<code>ReadProcessMemory</code>.</li></ul><h3 id="ReadProcessMemory-WriteProcessMemory"><a href="#ReadProcessMemory-WriteProcessMemory" class="headerlink" title="ReadProcessMemory &#x2F; WriteProcessMemory"></a>ReadProcessMemory &#x2F; WriteProcessMemory</h3><p><strong>跨进程读写内存</strong>的核心函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">ReadProcessMemory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE  hProcess,       <span class="hljs-comment">// 目标进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPCVOID lpBaseAddress,  <span class="hljs-comment">// 要读取的起始虚拟地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID  lpBuffer,       <span class="hljs-comment">// 存放数据的本地缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T  nSize,          <span class="hljs-comment">// 要读取的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T* lpNumberOfBytesRead <span class="hljs-comment">// 实际读取字节数（可选）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function">BOOL <span class="hljs-title">WriteProcessMemory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE  hProcess,        <span class="hljs-comment">// 目标进程句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPVOID  lpBaseAddress,   <span class="hljs-comment">// 要写入的起始虚拟地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">    LPCVOID lpBuffer,        <span class="hljs-comment">// 要写入数据的本地缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T  nSize,           <span class="hljs-comment">// 要写入的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">    SIZE_T* lpNumberOfBytesWritten <span class="hljs-comment">// 实际写入字节数（可选）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>关键就是目标进程句柄+虚拟地址+缓冲区, 但前提是<strong>读写的内存必须已提交, 读必须有可读权限, 写必须有可写权限</strong>, 这点靠<code>VirtualQueryEx</code>查询状态保证.</p><h3 id="跨进程内存读写实操"><a href="#跨进程内存读写实操" class="headerlink" title="跨进程内存读写实操"></a>跨进程内存读写实操</h3><p>这里打算做一个测试 : </p><ul><li>ProcessA构造一个类对象, 内部有一个val, 显示自己的pid和对象地址后进入循环等待.</li><li>ProcessB用进程pid和对象地址访问该对象并进行修改.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ProcessA.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> v) : <span class="hljs-built_in">val</span>(v) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">12345</span>)</span></span>;  <span class="hljs-comment">// 创建对象</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;Process ID: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetCurrentProcessId</span>() &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Object address: &quot;</span> &lt;&lt; &amp;obj &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ProcessB.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD pid;<br>    <span class="hljs-type">uintptr_t</span> objAddr;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter target PID: &quot;</span>;<br>    cin &gt;&gt; pid;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter target object address (hex, e.g., 0x12345678): &quot;</span>;<br>    cin &gt;&gt; std::hex &gt;&gt; objAddr;<br><br>    <span class="hljs-comment">// 增加读写查询权限</span><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION, FALSE, pid);<br>    <span class="hljs-keyword">if</span> (!hProcess) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Failed to open process, error: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 VirtualQueryEx 确认地址可读写</span><br>    MEMORY_BASIC_INFORMATION mbi;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">VirtualQueryEx</span>(hProcess, (LPCVOID)objAddr, &amp;mbi, <span class="hljs-built_in">sizeof</span>(mbi)) == <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;VirtualQueryEx failed, error: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (mbi.State != MEM_COMMIT || (mbi.Protect &amp; PAGE_NOACCESS)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Memory not accessible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 先读 val</span><br>    <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br>    SIZE_T bytesRead;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)objAddr, &amp;val, <span class="hljs-built_in">sizeof</span>(val), &amp;bytesRead) &amp;&amp; bytesRead == <span class="hljs-built_in">sizeof</span>(val)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Before write, val = &quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadProcessMemory failed, error: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 写 val = 999</span><br>    <span class="hljs-type">int</span> newVal = <span class="hljs-number">999</span>;<br>    SIZE_T bytesWritten;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">WriteProcessMemory</span>(hProcess, (LPVOID)objAddr, &amp;newVal, <span class="hljs-built_in">sizeof</span>(newVal), &amp;bytesWritten) &amp;&amp; bytesWritten == <span class="hljs-built_in">sizeof</span>(newVal)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Successfully wrote val = &quot;</span> &lt;&lt; newVal &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;WriteProcessMemory failed, error: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 再读 val</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">ReadProcessMemory</span>(hProcess, (LPCVOID)objAddr, &amp;val, <span class="hljs-built_in">sizeof</span>(val), &amp;bytesRead) &amp;&amp; bytesRead == <span class="hljs-built_in">sizeof</span>(val)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;After write, val = &quot;</span> &lt;&lt; val &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;ReadProcessMemory failed after write, error: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实际效果如下 : </p><p><img src="D:\xwechat_files\wxid_0c8qtb27aeen22_9747\temp\RWTemp\2025-09\9e20f478899dc29eb19741386f9343c8\aabfeb69ffa2c26861ee99602b054ae5.png" alt="aabfeb69ffa2c26861ee99602b054ae5"></p><p>需要注意的是, 打开进程句柄时需要传入对应的权限标识, 不然无法使用对应的函数, 我这里就加入了读写和查询的权限.</p><h3 id="跨进程内存读写可行性分析"><a href="#跨进程内存读写可行性分析" class="headerlink" title="跨进程内存读写可行性分析"></a>跨进程内存读写可行性分析</h3><p>实际上在进程运行时<strong>所有用户区堆内存&#x2F;数据段几乎都是可读写</strong>的, 本质是因为<strong>页保护属性对所有进程一视同仁</strong>, 如果设置为不可读写, 那么设置方也无法读写, 这是操作系统内存设计的底层逻辑, 无法改变. 因此跨进程读写还是有可行性的. </p><p>不过许多应用也会有很多反制措施, 比如禁止未授权的进程获取本进程的句柄等等, 但似乎依旧有漏洞可钻, 这点貌似很深就不深入学习了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>WindowsAPI</tag>
      
      <tag>线程</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows API 学习笔记(1) 类型和进程</title>
    <link href="/2025/09/04/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%20%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
    <url>/2025/09/04/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)%20%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习目标 : 主要在于学习怎么用C&#x2F;C++使用Windows操作系统, 不学界面, 只学底层, 比如内存管理, 线程, 系统信息调用, 网络编程相关.</p></blockquote><blockquote><p>类型和进程</p></blockquote><h2 id="Windows类型"><a href="#Windows类型" class="headerlink" title="Windows类型"></a>Windows类型</h2><table><thead><tr><th align="left">Windows类型</th><th align="left">等效C&#x2F;C++类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left"><code>BYTE</code></td><td align="left"><code>unsigned char</code></td><td align="left">1字节</td><td align="left">二进制数据、字节流</td></tr><tr><td align="left"><code>WORD</code></td><td align="left"><code>unsigned short</code></td><td align="left">2字节</td><td align="left">16位无符号整数（如端口号）</td></tr><tr><td align="left"><code>DWORD</code></td><td align="left"><code>unsigned long</code></td><td align="left">4字节</td><td align="left">32位无符号整数（如进程ID、错误码）</td></tr><tr><td align="left"><code>DWORD64</code></td><td align="left"><code>unsigned long long</code></td><td align="left">8字节</td><td align="left">64位无符号整数</td></tr><tr><td align="left"><code>INT</code>, <code>UINT</code></td><td align="left"><code>int</code>, <code>unsigned int</code></td><td align="left">4字节</td><td align="left">通用有&#x2F;无符号整数</td></tr><tr><td align="left"><code>LONG</code>, <code>ULONG</code></td><td align="left"><code>long</code>, <code>unsigned long</code></td><td align="left">4字节</td><td align="left">长整数（Win32 API常用）</td></tr><tr><td align="left"><code>BOOL</code></td><td align="left"><code>int</code></td><td align="left">4字节</td><td align="left">布尔值（<code>TRUE</code>&#x2F;<code>FALSE</code>）</td></tr><tr><td align="left"><code>HANDLE</code></td><td align="left"><code>void*</code></td><td align="left">4&#x2F;8字节</td><td align="left">内核对象通用句柄（文件、进程等）</td></tr><tr><td align="left"><code>CHAR</code>&#x2F;<code>LPSTR</code></td><td align="left"><code>char*</code></td><td align="left">1字节</td><td align="left">ANSI字符串（多字节编码）</td></tr><tr><td align="left"><code>WCHAR</code>&#x2F;<code>LPWSTR</code></td><td align="left"><code>wchar_t*</code></td><td align="left">2字节</td><td align="left">Unicode字符串（UTF-16）</td></tr><tr><td align="left"><code>LPVOID</code></td><td align="left"><code>void*</code></td><td align="left">4&#x2F;8字节</td><td align="left"><code>void*</code>（通用指针）</td></tr></tbody></table><h3 id="wchar"><a href="#wchar" class="headerlink" title="wchar"></a>wchar</h3><p>现代Windows系统的原生字符编码方式就是<strong>Unicode(UTF-16)</strong>, 就是wchar本身的编码方式(两字节宽字符), 因此Windows系统最好使用wchar字符串, 可以减少很多转码的开销.</p><p>C++本身也支持宽字符 : </p><ul><li><p><code>wchar_t</code> : 宽字符类型.</p></li><li><p><code>&lt;cwchar&gt;</code> : 宽字符库, 有<code>wprintf</code>, <code>wcslen</code>等实现对宽字符串的处理.</p></li><li><p><code>&lt;locale&gt;</code>  : 设置本地化, 因为默认按照ASCII编码解释, 通过setlocale可以改变解释规则.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">// 启用本地化支持（如控制台输出中文）</span><br></code></pre></td></tr></table></figure><p>这里选择<code>LC_ALL</code>代表依据操作系统本身的本地化规则来解释, 比如汉字在不设置之前就无法被读出.</p></li><li><p><code>std::wstring</code> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::wstring ws = <span class="hljs-string">L&quot;你好，世界！&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="CreateProcessW"><a href="#CreateProcessW" class="headerlink" title="CreateProcessW"></a>CreateProcessW</h3><blockquote><p>用绝对路径或相对路径指定一个可执行文件, 开辟一个进程运行该可执行文件.</p></blockquote><p>CreateProcessW总共有10个参数, 但现在只需要先知道第二个参数传入可执行文件路径.</p><p>下面的例子中, 我们开辟了一个进程运行了Windows自带的记事本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    STARTUPINFOW si&#123; <span class="hljs-built_in">sizeof</span>(si) &#125;;<br>    PROCESS_INFORMATION pi;<br><br>    <span class="hljs-comment">// 使用可修改的宽字符串缓冲区</span><br>    <span class="hljs-type">wchar_t</span> commandLine[] = <span class="hljs-string">L&quot;notepad.exe&quot;</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">CreateProcessW</span>(<br>        <span class="hljs-literal">NULL</span>,                   <span class="hljs-comment">// 应用程序名（NULL表示使用命令行）</span><br>        commandLine, <span class="hljs-comment">// 命令行参数</span><br>        <span class="hljs-literal">NULL</span>,                   <span class="hljs-comment">// 进程安全属性</span><br>        <span class="hljs-literal">NULL</span>,                   <span class="hljs-comment">// 线程安全属性</span><br>        FALSE,                  <span class="hljs-comment">// 不继承句柄</span><br>        <span class="hljs-number">0</span>,                      <span class="hljs-comment">// 创建标志</span><br>        <span class="hljs-literal">NULL</span>,                   <span class="hljs-comment">// 环境变量</span><br>        <span class="hljs-literal">NULL</span>,                   <span class="hljs-comment">// 工作目录</span><br>        &amp;si,                    <span class="hljs-comment">// 启动信息</span><br>        &amp;pi))                   <span class="hljs-comment">// 进程信息</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;成功启动！PID: %d\n&quot;</span>, pi.dwProcessId);<br>        <span class="hljs-built_in">CloseHandle</span>(pi.hProcess);<br>        <span class="hljs-built_in">CloseHandle</span>(pi.hThread);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误代码: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意第二个参数必须要传入<strong>可修改的宽字符串缓冲区</strong>, 我们需要在栈上开辟然后传入, 不可以直接在第二个参数处传入路径, 因为普通字符串会被视为常量<strong>只读</strong>, 不可修改, 而CreateProcessW会在内部对第二个参数进行修改, 因此必须栈上构造再传入.</li><li>倒数第二个参数可以设置一些启动线程的设置.</li><li>最后一个参数用来存放启动的进程对应的<strong>进程&#x2F;线程句柄</strong>, 这个两种句柄的作用很大, 可以查询各种进程&#x2F;线程的信息. 需要这两个句柄最后必须通过<code>CloseHandle</code>函数消掉, 不然会内存泄露.</li></ul><h3 id="OpenProcess"><a href="#OpenProcess" class="headerlink" title="OpenProcess"></a>OpenProcess</h3><blockquote><p>传入进程PID, 返回对应进程的线程句柄.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">OpenProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwDesiredAccess,  <span class="hljs-comment">// 访问权限（如 PROCESS_TERMINATE）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    BOOL  bInheritHandle,   <span class="hljs-comment">// 是否继承句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">    DWORD dwProcessId       <span class="hljs-comment">// 目标进程的PID</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="TerminateProcess"><a href="#TerminateProcess" class="headerlink" title="TerminateProcess"></a><strong>TerminateProcess</strong></h3><blockquote><p>传入句柄, 强制终止对应进程.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">TerminateProcess</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    HANDLE hProcess,  <span class="hljs-comment">// 进程句柄（通过 OpenProcess 或 CreateProcess 获取）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    UINT   uExitCode  <span class="hljs-comment">// 退出代码（自定义，通常填 0）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>下面一个例子, 我们将再外部打开记事本, 通过任务管理器找到对应的PID, 传入程序, 通过<code>OpenProcess</code>获取进程句柄, 再通过<code>TerminateProcess</code>强制停止记事本进程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    DWORD pid;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入要打开的进程PID: &quot;</span>);<br>    <span class="hljs-built_in">scanf_s</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pid);<br><br>    <span class="hljs-comment">// 打开进程（获取句柄）</span><br>    HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(<br>        PROCESS_ALL_ACCESS,  <span class="hljs-comment">// 所有权限（实际需根据需求调整）</span><br>        FALSE,               <span class="hljs-comment">// 不继承句柄</span><br>        pid                  <span class="hljs-comment">// 目标进程PID</span><br>    );<br><br>    <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开进程失败！错误代码: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;进程句柄: 0x%p\n&quot;</span>, hProcess);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TerminateProcess</span>(hProcess, <span class="hljs-number">0</span>)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;进程已终止！\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;终止失败！错误代码: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>    &#125;<br>    <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现, 我们外部开启的记事本会被我们启动的程序强制关闭.</p><h3 id="进程句柄的作用"><a href="#进程句柄的作用" class="headerlink" title="进程句柄的作用"></a>进程句柄的作用</h3><ul><li><p>终止进程 : 效果同上, 可以强关卡死的进程, 关闭冲突进程.</p></li><li><p>等待进程结束, 实现进程同步.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">WaitForSingleObject</span>(hProcess, INFINITE); <span class="hljs-comment">// 阻塞直到进程退出</span><br></code></pre></td></tr></table></figure></li><li><p>查询进程信息 : </p><ul><li><p>GetProcessTimes : 输出时间相关的数据, 传入进程句柄和四种时间参数.</p><table><thead><tr><th align="left">参数</th><th align="left">类型</th><th align="left">单位</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>lpCreationTime</code></td><td align="left"><code>FILETIME</code></td><td align="left">100纳秒</td><td align="left">进程创建时间（UTC时间戳）</td></tr><tr><td align="left"><code>lpExitTime</code></td><td align="left"><code>FILETIME</code></td><td align="left">100纳秒</td><td align="left">进程退出时间（若未退出则为0）</td></tr><tr><td align="left"><code>lpKernelTime</code></td><td align="left"><code>FILETIME</code></td><td align="left">100纳秒</td><td align="left">进程在内核模式消耗的CPU时间（所有线程累计）</td></tr><tr><td align="left"><code>lpUserTime</code></td><td align="left"><code>FILETIME</code></td><td align="left">100纳秒</td><td align="left">进程在用户模式消耗的CPU时间（所有线程累计）</td></tr></tbody></table></li><li><p>GetProcessMemoryInfo : 输入内存相关的数据, 传入进程句柄和<code>PROCESS_MEMORY_COUNTERS</code>, 以下是pmc的参数 : </p><table><thead><tr><th align="left">字段</th><th align="left">类型</th><th align="left">单位</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>WorkingSetSize</code></td><td align="left"><code>SIZE_T</code></td><td align="left">字节</td><td align="left">当前物理内存占用（工作集）</td></tr><tr><td align="left"><code>PeakWorkingSetSize</code></td><td align="left"><code>SIZE_T</code></td><td align="left">字节</td><td align="left">物理内存占用的历史峰值</td></tr><tr><td align="left"><code>PagefileUsage</code></td><td align="left"><code>SIZE_T</code></td><td align="left">字节</td><td align="left">虚拟内存使用量（含磁盘分页文件）</td></tr><tr><td align="left"><code>PeakPagefileUsage</code></td><td align="left"><code>SIZE_T</code></td><td align="left">字节</td><td align="left">虚拟内存占用的历史峰值</td></tr><tr><td align="left"><code>PageFaultCount</code></td><td align="left"><code>DWORD</code></td><td align="left">次</td><td align="left">页错误次数（硬错误+软错误）</td></tr></tbody></table></li></ul></li></ul><h3 id="进程状态检测器"><a href="#进程状态检测器" class="headerlink" title="进程状态检测器"></a>进程状态检测器</h3><p>利用Windows API的进程函数, 展示所有进程的名称&#x2F;路径&#x2F;内存占用&#x2F;CPU占用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;psapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pdh.h&gt;</span>  <span class="hljs-comment">// 用于CPU性能计数器</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pdhmsg.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib, <span class="hljs-string">&quot;pdh.lib&quot;</span>)</span><br><br><span class="hljs-comment">// 获取系统总物理内存</span><br><span class="hljs-function">ULONGLONG <span class="hljs-title">GetTotalPhysicalMemory</span><span class="hljs-params">()</span> </span>&#123;<br>    MEMORYSTATUSEX memInfo;<br>    memInfo.dwLength = <span class="hljs-built_in">sizeof</span>(MEMORYSTATUSEX);<br>    <span class="hljs-built_in">GlobalMemoryStatusEx</span>(&amp;memInfo);<br>    <span class="hljs-keyword">return</span> memInfo.ullTotalPhys;<br>&#125;<br><br><span class="hljs-comment">// 获取进程CPU使用率</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">GetProcessCpuUsage</span><span class="hljs-params">(HANDLE hProcess, ULONGLONG* lastTime, ULONGLONG* lastSysTime, ULONGLONG* lastUserTime)</span> </span>&#123;<br>    FILETIME createTime, exitTime, kernelTime, userTime;<br>    ULONGLONG now, sysTime, userTime64;<br><br>    <span class="hljs-built_in">GetSystemTimeAsFileTime</span>(&amp;createTime);<br>    now = ((ULONGLONG)createTime.dwHighDateTime &lt;&lt; <span class="hljs-number">32</span>) | createTime.dwLowDateTime;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">GetProcessTimes</span>(hProcess, &amp;createTime, &amp;exitTime, &amp;kernelTime, &amp;userTime)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1.0</span>;<br>    &#125;<br><br>    sysTime = ((ULONGLONG)kernelTime.dwHighDateTime &lt;&lt; <span class="hljs-number">32</span>) | kernelTime.dwLowDateTime;<br>    userTime64 = ((ULONGLONG)userTime.dwHighDateTime &lt;&lt; <span class="hljs-number">32</span>) | userTime.dwLowDateTime;<br><br>    ULONGLONG sysTimeDiff = sysTime - *lastSysTime;<br>    ULONGLONG userTimeDiff = userTime64 - *lastUserTime;<br>    ULONGLONG timeDiff = now - *lastTime;<br><br>    *lastTime = now;<br>    *lastSysTime = sysTime;<br>    *lastUserTime = userTime64;<br><br>    <span class="hljs-keyword">if</span> (timeDiff == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)(sysTimeDiff + userTimeDiff) * <span class="hljs-number">100.0</span> / (<span class="hljs-type">double</span>)timeDiff;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// 允许控制台输出中文</span><br><br>    <span class="hljs-comment">// 获取系统总内存</span><br>    ULONGLONG totalMemory = <span class="hljs-built_in">GetTotalPhysicalMemory</span>();<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;系统总内存: %.2f MB\n&quot;</span>, totalMemory / (<span class="hljs-number">1024.0</span> * <span class="hljs-number">1024.0</span>));<br><br>    <span class="hljs-comment">// 初始化CPU计数器</span><br>    ULARGE_INTEGER lastCPU, lastSysCPU, lastUserCPU;<br>    FILETIME ft;<br>    <span class="hljs-built_in">GetSystemTimeAsFileTime</span>(&amp;ft);<br>    lastCPU.LowPart = ft.dwLowDateTime;<br>    lastCPU.HighPart = ft.dwHighDateTime;<br><br>    SYSTEM_INFO sysInfo;<br>    <span class="hljs-built_in">GetSystemInfo</span>(&amp;sysInfo);<br>    DWORD numProcessors = sysInfo.dwNumberOfProcessors;<br><br>    <span class="hljs-comment">// 获取所有的进程id</span><br>    DWORD pids[<span class="hljs-number">1024</span>], cbNeeded;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">EnumProcesses</span>(pids, <span class="hljs-built_in">sizeof</span>(pids), &amp;cbNeeded)) &#123;<br>        <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;EnumProcesses失败! 错误: %d\n&quot;</span>, <span class="hljs-built_in">GetLastError</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    DWORD processCount = cbNeeded / <span class="hljs-built_in">sizeof</span>(DWORD);<br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;共发现 %d 个进程\n&quot;</span>, processCount);<br><br>    <span class="hljs-keyword">for</span> (DWORD i = <span class="hljs-number">0</span>; i &lt; processCount; i++) &#123;<br>        HANDLE hProcess = <span class="hljs-built_in">OpenProcess</span>(<br>            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,<br>            FALSE,<br>            pids[i]<br>        );<br><br>        <span class="hljs-keyword">if</span> (hProcess == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        WCHAR processName[MAX_PATH] = <span class="hljs-string">L&quot;&lt;未知&gt;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetModuleBaseNameW</span>(hProcess, <span class="hljs-literal">NULL</span>, processName, MAX_PATH) &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;[PID: %5d] 名称: %s\n&quot;</span>, pids[i], processName);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取进程路径</span><br>        WCHAR exePath[MAX_PATH];<br>        DWORD size = MAX_PATH;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">QueryFullProcessImageNameW</span>(hProcess, <span class="hljs-number">0</span>, exePath, &amp;size)) &#123;<br>            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;  路径: %s\n&quot;</span>, exePath);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取内存信息并计算百分比</span><br>        PROCESS_MEMORY_COUNTERS pmc;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetProcessMemoryInfo</span>(hProcess, &amp;pmc, <span class="hljs-built_in">sizeof</span>(pmc))) &#123;<br>            <span class="hljs-type">double</span> memoryMB = pmc.WorkingSetSize / (<span class="hljs-number">1024.0</span> * <span class="hljs-number">1024.0</span>);<br>            <span class="hljs-type">double</span> memoryPercent = (<span class="hljs-type">double</span>)pmc.WorkingSetSize * <span class="hljs-number">100.0</span> / (<span class="hljs-type">double</span>)totalMemory;<br>            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;  内存: %.2f MB (%.2f%%)\n&quot;</span>, memoryMB, memoryPercent);<br>        &#125;<br><br>        <span class="hljs-comment">// 获取CPU使用率</span><br>        ULONGLONG lastTime = <span class="hljs-number">0</span>, lastSysTime = <span class="hljs-number">0</span>, lastUserTime = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">double</span> cpuUsage = <span class="hljs-built_in">GetProcessCpuUsage</span>(hProcess, &amp;lastTime, &amp;lastSysTime, &amp;lastUserTime);<br>        <span class="hljs-keyword">if</span> (cpuUsage &gt;= <span class="hljs-number">0.0</span>) &#123;<br>            <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;  CPU使用率: %.2f%%\n&quot;</span>, cpuUsage / numProcessors);<br>        &#125;<br><br>        <span class="hljs-built_in">CloseHandle</span>(hProcess);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>WindowsAPI</tag>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++线程级异步</title>
    <link href="/2025/09/03/C++%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%BC%82%E6%AD%A5/"/>
    <url>/2025/09/03/C++%E7%BA%BF%E7%A8%8B%E7%BA%A7%E5%BC%82%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>async做到的只是简单的线程级异步, 并非像boost:asio那样的内核级异步, 其优势大概也就是简单了.</p><p>因此只适合做一些简单的异步任务, 但是其功能和线程池重合, 如果使用了线程池就没有必要使用async了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 启动异步任务</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(compute, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-comment">// 获取结果（会阻塞直到结果可用）</span><br><span class="hljs-type">int</span> result = fut.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>future内部可以封装一个类型, 这个类型的值在一开始可能并没有被计算出来, future可以通过调用get获取这个值, 如果值已被计算出来就马上返回, 还没就阻塞在这里等待.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, computeSomething);<br><span class="hljs-comment">// ...</span><br><span class="hljs-type">int</span> result = fut.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure><p>其关键点在于 : </p><ul><li><p>存在时间跨度 : </p><p>先给出future, 在之后再调用get, 在获取结果之前可以有更丰富的操作, 并且有时间跨度才能有对异步的支持.</p></li><li><p>对异步并行的支持 : </p><p><strong>有时间跨度 + 线程间通信</strong>, 使得future可以让异步操作有了返回值的功能, 可以跨线程接收异步操作的结果, 当我们可以使用其他线程执行任务并返回内容到主线程时, 我们可以利用并行的优势提高运行效率.</p></li></ul><p>那么关键在于<strong>如何产生一个future</strong>?</p><p>大体有三种办法 : </p><ul><li><p>async : </p><p>async可以接收一个函数对象, 将其放到一个线程中去执行, 会返回一个future对象, 其封装类型就是该函数的返回值, 当另一个线程中的该函数执行完就会填充这个future.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 利用future + async可以实现并行计算</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">parallelSum</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; data, <span class="hljs-type">size_t</span> start, <span class="hljs-type">size_t</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">accumulate</span>(data.<span class="hljs-built_in">begin</span>()+start, data.<span class="hljs-built_in">begin</span>()+end, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">1000</span>, <span class="hljs-number">1</span>)</span></span>; <span class="hljs-comment">// 1000个1</span><br>    <br>    <span class="hljs-comment">// 分成4部分并行计算</span><br>    std::future&lt;<span class="hljs-type">int</span>&gt; fut1 = std::<span class="hljs-built_in">async</span>(std::launch::async, parallelSum, std::<span class="hljs-built_in">ref</span>(data), <span class="hljs-number">0</span>, <span class="hljs-number">250</span>);<br>    std::future&lt;<span class="hljs-type">int</span>&gt; fut2 = std::<span class="hljs-built_in">async</span>(std::launch::async, parallelSum, std::<span class="hljs-built_in">ref</span>(data), <span class="hljs-number">250</span>, <span class="hljs-number">500</span>);<br>    std::future&lt;<span class="hljs-type">int</span>&gt; fut3 = std::<span class="hljs-built_in">async</span>(std::launch::async, parallelSum, std::<span class="hljs-built_in">ref</span>(data), <span class="hljs-number">500</span>, <span class="hljs-number">750</span>);<br>    std::future&lt;<span class="hljs-type">int</span>&gt; fut4 = std::<span class="hljs-built_in">async</span>(std::launch::async, parallelSum, std::<span class="hljs-built_in">ref</span>(data), <span class="hljs-number">750</span>, <span class="hljs-number">1000</span>);<br>    <br>    <span class="hljs-comment">// 合并结果</span><br>    <span class="hljs-type">int</span> total = fut<span class="hljs-number">1.</span><span class="hljs-built_in">get</span>() + fut<span class="hljs-number">2.</span><span class="hljs-built_in">get</span>() + fut<span class="hljs-number">3.</span><span class="hljs-built_in">get</span>() + fut<span class="hljs-number">4.</span><span class="hljs-built_in">get</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Total sum: &quot;</span> &lt;&lt; total &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>promise : </p><p>向promise中填充类型, 使用get_future()便可以返回对应类型的future. 可以让其他线程传入promise对象, 其他线程可以在适合的场景调用set_value来填充future. 这算是future最基础的用法.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::promise&lt;<span class="hljs-type">int</span>&gt; result_promise;<br><span class="hljs-keyword">auto</span> result_future = result_promise.<span class="hljs-built_in">get_future</span>();<br><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;] &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-comment">// 耗时计算</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> result = heavy_computation();</span></span><br><span class="hljs-params"><span class="hljs-function">    result_promise.set_value(result);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-comment">// 主线程可以做其他事情</span><br><span class="hljs-built_in">do_something_else</span>();<br><br><span class="hljs-comment">// 当需要结果时</span><br><span class="hljs-type">int</span> final_result = result_future.<span class="hljs-built_in">get</span>();<br>t.<span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure></li><li><p>packaged_task : </p><p>该类型可以封装任务(函数回调), 并返回获取该任务对应的返回值future. 人话说就是对一个函数进行改造, 使其return的那个返回值可以被future获取.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">char</span>)</span></span>;  <span class="hljs-comment">// 函数签名是 int(double, char)</span><br><span class="hljs-function">std::packaged_task&lt;<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-type">double</span>, <span class="hljs-type">char</span>)</span>&gt; <span class="hljs-title">task</span><span class="hljs-params">(foo)</span></span>;  <span class="hljs-comment">// 匹配签名</span><br></code></pre></td></tr></table></figure><p>可以理解为<strong>functional和promise的组合</strong>, 我们可以传入函数来放入packaged_task, 注意前面模板参数存入的函数前面要与放入的实际函数匹配.</p><p>于是我们就可以从中获取future : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::future&lt;<span class="hljs-type">int</span>&gt; fut = task.<span class="hljs-built_in">get_future</span>();<br><span class="hljs-comment">// ...</span><br><span class="hljs-type">int</span> ret = fut.<span class="hljs-built_in">get</span>();<br></code></pre></td></tr></table></figure></li></ul><p>有了上面三种产生future的方法后, 我们就可以将future嵌入到一些需求异步的场景中 : </p><p>以<strong>线程池</strong>为例, 下面是最简单的一种线程池 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uncopyable.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> : <span class="hljs-keyword">public</span> Uncopyable &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">using</span> Task = function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span> n = thread::<span class="hljs-built_in">hardware_concurrency</span>())<br>        : <span class="hljs-built_in">isstop</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">running_cnt</span>(<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) n = <span class="hljs-number">1</span>;<br>        pool_.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            pool_.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123; <span class="hljs-built_in">thread_work</span>(); &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">push</span><span class="hljs-params">(Task task)</span> </span>&#123;<br>        <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>        <span class="hljs-keyword">if</span> (isstop) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        q_.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">move</span>(task));<br>        cond_.<span class="hljs-built_in">notify_one</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待所有任务执行完</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait_all</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>        waitall.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>] &#123;<br>            <span class="hljs-keyword">return</span> q_.<span class="hljs-built_in">empty</span>() &amp;&amp; running_cnt == <span class="hljs-number">0</span>;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (isstop) <span class="hljs-keyword">return</span>;<br>        &#123;<br>            <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>            isstop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        cond_.<span class="hljs-built_in">notify_all</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; t : pool_) &#123;<br>            <span class="hljs-keyword">if</span> (t.<span class="hljs-built_in">joinable</span>()) t.<span class="hljs-built_in">join</span>();<br>        &#125;<br>        pool_.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_work</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) <br>        &#123;<br>            Task task;<br><br>            &#123;<br>                <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>                cond_.<span class="hljs-built_in">wait</span>(lk, [<span class="hljs-keyword">this</span>] &#123;<br>                    <span class="hljs-keyword">return</span> isstop || !q_.<span class="hljs-built_in">empty</span>();<br>                    &#125;);<br>                <span class="hljs-keyword">if</span> (isstop &amp;&amp; q_.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br><br>                task = <span class="hljs-built_in">move</span>(q_.<span class="hljs-built_in">front</span>());<br>                q_.<span class="hljs-built_in">pop</span>();<br>                ++running_cnt;<br>            &#125;<br><br>            <span class="hljs-built_in">task</span>();<br><br>            &#123;<br>                <span class="hljs-function">lock_guard&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>                <span class="hljs-keyword">if</span> (--running_cnt == <span class="hljs-number">0</span> &amp;&amp; q_.<span class="hljs-built_in">empty</span>()) &#123;<br>                    waitall.<span class="hljs-built_in">notify_all</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>vector&lt;thread&gt; pool_;<br>    queue&lt;Task&gt; q_;<br>    mutex m_;<br>    condition_variable cond_;<br>    condition_variable waitall;<br>    <span class="hljs-type">bool</span> isstop;<br>    <span class="hljs-type">int</span> running_cnt; <span class="hljs-comment">// 记录有多少线程正在执行任务</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们会发现这个线程池非常僵硬的一个点, 就是<strong>只能投放无参数无返回值的任务</strong>, 其他任何类型的任务都无法执行. 在学习了<strong>可变参数和函数绑定</strong>后, 我们可以实现<strong>投放任意参数的任务</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> task = std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...);<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>        <span class="hljs-keyword">if</span> (isstop) <span class="hljs-keyword">return</span>;<br>        q_.<span class="hljs-built_in">push</span>([task]() &#123; <span class="hljs-built_in">task</span>(); &#125;);<br>    &#125;<br>    cond_.<span class="hljs-built_in">notify_one</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们的思路是 : </p><p>每个任务线程都会从队列中取出任务并通过<code>task();</code>执行, 这种形式最好不变, 因此任务线程拿到的任务都是无参数的任务. 我们的操作要将传入的有参函数转化为无参函数, 这就要依赖可变参数和函数绑定了.</p><p>我们通过可变参数接收各种类型的参数, 只要函数重载匹配, 就可以将其绑定到对应函数中, 把<strong>原来需要的参数填满, 自然就变成无参函数了</strong>, 那么我们就可以将其推入队列中, 注意这里推入的是<code>[task]() &#123; task(); &#125;</code>而非<code>task</code>, 因为就算绑定了类型也还未转变, 前者是在将函数调用的类型转化为<code>function&lt;void()&gt;</code>, 让其可以存入队列中.</p><p>因此我们可以通过如下方式处理带参数的任务 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-comment">// ...</span><br>pool_.<span class="hljs-built_in">push</span>(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>但是我们会发现, 虽然现在线程池可以处理带参数的任务, 但是其实是<strong>获取不到返回值</strong>的!</p><p>仔细思考, <strong>获取线程池任务返回值</strong>其实是一个<strong>经典的异步场景</strong> : </p><ul><li>任务会被投入线程池中, 在一个线程中去运行.</li><li>投入任务后主线程希望获取返回值, 但不知道线程什么时候执行完成并返回.</li><li>任务在线程中需要有一个手段可以<strong>与主线程通信并且传输返回值</strong>.</li></ul><p>那么这个手段就是使用future, 我们来看使用future升级后的push函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> F, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">push</span><span class="hljs-params">(F&amp;&amp; f, Args&amp;&amp;... args)</span> -&gt; std::future&lt;<span class="hljs-keyword">typename</span> std::<span class="hljs-type">invoke_result_t</span>&lt;F, Args...&gt;&gt;</span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> return_type = std::<span class="hljs-type">invoke_result_t</span>&lt;F, Args...&gt;;<br><br>    <span class="hljs-keyword">auto</span> task = std::make_shared&lt;std::packaged_task&lt;<span class="hljs-built_in">return_type</span>()&gt;&gt;(<br>        std::<span class="hljs-built_in">bind</span>(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)<br>    );<br><br>    std::future&lt;return_type&gt; res = task-&gt;<span class="hljs-built_in">get_future</span>();<br>    &#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(m_)</span></span>;<br>        <span class="hljs-keyword">if</span> (isstop) <span class="hljs-keyword">return</span>;<br>        q_.<span class="hljs-built_in">push</span>([task]() &#123; (*task)(); &#125;);<br>    &#125;<br>    cond_.<span class="hljs-built_in">notify_one</span>();<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们的思路是 : </p><p>既然希望获取任务的返回值, 那么我们<strong>先确定这个任务返回值的类型</strong>, 并以此<strong>包装一个future</strong>, <strong>交给主线程</strong>, 然后主线程再<strong>利用get获取返回值</strong>. </p><p>我们来一步一步分析代码 : </p><ul><li><p><code>invoke_result_t</code>  : </p><p>这是C++17引入的一种模板元编程, 其最终表现为一种类型, 该类型是<strong>其模板参数传入的函数回调及参数所指定函数版本的返回值类型</strong>, 人话说就是给一个函数和其参数类型, 我去帮你找对应的返回值类型, 这里面包含了对函数重载的考虑.</p><p><code>invoke_result_t&lt;F, Args...&gt;</code>就是函数为F, 参数为Args…对应的返回值类型.</p></li><li><p><code>std::future&lt;typename std::invoke_result_t&lt;F, Args...&gt;&gt;</code>  : </p><p>实际返回一个包含了返回值类型的future对象, 外部就会通过这个对象调用get获取返回值.</p></li><li><p><code>return_type</code> : 记录返回值类型.</p></li><li><p><code>std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...)</code> : </p><p>和上一个版本一样, 将参数绑定到对应函数中, 返回的是一个<strong>参数被填满的函数调用</strong>.</p></li><li><p><code>std::packaged_task&lt;return_type()&gt;(bind(...))</code> :</p><ul><li>模板参数是<code>return_type()</code>, 表示返回值类型为return_type, 无参.</li><li>packaged_task将bind返回的函数对象进行包装, 返回一个<strong>可执行的并把返回值存入futuer对象的任务</strong>.</li></ul></li><li><p><code>make_shared</code> :</p><p>用来为包装过的任务对象添加智能指针. 主要原因是<code>packaged_task</code>包装的任务C++<strong>禁止拷贝</strong>, 但是我们希望传给其他线程进行调用, 那么就只能使用智能指针共享了.</p></li><li><p>res : 从task中取出的future对象, 用来传到外部.</p></li><li><p><code>[task]() &#123; (*task)(); &#125;</code> : </p><p>和上一个版本同理, 但这里由于我们把任务封装进智能指针中了, 就需要先解引用出来.</p></li></ul><p>至此我们可以向线程池中投入有无返回值, 参数任意的任务了!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><span class="hljs-comment">// ... </span><br>pool.<span class="hljs-built_in">push</span>(func1);<br>pool.<span class="hljs-built_in">push</span>(func2, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">auto</span> future = pool.<span class="hljs-built_in">push</span>(add, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">auto</span> ret = future.<span class="hljs-built_in">get</span>();<br>cout &lt;&lt; ret &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编译链接模型精要</title>
    <link href="/2025/08/10/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/"/>
    <url>/2025/08/10/C++%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E6%A8%A1%E5%9E%8B%E7%B2%BE%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<h2 id="C编译链接系统"><a href="#C编译链接系统" class="headerlink" title="C编译链接系统"></a>C编译链接系统</h2><blockquote><p>先来回顾C语言的编译流程 : 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</p></blockquote><h3 id="Preprocessor-预处理"><a href="#Preprocessor-预处理" class="headerlink" title="Preprocessor 预处理"></a>Preprocessor 预处理</h3><ul><li>输入  .c &#x2F; .cc 文件</li><li>输出  .i (intermediate 中间) 文件</li><li>工作 : <ul><li>将include字段用对应的.h文件替换</li><li>替换define字段</li><li>处理条件编译</li><li>删除注释</li></ul></li></ul><h3 id="Compiler-编译"><a href="#Compiler-编译" class="headerlink" title="Compiler 编译"></a>Compiler 编译</h3><ul><li>输入 .i 文件</li><li>输出 .s (source 源码) 文件</li><li>工作 :  进行编译层面的语法优化 + 转化为汇编语言. 其内部实现其实相对复杂, 编译器会分析你所构建的类或函数, 在内部生成类似语义树的结构, 进而推动高级代码向汇编代码的转变.</li></ul><h3 id="Assembler-汇编"><a href="#Assembler-汇编" class="headerlink" title="Assembler 汇编"></a>Assembler 汇编</h3><ul><li>输入 .s 文件</li><li>输出 .o (object 目标) 文件</li><li>工作 : 将汇编语言转化为适合的<strong>目标机器码</strong>(也就是CPU可以理解并且执行的二进制码).</li><li>注意 : 汇编语言有多种, CPU也有不同的目标机器码, 前两个阶段都根据不同的机器&#x2F;环境做出变化.</li></ul><h3 id="Linker-链接"><a href="#Linker-链接" class="headerlink" title="Linker 链接"></a>Linker 链接</h3><ul><li><p>输入 .o 文件</p></li><li><p>输出可执行文件</p></li><li><p>工作 : 实现多文件的链接, 将.o文件中需要的外部资源通过搜索查找等途径填充, 由预处理阶段替换的.h字段引导.</p><ul><li><p>符号解析 &#x2F; 重定位 : 为.o文件中引用但未定义的函数或变量在外部文件找到定义.</p></li><li><p><strong>节段机制</strong> : </p><p>学过进程地址空间就会直到, 每个进程地址空间都会被分配代码块, 数据块等字段用于进程运作, 链接器会利用节段机制将不同.cc文件的数据和代码汇聚到进程地址空间的<code>.test</code> &#x2F; <code>.data</code> &#x2F; <code>.bss</code> 等中, 实际就是将分散的源代码汇聚到一个进程体系中, 使其可以作为一个进程真正实现运行.</p></li></ul></li></ul><blockquote><p>上述过程可以简单理解为 高级语言 -&gt; 汇编语言 -&gt; 目标机器码 -&gt; 代码合并 + 进程实现 </p><p>我们一般统称前三个阶段<code>预处理-&gt;编译-&gt;汇编</code>为编译阶段, 最后一步为链接阶段.</p><p>下面是一些基础概念的讲解 :</p></blockquote><h3 id="翻译单元-TU"><a href="#翻译单元-TU" class="headerlink" title="翻译单元(TU)"></a>翻译单元(TU)</h3><p>可以理解为<strong>一个<code>.o</code>文件就是一个翻译单元</strong>, 而一个<code>.o</code>又对应一个<code>.cpp</code>, 也就是说一个项目<code>.cpp</code>文件的数量就是最后翻译单元的数量.</p><p>官方点说, 翻译单元就是源文件通过前三个阶段得来的展开代码, 而最后一个阶段就是把各个编译单元链接到一块的过程.</p><ul><li><strong>编译阶段每个翻译单元相互独立, 而链接阶段会汇聚所有翻译单元产生的<code>.o</code>文件</strong>.</li></ul><h3 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h3><p>通常编译器会缓存<code>.o</code>文件, 只有当<code>.o</code>文件对应的<code>.cpp</code>文件发生了修改(其包含的头文件发生修改也算), 才会重新进行编译, 不然都会直接使用原来的.o文件而不进行额外的编译, 这是后面前向声明的前置机制.</p><h3 id="头文件-h-与源文件-cpp-分离"><a href="#头文件-h-与源文件-cpp-分离" class="headerlink" title="头文件(.h)与源文件(.cpp)分离"></a>头文件(.h)与源文件(.cpp)分离</h3><p>这是一个非常基础的理念, 但是在这里重申一下, 首先这种分块的形式便于项目模块的分类和规划, 提供给外部使用也更方便. 但在编译角度, 这种形式可以天然降低重复编译 : 如果<code>.cpp</code>文件发生变化, 只要<code>.h</code>文件不变, 那么其他包含了该<code>.h</code>文件的<code>.cpp</code>文件就无需重新编译, 只需要发生变动的这个<code>.cpp</code>文件重新编译即可.</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>C内部有各种各样的符号表, 这里专门讲解在<code>.o</code>文件中的符号表, 不过就算是讲解, 也只是表达概念而不是深入底层, 因为其内部实现相对复杂, 不好理解.</p><ul><li><p>符号 : 你可以理解为对函数&#x2F;类&#x2F;变量的简称, 一般就是其名称再加一些标志符号.</p></li><li><p><code>.o</code>文件中的符号表 约等于 <strong>本目标文件对外的接口清单 + 对外的依赖清单</strong>.</p></li><li><p>在链接器拿到<code>.o</code>文件后就会知道其有什么样接口, 可以供其他文件使用; 同时也知道其有怎样的依赖, 需要链接器帮它找这些依赖文件.</p></li><li><p>一般<code>T</code>被用于表示<strong>拥有其定义</strong>, <code>U</code>被用于表示<strong>引用但未定义</strong>需要链接器帮忙寻找, 还有很多标志这里不详述.</p></li></ul><h3 id="静态库-a-lib"><a href="#静态库-a-lib" class="headerlink" title="静态库( .a &#x2F; .lib )"></a>静态库( .a &#x2F; .lib )</h3><p>这是一种用于<strong>存储<code>.o</code>文件</strong>的形式. </p><ul><li><p>目的 : 通过存储集合<code>.o</code>文件到<code>.a</code>中, <strong>在链接阶段直接使用现成的<code>.o</code>文件</strong>而直接跳过编译阶段, 大大提升编译速度.</p></li><li><p>生成 : 下面主要展示Linux系统中如何生成静态库, 一般都是使用<code>ar</code>进行静态库相关操作.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 生成目标文件</span><br>gcc -c add.c sub.c<br><span class="hljs-comment"># 2. 归档成静态库</span><br>ar rcs libmath.a add.o sub.o<br></code></pre></td></tr></table></figure></li><li><p>使用 : 生成的静态库名为<code>libmath.a</code>, 那么其真正库名就是<code>math</code>, 链接时需要<code>-l库名</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 3. 使用静态库链接</span><br>gcc main.c -L. -lmath -o main_static<br></code></pre></td></tr></table></figure></li><li><p>底层实现 : 在链接过程中, 链接器会<strong>把需要的<code>.o</code>文件拷贝到可执行文件的代码段</strong>.</p></li><li><p>更新 : 在头&#x2F;源文件发生变动时, 需要重新编译<code>.o</code>文件, 再将其重新加入静态库中, 如果原来有就会覆盖.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将 add.o 归并到 math 库中</span><br>ar rcs libmath.a add.o<br></code></pre></td></tr></table></figure></li></ul><h3 id="动态库-so-dll"><a href="#动态库-so-dll" class="headerlink" title="动态库( .so &#x2F; .dll )"></a>动态库( .so &#x2F; .dll )</h3><p>同样也是一种存储<code>.o</code>文件的形式, 其与静态库的差异主要在使用方式.</p><ul><li><p>目的 : 和静态库相同, 也是直接使用现成的<code>.o</code>文件跳过编译阶段, 但是其具体实现有很大差异.</p></li><li><p>生成 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译为位置无关代码</span><br>gcc -fPIC -c add.c sub.c<br><span class="hljs-comment"># 链接成动态库</span><br>gcc -shared -o libmath.so add.o sub.o<br></code></pre></td></tr></table></figure></li><li><p>使用 : 与静态库一致.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc main.c -L. -lmath -o main<br></code></pre></td></tr></table></figure></li><li><p>更新 :  动态库没有静态库类似的归并动作, 直接文件替换就行, 但是需要考虑链接问题 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 直接新增或替换</span><br><span class="hljs-built_in">cp</span> libmath.so.1.0.1 /usr/lib/  <br><span class="hljs-comment"># 将原本的链接导向新动态库</span><br><span class="hljs-built_in">ln</span> -sf libmath.so.1.0.1 /usr/lib/libmath.so.1<br></code></pre></td></tr></table></figure></li><li><p>底层实现 : </p><p>在连接过程中, 链接器<strong>会告诉可执行文件需要的<code>.o</code>文件在哪里</strong>, <strong>不进行实际的拷贝, 而是让可执行文件在运行时将其加载到内存中, 可执行文件到内存中去找</strong>.</p></li><li><p>优势 : </p><ul><li>加载到内存的动态库可以被共享, 也就是说只进行一次到内存的加载即可, <strong>内存占用低</strong>.</li><li>动态库可以理解为可执行文件的外部依赖, 但并无实际关联, 动态库的更新无需可执行文件重新编译, <strong>更新便捷</strong>.</li></ul></li><li><p>劣势 : 虽然更新便捷, 但是事实上会带来很多版本兼容性问题.</p></li><li><p>问题 : 如果加载时找不到动态库, 一般会显示<code>undefined symbol</code>, 其实就是运行时找不到有对应定义的动态库文件. 一般可以通过查找其对应的动态库文件是否存在, 设置环境变量帮助编译器找到对应的动态库来实现.</p></li></ul><hr><h2 id="C-编译链接系统"><a href="#C-编译链接系统" class="headerlink" title="C++编译链接系统"></a>C++编译链接系统</h2><h3 id="前向声明"><a href="#前向声明" class="headerlink" title="前向声明"></a>前向声明</h3><blockquote><p>前向声明在C中就存在, 不过在C++中重要性被进一步提升了, 这里就放入了C++部分.</p></blockquote><p>用来<strong>降低编译依存性</strong>的最主要手段, 可以大大减少编译时间.</p><blockquote><p>有关编译依存性在我往期博客 Effective C++ 系列中提到过, 后面也会深入讲解.</p></blockquote><ul><li><p>什么是编译依存性?</p><p>一个头文件如果修改, 那么所有使用其的源文件就都要重新编译, 由于头文件很大可能是一个套一个的, 一个头文件的修改就会引发非常多的源文件需要重新编译, 这就是编译依存性, 而前向声明可以极大降低这种危害.</p></li><li><p>什么是前向声明? </p><ul><li><p>在头文件中对函数进行声明, 可以视为一种最基础的前向声明, 表明在源文件中有其定义, 实现了函数声明与定义的解耦.</p></li><li><p>还有一种<strong>class的前向声明</strong>, 形式为<code>class PersonImpl;</code>保证有这样一个类型, 实现了类型声明与定义的解耦.</p><p>但是最为重要的是, 使用class前向声明有一个必须的前置规则 : </p><ul><li><strong>不可以访问该class的成员</strong>或<strong>执行需要知晓该class大小的行为(如建立实参等)</strong>.</li></ul><p>因为以上两种行为代表编译器必须要知道class的定义才能实现, 使用定义必须包含头文件而非前向声明.</p><p>不过一般也不需要记”不可以”怎样, 这里给出两种”可以”的情况 : </p><ul><li><strong>只使用指针或引用</strong>(Foo* or Foo&amp;), 因为指针大小是固定的, 不需要实际定义.</li><li><strong>作为函数的参数或返回类型</strong>, 并且不在该头文件的其他地方调用该函数.</li></ul></li></ul><p>这里举一个例子 : Person需要组合一个Name类实现自己的功能 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-function">std::string <span class="hljs-title">getname</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>Name* name;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// name.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Name</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function">std::string <span class="hljs-title">getname</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> name; &#125;<br><span class="hljs-keyword">private</span>:<br>std::string name;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;name.h&quot;</span></span><br><span class="hljs-function">std::string <span class="hljs-title">Person::getname</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> name-&gt;<span class="hljs-built_in">getname</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会发现, 虽然在<code>person.h</code>中<strong>用到了Name的指针</strong>, 但我们只需要前向声明保证有这个类型, 就无需再包含对应的头文件.</p><p>相应的, 我们会<strong>在源文件中包含对应的头文件</strong>, 在源文件中实现对Name的使用.</p><p>为了深入理解前向声明的作用, 我们用一个图来解释 : </p><p><img src="/../img/image/5.png"></p><p>这里我们用实线代表包含, 虚线代表前向声明. </p><ul><li><code>1.h</code>包含于当前头文件, 那么如果该文件发生修改, 那么源文件1234就都要重新编译.</li><li><code>2.h</code>前向声明于当前头文件, 包含于<code>1.cpp</code>, 那么如果该文件发生修改, 就只有<code>1.cpp</code>需要重新编译, 不会影响到其他源文件.</li></ul></li></ul><h3 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h3><p>这是一个基于前向声明降低编译依存性的典型方案, 我在Effective C++系列讲解过, 在此引用并加入一些新的理解 : </p><p>本方案以<strong>pimpl idiom</strong>手法为核心, <code>Handle classes</code>意为使用句柄的类, 这个句柄就是<strong>pimpl idiom</strong>手法的指针, <code>Person</code>类还是和上文一致, <code>PersonImpl</code>类<strong>应当和Person有着完全相同的成员函数, 并且有原本Person预想拥有的成员变量</strong>,  可以理解为<code>PersonImpl</code>才是真正的<code>Person</code>类, 以后所有的修改将在<code>PersonImpl</code>中进行.</p><p>一般来说我们要实现三个文件, 一个<code>Person.h</code>存放供客户使用的接口类, 一个<code>PersonImpl.h</code>存放对应接口类的实现类, 一个<code>Person.cpp</code>实现<code>Person</code>中函数声明的对应定义.  有点麻烦, 可以看代码理解, 接下来将给出两个分别封装接口类和实现类的头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h  存放接口类, 和上文一致</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// PersonImpl.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n) ,_birthDate(b) ,_address(a)<br>    &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp  在该文件实现接口类和实现类的真正关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PersonImpl.h&quot;</span></span><br><br><span class="hljs-comment">// 完成对接口类中声明函数的定义</span><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_shared</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span>  <span class="hljs-comment">// 只需包含接口类即可</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, date, addr)</span></span>;<br>cout &lt;&lt; p.<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里重申一下Handle classes的使用方式 : </p><ul><li>头文件分为接口类和实现类, 二者有<strong>完全相同的函数声明</strong>.</li><li>接口类<strong>前向声明实现类</strong>, 拥有实现类的指针.</li><li>实现类拥有所有成员变量, 包含各种与其相关的头文件.</li><li>在源文件<code>.cpp</code>中, 同时包含这两个类, <strong>让接口类(如 <code>Person</code>)的成员函数调用实现类(如 <code>PersonImpl</code>)的对应函数</strong>.</li></ul><p>可以通过下图加深理解 : </p><p><img src="/../img/image/6.png"></p><p>这种手法相比于最初的前向声明使用方法, 界限划分更加明显, 并且接口类的修改频率可以进一步降低, 因为<strong>其内部只前向声明了实现类</strong>, 无需前向声明其他类. 同时依旧保证了对实现类的修改不会影响包含了的接口类的源文件.</p><blockquote><p>下面介绍各种C++特性引发的编译过程变化 :</p></blockquote><h3 id="名字改编-name-mangling-与-函数重载"><a href="#名字改编-name-mangling-与-函数重载" class="headerlink" title="名字改编(name mangling) 与 函数重载"></a>名字改编(name mangling) 与 函数重载</h3><p>在C的链接阶段中描述一个函数一般都是直接用函数名, 因为C不允许函数同名, 在C++中为了契合函数重载, <strong>函数名会在前面的编译或汇编阶段在底层被修改, 通常是利用其返回值与参数配合原名进行修改</strong>, 使得在编译阶段不存在同名函数, 这种处理方式被称为 <code>name mangling</code>.</p><ul><li><p><code>extern &quot;C&quot;;</code> </p><p>这是C++为了适配C提供的声明语句. 声明此语句的头文件, <strong>表示其内部的函数是C风格的, 不受<code>name mangling</code>的影响</strong>.</p></li></ul><h3 id="ODR-One-Definition-Rule-原则"><a href="#ODR-One-Definition-Rule-原则" class="headerlink" title="ODR(One Definition Rule)原则"></a>ODR(One Definition Rule)原则</h3><ul><li><p>What :  <strong>在整个程序中，每个变量、函数、类、模板、枚举等实体只能有一个定义。</strong></p></li><li><p>Why :  因为C&#x2F;C++编译链接采取<strong>编译链接分离原则</strong>. 编译阶段取得的目标机器码, 必须要对于链接合法, 假如多个目标机器码(<code>.o</code>)合并后发现有重复的定义, 会导致链接失败.</p></li><li><p>How : </p><ul><li><p>不能在多个 <code>.cpp</code> 文件中定义同一个全局变量或普通函数。</p></li><li><p>一个含有全局变量或非 inline 函数的<code>.h</code>文件不能被参与编译的多个<code>.cpp</code>文件包含.</p></li></ul></li></ul><h3 id="基于ODR的例外处理"><a href="#基于ODR的例外处理" class="headerlink" title="基于ODR的例外处理"></a>基于ODR的例外处理</h3><p>前文说”合并<code>.o</code>文件在发现有重复定义后会直接链接失败”, 但是这种处理是有例外情况, 以下是情况列举 : </p><ul><li><p>inline 函数</p></li><li><p>模板的实例化结果（函数模板、类模板成员函数）</p></li><li><p><code>constexpr</code> 函数</p></li><li><p>类定义（尤其是 <code>inline</code> 成员函数）</p></li><li><p>inline 变量（C++17）</p></li></ul><p>现在先不要理解这些情况具体是什么, 后面会有详细的介绍, 只需要知道<strong>这些情况都会在编译阶段产生相同的定义后触发例外处理的机制</strong>.</p><p>例外处理一般是这样的 : <strong>如果有多个相同定义，保留一个，丢掉其他</strong>. </p><p>这种例外处理其实是编译器对于C++语法的一种妥协, 也在一定程度上是<strong>代码膨胀的根源</strong>. 进一步理解就是多个<code>.o</code>文件合并时, 丢弃掉的生成码都是多余浪费的, 而由于C底层的编译链接分离机制在根本上无法解决.</p><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><ul><li><p>错误认知 : </p><p>在学习inline初期很多人都将inline和内联展开进行了强关联, 但在现代C++这两者的关联非常微弱, 可以认为是完全不同的两个东西.</p></li><li><p>内联展开 : </p><p>编译器会在编译期间将一些函数调用直接替换为函数内部的代码, 其实际意义在于省去了函数调用复杂的步骤, 但是如果函数实际代码很长, 拷贝一遍的代价反而不如直接调用, 那就得不偿失了. 但是这不是我们需要考虑的, <strong>编译器会衡量是否应该使用内联展开</strong>. 许多教材中会表明inline关键字会”建议”函数进行内联展开, 但是这种建议其实也是近乎无效的,可以不纳入考虑.</p></li><li><p>真正意义 : </p><p><strong>inline函数允许在头文件中多次定义, 并遵守 ODR.</strong></p><p>其实就是解决了”一个头文件被多个源文件包含, 其中的函数由于同名会产生链接错误”的情况, 编译器和链接器会把其当成上面的例外情况处理.</p><p><strong>这种显示声明inline的函数</strong>, <strong>必须在头文件中实现定义</strong>, 因为链接器要确定只有这一个版本的定义并且所有调用点都可以看到完整的函数体.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// math.h</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-comment">// a.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><span class="hljs-type">int</span> a = <span class="hljs-built_in">square</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// b.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;math.h&quot;</span></span><br><span class="hljs-type">int</span> b = <span class="hljs-built_in">square</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><p>假如想把上面两个源文件合并编译为可执行文件, 在链接阶段就会发生报错, 但是如果<code>square</code>函数设置inline就不会报错.</p></li><li><p>inline 变量 : </p><p>在C++17引入, 但其思想内核与inline函数一致, 都是为了防止重定义带来的链接错误.</p></li><li><p>认知修正 : </p><p><strong>inline关键字与性能无关, 其真正目的是为了防止重定义带来的链接错误</strong>.</p></li></ul><h3 id="constexpr-函数"><a href="#constexpr-函数" class="headerlink" title="constexpr 函数"></a>constexpr 函数</h3><p>常量表达式函数, 这种函数如果编译器检测出可以直接求值, 那么编译器会直接将其替换为计算结果. </p><p>其底层其实采用了inline的机制, 你可以认为其自带一个inline关键字, 因此可以触发ORD的例外处理.</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>这里不细究模板本身, 主要理解和编译相关的模板实例化部分.</p><ul><li><p>模板实例化 : </p><p>简单理解就是<strong>在编译阶段会根据拿到的实际类型&#x2F;参数代入获得实例化的代码</strong>, 有以下需要注意的地方 : </p><ul><li>只要模板类型或模板参数不同, 就要生成一份额外的实例.</li><li>由于编译单元之间是相互独立的, 假如不同源文件中会使用相同的类型或参数生成模板, 依旧会生成两份相同的代码, 在链接阶段再根据例外处理留下一份, 这会造成实际的代码膨胀和浪费.</li></ul></li><li><p><code>extern template</code> : </p><p>该语法于C++11引入, 其作用是<strong>显式禁止某个模板在当前翻译单元内自动隐式实例化</strong>.</p><p>其实就是针对我们上面提到的第二点注意, 当我们意识到多个文件中如果使用了相同的实例化, 就可以<strong>只留一个执行实例化</strong>. </p><p>具体操作一般是<strong>在公共头文件中使用该语法, 禁止所有使用了该模板的源文件进行实例化, 再在一个源文件中显示实例化一次</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在头文件中</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::basic_string&lt;<span class="hljs-type">char</span>&gt;; <span class="hljs-comment">// 禁止自动生成</span><br><br><span class="hljs-comment">// 在一个 .cpp 文件中</span><br><span class="hljs-keyword">template</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">std</span>::basic_string&lt;<span class="hljs-type">char</span>&gt;; <span class="hljs-comment">// 显式生成一次</span><br></code></pre></td></tr></table></figure><p>在一个要被广泛使用的模板头文件中使用该操作, 可以有效缓解代码膨胀, C++标准库就广泛使用了这种技术.</p></li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static关键字主要作用是<strong>控制存储期和控制链接类型</strong>.</p><ul><li>链接类型 : 这是针对<strong>名称</strong>的概念, 如函数名, 变量名, 类名, <strong>描述其在不同翻译单元的可见性</strong>.<ul><li>外部链接 : 该名称在不同编译单元可见, 也就是跨源文件共享, 普通函数&#x2F;变量, inline函数&#x2F;变量, 模板函数&#x2F;变量 均属于外部链接. </li><li>内部链接 : 仅当前所处翻译单元可见, 只可在当前源文件中使用, 其他源文件不可获取, 即 static函数&#x2F;变量.</li><li>外部链接出现同名会报错, 但有很多例外处理; 内部链接在不同翻译单元可以同名, 互不影响.</li></ul></li></ul><p>static控制存储期为全局且唯一, 并且链接类型为内部链接, 也就是说只针对所处翻译单元.</p><p>,</p><h2 id="C-20-Modules-模块"><a href="#C-20-Modules-模块" class="headerlink" title="C++20 Modules (模块)"></a>C++20 Modules (模块)</h2><blockquote><p>对于C++20模块机制, 将会以 初步认知 -&gt; 简易使用 -&gt; 底层详解 -&gt; 复杂使用 的方式进行</p></blockquote><h3 id="初步认知"><a href="#初步认知" class="headerlink" title="初步认知"></a>初步认知</h3><p>C++20 Modules 抛弃了以<code>.h</code>文件为核心的<strong>文本替换</strong>的预处理过程, 转而支持以<code>.ixx</code>文件为核心的<strong>模块导出</strong>.</p><p>我们可以在<code>.ixx</code>文件中做出近乎<code>.h</code>文件的所有操作, 只需要添加一些特殊用于表明模块的关键字即可, 编译器便会在底层帮我们实现模块的支持.</p><p>模块在实际中可以大大加快编译速度, 减少代码膨胀, 对于编译依存性也有实质性的改善, 可以理解为是对于C&#x2F;C++编译系统的现代进化.</p><p>我们先学习模块的简易使用, 再进行后面深入的理解.</p><h3 id="初步使用"><a href="#初步使用" class="headerlink" title="初步使用"></a>初步使用</h3><p>就像原本<code>.h</code>和<code>.cpp</code>的组合一样, 我们也可以写一个<code>.ixx</code>和<code>.cpp</code>的组合.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// math.ixx</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> math;             <span class="hljs-comment">// 声明一个“可导出的”模块接口</span><br><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>;   <span class="hljs-comment">// 普通函数</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-comment">// 模板函数(需要实现定义)</span><br><span class="hljs-function">T <span class="hljs-title">sub</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a - b; &#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec2</span> &#123;<span class="hljs-comment">// 结构体 / 类</span><br>    <span class="hljs-type">double</span> x&#123;&#125;, y&#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// math_impl.cpp</span><br><span class="hljs-keyword">module</span> math;                    <span class="hljs-comment">// 说明“这是 math 模块的实现单元”</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>expert</code>  : </p><p>表示<strong>导出</strong>, 可以比较直观的理解这个动作, 就是把代码导出, 放在一个地方随时供使用. </p><ul><li><code>export module 名称;</code>   一个<code>.ixx</code>文件中只有一个, 用来表述导出的模块名, 模块名可以供其他文件导入使用.</li><li>再想要暴露给外部的函数&#x2F;类前加该关键字, 就会将其暴露其给导入该模块的文件, 可以用其控制可见性.</li></ul></li></ul><p>于是我们就可以通过<code>import</code>导入模块了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> math;                    <span class="hljs-comment">// 导入模块</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">sub</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>现在我们深入了解模块机制在编译期做了什么, 以实现一开始所说的优秀效果.</p><ul><li><p><code>.pcm</code> (Precompiled Module file) :</p><p><strong>预编译模块文件</strong>, 又称为<strong>语义单元</strong>. 每一个<code>.ixx</code>模板文件在编译阶段都会生成一个<code>.pcm</code>文件, 存储在系统中供后续编译使用. 我们知道在编译阶段, <code>include</code>头文件会执行文本替换, 并且编译器会进行语义分析生成语义树, 从而知道如何使用这些代码. 而<code>import</code>模板文件则是会直接调用<code>.pcm</code>文件, 你可以简单理解为其<strong>直接告诉你怎么使用这些代码</strong>, 从而<strong>跳过了文本替换和语义分析过程</strong>.</p><p><code>.pcm</code>中<strong>没有实际的机器码</strong>, <strong>有的只是语义信息(比如函数&#x2F;类名称, 参数等)</strong>, 告诉你怎么用. 真正的机器码在<code>.ixx</code>文件对应的那个<code>.cpp</code>文件所正常编译出来的<code>.o</code>文件中, 在链接阶段会直接导向这个<code>.o</code>文件, 也就是说整个过程中只有这一份机器码被频繁使用, 不会产生额外的编译.</p><p>并且<code>.pcm</code>也有类似于<code>.o</code>文件的存储机制. 在一次构建中, 新构建出来的<code>.pcm</code>文件将被存储, 除非模块文件的实现发生修改, 不然后续都会使用先前构建出来的这个<code>.pcm</code>文件, 这会大大减少编译实际.</p><p>这里需要明确一个概念 : <code>.pcm</code>是被用来进行<strong>跨TU(编译单元)交流</strong>的, 你可以理解为模块文件会提供一个<code>.pcm</code>文件用来告知其他编译单元中<code>import</code>它的源文件它怎么用.</p><p><code>.pcm</code>是GCC编译器给出的后缀, 在不同的编译器会有不同的后缀这里不细究, 但这种文件一般被统称为<strong>BMI</strong>.</p></li><li><p>编译顺序 : </p><p>上面遗留了一个非常关键的问题需要讨论 : </p><ul><li><strong>每个TU之间是相互独立的, 那么是如何保证模块文件的编译一定在其他编译单元之前的呢?</strong></li></ul><p>假如不保证, <code>.pcm</code>文件根本就没有生成, 也就不用讨论其他文件怎么使用了.</p><p>解决办法是 : <strong>C++要求编译器强制控制编译顺序</strong>, 也就是说虽然每个TU相互独立, 但是编译的顺序是可以调整的.</p><p>具体调整方式是 : 在构建初期会<strong>依据模块的依赖关系构造拓扑图</strong> (因为不同模块之间也有可能有依赖, 这点后面再议) , <strong>依照拓扑图的顺序进行编译</strong>.</p><p>这种编译顺序的硬性要求, 是使得<code>.pcm</code>文件可以实现跨TU交流的根基.</p></li><li><p>整体逻辑 : </p><ul><li><p>依据模块依赖关系构建拓扑图, 按序进行开始编译.</p></li><li><p>编译阶段(每个TU相互独立) : </p><p>模块文件 : 生成唯一的<code>.pcm</code>文件和<code>.o</code>文件. </p><p>普通文件 : 无模块导入, 照旧生成普通<code>.o</code>文件; 有模块导入, 获取对应<code>.pcm</code>文件, 依据其指导生成<code>.o</code>文件, 其中符号表中会对模块函数&#x2F;类显示<strong>引用但未定义(U)</strong>, 需要链接器帮忙寻找拥有其定义的目标机器码(T).</p></li><li><p>链接阶段 : </p><p>链接器汇聚所有<code>.o</code>文件, 依旧执行符号解析, 重定位, 节段等操作, 这里对于引用了模块文件的<code>.o</code>文件, 链接器会帮它们找到模块文件对应的目标机器码.</p></li></ul></li></ul><h3 id="与头文件的对比"><a href="#与头文件的对比" class="headerlink" title="与头文件的对比"></a>与头文件的对比</h3><table><thead><tr><th>特性</th><th>头文件模式</th><th>模块模式</th></tr></thead><tbody><tr><td>依赖获取方式</td><td>预处理文本替换</td><td>语法级 import</td></tr><tr><td>编译顺序</td><td>由 include 顺序隐式决定</td><td>由依赖图显式决定</td></tr><tr><td>依赖追踪</td><td>无（编译器不知道完整依赖图）</td><td><code>.pcm</code> 存完整依赖关系</td></tr><tr><td>重复解析</td><td>每个 TU 重新解析头文件</td><td><code>.pcm</code> 一次解析多次加载</td></tr><tr><td>重复实现</td><td>每个 TU 生成一份（ODR 合并）</td><td>单一实现（唯一 <code>.o</code>）</td></tr></tbody></table><h3 id="导出方式"><a href="#导出方式" class="headerlink" title="导出方式"></a>导出方式</h3><ul><li><p>批量导出 : 除了在函数&#x2F;类&#x2F;变量前加<code>export</code>来实现导出, 还可以用花括号包住进行批量导出 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123; ... &#125;;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>转发导出 : </p><p>一个模块文件可以通过<code>import</code>导入其他文件, 但是这样导入的模块接口只能自己使用, 不会对外暴露, 这是与<code>include</code>机制本质不同的. 因此我们如果想要把这些接口暴露出去, 那么可以使用转发导出, 语法形式为<code>export import</code> + 模块名.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> other_module;<br></code></pre></td></tr></table></figure></li></ul><h3 id="模块分区"><a href="#模块分区" class="headerlink" title="模块分区"></a>模块分区</h3><p>该技术用来将<strong>一个模块文件拆分成一主多副</strong>, 虽然拆分成了多个模块文件, 但是其本质还是同属同一个模块.</p><p>这种技术的核心价值还是在于<strong>分类</strong>, 让一个模块的功能划分与结构更加清晰, 在底层也许会在依赖方面有一定的优化, 但是你可以认为这都是附带的. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1) 主接口单元</span><br><span class="hljs-comment">// M.ixx</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> M;              <span class="hljs-comment">// 一个文件里只能有一次</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :core;          <span class="hljs-comment">// 把导出分区“并入”公共接口</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">int</span> <span class="hljs-title">api</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 2) 导出分区（接口分区）</span><br><span class="hljs-comment">// M.core.ixx</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> M:core;         <span class="hljs-comment">// 声明这是“可导出的分区（接口分区）”</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(T a, T b)</span> </span>&#123; <span class="hljs-keyword">return</span> a + b; &#125;<br><br><span class="hljs-comment">// 3) 内部分区</span><br><span class="hljs-comment">// M.detail.ixx</span><br><span class="hljs-keyword">module</span> M:detail;              <span class="hljs-comment">// 仅供模块 M 内部导入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><br><span class="hljs-comment">// 4) 实现单元</span><br><span class="hljs-comment">// M_impl.cpp</span><br><span class="hljs-keyword">module</span> M;                     <span class="hljs-comment">// 不是分区，M 的实现单元</span><br><span class="hljs-keyword">import</span> :detail;               <span class="hljs-comment">// 只能在 M 内部导入内部分区</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">api</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">helper</span>(<span class="hljs-number">42</span>); &#125;<br></code></pre></td></tr></table></figure><p>一般是如下对一个模块进行划分的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> M;           <span class="hljs-comment">// 主接口：只放门面、稳定声明</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">import</span> :api;        <span class="hljs-comment">// 导出分区：对外模板/内联（尽量稳定）</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> M:api;       <span class="hljs-comment">// 导出分区（少而稳）：模板/内联的小逻辑</span><br><span class="hljs-comment">// 导出少量真正需要对外可见的定义</span><br><br><span class="hljs-keyword">module</span> M:detail;           <span class="hljs-comment">// 内部分区：实现细节、第三方适配、重头依赖</span><br><span class="hljs-comment">// 大实现、重依赖、私有类型都放这里</span><br><br><span class="hljs-keyword">module</span> M;                  <span class="hljs-comment">// 实现单元：非模板大实现（.cpp 风格）</span><br></code></pre></td></tr></table></figure><h3 id="全局模块片段（Global-Module-Fragment-GMF）"><a href="#全局模块片段（Global-Module-Fragment-GMF）" class="headerlink" title="全局模块片段（Global Module Fragment, GMF）"></a>全局模块片段（Global Module Fragment, GMF）</h3><p>该机制主要用于<strong>旧式头文件与模块文件的兼容</strong>, 如果想要使用旧式头文件的函数进行模块文件内容的实现, 最好使用此机制, 使用方法如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">module</span>;                  <span class="hljs-comment">// ① 开始 Global Module Fragment</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>      <span class="hljs-comment">// ② 可以放传统头文件（旧式 include）</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;legacy.h&quot;</span>      <span class="hljs-comment">//    甚至本地的非模块化头文件</span></span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> mymod;     <span class="hljs-comment">// ③ 正式进入模块接口部分</span><br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>规则为 : <strong>在<code>module;(固定)</code>和<code>export module</code>之间添加头文件</strong>.</p><p>其中的头文件会<strong>正常进行文本替换, 并且不会被处理到<code>.pcm</code>等BMI文件中</strong>, 头文件中的内容都可以在本模块中被使用. 其优势在于<strong>隔绝了编译依赖</strong>, 本模块包含的头文件发生变化不会影响到其他包含本模块的代码.</p><p>假如不使用GMF而直接包含头文件, 头文件中的内容将不会进行文本替换并被正常处理到<code>.pcm</code>中, 会产生依赖传递, 并且宏会失效.</p><h3 id="私有模块片段（Private-Module-Fragment-PMF）"><a href="#私有模块片段（Private-Module-Fragment-PMF）" class="headerlink" title="私有模块片段（Private Module Fragment, PMF）"></a>私有模块片段（Private Module Fragment, PMF）</h3><p>和GMF相似, 但是与兼容无关, 目的只是为了<strong>隔绝编译依赖</strong>, 不让在接口文件中内容暴露出去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> image;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Image</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><br><span class="hljs-keyword">module</span> :<span class="hljs-keyword">private</span>;         <span class="hljs-comment">// ← 从这里起是“私有片段”，只对本接口单元可见</span><br><span class="hljs-comment">// 这里写一些只在本单元使用的实现细节/包含/静态对象等</span><br></code></pre></td></tr></table></figure><p>规则为 : 模块接口文件<strong>末尾</strong>使用<code>module :private;</code> , <strong>后续的任何实现都不会被处理到<code>.pcm</code>等BMI文件</strong>, 仅在本模块可见.</p><p>其实这些实现代码都应该在<code>.cpp</code>中实现, 但是有时出于便利或排版, 也完全可以考虑以PMF的形式写入模块接口文件.</p><h3 id="编译依存性相关"><a href="#编译依存性相关" class="headerlink" title="编译依存性相关"></a>编译依存性相关</h3><p>即使使用C++20模块, 编译依存性的问题依旧存在, 这是不可避免的, 因为只要存在模块和模块之间存在依赖, 只要发生接口修改, 就会像头文件包含头文件一样发生依赖传递, 不过C++20模块在依赖传递上做出了比较大的限制 :</p><ul><li><p>使用头文件会发生<strong>文本替换</strong>, 也就是说<strong>文本变化 &#x3D; 需要重新编译</strong>; 但使用模块会发生<strong>BMI文件调用</strong>, 也就是说文本变化不等于需要重新编译, <strong>没有加入BMI的内容, 怎么修改都无需重新编译</strong>, 我们可以使用PMF辅助.</p></li><li><p>默认<code>import</code>的模块外部不可见, 除非采用<strong>转发导入</strong><code>export import</code>, 让依赖传递更加可控.</p></li><li><p><strong>内部分区</strong>的机制鼓励程序员在模块内部分区构建实现类, 实现接口与实现分离, 从而隔绝依赖.</p></li></ul><p>因此<code>pimpl idiom</code>手法依然有效, 可以帮我们将所有实现隐藏在实现类中, <strong>在隔绝依赖的同时避免向外部暴露代码</strong>.</p><p>下面是C++20模块版本的 Handle Class : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// person.ixx（主接口单元，导出 API）</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> person;<br><span class="hljs-keyword">import</span> &lt;memory&gt;;<br><span class="hljs-keyword">import</span> &lt;string&gt;;<br><span class="hljs-comment">// 只做前置声明；不引入重头，避免污染 BMI</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><span class="hljs-comment">// 不导出，实现类仅做前置声明即可</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr);<br>    ~<span class="hljs-built_in">Person</span>();                                  <span class="hljs-comment">// 声明析构，在实现单元里定义（关键点）</span><br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 用 unique_ptr 最稳：默认 deleter 需要完整类型，但我们把析构定义放到实现单元</span><br>    std::unique_ptr&lt;PersonImpl&gt; pImpl;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// person.detail.ixx（内部分区，放实现细节）</span><br><br><span class="hljs-keyword">module</span>;                 <span class="hljs-comment">// 全局模块片段：这里可以吃“老头”</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">module</span> person:detail;<br><br><span class="hljs-comment">// 真正的实现类（完全不导出）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        : _name(n), _birthDate(b), _address(a) &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>        </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>     </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date        _birthDate;<br>    Address     _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// person_impl.cpp（实现单元，定义 Person 成员）</span><br><span class="hljs-keyword">module</span>; <br><span class="hljs-keyword">module</span> person;   <span class="hljs-comment">// 注意：不是 export</span><br><span class="hljs-keyword">import</span> :detail;         <span class="hljs-comment">// 用到内部分区里的 PersonImpl</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_unique</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br>Person::~<span class="hljs-built_in">Person</span>() = <span class="hljs-keyword">default</span>;  <span class="hljs-comment">// 在这里生成析构：此处已见到 PersonImpl 完整类型</span><br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>      </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure><p>你可以理解为把原来另开一个头尾件的形式改为给模块开一个内部分区, 但实质都是在存放实现类.</p>]]></content>
    
    
    
    <tags>
      
      <tag>编译链接</tag>
      
      <tag>C++20模块</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP/3</title>
    <link href="/2025/08/05/HTTP3/"/>
    <url>/2025/08/05/HTTP3/</url>
    
    <content type="html"><![CDATA[<h2 id="生态分析"><a href="#生态分析" class="headerlink" title="生态分析"></a>生态分析</h2><h3 id="TCP队头阻塞"><a href="#TCP队头阻塞" class="headerlink" title="TCP队头阻塞"></a>TCP队头阻塞</h3><p>这是HTTP&#x2F;2所拥有的根本性通病, 注意这里的队头阻塞<strong>不是指排队造成的阻塞</strong>, <strong>而是指丢包造成的阻塞</strong>. TCP为了实现可靠有序, 采用了超时重传机制, 该机制可以确保可靠有序, 但是对于现代网络却有严重缺陷.</p><p>TCP中如果发送出现丢包, <strong>必须要依靠超时重传等到当前包再次发来</strong>, 后面的包才能生效, 即使已经发来了, 后面的包也不能及时处理和使用, 这是在内核中就强制决定的事情, 上层根本无法干预, 其根本在于TCP”<strong>面向字节流</strong>“的本质.</p><p>因此HTTP&#x2F;2的根本问题在于TCP队头阻塞, 也就是TCP本身, 而TCP想要升级是非常艰难的.</p><h3 id="UDP-vs-TCP"><a href="#UDP-vs-TCP" class="headerlink" title="UDP vs TCP"></a>UDP vs TCP</h3><p>HTTP&#x2F;3最终选择了使用QUIC+UDP, QUIC先不详述, 可以理解为其可以利用UDP对TCP实现了约等于上位替代的效果. 下面将详述其原因 : </p><ul><li><p>升级因素 : </p><ul><li>UDP是极简的协议, 在各个操作系统中的底层实现很少, “留白”非常多, 在<strong>应用层可以主导UDP协议的用户态升级</strong>.</li><li>TCP协议相对复杂, 有很多定死的规则, 这些是在操作系统中实现的, 应用层无法触及, 但是不同操作系统在底层的实现既庞杂又不尽相同, 很难实现操作系统层面统一的升级.</li></ul></li><li><p>商业因素 : </p><p>基于上面的升级因素, TCP的升级会牵扯到整个操作系统社区, 基本无法有什么人来主导升级. 而UDP在不同操作系统中几乎统一, 不存在操作系统上的影响, 其大头始终在应用层的处理, 因此体量较大的公司就可以主导基于UDP的升级, QUIC就是谷歌主导开发的,  这种方式更受当下商业模式的青睐.</p></li><li><p>设计局限 : </p><p>也许这个才算最重要的原因, 就像上面说的TCP的问题导向可以简化如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">TCP队头阻塞 -&gt; 超时重传低效 -&gt; 面向字节流避无可避<br></code></pre></td></tr></table></figure><p>面向字节流这种无边界的设计必须要用这种类似超时重传的机制来补足, 效率必须为此让步, 这是设计上的局限.</p><ul><li><p>所以为什么一开始要使用TCP这种面向字节流的协议?</p><p>因为设计者一开始的目的是为了设计一种<strong>既通用又安全可靠</strong>的通信协议, 面向字节流完美匹配了通用的特性, 因为字节是计算机铁打不动的特性, 可以适应所有的通信任务, 就算会在效率上做出让步, 也在很多地方可以做到一劳永逸, 减少特殊结构体的设计. 现在出现的QUIC完全是因为当下社会对于通信的效率要求迅速提高导致, 其虽然确实可以做到上位替代, 但编码成本,复杂度都会提高, 通用性也会降低. 这里补充一条ai出来的评价 “QUIC 是高性能系统通信中针对效率、低延迟、抗队头阻塞设计的现代方案，牺牲的是实现成本、通用性与对中间设备的透明兼容. “.</p></li></ul></li></ul><hr><h2 id="TLS-1-3-安全加密协议"><a href="#TLS-1-3-安全加密协议" class="headerlink" title="TLS 1.3 (安全加密协议)"></a>TLS 1.3 (安全加密协议)</h2><h3 id="TLS-1-2"><a href="#TLS-1-2" class="headerlink" title="TLS 1.2"></a>TLS 1.2</h3><p>这是最基础最广泛的加密协议版本.</p><ul><li><p>为了实现机密性, 其使用了 <strong>非对称密钥交换 + 对称加密</strong> , 简单理解是使用了一些算法, 前者是通过公私钥使得双方在开始确定一个后期只有双方拥有的密钥, 后者则是利用这个密钥进行双方的交流.</p></li><li><p>非对称密钥交换 : </p><p>这里介绍最主流的<code>ECDHE</code>算法, 里面使用了椭圆曲线点乘.</p><ul><li>d为私钥, Q为公钥, G为公开可知的一个生成点, 通信双方都会生成一份自己的公私钥(a 和 b).</li><li>da &#x2F; db 都是1-n内的随机数.</li><li><code>Qa = da * G / Qb = db * G</code> , 公钥将会发给双方.</li><li><code>k = Qa * db = Qb * da = da * db * G</code>, k便是双方的共同密钥.</li></ul><p>至于为什么不可破解, 因为这里的 ***** 并非普通的乘法, 是<strong>椭圆曲线上的标量乘法</strong>, 肤浅理解就是 存在一种循环, 使得这种计算如果不知道对面的私钥, 仅凭计算破解可以有近乎无限的可能性, 是不可能的.</p><ul><li>前向保密 : <code>ECDHE</code>保证每次握手使用的私钥都是<strong>新的随机生成的私钥</strong>, 就算以前的私钥暴露也不会影响后面的通信.</li></ul></li><li><p>对称加密 : </p><p>简单来说就是用先前获得的共享密钥实现双方信息的快速加解密.</p><p>最主流的是<code>AEAD</code>模式, 不细究, 其实现了<strong>加密 + 完整性认证</strong>的一体原子化, 防止先解密再认证过程中可能出现的漏洞.</p></li><li><p>握手流程 : </p><p>握手建立连接共需<strong>2RTT</strong>.</p><ul><li>第一个RTT客户端发出请求, 服务端发出公钥给客户端.</li><li>第二个RTT客户端进入加密态, 发出公钥, 服务端接受后匹配成功也进入加密态, 发送匹配成功的字段.</li></ul></li><li><p>使用证书用来进行身份认证, 确保没有被中间人篡改, 一般是将<strong>私钥</strong>提供给CA进行<strong>数字签名</strong>, 发送过去后再用CA的公钥进行验证, 确保没有被篡改.</p></li></ul><h3 id="具体变动"><a href="#具体变动" class="headerlink" title="具体变动"></a>具体变动</h3><p>TLS1.3在TLS1.2的基础上主要是进行了简化和安全性的提升.</p><ul><li><p>将握手时间缩短到了<strong>1RTT</strong> : </p><p>具体是客户端在请求同时直接发出自己的公钥, 服务端接收进行匹配并发出自己的公钥及各种证书签名, 随后进入加密态, 客户端在接收匹配成功后也进入加密态. 这样就实现了1RTT实现连接建立.</p></li><li><p>会话恢复与0-RTT: </p><p>在以往每次握手与结束都是独立的, 但是TLS1.3要求可<strong>对过往的共享密钥与各种状态在会话层进行记录</strong>, 假如支持对旧密钥的使用, 客户端可以直接向服务端发出使用旧密钥的请求, 并直接进行加密数据的发送, 这种形式被称为”0-RTT”. 当然也是有一定风险的, 其<strong>与前向保密机制本质相悖</strong>, 越长久地记录与使用旧密钥, 被外部盗取的可能就越大, 需要对安全性做出妥协.</p></li><li><p>HKDF(密钥派生函数) : </p><p>ECDHE 负责“生成共享密钥”，HKDF 负责“把这个共享密钥变成一系列真正能加密通信的数据密钥”.</p></li><li><p>重放攻击 : </p><p>其本质在于<strong>欺诈服务器进行重复操作</strong>, 手段是重发截获的密文, 不去破解, 而是再次发送.</p></li></ul><hr><h2 id="QUIC-Quick-UDP-Internet-Connections"><a href="#QUIC-Quick-UDP-Internet-Connections" class="headerlink" title="QUIC (Quick UDP Internet Connections)"></a>QUIC (Quick UDP Internet Connections)</h2><p>QUIC重构了一个效果和TCP相近的以UDP为底层的网络通信协议, 抛去了TCP的缺点, 并且设计中与http&#x2F;2有很多相似的地方, 可以理解为其整合了TCP + HTTP&#x2F;2.</p><h3 id="QUIC报文"><a href="#QUIC报文" class="headerlink" title="QUIC报文"></a>QUIC报文</h3><ul><li><p>QUIC的报文以<strong>包</strong>为单位, 与UDP面向数据报的性质匹配.</p></li><li><p>一个包分为 Header 和 Payload(data).</p></li><li><p>Header 分为两种基础类, Long Header 和 Short Header, <strong>分别用于早期连接建立和数据传输</strong>.</p></li><li><p>Long Header : 下面是Long Header对应包的整体结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">+--------+--------+----------------------+--------------+------------------+--------------+<br>| <span class="hljs-number">1</span>B     | <span class="hljs-number">4</span>B     | DCID Len + DCID      | SCID Len + SCID | Packet Number   | Payload    |<br>| Flags  | Version| Destination Conn ID  | Source Conn ID  | (<span class="hljs-number">1</span><span class="hljs-number">-4</span> bytes)     | (frames)   |<br>+--------+--------+----------------------+--------------+------------------+--------------+<br></code></pre></td></tr></table></figure><table><thead><tr><th>字段名称</th><th>长度</th><th>类型说明</th><th>作用</th></tr></thead><tbody><tr><td><strong>Flags（首字节）</strong></td><td>1 byte</td><td>Bit 字段，包含包类型、包号长度等信息</td><td>指定包头类型、包号长度等</td></tr><tr><td><strong>Version</strong></td><td>4 bytes</td><td>uint32</td><td>指定使用的 QUIC 协议版本</td></tr><tr><td><strong>DCID Len + DCID</strong></td><td>1B + 可变</td><td>Length + byte[]</td><td>目标连接 ID（Destination Connection ID）</td></tr><tr><td><strong>SCID Len + SCID</strong></td><td>1B + 可变</td><td>Length + byte[]</td><td>源连接 ID（Source Connection ID）</td></tr><tr><td><strong>Packet Number</strong></td><td>1-4 bytes</td><td>uint8~uint32（根据Flag中指定）</td><td>包序号，用于重传与流控</td></tr><tr><td><strong>Payload</strong></td><td>可变</td><td>多个 Frame 的组合</td><td>包含握手数据（如 ClientHello）或流数据</td></tr></tbody></table><ul><li><p>Flags : 下面是在这个比特位中记录的信息 </p><table><thead><tr><th>比特位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>bits 7-6</td><td>固定 <code>11</code></td><td>表示是 Long Header</td></tr><tr><td>bits 5-4</td><td><strong>Packet Type</strong></td><td>包类型，决定是 Initial &#x2F; 0-RTT &#x2F; Handshake &#x2F; Retry</td></tr><tr><td>bits 3-2</td><td><strong>Packet Number Length (PNLen)</strong></td><td>Packet Number 字段的长度（0<del>3 表示 1</del>4 字节）</td></tr><tr><td>bits 1-0</td><td>Reserved</td><td>保留位，当前未使用（应设置为 0，接收方忽略）</td></tr></tbody></table><p>包类型后续详述, 包序号长度用于解析后面的包序号字段.</p></li><li><p>DCID(目标连接id) &#x2F; SCID(源连接id) : </p><p>其作用为标识唯一的一个连接, 在握手阶段还可以确立双向连接. 需要明确的是, UDP本身是<strong>无连接</strong>的, 这个连接机制是QUIC在上层为UDP额外设计的, 目的是为了在上层监视控制连接状态, 使其可以像TCP一样随时获取连接信息.</p><p>在握手阶段中, 客户端发送的SCID(随机生成)将被服务端用作连接的DCID, 服务端发送的SCID也会被客户端用作DCID, 以此实现连接的建立.</p><p>一个服务器可以和多个客户端有多条QUIC层面上的连接, 但是一对一情况下只能有一条连接.</p></li><li><p>Packet Number 相关的重传流控机制后面详述.</p></li><li><p>Payload 就是存放数据的字段,  但其中的单位为frame, frame有不同的类型, 后面详述.</p></li></ul></li><li><p>Short Header : 下面是Long Header对应包的整体结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">+--------+----------------------+--------------+--------------+<br>|  Flags | Destination Conn ID  | Packet Number| Payload      |<br>|   <span class="hljs-number">1</span>B   |        <span class="hljs-number">8</span>B            | (<span class="hljs-number">1</span><span class="hljs-number">-4</span> bytes)  | (frames)     |<br>+--------+----------------------+--------------+--------------+<br></code></pre></td></tr></table></figure><ul><li><p>Flags : Short Heder中的Flags和前者中的Flags有所不同.</p><table><thead><tr><th>比特位</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>bit 7</td><td>固定为 <code>0</code></td><td>表示 Short Header</td></tr><tr><td>bit 6</td><td><strong>Key Phase (K)</strong></td><td>用于密钥轮换：表示当前是否需要密钥轮换</td></tr><tr><td>bit 5</td><td>固定为 <code>0</code></td><td>保持格式一致（保留）</td></tr><tr><td>bit 4</td><td><strong>Spin Bit (S)</strong></td><td>可用于 RTT 测量，非加密，中间设备可观测</td></tr><tr><td>bits 3-2</td><td><strong>PNLen</strong></td><td>Packet Number 长度（00 ~ 11 表示 1 ~ 4 字节）</td></tr><tr><td>bits 1-0</td><td><strong>Reserved</strong></td><td>保留位，应随机设置，接收端忽略</td></tr></tbody></table></li></ul></li><li><p>Frame(帧)</p><p>这就是payload字段中的基本单元, 也可以近似为数据传输的基本单元.</p><ul><li><p>形式通常为 <code>Frame Type(1B)</code> + <code>根据type追加的各种对应字段(如stream_id, length, data等)</code>.</p></li><li><p>Frame Type : 下面是各种类型对应的编码和说明</p><table><thead><tr><th>十六进制</th><th>帧名（Frame Name）</th><th>说明</th></tr></thead><tbody><tr><td><code>0x00</code></td><td>PADDING</td><td>填充，无内容</td></tr><tr><td><code>0x01</code></td><td>PING</td><td>心跳，调试用</td></tr><tr><td><code>0x02</code></td><td>ACK</td><td>确认包，用于确认对方 packet</td></tr><tr><td><code>0x03</code></td><td>ACK + ECN</td><td>带显式拥塞通知</td></tr><tr><td><code>0x04</code></td><td>RESET_STREAM</td><td>中断某个流</td></tr><tr><td><code>0x05</code></td><td>STOP_SENDING</td><td>请求对方停止发送某流</td></tr><tr><td><code>0x06</code></td><td>CRYPTO</td><td>用于 TLS 握手数据的传输</td></tr><tr><td><code>0x07</code></td><td>NEW_TOKEN</td><td>地址验证相关</td></tr><tr><td><code>0x08</code>+</td><td>STREAM（流帧）</td><td>实际的数据帧（带 Stream ID）</td></tr><tr><td><code>0x1c</code></td><td>MAX_STREAMS</td><td>通知对方允许更多流</td></tr><tr><td><code>0x1e</code></td><td>DATA_BLOCKED</td><td>数据流被流控阻塞</td></tr><tr><td><code>0x1f</code></td><td>STREAMS_BLOCKED</td><td>流的数量受限</td></tr></tbody></table></li><li><p>CRYPTO 帧 : 其具体结构如下 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-function">Frame <span class="hljs-title">Type</span> <span class="hljs-params">(<span class="hljs-number">1</span>B)</span>]</span><br><span class="hljs-function">[<span class="hljs-title">Offset</span> <span class="hljs-params">(varint)</span>]         <span class="hljs-comment">// TLS 数据在整个 crypto stream 中的偏移</span></span><br><span class="hljs-function">[<span class="hljs-title">Length</span> <span class="hljs-params">(varint)</span>]         <span class="hljs-comment">// 本次数据长度</span></span><br><span class="hljs-function">[Crypto <span class="hljs-title">Data</span> <span class="hljs-params">(Length 字节)</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>STREAM 帧 : 该帧是最基础的数据帧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[<span class="hljs-function">Frame <span class="hljs-title">Type</span> <span class="hljs-params">(<span class="hljs-number">1</span>B)</span>]</span><br><span class="hljs-function">[Stream <span class="hljs-title">ID</span> <span class="hljs-params">(varint)</span>]</span><br><span class="hljs-function">[<span class="hljs-title">Offset</span> <span class="hljs-params">(varint, optional)</span>]</span><br><span class="hljs-function">[<span class="hljs-title">Length</span> <span class="hljs-params">(varint, optional)</span>]</span><br><span class="hljs-function">[<span class="hljs-title">Data</span> <span class="hljs-params">(length 指定的字节数)</span>]</span><br></code></pre></td></tr></table></figure><p>需要注意的是, stream帧相比于其他帧, 其<code>Frame Type</code>字段除了表明帧类型之外, 其前三位还有<strong>标记位</strong>的作用 : </p><table><thead><tr><th>位名</th><th>含义</th></tr></thead><tbody><tr><td>FIN(0)</td><td>1 表示这是该流的最后一块</td></tr><tr><td>LEN(1)</td><td>1 表示帧中包含 Length 字段</td></tr><tr><td>OFF(2)</td><td>1 表示帧中包含 Offset 字段</td></tr></tbody></table></li></ul></li><li><p>Packet Type : </p><p>在Long Header中的flags中我们可以发现<code>Packet Type</code>字段, 而Short Header中没有. 因为前者有四种包类型, 后者只有一种<code>1-RTT</code>. 因此包类型这个机制主要是为了<strong>控制握手阶段的各种机制</strong>而创造的.</p><ul><li><strong>不同的包类型有不同的可用frame类型, 不同的密钥, 不同的加密方式</strong>.</li></ul><table><thead><tr><th>包类型</th><th>可用 frame 类型</th><th>是否加密</th><th>使用密钥类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>Initial</strong></td><td><code>CRYPTO</code>, <code>PADDING</code>, <code>ACK</code></td><td>❌（初始密钥）</td><td>Initial Secret</td><td>主要用于传输 ClientHello</td></tr><tr><td><strong>Handshake</strong></td><td><code>CRYPTO</code>, <code>ACK</code>, <code>CONNECTION_CLOSE</code></td><td>✅</td><td>Handshake Secret</td><td>ServerHello、Finished 等</td></tr><tr><td><strong>0-RTT</strong></td><td><code>STREAM</code>, <code>ACK</code>, <code>PADDING</code></td><td>✅</td><td>0-RTT Secret（缓存）</td><td>客户端早发应用数据，不可靠</td></tr><tr><td><strong>Retry</strong></td><td>❌ 无 frame</td><td>❌</td><td>明文</td><td>特殊包，用于拒绝连接请求并附带 token</td></tr><tr><td><strong>1-RTT</strong></td><td>所有 frame（包括 STREAM）</td><td>✅</td><td>Application Secret（1-RTT）</td><td>应用数据正式传输阶段</td></tr></tbody></table><p>这里我们需要结合前面学习的<strong>帧类型和TLS1.3中的握手机制</strong>加以理解, 不同的帧类型会被用在不同的包中, <code>Initial</code>和<code>Handshake</code>分别被用来1RTT建立连接的来去程中, 而<code>0-RTT</code>则被用在0RTT恢复连接的过程中. 我们可以看见<strong>QUIC已经在底层将TLS1.3的机制融入到了设计</strong>中.</p></li><li><p>加密相关 : </p><p>QUIC几乎所有包和包中的帧都进行了加密, 但是<code>Initial</code>包并非, 毕竟还没有共享密钥, 虽然确实会加密, 但也是简易加密, 可以很快破解, 其核心作用更多是在于<strong>保证完整性</strong>. 直到回程服务器开始发送<code>Handshake</code>帧, 在确立了共享密钥之后, 连接才正式进入了完全加密阶段.</p><p>另外在<code>Short Header</code>包头中的<code>Flags</code>中, 还有<code>Key Phase</code>标志位用于是否进行<strong>密钥轮换</strong>. 所谓密钥轮换, 其目的是<strong>防止长期使用同一个密钥所带来的泄露风险</strong>, 只要变更该标志位, 就代表需要进行密钥轮换, 降低泄露风险.</p></li></ul><h3 id="Stream管理与数据传输"><a href="#Stream管理与数据传输" class="headerlink" title="Stream管理与数据传输"></a>Stream管理与数据传输</h3><p>QUIC的Stream机制和HTTP&#x2F;2的流机制一脉相承, 但是使用UDP解决了HTTP&#x2F;2 TCP队头阻塞的核心痛点, 并且QUIC在此基础上实现了更细粒度的控制.</p><p>为什么可以解决队头阻塞问题? 这里再细化一下最初对于TCP队头阻塞的理解, <strong>只要发生丢包, 后面的包都要等丢的包重发完毕才可生效</strong>, 这就产生一个现象, 就算包是属于不同流的, 但是在HTTP&#x2F;2底层仍属于同一个TCP连接, 也就是说<strong>不同流的丢包是会相互影响</strong>的. QUIC的设计<strong>将连接的有序细化为了流的有序</strong>, 也就是说<strong>一个流的丢包只会影响所属流, 流之间没有影响</strong>.</p><p>简单理解中, QUIC依旧依据stream_id进行每个流的单独管理, 但在很多机制上有所改变或细化 : </p><ul><li><p>stream id : </p><p>在HTTP&#x2F;2中stream_id是根据双方按奇偶划分的, 但在QUIC中, stream_id一般大小被设置为62bit, 分为两个标志位和编码部分 : </p><table><thead><tr><th>比特位</th><th>含义</th></tr></thead><tbody><tr><td>bit 0</td><td>发起者：0 &#x3D; client, 1 &#x3D; server</td></tr><tr><td>bit 1</td><td>类型：0 &#x3D; bidirectional(单向), 1 &#x3D; unidirectional(双向)</td></tr><tr><td>bits 2-61</td><td><strong>编号部分（严格递增）</strong></td></tr></tbody></table><p>也就是说流有了明确的发起者和方向类型的定义, 编号的递增规则会根据前面标志位有所变化, 这里不再细究.</p></li><li><p>流的方向 : </p><p>在stream_id中就需要声明流的方向,  我们可以自己设置流的流向.</p><ul><li>在HTTP&#x2F;2中, 流向是固定双向的, 因为TCP本身固定双向, 两边都要设置流控资源和状态机.</li><li>在QUIC协议中, <strong>流向可单可双</strong>, 因为UDP是无方向的, 单向可只在接收方设置流控资源和状态机, 可以做到更细粒度的控制.</li></ul></li><li><p>流控手段 : </p><p>和HTTP&#x2F;2几乎相同, 都可以控制连接流量和单一流的流量, 存在特殊的帧类型<code>MAX_DATA / MAX_STREAMS</code>来控制流量. </p><p>但是QUIC<strong>可以控制流的断开</strong> : </p><ul><li><p><code>STOP_SENDING</code> : 这是一个特殊的帧类型, 用于中断对方在该流上的数据传输. </p><p>主要用于接收方出于某些原因取消资源接收的情况, 在HTTP&#x2F;2中没有办法中途取消, 只能将对方发来的包直接抛弃掉, 这会让服务端浪费很多资源, 而QUIC可以中断单独流并且不影响其他流.</p></li></ul></li></ul><h3 id="重传-ACK-管理机制"><a href="#重传-ACK-管理机制" class="headerlink" title="重传&#x2F;ACK 管理机制"></a>重传&#x2F;ACK 管理机制</h3><p>核心就是实现类似TCP的<strong>保序 + 丢包重传</strong>机制.</p><ul><li><p>Packet Number : </p><p>每个包都会被分配到自己的包序号, 序号严格递增, 用来配合重传机制. 并且这个参数由于每包独立, 其还被用作<code>AEAD</code>加密算法进行密钥派生的参数, 可以确保密钥不被破解.</p></li><li><p><code>ACK</code>帧 : </p><p>这也是一个特殊的帧类型, 由接收方发送, 让发送方进行确认和丢包判断.</p><ul><li>只要收到对应包的ACK帧, 就代表该包已接收. </li><li>ACK帧中还会描述在当前包之前<strong>未收到的包序号范围</strong>(Range), 也就是说QUIC采用范围判断.</li><li>一个ACK帧<strong>可以一次性ACK多个包</strong>, 不像TCP需要按序且一对一.</li><li><code>ack_delay</code>字段是ACK帧的必带字段, 用于描述ACK帧故意延迟发送了多久. <strong>延迟发送机制</strong>是为了配合上一条特性, 累计一定的ACK一并发出, 可以<strong>有效降低ACK帧的发送频率</strong>.</li></ul></li><li><p>丢包检测机制 : </p><p>总共由两种丢包检测机制, 一种基于时间, 一种基于包序号.</p><ul><li><p>基于时间的超时检测 : 超过一定RTT的时间未收到ACK帧自动重传.</p></li><li><p>基于包序号的检测 : 可以设置一个值k, 通过接收到的未到包序号范围, 只要包序号小于<code>最大包序号 - k</code>的包, 将直接重传.</p><p>该检测对标TCP的快速重传机制, 判断更加简单且敏感.</p></li></ul></li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>思想内核与TCP一致, 依旧是维护一个拥塞窗口, 即<strong>已发送但未被确认的字节值</strong>. 不过QUIC有以下三个额外的特点 : </p><ul><li><p>QUIC规定下的拥塞控制算法是可拔插的, 也就是可以据情况随时更换拥塞控制算法, 这里不细究算法内核.</p></li><li><p>所有拥塞控制算法离不开使用RTT, 因此为了计算准确的RTT, 会获取ACK帧中的<code>ack_delay</code>字段来辅助计算.</p></li><li><p>由于QUIC的流有流向机制, 所以只需要在发送方设置拥塞控制机制, 接收方无需设置.</p></li></ul><h3 id="连接迁移与路径验证"><a href="#连接迁移与路径验证" class="headerlink" title="连接迁移与路径验证"></a>连接迁移与路径验证</h3><p>QUIC<strong>允许客户端随时变更网络</strong>, 而不需要重新建立连接, 可以在原连接上进行. 经典例子就是wifi网络的替换(wifi1 -&gt; wifi2 或 移动网络 -&gt; wifi).</p><ul><li><p>IP 欺骗攻击（Address Spoofing）</p><p>简单来说就是攻击方可以伪造变更ip的数据包, 欺诈攻击方进行无用的传输, 也有可能带来更深层次的数据泄露.</p></li><li><p>路径验证 : </p><p>QUIC会<strong>在连接发生迁移时通过发送特殊帧的方式确立对迁移连接的重新信任</strong>, 以此防IP欺诈攻击.</p><ul><li>虽然在QUIC在设计上把连接用CID表示, 不再依赖于ip&#x2F;port, 但是其内部依旧会存储CID对应的ip&#x2F;port, 当发生实际迁移时, 就可以迅速感知到这种变化.</li><li><code>PATH_CHALLENGE</code>帧 : 在服务器注意到连接迁移时向目标客户端发送, 用于确认.</li><li><code>PATH_RESPONSE</code>帧 : 接收到<code>PATH_CHALLENGE</code>帧后发送, 只有拥有先前的共同密钥才能进行正确的响应, 服务器收到后确立信任.</li></ul></li></ul><hr><h2 id="HTTP-3-内核"><a href="#HTTP-3-内核" class="headerlink" title="HTTP&#x2F;3 内核"></a>HTTP&#x2F;3 内核</h2><p>HTTP&#x2F;3完全基于QUIC协议设计, 可以理解为QUIC的<strong>完全上层建筑</strong>.</p><p>但是HTTP&#x2F;3 是 HTTP&#x2F;2 的语义继承者：方法、状态码、字段等基本一致, 各种设计理念一脉相承, 只在个别情况会有实际差别, 如果想要学习每个帧类型的作用可以看我HTTP&#x2F;2的讲解.</p><h3 id="QUIC是如何承载HTTP-3的"><a href="#QUIC是如何承载HTTP-3的" class="headerlink" title="QUIC是如何承载HTTP&#x2F;3的?"></a>QUIC是如何承载HTTP&#x2F;3的?</h3><ul><li>QUIC实现的是传输层的工作.</li><li>HTTP&#x2F;3也有自己的帧概念, 和HTTP&#x2F;2基本一致, <strong>HTTP&#x2F;3 所有帧都是“间接”地存在于 QUIC Packet 的 STREAM 帧内部的</strong>.</li><li><strong>每个 HTTP 请求&#x2F;响应都使用一个 QUIC Stream, 多个流可以并发交错发送</strong>.</li></ul><h3 id="HTTP-3-与-HTTP-2-的兼容"><a href="#HTTP-3-与-HTTP-2-的兼容" class="headerlink" title="HTTP&#x2F;3 与 HTTP&#x2F;2 的兼容"></a>HTTP&#x2F;3 与 HTTP&#x2F;2 的兼容</h3><ul><li>帧结构, 帧类型, 帧的处理几乎不变.</li><li>流控机制没有变化.</li><li>优先级机制不变, 但是在HTTP&#x2F;3中几乎不再使用, QUIC认为”多帧就是高优先级”.</li></ul><h3 id="基于流向的流类型划分"><a href="#基于流向的流类型划分" class="headerlink" title="基于流向的流类型划分"></a>基于流向的流类型划分</h3><p>HTTP&#x2F;3在QUIC的流向基础上规定了四种流类型 : </p><ul><li>控制流 (Control Stream) : <ul><li><strong>单向</strong>流, <strong>第一帧必须是<code>SETTINGS</code>帧</strong>, 后续帧视情况添加.</li><li>用于<strong>初始连接时协商参数</strong>, 双方<strong>必须</strong>在握手之前各开一条控制流进行交流.</li></ul></li><li>请求&#x2F;响应流 : <ul><li>双向流, 最基础的HTTP流, 包含<code>HEADERS</code>&#x2F;<code>DATA</code>等基础帧.</li><li>一般会并发开很多这样的流进行数据传输.</li></ul></li><li>QPACK encoder stream &#x2F; decoder stream : <ul><li>两条单向流, 分别由客户端 &#x2F; 服务端发起.</li><li>其作用是配合实现报头压缩机制, 后面详述.</li></ul></li><li>还有一种用来配合Server Push机制, 但是该机制已经过时, 被高速缓存取代.</li></ul><p>在实际HTTP&#x2F;3连接中, 各种流的使用逻辑大致如下 : </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">QUIC连接建立成功<br>│<br>├─&gt; 客户端创建控制流（发送 SETTINGS）<br>│<br>├─&gt; 服务端创建控制流（发送 SETTINGS）<br>│<br>├─&gt; 客户端创建 QPACK Encoder Stream（ID=2）<br>│<br>├─&gt; 服务端创建 QPACK Decoder Stream（ID=3）<br>│<br>├─&gt; 客户端创建请求流（ID=0, 4, 8...）<br>│    ├─&gt; HEADERS（请求头）<br>│    ├─&gt; DATA（请求体）<br>│    └─&gt; END_STREAM<br>│<br>└─&gt; 服务端在同一流上响应<br>     ├─&gt; HEADERS（响应头）<br>     ├─&gt; DATA（响应体）<br>     └─&gt; END_STREAM<br></code></pre></td></tr></table></figure><h3 id="QPACK报头压缩机制"><a href="#QPACK报头压缩机制" class="headerlink" title="QPACK报头压缩机制"></a>QPACK报头压缩机制</h3><p>其自然对标的是HTTP&#x2F;2的HPACK机制, 相比于其他部分不同, 这一部分有相对大的改动.</p><ul><li><p>为什么不能沿用HPACK机制?</p><p>因为<strong>动态表需要双方完全一致, 需要保证同步</strong>, 而HPACK的同步是<strong>依赖于TCP机制的有序性</strong>实现的, QUIC所依赖的UDP本身是无序的, 所以需要我们设置一定的机制保证动态表的一致性.</p></li><li><p>在HTTP&#x2F;2中, 报头压缩机制是融合在<code>HEADERS</code>帧中的, 可以理解为HTTP&#x2F;2在用<code>HEADERS</code>帧控制动态表, 但在HTTP&#x2F;3中将这一机制从其中拆解出来, 放到了独立的两条单向流中, 更加便于控制管理.</p></li><li><p>QPACK encoder stream &#x2F; decoder stream : </p><p>这是两条单向流, 双方在内核依旧会维护动态表, 会由<code>encoder stream</code>, 也就是客户端主导对于双方动态表的修改, 其会发送要求对端修改动态表的帧, 而<code>decoder stream</code>则用来回复各种修改的回应和动态表的使用情况.</p></li><li><p>但是上面并没有解决动态表要实现双方同步的诉求, 由于UDP是无序的, 客户端修改了自身的动态表并发送对端的修改命令, 对端的修改会有不可避免的时差, 如果提前接收到了使用这个修改的<code>HEADER</code>帧, 就会产生不可逆的错误.</p></li><li><p><code>Required Insert Count</code> : </p><p>这是<code>HEADERS</code>帧中需要表明的一个数值, <strong>代表这个<code>HEADERS</code>帧可使用的最小动态表范围</strong>, 简单来说就是<strong>不再要求双方动态表完全一致, 而是要求双方动态表一定范围内完全一致即可</strong>. </p><p>具体描述就是假设动态表是双方维护的一组的vector(分为E方和D方), 一般都是E方先进行插入, 然后告诉D方进行插入, 假如这期间E方发起请求, <code>HEADERS</code>帧中的<code>Required Insert Count</code>就会记录当前E方vector的最大下标, D方接收到时会查看自己的vector最大下标是否大于等于这个值, 如果大于, 则进行读取, 反之则阻塞等到条件符合.</p><p>至此QPACK解决了QUIC的无序传输动态表更新问题.</p></li></ul><h3 id="升级机制"><a href="#升级机制" class="headerlink" title="升级机制"></a>升级机制</h3><p>客户端可以通过HTTP&#x2F;1或HTTP&#x2F;2探测服务端是否支持HTTP&#x2F;3服务.</p><ul><li><p><code>Alt-Svc</code> : 其可作为字段出现在1&#x2F;2的报头字段中, 用来表示自己支持HTTP&#x2F;3, 也可以附带端口和时间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Alt-Svc: h3=<span class="hljs-string">&quot;:443&quot;</span>; ma=<span class="hljs-number">86400</span><br></code></pre></td></tr></table></figure><blockquote><p>表示支持 HTTP&#x2F;3（版本 h3），端口是 443，缓存时间为 1 天。</p></blockquote></li><li><p>在接收到此字段后, 客户就可以尝试使用QUIC连接服务器并开始HTTP&#x2F;3传输.</p></li></ul><blockquote><p>这里想要去学习HTTP3在C++中的实际使用, 简单看了ngtcp2和nghttp3库, 使用起来有些复杂, 之后可能会补充学习.</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP/2</title>
    <link href="/2025/08/01/HTTP2/"/>
    <url>/2025/08/01/HTTP2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>分为两部分 : 理论知识 和 nghttp2库使用</p></blockquote><h2 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h2><p>可以理解为在HTTP&#x2F;1.1上做了很多精简优化的工作, 解决了很多冗余的部分, 实现了精细地控制.</p><p>提升了加载速度, 减少了连接资源的浪费, 避免的频繁的队头阻塞.</p><h3 id="整体理解"><a href="#整体理解" class="headerlink" title="整体理解"></a>整体理解</h3><ul><li>依旧使用TCP进行数据传递, 但是一组请求响应不再会长时间占用整个TCP连接, 并且不同的请求都将始终在一条TCP连接上实现.</li><li>流机制和帧机制实现了上述的效果.</li><li>HPACK压缩机制实现了对多个相同报头的字段冗余问题.</li><li>提供优先级机制控制不同流直接的传输优先级.</li><li>提供流控机制防止单一流占用过多资源.</li></ul><h3 id="流机制-Stream"><a href="#流机制-Stream" class="headerlink" title="流机制 Stream"></a>流机制 Stream</h3><ul><li><p><strong>一个完整的请求响应的流程就是一个完整的流.</strong></p></li><li><p>所有流都在同一个TCP连接上.</p></li><li><p>每个流都可以被分为多个帧, 帧是最基本的数据单元, 最基础的类型包括HEADERS(报头), DATA(报文), 接收方可以根据帧的类型去对应处理相应的流.</p></li><li><p>stream id : </p><ul><li>每条流都会分配一个独立唯一的id,接收方可以根据id实现同一流资源的合并, 使得不同流可以交叉进行.</li><li>一般来说正常认知都是客户端发起一个流, 因为都是客户想请求资源, 但是其实服务端也可以发起流, 这种情况被称为Server Push(服务器推送), 后面会解释. 因此协议规定<strong>客户端发起的stream id为奇数, 服务端发起的stream id为偶数</strong>, 这样可以天然避免id冲突.</li></ul></li></ul><h3 id="帧机制-Frame"><a href="#帧机制-Frame" class="headerlink" title="帧机制 Frame"></a>帧机制 Frame</h3><ul><li><p>整个HTTP&#x2F;2的最小数据单元.</p></li><li><p>每个帧有固定的 9 字节帧头和一个可变长度的帧体.</p></li><li><p>帧头包含 : 帧体长度, 帧类型, 标志位, stream id. 其中不同的帧类型传递不同类型的信息, 标志位可以根据不同的帧类型设置一些特殊的选项.</p></li><li><p>帧类型如下 : </p><table><thead><tr><th>帧类型</th><th>描述</th><th>Stream ID 是否为 0</th></tr></thead><tbody><tr><td><code>DATA</code> (0x0)</td><td>传输请求或响应体内容</td><td>否</td></tr><tr><td><code>HEADERS</code> (0x1)</td><td>传输 HTTP 头部，标识一个请求或响应的开始</td><td>否</td></tr><tr><td><code>PRIORITY</code> (0x2)</td><td>声明流的优先级信息</td><td>否</td></tr><tr><td><code>RST_STREAM</code> (0x3)</td><td>强制终止流</td><td>否</td></tr><tr><td><code>SETTINGS</code> (0x4)</td><td>交换连接参数，初始化连接</td><td>✅ 是</td></tr><tr><td><code>PUSH_PROMISE</code> (0x5)</td><td>服务端推送资源预告</td><td>否</td></tr><tr><td><code>PING</code> (0x6)</td><td>保活&#x2F;RTT 检测（8字节数据）</td><td>✅ 是</td></tr><tr><td><code>GOAWAY</code> (0x7)</td><td>关闭连接并告知最后处理的 stream</td><td>✅ 是</td></tr><tr><td><code>WINDOW_UPDATE</code> (0x8)</td><td>控制流量窗口大小</td><td>否或是</td></tr></tbody></table></li><li><p>最常用的标志位是<code>END_STREAM</code>, 该标志代表流结束, 可以在<code>HEADERS</code>和<code>DATA</code>帧中出现, 表示后续不会有新的帧传来, 流已经结束.</p></li></ul><h3 id="服务器推送-Server-Push"><a href="#服务器推送-Server-Push" class="headerlink" title="服务器推送 Server Push"></a>服务器推送 Server Push</h3><blockquote><p>注意该技术很大程度上已过时.</p></blockquote><ul><li><p>由服务器主动向客户端发起请求, 新建一个流进行数据传递.</p></li><li><p>类似场景如请求一个网站, 服务端会将需求的html页面作为响应发送给用户, 相应的服务端也会知道网页需要的css&#x2F;js&#x2F;图片等资源, 于是不用等客户端再次请求这些资源, 服务端就可以申请向客户端直接发送.</p></li><li><p><code>PUSH_PROMISE</code> : </p><p>这是一个特殊的帧类型, 用于向客户端预告自己将向其发送一些客户端可能需要的资源.</p><p>其中帧体会包含两种字段 : <code>Promised Stream ID</code>(新建流的id) 和 <code>Header Block Fragment</code>(模拟的请求头).</p><p>在发生类似上面的场景时, 服务端就会向客户端发送这样的一个承诺帧, 之后再开始传输<code>DATA</code>帧.</p></li><li><p>性能分析 : </p><p>其优化主要在减少了RTT(往返时间). 普通过程中客户端需要解析出需要的资源再向服务端请求, 需要RTT * 2, 但是Server Push只需要一个RTT就可以实现, 谷歌测试这种技术的提速大概在30%.</p></li><li><p>适用场景 : </p><p>其实就是公共网络下, 可以减缓RTT比较长情况下的延迟. 如果都在一个局域网中RTT非常小就完全没必要了.</p></li></ul><h3 id="HPACK压缩机制"><a href="#HPACK压缩机制" class="headerlink" title="HPACK压缩机制"></a>HPACK压缩机制</h3><ul><li><p>必要性 : </p><p>在一个TCP连接中, 发送的报头其实有很多都是重复的, 比如很多method都是GET, 很多scheme都是https, 但普通情况下我们还是需要传输一个很长的字段再解析出来, 这其实是相对低效的做法, 而这种报头压缩机制会将字段转化成简短的索引, 就可以有效解决这种问题.</p></li><li><p>方法简述 : </p><p>其实本质就是维护一些映射, 使得一些非常小的索引可以代指一些比较长的字段. 但是这种映射只有<strong>在双方互通且完全一致</strong>的情况下才有可行性, 而TCP可以帮助我们实现这种要求.</p></li><li><p>存储结构 : </p><ul><li><p>存储机构包含两种 : 静态表 和 动态表, 前者固定不变, 后者同步更新.</p></li><li><p>静态表 : 存储<strong>固定的、所有连接共享的、永不变的</strong>索引映射, 这是官方定好的, 具体如下 : </p><table><thead><tr><th>Index</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>1</td><td><code>:authority</code></td><td>-</td></tr><tr><td>2</td><td><code>:method</code></td><td><code>GET</code></td></tr><tr><td>3</td><td><code>:method</code></td><td><code>POST</code></td></tr><tr><td>4</td><td><code>:path</code></td><td><code>/</code></td></tr><tr><td>5</td><td><code>:path</code></td><td><code>/index.html</code></td></tr><tr><td>6</td><td><code>:scheme</code></td><td><code>http</code></td></tr><tr><td>7</td><td><code>:scheme</code></td><td><code>https</code></td></tr><tr><td>8</td><td><code>:status</code></td><td><code>200</code></td></tr><tr><td>13</td><td><code>content-length</code></td><td>-</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>默认的静态表索引为<strong>1 - 61</strong>, 注意这静态表中有一部分是对完整[name value]的映射, 而一部分只是对name的映射.</p></li><li><p>动态表 : <strong>运行时可变的，用于存储最近使用过的 name&#x2F;value 对</strong>, 举例如下 : </p><table><thead><tr><th>Index</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>62</td><td>cookie</td><td><code>session=xyz</code></td></tr><tr><td>63</td><td>referer</td><td><code>https://xxx</code></td></tr><tr><td>64</td><td>accept</td><td><code>text/html</code></td></tr></tbody></table><p>动态表索引从<strong>62</strong>开始, 按序递增, 动态表中的映射一般都是对完整[name value]的映射.</p><p>需要注意的是, 动态表的更新<strong>必须同步</strong>, 也就是说双方维护的动态表必须完全相同, 如果不同, 那么交流的正确性是绝对无法保证的, 而这一点可以用TCP的<strong>有序</strong>性质实现保证.</p></li></ul><p>注意上述的两个表, 在实现中大多用vector实现而非map, 因为我们的索引可以和数组下标对应, 用顺序表更为快捷便利.</p></li></ul><blockquote><p>针对此压缩机制, 双方的编解码器可以维护这两个表, 从而用索引代指一些常用且冗长的字段. 但索引成立的前提是双方信息互通, 都知道索引代表了什么.</p><p>静态表双方在一开始就可以持有, 但是动态表如何实现双方索引互通呢? 解决方法在报头格式中.</p></blockquote><p><strong>压缩报头格式</strong> :  多字段, 每段组成如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[前导字节 name value]<br></code></pre></td></tr></table></figure><ul><li><p>前导字节 : 用于表示该段的类型, 是字段还是索引, 是否需要另外的操作, 共四种 : </p><table><thead><tr><th>编码类型</th><th>说明</th><th>典型前缀（高位）</th></tr></thead><tbody><tr><td>1. Indexed Header Field</td><td>只发送索引，表示该字段完全命中静态&#x2F;动态表</td><td><code>1xxxxxxx</code> （首位 1）</td></tr><tr><td>2. Literal Header Field with Incremental Indexing</td><td>新字段，插入动态表（就是 <code>0x40</code> 类型）</td><td><code>01xxxxxx</code> （前两位 01）</td></tr><tr><td>3. Literal Header Field without Indexing</td><td>发送字段，但<strong>不插入动态表</strong></td><td><code>0000xxxx</code>（前四位 0000）</td></tr><tr><td>4. Literal Header Field Never Indexed</td><td>明确声明此字段不应被压缩器存储（例如敏感字段）</td><td><code>0001xxxx</code>（前四位 0001）</td></tr></tbody></table><ul><li><p>当我们使用第一种编码类型, 代表我们在动态表或静态表中有对应的[name value]映射, 将使用索引替代, 此时<strong>后面7位x对应值就代表双方约定的索引值</strong>.</p><p>例如我们想发送字段<code>:method: GET</code>, 由于在静态表中有其完整对, 我们可以直接发送<code>0x82(10000010)</code>这个字节代指该段.</p></li><li><p>当我们使用第二种编码类型, 代表没有匹配或仅name匹配, 并且我们要让接收端将其插入动态表.</p><p>无匹配插入 : <code>0x40(01000000) name value</code> </p><p>部分匹配插入 : <code>01xxxxxx value</code>, 这种情况存在主要因为静态表中会存一些仅匹配name的索引, 这种插入只是帮我们省略了一个name而已.</p></li><li><p>这里我们可以发现HPACK压缩机制本身是由<strong>发送方主导</strong>的, 发送方可以决定接收方的行为, 因为本身表结构就需要双方一致, 如果接收方还可以拒绝接收方的行为的话, 为了两边一致就要做出很大的性能牺牲了.</p></li></ul></li><li><p>name &#x2F; value : </p><p>当我们需要传这两个字段时, 可以直接明文传输, 也可以选择使用哈夫曼编码压缩.</p></li></ul><p>至此, 加入我们想传入这样的报头 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">:method: GET<br>:path: /<br>:scheme: https<br>:authority: www.example.com<br>user-agent: curl/<span class="hljs-number">7.79</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>其就会被压缩成这样:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">82</span>                          -&gt; :method: GET<br><span class="hljs-number">84</span>                          -&gt; :path: /<br><span class="hljs-number">87</span>                          -&gt; :scheme: https<br><span class="hljs-number">41</span> <span class="hljs-number">11</span> <span class="hljs-number">77</span> <span class="hljs-number">77</span> <span class="hljs-number">77</span> <span class="hljs-number">2</span>e <span class="hljs-number">65</span> <span class="hljs-number">78</span> <span class="hljs-number">61</span> <span class="hljs-number">6</span>d <span class="hljs-number">70</span> <span class="hljs-number">6</span>c <span class="hljs-number">65</span> <span class="hljs-number">2</span>e <span class="hljs-number">63</span> <span class="hljs-number">6</span>f <span class="hljs-number">6</span>d  -&gt; :authority: www.example.com<br><span class="hljs-number">7</span>A <span class="hljs-number">0</span>C <span class="hljs-number">63</span> <span class="hljs-number">75</span> <span class="hljs-number">72</span> <span class="hljs-number">6</span>C <span class="hljs-number">2</span>F <span class="hljs-number">37</span> <span class="hljs-number">2</span>E <span class="hljs-number">37</span> <span class="hljs-number">39</span> <span class="hljs-number">2</span>E <span class="hljs-number">31</span>              -&gt; user-agent: curl/<span class="hljs-number">7.79</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><p>其中前三段在静态表中都有对应段, 直接索引替代. 第四,五段都采用了部分匹配插入, 41(01000001)因为<code>:authority</code>的索引是1, 7A(01011110)因为<code>user-agent</code>的索引是58, 后面的字段都是value明问转化成的哈夫曼编码.</p><h3 id="优先级机制"><a href="#优先级机制" class="headerlink" title="优先级机制"></a>优先级机制</h3><p>优先级机制用来解决HTTP&#x2F;2使用单一TCP连接带来的阻塞问题, 其通过给流设置优先级来实现高优先级的流资源(如html&#x2F;css)可以高优先地发出, 避免被一些较大但次优先的资源(如图片)占用TCP连接资源.</p><p>HTTP&#x2F;2设置了一个依赖树来实现优先级的设置, 子流的优先级始终低于父流, 父流可以更多地占用资源.</p><p>关键在于三种参数的设置 : </p><table><thead><tr><th>字段</th><th>作用</th><th>默认值 &#x2F; 推荐用法</th></tr></thead><tbody><tr><td>Exclusive</td><td>是否独占父流，重塑依赖树</td><td>默认 0，某些关键资源设为 1</td></tr><tr><td>Stream Dependency</td><td>依赖的父流 ID</td><td>默认 0，表示虚拟根节点</td></tr><tr><td>Weight</td><td>调度比例</td><td>默认 16，建议关键资源设置为 &gt;100</td></tr></tbody></table><p>我们可以在<code>HEADERS</code>帧和<code>PRIORITY</code>帧中设置这些参数, 具体设置方式不细究.</p><h3 id="流控机制"><a href="#流控机制" class="headerlink" title="流控机制"></a>流控机制</h3><ul><li><p>必要性 :</p><p>HTTP&#x2F;1中都是每个请求响应都对应一条独立连接, 不同请求响应的流量不影响彼此, 并且TCP自己就有流量控制. 但是HTTP&#x2F;2中每个请求响应共用一条连接, 一个流的数据传输如果过大且不加限制, 是绝对会拖慢其他流的传输的. 可以理解为TCP的流控是针对一条街道的, 而HTTP&#x2F;2的流控是针对街道上的每条车道的.</p></li><li><p>HTTP&#x2F;2 流控是<strong>接收方驱动的</strong>. 流控通过接收方控制窗口大小实现, 和TCP的拥塞窗口机制类似.</p></li><li><p>接收方需要向发送方发送<code>WINDOW_UPDATE</code>帧告知发送方<strong>还能发送多少</strong>.</p><ul><li>0x08, 这是<code>WINDOW_UPDATE</code>帧的类型代码.</li><li>在<code>WINDOW_UPDATE</code>帧的报体中会有<code>Window Size Increment</code>字段, 大小4字节, 可以用来设置窗口的大小.</li></ul></li><li><p>发送方每个时刻发送的数据总量(DATA 帧中的大小总和)<strong>不能超过接收方通告的流控窗口大小</strong>.</p></li><li><p>HTTP&#x2F;2有默认的窗口大小, <strong>64KB</strong>, 因此在发送方前期发送给接收方数据时是按照这默认大小来的.</p></li><li><p>如果接收方长时间不发送<code>WINDOW_UPDATE</code>帧给发送方, 发送方应当逐渐减小窗口至0, 直到接收到<code>WINDOW_UPDATE</code>帧, 也就是说如果想要发送方长时间持续发送内容, 就需要用户方持续发送<code>WINDOW_UPDATE</code>帧.</p></li><li><p>为什么必须要由接收方主导?</p><p>因为发送方的能力一般是较高的, 但是接收方的机器水平参差不齐, 发送方并不能获取接收方的信息, 需要接收方按自己的接收能力控制窗口.</p></li><li><p>当然接收方也有可能把窗口设的很大恶意拖慢发送方服务, 这需要配合限流技术预防.</p></li></ul><h3 id="SETTINGS帧"><a href="#SETTINGS帧" class="headerlink" title="SETTINGS帧"></a>SETTINGS帧</h3><p>这是TCP连接建立后双方发的第一个帧, 用来交换初始参数.</p><ul><li>建立连接后，客户端和服务端都必须各发送一帧 SETTINGS.</li><li>初始参数包括但不限于 : <ul><li>初始流窗口大小（<code>SETTINGS_INITIAL_WINDOW_SIZE</code>）</li><li>最大并发 stream 数量（<code>SETTINGS_MAX_CONCURRENT_STREAMS</code>）</li><li>单帧最大大小（<code>SETTINGS_MAX_FRAME_SIZE</code>）</li><li>是否启用服务器推送（<code>SETTINGS_ENABLE_PUSH</code>）</li></ul></li><li>收到SETTINGS帧后, 每一端都需要发送 ACK 帧回应, 只有收到ACK帧, 设置才算是真正成立.</li></ul><h2 id="nghttp2库"><a href="#nghttp2库" class="headerlink" title="nghttp2库"></a>nghttp2库</h2><h3 id="最基础的http2报文收发客户端"><a href="#最基础的http2报文收发客户端" class="headerlink" title="最基础的http2报文收发客户端"></a>最基础的http2报文收发客户端</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;nghttp2/nghttp2.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/ssl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/err.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HOST <span class="hljs-string">&quot;nghttp2.org&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT <span class="hljs-string">&quot;443&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAKE_NV(NAME, VALUE)                                                 \</span><br><span class="hljs-meta">    &#123;(uint8_t *)NAME, (uint8_t *)VALUE, sizeof(NAME) - 1, sizeof(VALUE) - 1, \</span><br><span class="hljs-meta">     NGHTTP2_NV_FLAG_NONE&#125;</span><br><br><span class="hljs-type">int</span> stream_id = <span class="hljs-number">-1</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">send_callback</span><span class="hljs-params">(nghttp2_session *session,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> length,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">int</span> flags, <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    SSL *ssl = (SSL *)user_data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SSL_write</span>(ssl, data, (<span class="hljs-type">int</span>)length);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">recv_callback</span><span class="hljs-params">(nghttp2_session *session,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">uint8_t</span> *buf, <span class="hljs-type">size_t</span> length,</span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">int</span> flags, <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    SSL *ssl = (SSL *)user_data;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SSL_read</span>(ssl, buf, (<span class="hljs-type">int</span>)length);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">on_header_callback</span><span class="hljs-params">(nghttp2_session *session,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> nghttp2_frame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *name, <span class="hljs-type">size_t</span> namelen,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *value, <span class="hljs-type">size_t</span> valuelen,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">uint8_t</span> flags, <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[HEADER] %.*s: %.*s\n&quot;</span>, (<span class="hljs-type">int</span>)namelen, name, (<span class="hljs-type">int</span>)valuelen, value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">on_data_chunk_recv</span><span class="hljs-params">(nghttp2_session *session, <span class="hljs-type">uint8_t</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">int32_t</span> stream_id,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *data, <span class="hljs-type">size_t</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">                              <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[DATA] %.*s\n&quot;</span>, (<span class="hljs-type">int</span>)len, data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">on_stream_close</span><span class="hljs-params">(nghttp2_session *session,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">int32_t</span> stream_id, <span class="hljs-type">uint32_t</span> error_code,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[INFO] Stream %d closed\n&quot;</span>, stream_id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// ALPN 回调</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">select_proto_cb</span><span class="hljs-params">(SSL *ssl, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **out, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *outlen,</span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *in, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> inlen, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> h2[] = &#123;<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>&#125;;<br>    *out = h2;<br>    *outlen = <span class="hljs-built_in">sizeof</span>(h2);<br>    <span class="hljs-keyword">return</span> SSL_TLSEXT_ERR_OK;<br>&#125;<br><br><span class="hljs-function">SSL *<span class="hljs-title">connect_tls</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *port, <span class="hljs-type">int</span> *sockfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints = &#123;<span class="hljs-number">0</span>&#125;, *res;<br>    hints.ai_family = AF_UNSPEC;<br>    hints.ai_socktype = SOCK_STREAM;<br><br>    <span class="hljs-built_in">getaddrinfo</span>(host, port, &amp;hints, &amp;res);<br>    *sockfd = <span class="hljs-built_in">socket</span>(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);<br>    <span class="hljs-built_in">connect</span>(*sockfd, res-&gt;ai_addr, res-&gt;ai_addrlen);<br><br>    <span class="hljs-built_in">SSL_library_init</span>();<br>    <span class="hljs-built_in">SSL_load_error_strings</span>();<br>    <span class="hljs-type">const</span> SSL_METHOD *method = <span class="hljs-built_in">TLS_client_method</span>();<br>    SSL_CTX *ctx = <span class="hljs-built_in">SSL_CTX_new</span>(method);<br><br>    <span class="hljs-built_in">SSL_CTX_set_alpn_protos</span>(ctx, (<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *)<span class="hljs-string">&quot;\x2h2&quot;</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">SSL_CTX_set_alpn_select_cb</span>(ctx, select_proto_cb, <span class="hljs-literal">NULL</span>);<br><br>    SSL *ssl = <span class="hljs-built_in">SSL_new</span>(ctx);<br>    <span class="hljs-built_in">SSL_set_fd</span>(ssl, *sockfd);<br>    <span class="hljs-built_in">SSL_connect</span>(ssl);<br>    <span class="hljs-keyword">return</span> ssl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd;<br>    SSL *ssl = <span class="hljs-built_in">connect_tls</span>(HOST, PORT, &amp;sockfd);<br><br>    nghttp2_session_callbacks *callbacks;<br>    <span class="hljs-built_in">nghttp2_session_callbacks_new</span>(&amp;callbacks);<br>    <span class="hljs-built_in">nghttp2_session_callbacks_set_send_callback</span>(callbacks, send_callback);<br>    <span class="hljs-built_in">nghttp2_session_callbacks_set_recv_callback</span>(callbacks, recv_callback);<br>    <span class="hljs-built_in">nghttp2_session_callbacks_set_on_header_callback</span>(callbacks, on_header_callback);<br>    <span class="hljs-built_in">nghttp2_session_callbacks_set_on_data_chunk_recv_callback</span>(callbacks, on_data_chunk_recv);<br>    <span class="hljs-built_in">nghttp2_session_callbacks_set_on_stream_close_callback</span>(callbacks, on_stream_close);<br><br>    nghttp2_session *session;<br>    <span class="hljs-built_in">nghttp2_session_client_new</span>(&amp;session, callbacks, ssl);<br><br>    <span class="hljs-comment">// 初始化 SETTINGS 帧</span><br>    nghttp2_settings_entry iv = &#123;NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, <span class="hljs-number">100</span>&#125;;<br>    <span class="hljs-built_in">nghttp2_submit_settings</span>(session, NGHTTP2_FLAG_NONE, &amp;iv, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 准备请求头部</span><br>    <span class="hljs-type">const</span> nghttp2_nv hdrs[] = &#123;<br>        <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:method&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>),<br>        <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:path&quot;</span>, <span class="hljs-string">&quot;/httpbin/get&quot;</span>),<br>        <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:scheme&quot;</span>, <span class="hljs-string">&quot;https&quot;</span>),<br>        <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:authority&quot;</span>, HOST),<br>        <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;user-agent&quot;</span>, <span class="hljs-string">&quot;nghttp2-c-client&quot;</span>)&#125;;<br><br>    stream_id = <span class="hljs-built_in">nghttp2_submit_request</span>(session, <span class="hljs-literal">NULL</span>, hdrs, <span class="hljs-built_in">sizeof</span>(hdrs) / <span class="hljs-built_in">sizeof</span>(hdrs[<span class="hljs-number">0</span>]), <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">nghttp2_session_send</span>(session);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> rv = <span class="hljs-built_in">nghttp2_session_recv</span>(session);<br>        <span class="hljs-keyword">if</span> (rv &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        rv = <span class="hljs-built_in">nghttp2_session_send</span>(session);<br>        <span class="hljs-keyword">if</span> (rv &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">nghttp2_session_want_read</span>(session) == <span class="hljs-number">0</span> &amp;&amp;<br>            <span class="hljs-built_in">nghttp2_session_want_write</span>(session) == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">nghttp2_session_del</span>(session);<br>    <span class="hljs-built_in">SSL_shutdown</span>(ssl);<br>    <span class="hljs-built_in">close</span>(sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>初看确实比较麻烦, 实质上就是向<code>nghttp2.org</code>这个网站发送了一个请求, 然后通过设置各种事件的回调实现响应的接收, 回调包括读, 写,报头帧, 数据帧. 其实nghttp2有和boost::asio结合实现的简便版本, 不过目前没有普及, 这里还是拿最初始的版本进行学习.</p><h3 id="服务器推送部分"><a href="#服务器推送部分" class="headerlink" title="服务器推送部分"></a>服务器推送部分</h3><p>在客户端, 首先应该在<code>SETTINGS</code>帧中就设置<code>SETTINGS_ENABLE_PUSH</code>, 告诉服务端你是否接受服务器推送.</p><p>如果接受, 需要设置针对<code>PUSH_PROMISE</code>帧的回调函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">on_begin_headers_callback</span><span class="hljs-params">(nghttp2_session *session,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">const</span> nghttp2_frame *frame,</span></span><br><span class="hljs-params"><span class="hljs-function">                                     <span class="hljs-type">void</span> *user_data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (frame-&gt;hd.type == NGHTTP2_PUSH_PROMISE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;[INFO] PUSH_PROMISE for promised stream %d\n&quot;</span>, frame-&gt;push_promise.promised_stream_id);<br>        stream_info[frame-&gt;push_promise.promised_stream_id] = <span class="hljs-string">&quot;[Push Resource]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然这里只是打印了一下帧信息, 实际我们可以采取系列行为, 比如停止后续对于该推送资源的请求, 就用服务器发过来的资源即可.</p><hr><p>在服务端, 我们在检测到可以提前推送的资源后, 可以触发服务器推送机制, 发送<code>PUSH_PROMISE</code>帧 + 报头帧 + 数据帧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// ① 提交 PUSH_PROMISE 帧</span><br>nghttp2_nv push_hdrs[] = &#123;<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:method&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>),<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:path&quot;</span>, <span class="hljs-string">&quot;/style.css&quot;</span>),<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:scheme&quot;</span>, <span class="hljs-string">&quot;https&quot;</span>),<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:authority&quot;</span>, <span class="hljs-string">&quot;example.com&quot;</span>)<br>&#125;;<br><br><span class="hljs-type">int32_t</span> promised_stream_id = <span class="hljs-built_in">nghttp2_submit_push_promise</span>(<br>    session,<br>    NGHTTP2_FLAG_NONE,<br>    parent_stream_id,   <span class="hljs-comment">// 原请求 stream ID</span><br>    push_hdrs,<br>    <span class="hljs-built_in">sizeof</span>(push_hdrs) / <span class="hljs-built_in">sizeof</span>(push_hdrs[<span class="hljs-number">0</span>]),<br>    <span class="hljs-literal">NULL</span>  <span class="hljs-comment">// user_data 可选</span><br>);<br><br><span class="hljs-comment">// ② 为推送资源准备 HEADERS 和 DATA 响应</span><br>nghttp2_nv resp_hdrs[] = &#123;<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:status&quot;</span>, <span class="hljs-string">&quot;200&quot;</span>),<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;content-type&quot;</span>, <span class="hljs-string">&quot;text/css&quot;</span>)<br>&#125;;<br><br><span class="hljs-comment">// 假设你将推送的内容保存在 memory_data 里</span><br>nghttp2_data_provider data_prd;<br>data_prd.source.ptr = memory_data;<br>data_prd.read_callback = your_data_read_callback; <span class="hljs-comment">// 提供数据内容</span><br><br><span class="hljs-built_in">nghttp2_submit_response</span>(<br>    session,<br>    promised_stream_id,<br>    resp_hdrs,<br>    <span class="hljs-built_in">sizeof</span>(resp_hdrs) / <span class="hljs-built_in">sizeof</span>(resp_hdrs[<span class="hljs-number">0</span>]),<br>    &amp;data_prd<br>);<br></code></pre></td></tr></table></figure><ul><li><p>服务端如何知道要主动推送什么资源?</p><p>最朴素的想法就是扫描请求的资源, 发现其依赖的资源, 就像在html文件中找css&#x2F;js文件. 但基于效率可以针对文件生成其对应的依赖列表, 这样在客户端请求资源时即可立刻按照其依赖列表迅速进行推送申请了.</p></li></ul><h3 id="HPACK压缩部分"><a href="#HPACK压缩部分" class="headerlink" title="HPACK压缩部分"></a>HPACK压缩部分</h3><p>报头压缩的部分nghttp2库中已经在内部全部实现, 无需外部的使用者关心.</p><h3 id="优先级部分"><a href="#优先级部分" class="headerlink" title="优先级部分"></a>优先级部分</h3><p>nghttp2中有对优先级数值的封装 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>  <span class="hljs-type">int32_t</span> stream_id;    <span class="hljs-comment">// 依赖的父 stream ID</span><br>  <span class="hljs-type">int32_t</span> weight;       <span class="hljs-comment">// 权重值（1~256）</span><br>  <span class="hljs-type">uint8_t</span> exclusive;    <span class="hljs-comment">// 是否独占依赖（0 或 1）</span><br>&#125; nghttp2_priority_spec;<br></code></pre></td></tr></table></figure><p>其可用于在<code>HEADERS</code>和<code>PRIORITYS</code>帧中传递优先级信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">nghttp2_priority_spec ps;<br><span class="hljs-built_in">nghttp2_priority_spec_init</span>(&amp;ps, parent_id, weight, exclusive);<br><br>nghttp2_nv headers[] = &#123;<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:method&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>),<br>    <span class="hljs-built_in">MAKE_NV</span>(<span class="hljs-string">&quot;:path&quot;</span>, <span class="hljs-string">&quot;/img1.png&quot;</span>),<br>    ...<br>&#125;;<br><br><span class="hljs-built_in">nghttp2_submit_headers</span>(session, NGHTTP2_FLAG_END_STREAM, stream_id,<br>                       &amp;ps, headers, header_count, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// ------------------------------------------------------------------ // </span><br><br>nghttp2_priority_spec ps;<br><span class="hljs-built_in">nghttp2_priority_spec_init</span>(&amp;ps, new_parent_id, new_weight, new_exclusive);<br><br><span class="hljs-built_in">nghttp2_submit_priority</span>(session, stream_id, &amp;ps, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="流控部分"><a href="#流控部分" class="headerlink" title="流控部分"></a>流控部分</h3><p>主要通过以下几个部分实现 : </p><ul><li><p>设置初始窗口大小 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">nghttp2_option_set_initial_window_size</span>(option, <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);  <span class="hljs-comment">// 1MB</span><br></code></pre></td></tr></table></figure><p>其会控制每个流初始的窗口大小.</p></li><li><p>接收方定时发送<code>WINDOW_UPDATE</code>帧恢复窗口.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">nghttp2_submit_window_update</span>(session, <span class="hljs-number">0</span>, <span class="hljs-number">32768</span>);        <span class="hljs-comment">// 恢复连接窗口</span><br><span class="hljs-built_in">nghttp2_submit_window_update</span>(session, stream_id, <span class="hljs-number">32768</span>); <span class="hljs-comment">// 恢复该 stream 窗口</span><br></code></pre></td></tr></table></figure><ul><li>关于调用时机, 一般是接收方接收完一段消息后就立刻恢复, 如果注重服务器效率, 且接收方流量小实时性要求不高, 也可以设置一些累计机制触发恢复, 可以减少<code>WINDOW_UPDATE</code>帧的发送频率.</li></ul></li><li><p>发送方在想要发送内容时通过api获取窗口大小, 按此大小发送内容 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">nghttp2_session_get_remote_window_size</span>(session);<span class="hljs-comment">// 连接级窗口</span><br><span class="hljs-built_in">nghttp2_session_get_stream_remote_window_size</span>(session, stream_id);<span class="hljs-comment">// 流级窗口</span><br></code></pre></td></tr></table></figure><ul><li>确实有<code>WINDOW_UPDATE</code>帧的回调函数, 但是一般来说没有必要, 只需要发送时获取窗口大小即可.</li><li>nghttp2库内部会自动解析<code>WINDOW_UPDATE</code>帧并存储对应窗口大小.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP/1</title>
    <link href="/2025/07/20/HTTP1/"/>
    <url>/2025/07/20/HTTP1/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h2><p>短连接(非持久性连接)</p><p>每次HTTP请求都要创建一个新的TCP连接, 响应完就关闭连接.</p><hr><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h2><p>长连接, 使用最广泛的HTTP协议</p><h3 id="keep-alive-持久连接"><a href="#keep-alive-持久连接" class="headerlink" title="keep-alive : 持久连接"></a>keep-alive : 持久连接</h3><p><code>Connection: keep-alive</code> : 表示复用已有的TCP连接连续发送多个请求, 不断开当前的TCP连接.</p><p><code>Connection: close</code> : 表示想确实关闭连接.</p><h3 id="分块传输编码-Chunked-Transfer-Encoding"><a href="#分块传输编码-Chunked-Transfer-Encoding" class="headerlink" title="分块传输编码(Chunked Transfer Encoding)"></a>分块传输编码(Chunked Transfer Encoding)</h3><p>HTTP&#x2F;1.1的重要功能模块, 其核心功能在于允许<strong>不知道总内容长度</strong>的前提下, 将响应内容<strong>一块一块发给客户端</strong>.</p><p>其赋予了HTTP请求<strong>实时性</strong>, 也就是说不必在发送前就要确定全部要发送的内容, 而是可以有一点发一点, 服务器持续发送, 客户端持续接收, 这对某些实时生成的信息的发送有很大帮助, 比如日志, 动态渲染, 聊天等等.</p><p>先看一条chunked的响应是怎样的 : </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Transfer-Encoding</span><span class="hljs-punctuation">: </span>chunked<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br><br><span class="language-css"><span class="hljs-number">5</span>\<span class="hljs-attribute">r</span>\n</span><br><span class="language-css">Hello\<span class="hljs-attribute">r</span>\n</span><br><span class="language-css"><span class="hljs-number">6</span>\<span class="hljs-attribute">r</span>\n</span><br><span class="language-css"> world\<span class="hljs-attribute">r</span>\n</span><br><span class="language-css"><span class="hljs-number">0</span>\<span class="hljs-attribute">r</span>\n</span><br><span class="language-css">\<span class="hljs-attribute">r</span>\n</span><br></code></pre></td></tr></table></figure><ul><li><p>首先我们不需要填写<code>Content-Length</code>这一属性, 因为我们本身就不确定长度.</p></li><li><p>我们需要添加<code>Transfer-Encoding: chunked</code>, 该字段表明我们是chunked响应, 如果客户端有针对正常响应和chunked响应进行分类处理, 就会根据此字段选择合适的处理方式.</p></li><li><p>一个check的结构如下 : </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">&lt;chunk-size&gt;\r\n<br>&lt;chunk-data&gt;\r\n<br></code></pre></td></tr></table></figure><p>我们可以不断发送这样的结构让客户端持续接收, 直到我们想结束这次响应, 我们可以将chunk-size设置为0, 发送如下字段表示结束 : </p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">0\r\n<br>\r\n<br></code></pre></td></tr></table></figure></li></ul><p>也就是说我们在服务端自己决定什么时候开始响应, 响应什么, 什么时候结束响应, 就像下面 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 开始响应, 先发送5个字节</span><br>HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">200</span> OK<br>Transfer-Encoding: chunked<br>Content-Type: text/plain<br><br><span class="hljs-number">5</span>\r\n<br>Hello\r\n<br>    <br><span class="hljs-comment">// 等一会, 再发送6个字节</span><br><span class="hljs-number">6</span>\r\n<br> world\r\n<br>    <br><span class="hljs-comment">// 再等一会, 确定没有后结束响应</span><br><span class="hljs-number">0</span>\r\n<br>\r\n<br></code></pre></td></tr></table></figure><p>类比到日志流, 有新日志我们可以先开始响应发出去, 然后循环等待新的日志生成, 我们再发送出去. 这样实现的效果是 : 客户端只要接收到一块就可以进行处理并呈现在界面上, 但响应只要没有结束, 我们就可以持续发送并让客户端实时接收.</p><p>因此这样的客户端的解析器应拥有什么功能?</p><ul><li>每个chunk模块的循环读取功能, 可以将每个chunk模块取出.</li><li>利用buf解决TCP粘包问题, 毕竟还是依赖于TCP.</li></ul><p>下面给出一个解析器模板 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">ParseState</span> &#123;<br>    ReadingChunkSize,<br>    ReadingChunkData,<br>    ReadingChunkCRLF,<br>    Done<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ChunkedParser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ChunkedParser</span>() : <span class="hljs-built_in">state</span>(ParseState::ReadingChunkSize), <span class="hljs-built_in">chunkSize</span>(<span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>&#123;<br>        buffer += data;<br>        <span class="hljs-built_in">parse</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isFinished</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> state == ParseState::Done;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string buffer;<br>    ParseState state;<br>    <span class="hljs-type">size_t</span> chunkSize;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parse</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state == ParseState::ReadingChunkSize) &#123;<br>                <span class="hljs-type">size_t</span> pos = buffer.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>                <span class="hljs-keyword">if</span> (pos == std::string::npos) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// incomplete line</span><br>                std::string sizeStr = buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, pos);<br>                std::stringstream ss;<br>                ss &lt;&lt; std::hex &lt;&lt; sizeStr;<br>                ss &gt;&gt; chunkSize;<br>                buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, pos + <span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span> (chunkSize == <span class="hljs-number">0</span>) &#123;<br>                    state = ParseState::Done;<br>                    std::cout &lt;&lt; <span class="hljs-string">&quot;[Parser] Reached end of chunked stream.\n&quot;</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                state = ParseState::ReadingChunkData;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (state == ParseState::ReadingChunkData) &#123;<br>                <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">size</span>() &lt; chunkSize) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// wait for more data</span><br>                std::string chunk = buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, chunkSize);<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[Chunk] &quot;</span> &lt;&lt; chunk &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>                buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, chunkSize);<br>                state = ParseState::ReadingChunkCRLF;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (state == ParseState::ReadingChunkCRLF) &#123;<br>                <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">if</span> (buffer.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>) != <span class="hljs-string">&quot;\r\n&quot;</span>) &#123;<br>                    std::cerr &lt;&lt; <span class="hljs-string">&quot;[Error] Expected \\r\\n after chunk data.\n&quot;</span>;<br>                    state = ParseState::Done;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                buffer.<span class="hljs-built_in">erase</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>                state = ParseState::ReadingChunkSize;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>另外需要注意的一点是chunked模式是会长时间占用一个TCP连接的, 使用期间是不能穿插其他信息发送的, 因此相对更适合发送<strong>类型单一且不连续</strong>的信息和<strong>极端要求实时性</strong>的信息.</li></ul><h3 id="缓存控制机制"><a href="#缓存控制机制" class="headerlink" title="缓存控制机制"></a>缓存控制机制</h3><p>简单来说就是你可以设置一些选项如<code>Cache-Control</code>, 来<strong>告知客户端你的响应内容可以被怎样缓存, 缓存多久</strong>. 在正常的浏览器一般都会遵从服务器的决定, 在部分情况浏览器也会进行调优, 这些选项是否被执行都是非强制的, 主导权在客户端方面.</p><p>对于缓存的理解相对简单, 就是浏览器或其他客户端可以把从服务器得到的响应资源缓存下来, 在下一次访问相同目标时就会先从缓存中读取, 可以<strong>降低服务器的压力</strong>.</p><p>我们的缓存选项就是对客户方的缓存行为进行指导, 是否遵从主权在于客户方.</p><p>下面是<code>Cache-Control</code>字段的各种指令 : </p><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td><code>public</code></td><td>可以被任何缓存（包括中间代理）缓存</td></tr><tr><td><code>private</code></td><td>只能被客户端缓存，禁止中间代理缓存</td></tr><tr><td><code>no-cache</code></td><td><strong>不代表不能缓存</strong>，而是每次使用前必须协商验证</td></tr><tr><td><code>no-store</code></td><td>不允许缓存任何内容（如银行、支付页面）</td></tr><tr><td><code>max-age=秒</code></td><td>缓存的最大有效时间，超过就需要验证</td></tr><tr><td><code>s-maxage=秒</code></td><td>专门给共享缓存（CDN、代理）用，优先级高于 <code>max-age</code></td></tr><tr><td><code>must-revalidate</code></td><td>缓存过期后必须向服务器验证，不能使用过期内容</td></tr><tr><td><code>proxy-revalidate</code></td><td>类似于 <code>must-revalidate</code>，但仅针对代理服务器</td></tr></tbody></table><h3 id="虚拟主机支持"><a href="#虚拟主机支持" class="headerlink" title="虚拟主机支持"></a>虚拟主机支持</h3><p>简单来说就是增加了新报头<code>Host</code>, 可以使<strong>一个服务器提供多个服务(多个网站)</strong>, 多个域名可以共享一个服务器.</p><p>在HTTP&#x2F;1.0, HTTP请求发送的目标就是我们Tcp连接到的那个ip:port, 但是在HTTP&#x2F;1.1中我们可以利用Nginx监听这个端口, 再由nginx根据我们<code>Host</code>中写入的域名选择正确的路径, 使得相同的地址因为不同的域名可以导向不同的服务, 实现<strong>“路径级别”的路由</strong>.</p><p>在HTTP&#x2F;1.1中, 所有请求中都要带<code>Host</code>字段.</p><p>下面是一个简单的http请求 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://www.example.com/index.html<br></code></pre></td></tr></table></figure><p>浏览器会将其转换成一下的http请求 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">GET /index.html HTTP/1.1<br>Host: www.example.com<br></code></pre></td></tr></table></figure><p>当浏览器通过DNS找到对应地址后, 我们假定这是一个nginx代理, 其会取出我们的Host字段分析再给出我们正确的路径 : </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span> www.example.com;<br>    <span class="hljs-attribute">root</span> /var/www/example;<br>&#125;<br></code></pre></td></tr></table></figure><p>结合请求路径<code>/index.html</code>, 就可以得到正确路径<code>/var/www/example/index.html</code>, 服务器会将该路径下的文件发送给客户.</p><p><code>Host</code>字段可以不用, 但是在需要服务器搭载多个服务的情况下可以发挥很大的作用.</p><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p><code>Range</code> &#x2F; <code>Content-Range</code> : </p><p>可以在报头中就声明要求获取文件的哪个字节段.</p><h3 id="内容压缩"><a href="#内容压缩" class="headerlink" title="内容压缩"></a>内容压缩</h3><p><code>Content-Encoding</code> :</p><p>可以在报头中声明本次发送的内容被怎样的方式压缩.</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ul><li>队头阻塞 : 一个连接只能同时处理一个请求, 只可串行化.</li><li>为了实现并发只能开多个TCP连接.</li><li>报头冗余字段过多, 效率低.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程服务端编程 读书笔记3</title>
    <link href="/2025/07/16/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2025/07/16/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>工程实践经验谈 </p></blockquote><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><ul><li>分布式系统不是放大了的单机系统, 根本原因在于单机没有部分故障.</li><li>单机与分布式的根本区别在于进程地址空间是一个还是多个.</li></ul><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>一般的解决方案是 : </p><p>通过某个集中的负载均衡器来收集并分发负载情况, 可以把消息数目降到M + N(M台web服务器, N台服务提供服务器).</p><p>但是这种方式会引发单点故障(Single Point of Failure), 最简单的解决方法是进行冗余备份, Nginx就有通过在不同服务器上搭建主从实例的功能来实现保活.</p><ul><li><p>如何定义服务端的负载?</p><p>负载可以认为是一种性能集合, 我们可以把很多因素考虑进去, 如 : CPU使用率, 内存占用率, 硬盘剩余空间, 网络带宽等等. 没有明确唯一的定义, 不同中间件对于负载的计算方法也有很大差异, 而且会给使用者留出很大的可操作空间.</p></li><li><p>如何规避分布式系统中保持全局数据一致性的问题?</p><p>其实很多时候如果对全局数据没有强制要求, 可以先忽视, 只是从当前视角分析哪个服务器负载小, 就选哪个, 这样体现在全局上, 大体依旧是均匀分配的.</p></li></ul><h4 id="时序混乱"><a href="#时序混乱" class="headerlink" title="时序混乱"></a>时序混乱</h4><p>虽然两个服务器间建立的TCP连接是可以保序的, 但是多个服务器之间的发送时序是无法包装, 就算是理应提前发出去的消息, 也有可能延迟于其他服务器后发的消息. 而且不同服务器的时钟一定会有误差, 通过发送方和接收方的时间戳插值计算延迟是完全不可靠的.</p><ul><li>可以使分布式系统内每台机器都运行NTP(网络时间协议)来使各台机器间的时间大体同步.</li><li>如果还需更精确, 有逻辑时钟等方案.</li></ul><h4 id="可靠性和可用性"><a href="#可靠性和可用性" class="headerlink" title="可靠性和可用性"></a>可靠性和可用性</h4><ul><li>“并联”可以极大地提高可靠性, 在硬件上可以体现为两套电源, 在软件上可以体现为多个相同服务的服务器.</li><li>提高冗余, 增加数据备份 &#x2F; 降低重建硬盘的时间 可以进一步提高可靠性.</li><li>可靠性指的是数据不丢失的概率, 可用性指的是数据或服务可以随时被访问到的概率.</li><li>在没有 RAID 的服务器上启用 swap，等于将“全系统的内存可靠性”交给一个“可能随时坏掉的磁盘”，一旦 swap 区损坏，任意进程都可能崩溃或行为异常，因此建议关闭 swap.</li><li>高可用的关键不在于做到不停机, 而是能做到<strong>随时重启任何一个进程或服务</strong>.</li><li>软件的可靠性指标不应过高, 因为体量提高后的硬件故障率其实非常高, 软件非常可靠也没有用.</li></ul><h4 id="“随时重启进程”作为程序设计目标"><a href="#“随时重启进程”作为程序设计目标" class="headerlink" title="“随时重启进程”作为程序设计目标"></a>“随时重启进程”作为程序设计目标</h4><ul><li>进程只要被kill或exit就可以直接重启.</li><li>这要求我们的ICP(进程间通信方式)必须是<strong>操作系统可自动回收</strong>的, 其不可以对其他进程造成任何影响.</li><li>只应当用TCP作为唯一的进程间通信手段, 进程一旦退出, 操作系统会自动将连接与断开关闭, 不要使用跨进程的信号量或共享内存.</li><li>客户端应在连接断开后可以自动重连, 要求客户端可以检测服务端心跳, 在断开后可以自动failover到备用地址.</li><li>客户端应兼容新旧版的服务端协议, 这样在升级服务端时就可以每次杀掉一部分的服务进行, 使服务升级交替进行(<strong>灰度升级</strong>).</li><li>另一种升级方式是迁移, 可以先启动新服务进程, 再让旧服务进程停止接受新请求, 再将新请求导向新进程.</li></ul><h4 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h4><ul><li><p>服务分为有状态服务和无状态服务,  其实就是指代服务需不需要记录上下文信息, 比如登录状态, 会话状态, 临时缓存的信息等等. 无状态服务是很有优势的, 在故障发生时重启也没有问题, 但是有状态服务需要考虑前世进程的影响, 因为进程一旦重启, <strong>之前记录或缓存的所有信息都会清空</strong>.</p></li><li><p>举个例子就是客户端已经在服务端登录了, 结果服务端崩溃, 重启之后服务端并不知道客户端登录, 但是客户端如果没有有效手段区分出服务端已经重启, 那么就会依旧认为自己是已经登录的状态, 就会造成双方的逻辑不一致, 很有可能崩溃.</p></li><li><p>因此在使用有状态服务时, 我们需要对每个进程设置一个<strong>唯一进程标识</strong>, 让客户端分清进程是否发生变化, 一旦发生变化, 客户就可以进行对应的救灾措施, 比如马上重新执行登录操作, 恢复之前的状态.</p></li><li><p>如果设定唯一进程标识?</p><ul><li><p><code>&quot;ip:prot&quot;</code>的方式只可被无状态服务使用, 有状态服务这样子使用是无法区分先后的.</p></li><li><p><code>&quot;ip:port:start_time:pid&quot;</code> 这种定义标准可以被使用, 其几乎没有重复概率, 将其发给客户端就可以表示当前的唯一进程, 并且其本身是有意义的, 从中可以随时提取出服务定位和时间, 便于服务重启.</p></li><li><p><code>UUID</code>是当前最主流标识唯一进程的方式, 其绝对不会重复且获取简单, 在终端界面可以用<code>uuidgen</code>获取 ,  在c&#x2F;c++代码可以通过以下方式获取:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;uuid/uuid.h&gt;</span></span><br><span class="hljs-comment">//....</span><br><span class="hljs-type">uuid_t</span> uuid;<br><span class="hljs-type">char</span> uuid_str[<span class="hljs-number">37</span>];  <span class="hljs-comment">// UUID 字符串长度为 36 + 1 个 &#x27;\0&#x27;</span><br><span class="hljs-built_in">uuid_generate</span>(uuid);<br><span class="hljs-built_in">uuid_unparse</span>(uuid, uuid_str);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="应用层心跳"><a href="#应用层心跳" class="headerlink" title="应用层心跳"></a>应用层心跳</h4><ul><li><p>为什么不能用Tcp keepalive替代应用层心跳?</p><p>Tcp keepalive只能证明目标端口上的进程依旧在线, 不能确定此进程是否正常运行, 不可知对方是否死锁或阻塞.</p></li><li><p>因此我们需要设置应用层心跳, 一般是服务端向客户端发送心跳.</p></li><li><p>延迟不可避免, 分布式系统没有全局的瞬时状态, 不存在立刻判断对方故障的方法.</p></li><li><p>高置信度和低反应时间不可兼得.</p></li><li><p>心跳包中可以包含当前服务端的复杂, 可以便于客户端做负载均衡.</p></li><li><p>心跳协议实现还有两个关键点 : </p><ul><li><p><strong>要在工作线程发送, 不要单独起一个心跳线程</strong>.</p><p>这是<strong>防止工作线程死锁或阻塞时还在继续发心跳</strong>, 工作线程必须实际可用才行.</p></li><li><p><strong>与业务消息用同一个连接, 不要单独用一个心跳连接.</strong></p><p>应用层心跳还应该可以<strong>验证网络通畅</strong>, 只有用同一个连接发送才可以证明连接通畅. 另外还有一个用处是进行连接的<strong>保活</strong>, 因为很多服务器会设置防火墙, 在一个连接长时间没有数据交换后, 防火墙就会在双方不知情的清空下断开连接, 也就是说这之后的第一条消息必定是延迟的, TCP会根据延迟判断连接已经断开, 再重新建立连接发送.</p></li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程服务端编程 读书笔记2</title>
    <link href="/2025/07/14/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2025/07/14/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第二部分 Muduo网络库</p></blockquote><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><ul><li>如何完整高效地传输一个文件?</li></ul><p>文件传输过程一般如下 : </p><ul><li>磁盘 -&gt; 内核页缓冲 -&gt; 用户缓冲区 -&gt; Tcp发送缓冲区 -&gt; 网卡等</li></ul><p>最简单的传输方式当然就是fread + send 一口气传出, 但是这样如果文件非常大的话, 服务器扛不住几个连接, 因为这样的内存消耗非常大. </p><p>书中提出了一种解决内存占用过多的方法 : <strong>流水线 — 分块传输</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/TcpConnection.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/base/Logging.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/any.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo::net;<br><br><span class="hljs-comment">// 自定义删除器，用于自动 fclose</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">customDeleter</span><span class="hljs-params">(FILE* fp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (fp)<br>    &#123;<br>        ::<span class="hljs-built_in">fclose</span>(fp);<br>        LOG_INFO &lt;&lt; <span class="hljs-string">&quot;FILE* closed&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> FilePtr = std::shared_ptr&lt;FILE&gt;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (conn-&gt;<span class="hljs-built_in">connected</span>())<br>    &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename = <span class="hljs-string">&quot;example.txt&quot;</span>;  <span class="hljs-comment">// 假设传输该文件</span><br>        FILE* fp = ::<span class="hljs-built_in">fopen</span>(filename, <span class="hljs-string">&quot;rb&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (fp)<br>        &#123;<br>            <span class="hljs-comment">// 使用 shared_ptr + 自定义 deleter 管理 FILE*</span><br>            <span class="hljs-function">FilePtr <span class="hljs-title">ctx</span><span class="hljs-params">(fp, customDeleter)</span></span>;<br>            conn-&gt;<span class="hljs-built_in">setContext</span>(ctx);<br><br>            <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>];<br>            <span class="hljs-type">size_t</span> nread = ::<span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span> buf, fp);<br>            <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                conn-&gt;<span class="hljs-built_in">send</span>(buf, nread);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            LOG_INFO &lt;&lt; <span class="hljs-string">&quot;FileServer - no such file&quot;</span>;<br>            conn-&gt;<span class="hljs-built_in">shutdown</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LOG_INFO &lt;&lt; <span class="hljs-string">&quot;FileServer - connection closed&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onWriteComplete</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr&amp; conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    FilePtr fp = boost::<span class="hljs-built_in">any_cast</span>&lt;FilePtr&gt;(conn-&gt;<span class="hljs-built_in">getContext</span>());<br><br>    <span class="hljs-keyword">if</span> (fp &amp;&amp; *fp)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>];<br>        <span class="hljs-type">size_t</span> nread = ::<span class="hljs-built_in">fread</span>(buf, <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span> buf, fp.<span class="hljs-built_in">get</span>());<br><br>        <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            conn-&gt;<span class="hljs-built_in">send</span>(buf, nread);  <span class="hljs-comment">// 下一块数据</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// 自动关闭 FILE*（shared_ptr 析构时调用 fclose）</span><br>            conn-&gt;<span class="hljs-built_in">setContext</span>(<span class="hljs-built_in">FilePtr</span>());  <span class="hljs-comment">// 清空 context，触发析构</span><br>            conn-&gt;<span class="hljs-built_in">shutdown</span>();             <span class="hljs-comment">// 主动关闭连接</span><br>            LOG_INFO &lt;&lt; <span class="hljs-string">&quot;FileServer - done&quot;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在建立连接时, 我们只读发了一个64kb, 在写完后才会自动调用Muduo的写完回调, 写完回调中还会继续发送64kb, 发完又会执行写完回调, 直到发完为止. 这是一个很典型的异步循环事件, 可以减少线程阻塞时间与内存占用.</p><p>流水线传输的优势 : </p><ul><li>内存占用少</li><li>防止长时间阻塞等待, 除非你用了非阻塞 + epoll</li><li>可以配合流控动态调整(HighWaterMark)</li><li>可以便于实现限速 &#x2F; 动态生成内容 &#x2F; 生成日志等操作</li></ul><p>当然这是最普遍的跨平台做法, 如果目光放在Linux平台上就有更快捷的方法 : </p><ul><li><p><strong>sendfile</strong> : </p><p>这是专门用来发送文件到socket的内核态函数, 也就是说可以直接跳过内核页缓存到用户缓冲区的拷贝, 直接发给socket, 这样直接砍掉了大部分的内存消耗并且效率极高. 当然sendfile也不是说就可以直接全读全发了, 例如Nginx就还是采取了流水线分块的方式使用sendfile, 这主要还是因为除了内存占用, 其还有其他优势.</p></li><li><p>io_uring : 后面详解.</p></li></ul><h3 id="TCP分包"><a href="#TCP分包" class="headerlink" title="TCP分包"></a>TCP分包</h3><ul><li>针对短连接TCP(需求可靠传输少量数据)的情况, 一般不用考虑分包, 只要等待对方关闭连接, 我方返回0时就可以确定拿到所有数据.</li><li>针对长连接TCP, 有四种方法 : <ul><li>消息长度固定</li><li>用特殊的字符或字符串为边界, 如HTTP</li><li>每个消息都加入一个长度字段, 表示之后要发来的消息长度</li><li>消息本身就有自己的格式 : json &#x2F; protobuf</li></ul></li></ul><h3 id="Buffer设计"><a href="#Buffer设计" class="headerlink" title="Buffer设计"></a>Buffer设计</h3><ul><li>非阻塞 + IO复用 的网络编程中, 应用层的Buffer是必须的 : <ul><li>output buffer : 因为程序最好不要在write时阻塞, 这种情况受限于网络传输状态, 必须要配置输出缓存, 其作用是在一次write无法全部写出去时, 将剩余的部分存到buffer中, 并且设置回调, 当TCP发送缓冲区可写时再调用回调, 也许可以调用io_uring异步IO提高效率. <strong>可加强</strong></li></ul></li></ul><h3 id="Protobuf使用"><a href="#Protobuf使用" class="headerlink" title="Protobuf使用"></a>Protobuf使用</h3><ul><li>特性 : <ul><li>protobuf是一个内容格式, 并非传输协议, 因此其并为封装消息长度, 消息类型之类的东西.</li><li>便捷的是, 如果我们不要Tcp长连接, 需求类型单一, 就可以直接凭借字段解析, 无需依靠长度和类型, 就可以拿到我们想要的数据.</li><li>如果需要Tcp长连接, 可以考虑追加header, 其中包含服务名和方法名&#x2F;类型名, 我们接收到可以利用Descriptor加这些名字自动构建对应的服务方法类型.</li></ul></li><li>ProtobufCodec</li><li>ProtobufDispatcher</li></ul><h3 id="限制服务器的最大并发连接数"><a href="#限制服务器的最大并发连接数" class="headerlink" title="限制服务器的最大并发连接数"></a>限制服务器的最大并发连接数</h3><ul><li><p>可以通过调高进程的文件描述符数目缓解, 但是不宜过多会拖慢进程.</p></li><li><p>最方便快捷的就是设置一个最大连接数, 这个数据在多线程情况下应当线程安全, 当连接数超过这个数, 就直接把连接断掉, 不继续处理.</p></li><li><p>不这样做会发生什么?  </p><p>新连接一直不会得到处理, epoll_wait会被极频繁触发, 极大提高cpu占有率.</p></li></ul><h3 id="检测并清理无效连接"><a href="#检测并清理无效连接" class="headerlink" title="检测并清理无效连接"></a>检测并清理无效连接</h3><p>方法一般就是两大类 : 踢掉空闲连接 和 设置心跳协议.</p><p>前者可以当作权益之计, 但是够轻量, 够便捷, 基本思路就是维护一些桶, 将超时桶中的连接关闭, 一旦有新连接就更新所在桶.</p><p>后者更加稳定有效, 虽然内部会比较冗杂, 但是又很多现代的优化方式, 比如操作系统内核层的心跳机制, 用io_uring + kqueue直接实现精准定时发送.</p><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><h4 id="简易理解"><a href="#简易理解" class="headerlink" title="简易理解"></a>简易理解</h4><ul><li>目的 : 减少系统调用(减少状态转换开销), 减少无效拷贝, 异步实现接口.</li><li>实现 : 内部维护一个请求队列和一个结果队列, 会利用mmap申请一块共享内存, 系统存放数据和用户取出数据都在这块内存上进行, 可以有效减少内核函数调用, 并且纯异步可以有效提高并发.</li><li>使用 : 在此实现上, io_uring提供了很多便利各种服务的接口, 支持读、写、accept、connect、send、recv、splice、sendfile 等统一异步接口, 也就是它们的异步高效版.</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul><li><p>初始化与销毁 : </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>io_uring_queue_init()</code></td><td>初始化 io_uring（内核分配 SQ&#x2F;CQ）</td></tr><tr><td><code>io_uring_queue_exit()</code></td><td>清理资源，解除映射</td></tr></tbody></table></li><li><p>提交请求(提交异步事件) : </p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>io_uring_get_sqe()</code></td><td>获取一个空的提交项（SQE）指针</td></tr><tr><td><code>io_uring_prep_*()</code></td><td>填充 SQE，不同操作有不同函数，如 <code>io_uring_prep_read()</code>、<code>io_uring_prep_accept()</code></td></tr><tr><td><code>io_uring_sqe_set_data()</code></td><td>给 SQE 绑定用户数据（上下文结构体）</td></tr><tr><td><code>io_uring_submit()</code></td><td>将 SQE 正式提交到内核队列</td></tr><tr><td><code>io_uring_submit_and_wait()</code></td><td>提交并等待至少 N 个事件完成（阻塞）</td></tr></tbody></table><p>sqe简单来说就是一个请求句柄, 我们可以用其注册不同的事件, 当然如果有需要的资源(如buf, fd)我们需要填入, 当然在获取对应cqe的时候我们会希望获取一些上下文信息, 可以利用<code>io_uring_sqe_set_data()</code>传入我们自定义结构体的指针, 之后我们就可以利用<code>io_uring_cqe_get_data()</code>获取.</p></li><li><p>获取完成结果 :</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>io_uring_wait_cqe()</code></td><td>阻塞直到有一个 CQE 可用</td></tr><tr><td><code>io_uring_peek_cqe()</code></td><td>非阻塞地获取一个 CQE，如果没有返回 NULL</td></tr><tr><td><code>io_uring_cqe_get_data()</code></td><td>获取你当初绑定的上下文指针（通过 <code>io_uring_sqe_set_data</code> 传入）</td></tr><tr><td><code>io_uring_cqe_seen()</code></td><td>标记这个 CQE 已处理完毕，释放 CQ 空间</td></tr></tbody></table><p><code>io_uring_wait_cqe()</code>会返回cqe对象, cqe-&gt;res中存储的是你在sqe中请求任务函数的返回值, 比如read就会返回int表明是否读取成功与读取长度, accept就会返回新连接的fd.</p></li></ul><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>以下是最简使用io_uring读取一个文件的代码 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;liburing.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path = <span class="hljs-string">&quot;testconf.txt&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">4096</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(path, O_RDONLY);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化 io_uring（默认 8 项）</span><br>    io_uring ring;<br>    <span class="hljs-built_in">io_uring_queue_init</span>(<span class="hljs-number">8</span>, &amp;ring, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 准备提交一个 read 操作</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_sqe</span> *sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(&amp;ring);<br>    <span class="hljs-built_in">io_uring_prep_read</span>(sqe, fd, buffer, <span class="hljs-built_in">sizeof</span>(buffer) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 类似 read(fd, buf, 4096, offset=0)</span><br>    <span class="hljs-built_in">io_uring_submit</span>(&amp;ring);                                     <span class="hljs-comment">// 通知内核提交任务</span><br><br>    <span class="hljs-comment">// 等待结果</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_cqe</span> *cqe;<br>    <span class="hljs-built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);<br>    <span class="hljs-keyword">if</span> (cqe-&gt;res &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;read failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">strerror</span>(-cqe-&gt;res) &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Read success, bytes: &quot;</span> &lt;&lt; cqe-&gt;res &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Content: \n&quot;</span><br>                  &lt;&lt; buffer &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);<br>    <span class="hljs-built_in">io_uring_queue_exit</span>(&amp;ring);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="回显服务器"><a href="#回显服务器" class="headerlink" title="回显服务器"></a>回显服务器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;liburing.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8888</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKLOG 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 2048</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_DEPTH  256</span><br><br><span class="hljs-keyword">enum</span> &#123;<br>    ACCEPT,<br>    READ,<br>    WRITE<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">conn_info</span> &#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">int</span> type;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_accept</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_uring* ring, <span class="hljs-type">int</span> server_fd, sockaddr_in* client_addr, <span class="hljs-type">socklen_t</span>* client_len)</span> </span>&#123;<br>    io_uring_sqe* sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br><br>    <span class="hljs-keyword">auto</span>* ci = <span class="hljs-keyword">new</span> conn_info&#123;server_fd, ACCEPT&#125;;<br><br>    <span class="hljs-built_in">io_uring_prep_accept</span>(sqe, server_fd, (sockaddr*)client_addr, client_len, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>    <span class="hljs-built_in">io_uring_submit</span>(ring);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_uring* ring, <span class="hljs-type">int</span> client_fd, <span class="hljs-type">char</span>* buf)</span> </span>&#123;<br>    io_uring_sqe* sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br><br>    <span class="hljs-keyword">auto</span>* ci = <span class="hljs-keyword">new</span> conn_info&#123;client_fd, READ&#125;;<br><br>    <span class="hljs-built_in">io_uring_prep_recv</span>(sqe, client_fd, buf, BUFFER_SIZE, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>    <span class="hljs-built_in">io_uring_submit</span>(ring);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> io_uring* ring, <span class="hljs-type">int</span> client_fd, <span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> len)</span> </span>&#123;<br>    io_uring_sqe* sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br><br>    <span class="hljs-keyword">auto</span>* ci = <span class="hljs-keyword">new</span> conn_info&#123;client_fd, WRITE&#125;;<br><br>    <span class="hljs-built_in">io_uring_prep_send</span>(sqe, client_fd, buf, len, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>    <span class="hljs-built_in">io_uring_submit</span>(ring);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">make_socket_non_blocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> server_fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    sockaddr_in addr&#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    addr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-built_in">bind</span>(server_fd, (sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-built_in">listen</span>(server_fd, BACKLOG);<br>    <span class="hljs-built_in">make_socket_non_blocking</span>(server_fd);<br><br>    io_uring ring;<br>    <span class="hljs-built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="hljs-number">0</span>);<br><br>    sockaddr_in client_addr&#123;&#125;;<br>    <span class="hljs-type">socklen_t</span> client_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>    <span class="hljs-built_in">add_accept</span>(&amp;ring, server_fd, &amp;client_addr, &amp;client_len);<br><br>    <span class="hljs-type">char</span>* buffers[QUEUE_DEPTH] = &#123;<span class="hljs-literal">nullptr</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; QUEUE_DEPTH; ++i)<br>        buffers[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUFFER_SIZE];<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        io_uring_cqe* cqe;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;wait_cqe failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">strerror</span>(-ret) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span>* ci = <span class="hljs-built_in">static_cast</span>&lt;conn_info*&gt;(<span class="hljs-built_in">io_uring_cqe_get_data</span>(cqe));<br>        <span class="hljs-type">int</span> client_fd = ci-&gt;fd;<br>        <span class="hljs-type">int</span> type = ci-&gt;type;<br>        <span class="hljs-type">int</span> res = cqe-&gt;res;<br><br>        <span class="hljs-keyword">if</span> (type == ACCEPT) &#123;<br>            <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">make_socket_non_blocking</span>(res);<br>                <span class="hljs-built_in">add_read</span>(&amp;ring, res, buffers[res % QUEUE_DEPTH]);<br>            &#125;<br>            <span class="hljs-built_in">add_accept</span>(&amp;ring, server_fd, &amp;client_addr, &amp;client_len);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == READ) &#123;<br>            <span class="hljs-keyword">if</span> (res &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">close</span>(client_fd);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">add_write</span>(&amp;ring, client_fd, buffers[client_fd % QUEUE_DEPTH], res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == WRITE) &#123;<br>            <span class="hljs-built_in">add_read</span>(&amp;ring, client_fd, buffers[client_fd % QUEUE_DEPTH]);<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> ci;<br>        <span class="hljs-built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);<br>    &#125;<br><br>    <span class="hljs-built_in">io_uring_queue_exit</span>(&amp;ring);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; QUEUE_DEPTH; ++i)<br>        <span class="hljs-keyword">delete</span>[] buffers[i];<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到其中循环读取cqe, 其实和epoll_wait非常像, 但是本质不一样, cqe得到的是已经通过异步完成的结果, 而epoll_wait得到是事件发送的通知. 不过io_uring_wait_cqe只能读取一个完成事件, 如果想一次性像epoll_wait多个读取事件集的话, 可以使用<code>io_uring_peek_batch_cqe()</code>非阻塞地获取ceq集.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">unsigned</span> count = <span class="hljs-built_in">io_uring_peek_batch_cqe</span>(&amp;ring, cqe_array, max_count);<br></code></pre></td></tr></table></figure><h4 id="Buffer相关"><a href="#Buffer相关" class="headerlink" title="Buffer相关"></a>Buffer相关</h4><p>我们可以将自己申请的buffer提前注册到io_uring服务中, 这样io_uring就会将我们用户态的缓冲区注册到内核中, 人话说就是, <strong>io_uring会把我们的申请的用户态缓冲区当作内核缓冲区来用.</strong> 这样就可以省去内核态缓冲区到用户缓冲区的拷贝, 可以提高效率, 甚至部分操作还可以实现零拷贝.</p><ul><li><p>首先我们需要自己把需要注册的缓冲区new出来并注册 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">char</span> *&gt; buffers;<br>iovec iovecs[QUEUE_DEPTH];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; QUEUE_DEPTH; ++i)<br>&#123;<br>    <span class="hljs-type">char</span> *buf = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUFFER_SIZE];<br>    buffers.<span class="hljs-built_in">push_back</span>(buf);<br>    iovecs[i].iov_base = buf;<br>    iovecs[i].iov_len = BUFFER_SIZE;<br>&#125;<br><span class="hljs-built_in">io_uring_register_buffers</span>(&amp;ring, iovecs, QUEUE_DEPTH);<br></code></pre></td></tr></table></figure><p>需要注意的是, io_uring要求绑定的缓冲区必须是iovec数组, 这个结构体常用于readv&#x2F;writev中, 其中存放指向缓冲区的指针和大小.</p></li><li><p>那么在之后的<code>io_uring_prep_*</code>各种操作中就可以直接使用我们注册的缓冲区.</p></li><li><p>对于缓冲区的使用有两种使用模式 : </p><ul><li><p>Fixed Buffer 模式 : 由用户选择注册缓冲区中的那块buf(其实就是iovec数组的哪个下标), 便于用户细化控制.</p></li><li><p>Buffer Selection 模式 : 内部将用户注册的内存投放到内存池中, 由系统自动随机选择未被使用的buf, 用户可以从cqe中提取出系统的选择结果, 代码更加方便, 并且内存分配更有效, 适合高并发场景. </p></li><li><p>可以通过seq请求句柄设置我们使用哪个buffer模式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">sqe-&gt;flags |= IOSQE_BUFFER_FIXED;<br>sqe-&gt;flags |= IOSQE_BUFFER_SELECT;<br></code></pre></td></tr></table></figure></li></ul><p>后面提供两种版本的回显服务器优化.</p></li></ul><h4 id="Fixed-Buffer优化的回显服务器"><a href="#Fixed-Buffer优化的回显服务器" class="headerlink" title="Fixed Buffer优化的回显服务器"></a>Fixed Buffer优化的回显服务器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;liburing.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8888</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BACKLOG 512</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 2048</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> QUEUE_DEPTH 256</span><br><br><span class="hljs-keyword">enum</span><br>&#123;<br>    ACCEPT,<br>    READ,<br>    WRITE<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">conn_info</span><br>&#123;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-type">int</span> type;<br>    <span class="hljs-type">int</span> buf_index;<br>&#125;;<br><br><span class="hljs-comment">// 全局缓冲区信息</span><br>std::vector&lt;<span class="hljs-type">char</span> *&gt; buffers;<br>iovec iovecs[QUEUE_DEPTH];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">make_socket_non_blocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_accept</span><span class="hljs-params">(io_uring *ring, <span class="hljs-type">int</span> server_fd, sockaddr_in *client_addr, <span class="hljs-type">socklen_t</span> *client_len)</span></span><br><span class="hljs-function"></span>&#123;<br>    io_uring_sqe *sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br>    <span class="hljs-keyword">auto</span> *ci = <span class="hljs-keyword">new</span> conn_info&#123;server_fd, ACCEPT, <span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-built_in">io_uring_prep_accept</span>(sqe, server_fd, (sockaddr *)client_addr, client_len, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_read</span><span class="hljs-params">(io_uring *ring, <span class="hljs-type">int</span> client_fd, <span class="hljs-type">int</span> buf_index)</span></span><br><span class="hljs-function"></span>&#123;<br>    io_uring_sqe *sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br>    <span class="hljs-keyword">auto</span> *ci = <span class="hljs-keyword">new</span> conn_info&#123;client_fd, READ, buf_index&#125;;<br><br>    <span class="hljs-built_in">io_uring_prep_read_fixed</span>(sqe, client_fd, iovecs[buf_index].iov_base, BUFFER_SIZE, <span class="hljs-number">0</span>, buf_index);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_write</span><span class="hljs-params">(io_uring *ring, <span class="hljs-type">int</span> client_fd, <span class="hljs-type">int</span> buf_index, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    io_uring_sqe *sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(ring);<br>    <span class="hljs-keyword">auto</span> *ci = <span class="hljs-keyword">new</span> conn_info&#123;client_fd, WRITE, buf_index&#125;;<br><br>    <span class="hljs-built_in">io_uring_prep_write_fixed</span>(sqe, client_fd, iovecs[buf_index].iov_base, len, <span class="hljs-number">0</span>, buf_index);<br>    <span class="hljs-built_in">io_uring_sqe_set_data</span>(sqe, ci);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> server_fd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    sockaddr_in addr&#123;&#125;;<br>    addr.sin_family = AF_INET;<br>    addr.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br>    addr.sin_addr.s_addr = INADDR_ANY;<br><br>    <span class="hljs-built_in">bind</span>(server_fd, (sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br>    <span class="hljs-built_in">listen</span>(server_fd, BACKLOG);<br>    <span class="hljs-built_in">make_socket_non_blocking</span>(server_fd);<br><br>    io_uring ring;<br>    <span class="hljs-built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 注册固定缓冲区</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; QUEUE_DEPTH; ++i)<br>    &#123;<br>        <span class="hljs-type">char</span> *buf = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[BUFFER_SIZE];<br>        buffers.<span class="hljs-built_in">push_back</span>(buf);<br>        iovecs[i].iov_base = buf;<br>        iovecs[i].iov_len = BUFFER_SIZE;<br>    &#125;<br>    <span class="hljs-built_in">io_uring_register_buffers</span>(&amp;ring, iovecs, QUEUE_DEPTH);<br><br>    sockaddr_in client_addr&#123;&#125;;<br>    <span class="hljs-type">socklen_t</span> client_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br>    <span class="hljs-built_in">add_accept</span>(&amp;ring, server_fd, &amp;client_addr, &amp;client_len);<br>    <span class="hljs-built_in">io_uring_submit</span>(&amp;ring);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        io_uring_cqe *cqe;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;wait_cqe failed: &quot;</span> &lt;&lt; <span class="hljs-built_in">strerror</span>(-ret) &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> *ci = <span class="hljs-built_in">static_cast</span>&lt;conn_info *&gt;(<span class="hljs-built_in">io_uring_cqe_get_data</span>(cqe));<br>        <span class="hljs-type">int</span> client_fd = ci-&gt;fd;<br>        <span class="hljs-type">int</span> type = ci-&gt;type;<br>        <span class="hljs-type">int</span> res = cqe-&gt;res;<br><br>        <span class="hljs-keyword">if</span> (type == ACCEPT)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">make_socket_non_blocking</span>(res);<br>                <span class="hljs-type">int</span> buf_index = res % QUEUE_DEPTH;<br>                <span class="hljs-built_in">add_read</span>(&amp;ring, res, buf_index);<br>            &#125;<br>            <span class="hljs-built_in">add_accept</span>(&amp;ring, server_fd, &amp;client_addr, &amp;client_len);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == READ)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (res &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">close</span>(client_fd);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">int</span> buf_index = ci-&gt;buf_index;<br>                <span class="hljs-built_in">add_write</span>(&amp;ring, client_fd, buf_index, res);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == WRITE)<br>        &#123;<br>            <span class="hljs-type">int</span> buf_index = ci-&gt;buf_index;<br>            <span class="hljs-built_in">add_read</span>(&amp;ring, client_fd, buf_index);<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> ci;<br>        <span class="hljs-built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);<br>        <span class="hljs-built_in">io_uring_submit</span>(&amp;ring);<br>    &#125;<br><br>    <span class="hljs-built_in">io_uring_queue_exit</span>(&amp;ring);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> *buf : buffers)<br>        <span class="hljs-keyword">delete</span>[] buf;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>io_uring_prep_read_fixed : </p><p>这是一个便利函数, 其内部相当于调用了原函数, 设置使用Fixed Buffer模式, 设定使用的buffer_index.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">io_uring_prep_read</span>(sqe, fd, my_buffer, BUF_SIZE, <span class="hljs-number">0</span>);<br>sqe-&gt;flags |= IOSQE_BUFFER_FIXED;  <span class="hljs-comment">// 告诉内核这个 buffer 是固定注册的</span><br>sqe-&gt;buf_index = <span class="hljs-number">0</span>; <br></code></pre></td></tr></table></figure></li><li><p>分析代码可以看出, 这里每次accept接收到新连接后都会为每个连接分配一个新的缓冲区下标, 以此做到每个连接对应一个缓冲区, 彼此不会相互影响.</p></li><li><p>当然我们发送的消息有可能一个缓冲区接收不了, 那么就只会读满缓冲区然后返回, 剩下的都会留在内核接收缓冲区中. 因此如果想解决这种情况, 可以判断接收大小是否等于BUF_SIZE, 如果等于就再提交一次异步读任务.</p></li></ul><h3 id="细碎知识"><a href="#细碎知识" class="headerlink" title="细碎知识"></a>细碎知识</h3><ul><li><p>使用前向声明可以简化头文件之间的依赖关系, 避免将内部类暴露给用户.</p></li><li><p>流复用 + 均衡控制</p></li><li><p>TLS加密&#x2F;压缩</p></li><li><p>定时器内部使用gettimeofday(2)获取当前时间, 使用timerfd_*系列函数处理定时任务, 将定时器转化为fd, 可以用处理IO的方式处理超时事件.</p></li><li><p>往返时间 &#x3D; round trip time &#x3D; RTT.</p><p>往返时间 &#x2F; 2 一般不可代表单程延迟, 因为时间域不同, 双方发送路径可能不同.</p></li><li><p>基于 io_uring &#x2F; kqueue 的高效超时检测</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>文件传输</tag>
      
      <tag>io_uring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux多线程服务端编程 读书笔记1</title>
    <link href="/2025/07/12/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2025/07/12/%5BLinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%5D%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第一部分 C++多线程系统编程</p></blockquote><h3 id="析构所在的线程"><a href="#析构所在的线程" class="headerlink" title="析构所在的线程"></a>析构所在的线程</h3><p>当share_ptr引用计数归零时, 会在归零的这个线程就地析构, 而这个线程不一定是对象诞生的线程.</p><p>这就引发出一个问题 : </p><ul><li>如果对象的析构比较耗时, 且经常在关键线程触发析构, 就会拖慢关键线程的速度.</li></ul><p>这种情况的解决方案是专门做一个阻塞队列存入要析构的智能指针, 另开一个专门析构的线程从队列中取出进行析构.</p><h3 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h3><ul><li><p>其核心作用在于<strong>提高响应速度</strong>, 不是提高绝对性能, 而是提高平均响应性能.</p></li><li><p>绝对的IO密集和绝对的计算密集都并非多线程的优势, 前者性能瓶颈在磁盘&#x2F;网络IO(简单说就是从磁盘&#x2F;网络缓冲区读数据太慢了, 读到的内容cpu可以马上处理, 而且单线程就可以完成, 根本不是cpu的问题), 后者多进程也完全可以. </p></li><li><p>适用多线程的条件 : </p><ul><li>存在数据共享.</li><li>提供非均质的服务, 有优先级差异或难易度差异.</li><li>希望使用异步操作.</li><li>需要有效划分责任和功能.</li></ul></li><li><p>多线程可以让IO和计算相互重叠, 降低延迟, 简单讲就是如果用一个主线程专门用来响应, 其将工作分发给工作线程, 相比于只用一个主线程响应+工作, 一个任务速度一样, 但是多个任务并发效率就会明显提升.</p></li><li><p>一个事件循环的多线程程序应该轻松支持5万并发连接.</p></li><li><p>多线程可以有效降低”简单任务被复杂任务被任务压住”的出现概率.</p></li><li><p>BlockingQueue是解决多线程程序的利器.</p></li><li><p>虽然所有网络写操作都可以异步去做, 但是如果Tcp缓存区是空的, 也可以直接在服务线程写完, 这是一种网络库的性能优化策略.</p></li></ul><h3 id="线程模型选择"><a href="#线程模型选择" class="headerlink" title="线程模型选择"></a>线程模型选择</h3><ul><li>计算密集型 : Reactor + 线程池(多线程) -&gt; IO不是瓶颈, 多线程增加cpu利用, 比多进程易于管理.</li><li>轻量级请求(短连接 + 快速响应) : Reactor + 单线程 -&gt; 处理本身迅速, 无需线程池, 参考Nginx.</li><li>IO密集型 : Proactor -&gt; 事件IO全部交给内核处理, 自己线程运行响应不受影响.</li><li>延迟敏感&#x2F;要求高吞吐 : Proactor -&gt; 可以随时同时处理很多任务(虽然是内核背后实现的).</li></ul><h3 id="多线程磁盘IO"><a href="#多线程磁盘IO" class="headerlink" title="多线程磁盘IO"></a>多线程磁盘IO</h3><p>如果想提高文件读取效率, 可以使用多线程每个线程分配多个部分同时读取, 都使用pread, 拼接到目标的buffer.</p><p>也可以使用mmap, 从映射中每个线程分别读取自己的部分到buffer中.</p><p>当然如果想要磁盘IO到socket, sendfile这种内核函数往往才是最优解.</p><p>现在也可以使用io_uring,  其可以实现异步将数据从磁盘搬到用户缓冲区, 真异步, 并且搬运效率还比前两种高.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;liburing.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    io_uring ring;<br>    <span class="hljs-built_in">io_uring_queue_init</span>(<span class="hljs-number">8</span>, &amp;ring, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, O_RDONLY);<br>    <span class="hljs-type">char</span>* buf = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">4096</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_sqe</span>* sqe = <span class="hljs-built_in">io_uring_get_sqe</span>(&amp;ring);<br>    <span class="hljs-built_in">io_uring_prep_read</span>(sqe, fd, buf, <span class="hljs-number">4096</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">io_uring_submit</span>(&amp;ring);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">io_uring_cqe</span>* cqe;<br>    <span class="hljs-built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);<br><br>    <span class="hljs-keyword">if</span> (cqe-&gt;res &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;read error: %s\n&quot;</span>, <span class="hljs-built_in">strerror</span>(-cqe-&gt;res));<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">write</span>(STDOUT_FILENO, buf, cqe-&gt;res);<br><br>    <span class="hljs-built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);<br>    <span class="hljs-built_in">close</span>(fd);<br>    <span class="hljs-built_in">free</span>(buf);<br>    <span class="hljs-built_in">io_uring_queue_exit</span>(&amp;ring);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Linux分配文件描述符方式所引发的问题"><a href="#Linux分配文件描述符方式所引发的问题" class="headerlink" title="Linux分配文件描述符方式所引发的问题"></a>Linux分配文件描述符方式所引发的问题</h3><ul><li>Linux分配文件描述符, 分配的是当前最小可用的文件描述符码.</li></ul><p>这种分配方式有可能会引发”串话”, 简单说就是两个不同时间的对象持有同一个文件描述符, 向前一个发送的消息有可能发送到后一个中. 解决方法是 : </p><ul><li>用RAII包装文件描述符.</li></ul><p>人话说就是用一个类管理文件描述符, 这个类在外部用智能指针之类的资源管理类维护, 这样就算文件描述符一样, 但是我们看的是持有这个文件描述符的对象, 只要各自有一个对象就行.</p><p>实践到Muduo库中, 就是TcpConnection, 一般用<code>share_ptr&lt;Tcpconnection&gt;</code>, 只要连接断开这个对象就会析构, 但是我们处理事务对象也会同时拥有对应的<code>weak_ptr&lt;Tcpconnection&gt;</code>用来观察, 在事务处理完后就可用通过提升弱指针观察Tcpconnection是否还存在, 存在就发送, 不存在就算了, 这种处理技术又被称为 — <strong>弱回调</strong>.</p><h3 id="细碎知识"><a href="#细碎知识" class="headerlink" title="细碎知识"></a>细碎知识</h3><ul><li><p>最低限度地共享对象,  优先使用高层同步设施(线程池, 队列), 如果不得已必须, 优先使用互斥锁和条件变量, 不要用读写锁和信号量.</p></li><li><p>读写锁的效率不一定比互斥锁高, 因为其会维护额外的东西, 并且我们一般希望临界区短些, 临界区越短, 读写锁的优势越小.</p></li><li><p>必须通过循环判断布尔值来解决虚假唤醒问题.</p></li><li><p>单例模式中的实例一般是静态变量, 在第一次执行时创建, C++11后保证静态变量的创建是线程安全的, 也就是说这种创建方式是线程安全的. 也可以通过new在堆上创建, 这种创建是可以传入参数的(静态变量不可), 并且销毁是可控的, 但是这里会有线程安全问题, 可以通过call_once来解决 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-function"><span class="hljs-type">static</span> T* <span class="hljs-title">instance</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    std::<span class="hljs-built_in">call_once</span>(flag_, [&amp;] &#123;<br>        instance_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> instance_;<br>&#125;traverse<br></code></pre></td></tr></table></figure><p>其保证内部的代码原子且只被执行一次.</p></li><li><p>one loop per thread 的优势 : </p><ul><li>线程数目固定, 开始时创建, 不会频繁地创建和销毁, 如果用一个线程池去控制也更方便, 更好控制.</li><li>负责调配方便, 数目固定直接轮询其实就是非常好的方案.</li><li>每个连接会对应固定线程, 不需要关心线程安全, 没有锁的顾虑.</li></ul></li><li><p>进程间通信选择TCP往往是最优的选择, 因为其天然跨主机, 可以长连接, 更稳定, 相比于多出来的一些花销, 其使用更加简洁且功能丰富.</p></li><li><p>当想限制CPU的占用率时, 需要使用单线程.</p></li><li><p>系统的文件函数一般都是线程安全的, 但是如果组合起来的话就可能有问题, 比如想指定读某个文件的某部分, 就需要先lseek再read, 但是lseek和read的中间可能有其他线程也会调用lseek, 由于lseek的影响是全局的, 就会read错误. 解决方法是使用pread, 其就是内部封装了lseek和read再使其原子化. </p></li><li><p>多线程程序中不要使用信号, 就算要用也要转换成统一的事件, 推荐用signalfd之间转化为文件描述符事件.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libuv事件库</title>
    <link href="/2025/07/11/libuv%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    <url>/2025/07/11/libuv%E7%BD%91%E7%BB%9C%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="回显服务器"><a href="#回显服务器" class="headerlink" title="回显服务器"></a>回显服务器</h3><p>先实现一个最简的Tcp回显服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;uv.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 7000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-comment">// 分配缓冲区</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">alloc_buffer</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span> *handle, <span class="hljs-type">size_t</span> suggested_size, <span class="hljs-type">uv_buf_t</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    buf-&gt;base = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(suggested_size);<br>    buf-&gt;len = suggested_size;<br>&#125;<br><br><span class="hljs-comment">// 关闭连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_close</span><span class="hljs-params">(<span class="hljs-type">uv_handle_t</span> *handle)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">free</span>(handle);<br>&#125;<br><br><span class="hljs-comment">// 写回数据后的回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo_write</span><span class="hljs-params">(<span class="hljs-type">uv_write_t</span> *req, <span class="hljs-type">int</span> status)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Write error %s\n&quot;</span>, <span class="hljs-built_in">uv_strerror</span>(status));<br>    &#125;<br>    <span class="hljs-built_in">free</span>(req-&gt;data);<br>    <span class="hljs-built_in">free</span>(req);<br>&#125;<br><br><span class="hljs-comment">// 读数据后的回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_read</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span> *client, <span class="hljs-type">ssize_t</span> nread, <span class="hljs-type">const</span> <span class="hljs-type">uv_buf_t</span> *buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (nread &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-type">uv_write_t</span> *req = (<span class="hljs-type">uv_write_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uv_write_t</span>));<br>        <span class="hljs-type">uv_buf_t</span> wrbuf = <span class="hljs-built_in">uv_buf_init</span>(buf-&gt;base, nread);<br>        req-&gt;data = buf-&gt;base; <span class="hljs-comment">// 保存写回用的数据</span><br><br>        <span class="hljs-built_in">uv_write</span>(req, client, &amp;wrbuf, <span class="hljs-number">1</span>, echo_write);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nread &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nread != UV_EOF)<br>            <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Read error %s\n&quot;</span>, <span class="hljs-built_in">uv_err_name</span>(nread));<br>        <span class="hljs-built_in">uv_close</span>((<span class="hljs-type">uv_handle_t</span> *)client, on_close);<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(buf-&gt;base);<br>&#125;<br><br><span class="hljs-comment">// 有新连接时触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_new_connection</span><span class="hljs-params">(<span class="hljs-type">uv_stream_t</span> *server, <span class="hljs-type">int</span> status)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;New connection error %s\n&quot;</span>, <span class="hljs-built_in">uv_strerror</span>(status));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">uv_tcp_t</span> *client = (<span class="hljs-type">uv_tcp_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">uv_tcp_t</span>));<br>    <span class="hljs-built_in">uv_tcp_init</span>(server-&gt;loop, client);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">uv_accept</span>(server, (<span class="hljs-type">uv_stream_t</span> *)client) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">uv_read_start</span>((<span class="hljs-type">uv_stream_t</span> *)client, alloc_buffer, on_read);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">uv_close</span>((<span class="hljs-type">uv_handle_t</span> *)client, on_close);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uv_loop_t</span> *loop = <span class="hljs-built_in">uv_default_loop</span>();<br><br>    <span class="hljs-type">uv_tcp_t</span> server;<br>    <span class="hljs-built_in">uv_tcp_init</span>(loop, &amp;server);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>    <span class="hljs-built_in">uv_ip4_addr</span>(<span class="hljs-string">&quot;0.0.0.0&quot;</span>, PORT, &amp;addr);<br><br>    <span class="hljs-built_in">uv_tcp_bind</span>(&amp;server, (<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">uv_listen</span>((<span class="hljs-type">uv_stream_t</span> *)&amp;server, <span class="hljs-number">128</span>, on_new_connection);<br><br>    <span class="hljs-keyword">if</span> (r)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Listen error %s\n&quot;</span>, <span class="hljs-built_in">uv_strerror</span>(r));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Echo server listening on port %d...\n&quot;</span>, PORT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">uv_run</span>(loop, UV_RUN_DEFAULT);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到都是和其他网络库非常相似的事件循环, 但也有非常强的异步风格, 处理事件都是需要传入相应回调的.</p><p>比较有意思的是<code>uv_read_start</code>的使用, 这个函数需要传入申请缓冲区的回调和读事件发生后的回调, 这里并不需要我们在外部提前申请缓冲区, 而是由库内部自己决定申请缓冲区的时机, 于是就可以在读事件发生时再及时申请内存然后读入, 非常好地利用了异步的特性, 避免了长期占有部分内存. 关于如何获取内部读到的数据, 读事件完毕后的回调中必须要有<code>uv_buf_t</code>这个类型, 我们可以从该类型参数中取出读到的内容.</p><h3 id="libuv特性及优势"><a href="#libuv特性及优势" class="headerlink" title="libuv特性及优势"></a>libuv特性及优势</h3><ul><li><p>libuv是一般使用单线程模型, 支持线程池但很少使用. 本身还是Reactor模型, 通过事件循环多路复用分发事件.</p></li><li><p>非常标准的纯异步网络库, 都是通过回调进行处理.</p></li><li><p>专门匹配Node.js, 可以比较完美地匹配windows环境, 虽然本身跨平台, 但是相比于其他网络库在windows平台有天然优势, 可以实现很多windows下的异步操作.</p></li><li><p>原生支持异步文件 &#x2F; DNS &#x2F; 子进程.</p></li></ul><h3 id="异步文件操作"><a href="#异步文件操作" class="headerlink" title="异步文件操作"></a>异步文件操作</h3><p>利用libuv实现异步文件读取.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;uv.h&gt;</span></span><br><br><span class="hljs-type">uv_loop_t</span> *loop;<br><span class="hljs-type">uv_fs_t</span> open_req, read_req, close_req;<br><span class="hljs-type">uv_buf_t</span> iov;<br><span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_close</span><span class="hljs-params">(<span class="hljs-type">uv_fs_t</span>* req)</span> </span>&#123;<br>    <span class="hljs-built_in">uv_fs_req_cleanup</span>(req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_read</span><span class="hljs-params">(<span class="hljs-type">uv_fs_t</span>* req)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (req-&gt;result &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read: %.*s\n&quot;</span>, (<span class="hljs-type">int</span>)req-&gt;result, buffer);<br>    &#125;<br>    <span class="hljs-built_in">uv_fs_req_cleanup</span>(req);<br>    <span class="hljs-built_in">uv_fs_close</span>(loop, &amp;close_req, open_req.result, on_close);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_open</span><span class="hljs-params">(<span class="hljs-type">uv_fs_t</span>* req)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (req-&gt;result &gt;= <span class="hljs-number">0</span>) &#123;<br>        iov = <span class="hljs-built_in">uv_buf_init</span>(buffer, <span class="hljs-built_in">sizeof</span>(buffer));<br>        <span class="hljs-built_in">uv_fs_read</span>(loop, &amp;read_req, req-&gt;result, &amp;iov, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, on_read);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Error opening file: %s\n&quot;</span>, <span class="hljs-built_in">uv_strerror</span>((<span class="hljs-type">int</span>)req-&gt;result));<br>    &#125;<br>    <span class="hljs-built_in">uv_fs_req_cleanup</span>(req);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    loop = <span class="hljs-built_in">uv_default_loop</span>();<br>    <span class="hljs-built_in">uv_fs_open</span>(loop, &amp;open_req, <span class="hljs-string">&quot;test.txt&quot;</span>, O_RDONLY, <span class="hljs-number">0</span>, on_open);<br>    <span class="hljs-built_in">uv_run</span>(loop, UV_RUN_DEFAULT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要就是围绕<code>uv_fs_t</code>这个类实现异步文件读取, 读到内容都会先存在这个类中.</p><h3 id="异步-DNS-解析"><a href="#异步-DNS-解析" class="headerlink" title="异步 DNS 解析"></a>异步 DNS 解析</h3><p>这个主要是为了配合Nodejs实现网页前端的异步域名解析 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;uv.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_resolved</span><span class="hljs-params">(<span class="hljs-type">uv_getaddrinfo_t</span>* req, <span class="hljs-type">int</span> status, <span class="hljs-keyword">struct</span> addrinfo* res)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (status &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;getaddrinfo callback error %s\n&quot;</span>, <span class="hljs-built_in">uv_strerror</span>(status));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> addr[<span class="hljs-number">17</span>] = &#123;<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br>    <span class="hljs-built_in">uv_ip4_name</span>((<span class="hljs-keyword">struct</span> sockaddr_in*) res-&gt;ai_addr, addr, <span class="hljs-number">16</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Resolved IP: %s\n&quot;</span>, addr);<br><br>    <span class="hljs-built_in">uv_freeaddrinfo</span>(res);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">uv_loop_t</span>* loop = <span class="hljs-built_in">uv_default_loop</span>();<br>    <span class="hljs-type">uv_getaddrinfo_t</span> resolver;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints = &#123;<span class="hljs-number">0</span>&#125;;<br>    hints.ai_family = AF_INET;<br>    hints.ai_socktype = SOCK_STREAM;<br><br>    <span class="hljs-built_in">uv_getaddrinfo</span>(loop, &amp;resolver, on_resolved, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-string">&quot;80&quot;</span>, &amp;hints);<br>    <span class="hljs-built_in">uv_run</span>(loop, UV_RUN_DEFAULT);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>libuv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>boost::asio网络库</title>
    <link href="/2025/07/08/boost%20asio%E7%BD%91%E7%BB%9C%E5%BA%93/"/>
    <url>/2025/07/08/boost%20asio%E7%BD%91%E7%BB%9C%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主要学习asio网络库有关异步方面的使用 </p></blockquote><p>这里先给出一个最简便的TCP异步echo服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// async_echo_server.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Session&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(tcp::socket socket) : <span class="hljs-built_in">socket_</span>(std::<span class="hljs-built_in">move</span>(socket)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">do_read</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_read</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">self</span><span class="hljs-params">(shared_from_this())</span></span>;<br>        socket_.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(data_, max_length),<br>                                [<span class="hljs-keyword">this</span>, self](boost::system::error_code ec, std::<span class="hljs-type">size_t</span> length)<br>                                &#123;<br>                                    <span class="hljs-keyword">if</span> (!ec)<br>                                        <span class="hljs-built_in">do_write</span>(length);<br>                                &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_write</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> length)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">self</span><span class="hljs-params">(shared_from_this())</span></span>;<br>        boost::asio::<span class="hljs-built_in">async_write</span>(socket_, boost::asio::<span class="hljs-built_in">buffer</span>(data_, length),<br>                                 [<span class="hljs-keyword">this</span>, self](boost::system::error_code ec, std::<span class="hljs-type">size_t</span> <span class="hljs-comment">/*length*/</span>)<br>                                 &#123;<br>                                     <span class="hljs-keyword">if</span> (!ec)<br>                                         <span class="hljs-built_in">do_read</span>();<br>                                 &#125;);<br>    &#125;<br><br>    tcp::socket socket_;<br>    <span class="hljs-keyword">enum</span><br>    &#123;<br>        max_length = <span class="hljs-number">1024</span><br>    &#125;;<br>    <span class="hljs-type">char</span> data_[max_length];<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(boost::asio::io_context &amp;io_context, <span class="hljs-type">short</span> port)<br>        : <span class="hljs-built_in">acceptor_</span>(io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port))<br>    &#123;<br>        <span class="hljs-built_in">do_accept</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        acceptor_.<span class="hljs-built_in">async_accept</span>(<br>            [<span class="hljs-keyword">this</span>](boost::system::error_code ec, tcp::socket socket)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!ec)<br>                    std::<span class="hljs-built_in">make_shared</span>&lt;Session&gt;(std::<span class="hljs-built_in">move</span>(socket))-&gt;<span class="hljs-built_in">start</span>();<br>                <span class="hljs-built_in">do_accept</span>();<br>            &#125;);<br>    &#125;<br><br>    tcp::acceptor acceptor_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        boost::asio::io_context io_context;<br>        <span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(io_context, <span class="hljs-number">12345</span>)</span></span>;<br>        io_context.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 事件循环</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>main部分 : <ul><li>io_context : 事件循环核心句柄, 通过调用run来开始运作.</li></ul></li><li>Server : 服务器类, 使用acceptor接受并处理连接.<ul><li>acceptor : 这里网络库自带的acceptor类, 只要我们把句柄和绑定需要的数据传入, 在其构造函数中就会自动调用socket + bind + listen.</li><li>endpoint : 这就是一个存放用于绑定数据的类.</li><li>async_accept : 在新连接建立时, 会调用传入的回调函数, 参数要求为(boost::system::error_code ec, tcp::socket socket), 这样就可以取出socket进行操作, 这里调用了Session类的start, 会针对连接进行处理.</li></ul></li><li>Session : 会话类, 处理每一条的连接的读写.<ul><li>async_read_some : 在读事件触发时向准备好的缓冲区存入读到的数据, 然后触发其中给出的回调函数, 可以在回调中进行数据处理, echo服务器所以直接调用do_write准备发回.</li><li>async_write : 传入目标socket, 数据缓冲区, 回调函数, 就可以在发送完数据后调用回调再度调用do_read进入读事件等待阶段.</li></ul></li></ul><h3 id="有关异步使用递归回调的设计哲学"><a href="#有关异步使用递归回调的设计哲学" class="headerlink" title="有关异步使用递归回调的设计哲学"></a>有关异步使用递归回调的设计哲学</h3><p>在同步Reactor模型中,  处理事件循环我们往往会使用while直接处理, 就像下面这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-built_in">read</span>();     <span class="hljs-comment">// 这里一般是阻塞的</span><br><span class="hljs-built_in">process</span>();<br><span class="hljs-built_in">write</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是while在异步中是使用不了的, 异步强调的是控制流的保持, 其没有任何地方是会阻塞的, 核心全在于回调函数如何处理, 假如我们要让逻辑实现一个闭环, 那就要使用递归回调实现类似于循环的效果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">async_read</span>(..., [](...) &#123;<br>    <span class="hljs-built_in">process</span>();<br>    <span class="hljs-built_in">async_write</span>(..., [](...) &#123;<br>        <span class="hljs-built_in">again_read</span>();<br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的echo就是这样的逻辑, 读完进行处理, 处理完发送, 发送完再注册读事件, 这样就类似于实现了一个天然的状态机, 并且可以使线程资源最大化.</p><h3 id="enable-shared-from-this"><a href="#enable-shared-from-this" class="headerlink" title="enable_shared_from_this"></a>enable_shared_from_this</h3><p>我们可以看到Session类继承了该类, 其作用在于可以使成员函数内部调用<code>shared_from_this()</code>, 该函数会返回当前类对象的智能指针, 其实就是对this进行了封装.</p><p>其作用的核心在于<strong>延长对象的生命周期</strong>. 这里应用到异步中, 就是可以使构建出来的Session对象始终不被析构, 就算没有实际的对象去管理它们. 因为我们的self对象会一直被lambda捕获, 其内部Session对象就不会被析构. 这里要明白一个知识 : <strong>只要 lambda 回调函数中捕获了 <code>shared_ptr</code>(哪怕它还没执行),对象的引用计数就会保持 +1</strong>. </p><p>更进一步理解, 我们可以发现, Session类在accept函数中被make_shared出来, 在离开了这个回调函数后其实shared_ptr计数就会-1. 但是Session并不会析构, 因为已经调用了start, 整个逻辑链路已经开启, 在do_read和do_write中都会在lambda中捕获self, 计数永远不会降到0, 也就是<strong>其生命周期不再和作用域有关, 会一直在这个逻辑链路中存在下去</strong>.</p><h3 id="多线程版本"><a href="#多线程版本" class="headerlink" title="多线程版本"></a>多线程版本</h3><p>上面只是单线程版本的, 但是并发量由于异步存在已经足够高, 几万并发没什么问题, 当然我们也可以写多线程版本的, 其实只要再main函数中做修改就可以了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        boost::asio::io_context io_context;<br><br>        <span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(io_context, <span class="hljs-number">12345</span>)</span></span>;<br><br>        <span class="hljs-comment">// 获取系统线程数（你也可以写固定值如 4）</span><br>        <span class="hljs-type">int</span> thread_count = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Start with &quot;</span> &lt;&lt; thread_count &lt;&lt; <span class="hljs-string">&quot; threads\n&quot;</span>;<br><br>        <span class="hljs-comment">// 创建线程池，所有线程调用 io_context.run()</span><br>        std::vector&lt;std::thread&gt; threads;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_count; ++i)<br>        &#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>([&amp;io_context]() &#123;<br>                io_context.<span class="hljs-built_in">run</span>();<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程结束（实际永不结束）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : threads)<br>            t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>io_context作为核心句柄, 你可以理解其内部存在一个线程安全的消息队列, 用其在不同线程调用run(), 其实是让每个线程都可以从自己的消息队列中利用互斥锁线程安全地获取任务.</p><p>当然如果学过muduo, 我们也可以采用<code>one loop per thread</code>的思想, 一个事件循环对应一个线程, 这样就可以避免消息队列中的锁竞争了, 下面是多io_context多线程版本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><br><span class="hljs-comment">// 一个 echo 会话</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Session</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;Session&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Session</span>(tcp::socket socket) : <span class="hljs-built_in">socket_</span>(std::<span class="hljs-built_in">move</span>(socket)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">do_read</span>(); &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_read</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> self = <span class="hljs-built_in">shared_from_this</span>();<br>        socket_.<span class="hljs-built_in">async_read_some</span>(boost::asio::<span class="hljs-built_in">buffer</span>(data_),<br>                                [<span class="hljs-keyword">this</span>, self](boost::system::error_code ec, std::<span class="hljs-type">size_t</span> length)<br>                                &#123;<br>                                    <span class="hljs-keyword">if</span> (!ec)<br>                                        <span class="hljs-built_in">do_write</span>(length);<br>                                &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_write</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> length)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">auto</span> self = <span class="hljs-built_in">shared_from_this</span>();<br>        boost::asio::<span class="hljs-built_in">async_write</span>(socket_, boost::asio::<span class="hljs-built_in">buffer</span>(data_, length),<br>                                 [<span class="hljs-keyword">this</span>, self](boost::system::error_code ec, std::<span class="hljs-type">size_t</span> <span class="hljs-comment">/*len*/</span>)<br>                                 &#123;<br>                                     <span class="hljs-keyword">if</span> (!ec)<br>                                         <span class="hljs-built_in">do_read</span>();<br>                                 &#125;);<br>    &#125;<br><br>    tcp::socket socket_;<br>    <span class="hljs-keyword">enum</span><br>    &#123;<br>        max_length = <span class="hljs-number">1024</span><br>    &#125;;<br>    <span class="hljs-type">char</span> data_[max_length];<br>&#125;;<br><br><span class="hljs-comment">// 每个 worker 包含一个 io_context 和它自己的线程</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Worker</span><br>&#123;<br>    boost::asio::io_context io_context;<br>    boost::asio::executor_work_guard&lt;boost::asio::io_context::executor_type&gt; work_guard;<br>    std::thread thread;<br><br>    <span class="hljs-built_in">Worker</span>() : <span class="hljs-built_in">work_guard</span>(boost::asio::<span class="hljs-built_in">make_work_guard</span>(io_context)) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        thread = std::<span class="hljs-built_in">thread</span>([<span class="hljs-keyword">this</span>]()<br>                             &#123; io_context.<span class="hljs-built_in">run</span>(); &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        io_context.<span class="hljs-built_in">stop</span>();<br>        <span class="hljs-keyword">if</span> (thread.<span class="hljs-built_in">joinable</span>())<br>            thread.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// Server 只负责监听和分发连接</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Server</span>(boost::asio::io_context &amp;main_io_context, <span class="hljs-type">short</span> port, std::vector&lt;std::shared_ptr&lt;Worker&gt;&gt; &amp;workers)<br>        : <span class="hljs-built_in">acceptor_</span>(main_io_context, tcp::<span class="hljs-built_in">endpoint</span>(tcp::<span class="hljs-built_in">v4</span>(), port)), <span class="hljs-built_in">workers_</span>(workers)<br>    &#123;<br>        <span class="hljs-built_in">do_accept</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_accept</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        acceptor_.<span class="hljs-built_in">async_accept</span>(<br>            [<span class="hljs-keyword">this</span>](boost::system::error_code ec, tcp::socket socket)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!ec)<br>                &#123;<br>                    <span class="hljs-comment">// Round-Robin 分发连接</span><br>                    <span class="hljs-keyword">auto</span> &amp;worker = workers_[next_worker_];<br>                    boost::asio::<span class="hljs-built_in">post</span>(worker-&gt;io_context, [sock = std::<span class="hljs-built_in">move</span>(socket)]() <span class="hljs-keyword">mutable</span><br>                                      &#123; std::<span class="hljs-built_in">make_shared</span>&lt;Session&gt;(std::<span class="hljs-built_in">move</span>(sock))-&gt;<span class="hljs-built_in">start</span>(); &#125;);<br>                    next_worker_ = (next_worker_ + <span class="hljs-number">1</span>) % workers_.<span class="hljs-built_in">size</span>();<br>                &#125;<br>                <span class="hljs-built_in">do_accept</span>(); <span class="hljs-comment">// 继续接受</span><br>            &#125;);<br>    &#125;<br><br>    tcp::acceptor acceptor_;<br>    std::vector&lt;std::shared_ptr&lt;Worker&gt;&gt; &amp;workers_;<br>    std::<span class="hljs-type">size_t</span> next_worker_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> thread_count = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Starting server with &quot;</span> &lt;&lt; thread_count &lt;&lt; <span class="hljs-string">&quot; threads\n&quot;</span>;<br><br>        <span class="hljs-comment">// 主 io_context 只用于 acceptor</span><br>        boost::asio::io_context main_io_context;<br><br>        <span class="hljs-comment">// 创建 worker 池</span><br>        std::vector&lt;std::shared_ptr&lt;Worker&gt;&gt; workers;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; thread_count; ++i)<br>        &#123;<br>            <span class="hljs-keyword">auto</span> w = std::<span class="hljs-built_in">make_shared</span>&lt;Worker&gt;();<br>            w-&gt;<span class="hljs-built_in">run</span>();<br>            workers.<span class="hljs-built_in">push_back</span>(w);<br>        &#125;<br><br>        <span class="hljs-comment">// 启动服务器（监听 + 分发连接）</span><br>        <span class="hljs-function">Server <span class="hljs-title">server</span><span class="hljs-params">(main_io_context, <span class="hljs-number">12345</span>, workers)</span></span>;<br><br>        <span class="hljs-comment">// 主线程运行 acceptor 的 io_context</span><br>        main_io_context.<span class="hljs-built_in">run</span>();<br><br>        <span class="hljs-comment">// 停止所有工作线程（程序退出时）</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;w : workers)<br>            w-&gt;<span class="hljs-built_in">stop</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的核心修改在Server和Worker中, Session中没有变动.</p><ul><li><p>主体思路就是由主io_context控制Server, 生成Worker线程存入线程池中, Server将新连接分发到Worker中.</p></li><li><p>Worker : </p><ul><li>每个Worker中都会控制一个io_context, work_guard 和 thread.</li><li>io_context 用来在run时在线程中开始监听.</li><li>work_guard 的作用是<strong>防止io_context在调用run时因为没有任务而立刻退出</strong>, 所以我们如果要在多线程情况下使用线程池的话, 必须要使用work_guard, 其会时run函数就算没有任务, 也会在此阻塞等待任务.</li></ul></li><li><p>Server : </p><ul><li><p>workers_ : main函数中会创建worker线程存入数组, Server构造函数需要传入这个数组.</p></li><li><p>每当接收到一个新连接时, 就会轮询取出一个工作线程, 利用asio库中的post向指定的工作线程中建立监听.</p><ul><li><pre><code class="cpp">boost::asio::post(worker-&gt;io_context, [sock = std::move(socket)]() mutable &#123; std::make_shared&lt;Session&gt;(std::move(sock))-&gt;start(); &#125;);<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br>      <span class="hljs-string">我们在每个worker中都会存入其对应的io_context,</span> <span class="hljs-string">再在回调函数中建立新的会话,</span> <span class="hljs-string">就可以让工作线程执行对新连接的监听了.</span><br><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">注意这里的mutable是针对lambda的一种写法,</span> <span class="hljs-string">因为默认情况下,</span> <span class="hljs-string">lambda表达式被捕获的变量是不可以被修改的,</span> <span class="hljs-string">因为lambda本身是const的,</span> <span class="hljs-string">但是如果加上mutable就可以进行任意修改了,</span> <span class="hljs-string">这里我们就是希望直接接管socket的使用权,</span> <span class="hljs-string">因此使用了mutable.</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment">### executor(调度器)</span><br><br><span class="hljs-string">调度器,</span> <span class="hljs-string">其实asio库用于调度的核心组件,</span> <span class="hljs-string">用于告诉任务应该在哪里(线程</span> <span class="hljs-string">/</span> <span class="hljs-string">io_context</span> <span class="hljs-string">/</span> <span class="hljs-string">strand)执行,</span> <span class="hljs-string">在普通单线程和多线程异步中并没有提及,</span> <span class="hljs-string">是其在背后隐式调用.</span> <span class="hljs-string">但是我们后面会学习协程,</span> <span class="hljs-string">其需要显式调用调度器找到自己工作的线程与io_context,</span>  <span class="hljs-string">故在此先行介绍.</span><br><br><span class="hljs-string">一个</span> <span class="hljs-string">`io_context`</span> <span class="hljs-string">对应一个唯一的</span> <span class="hljs-string">`executor`</span> <span class="hljs-string">实例,</span> <span class="hljs-string">因此我们也可以通过`io.get_executor();`来直接获取调度器.</span> <br><br><span class="hljs-string">在一个绑定了io_context的协程函数中我们就可以这样获取调度器</span> <span class="hljs-string">:</span> <br><br><span class="hljs-string">```cpp</span><br><span class="hljs-string">auto</span> <span class="hljs-string">executor</span> <span class="hljs-string">=</span> <span class="hljs-string">co_await</span> <span class="hljs-string">this_coro::executor;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul></li></ul></li></ul><h3 id="协程版本"><a href="#协程版本" class="headerlink" title="协程版本"></a>协程版本</h3><p>asio网络库也支持协程, 其配合C++20的协程可以写出更加简短的同步风格的异步代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/co_spawn.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/use_awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/detached.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<br><br><span class="hljs-comment">// Echo 处理协程</span><br><span class="hljs-function">awaitable&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">echo_session</span><span class="hljs-params">(tcp::socket socket)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">for</span> (;;)<br>        &#123;<br>            <span class="hljs-comment">// 异步读取数据</span><br>            std::<span class="hljs-type">size_t</span> n = <span class="hljs-keyword">co_await</span> socket.<span class="hljs-built_in">async_read_some</span>(<span class="hljs-built_in">buffer</span>(data), use_awaitable);<br>            <span class="hljs-comment">// 异步写回数据</span><br>            <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(data, n), use_awaitable)</span></span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Session ended: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 接受连接并启动协程</span><br><span class="hljs-function">awaitable&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">listener</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取绑定当前协程的executor, 可以通过其获取io_context</span><br>    <span class="hljs-keyword">auto</span> executor = <span class="hljs-keyword">co_await</span> this_coro::executor;<br>    <span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(executor, tcp::endpoint(tcp::v4(), port))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-comment">// 异步等待连接事件发生返回socket</span><br>        tcp::socket socket = <span class="hljs-keyword">co_await</span> acceptor.<span class="hljs-built_in">async_accept</span>(use_awaitable);<br>        <span class="hljs-comment">// 再注册新的协程函数并触发</span><br>        <span class="hljs-built_in">co_spawn</span>(executor, <span class="hljs-built_in">echo_session</span>(std::<span class="hljs-built_in">move</span>(socket)), detached);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        io_context io;<br>        <span class="hljs-comment">// 启动协程</span><br>        <span class="hljs-built_in">co_spawn</span>(io, <span class="hljs-built_in">listener</span>(<span class="hljs-number">12345</span>), detached);<br>        io.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 开始事件循环</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Server error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到代码非常短, 并且和同步代码风格非常相似, 但也有很多要点需要解读 : </p><ul><li><p>如果没有学过C++20协程编程可以看我往期的博客, 不然无法理解里面co_await的用法.</p></li><li><p>co_spawn(事件循环句柄, 协程函数, 结束方式) :</p><p>本函数用来将一个协程注册进入事件循环的executor(调度器)中, 其会先执行协程函数, 然后其中promise_type中起始回调设置的是suspend_always, 在开始就会暂停, 然后调用器会发布任务到事件循环中resume这个协程函数.</p></li><li><p><code>auto executor = co_await this_coro::executor;</code></p><p>获取绑定当前协程的executor, 可以当作固定不变的一步, 因为我们需要executor来构建acceptor.</p></li><li><p>acceptor : </p><p>这里构建acceptor的构造可以理解为调用了其针对协程的特殊版本, 用executor来告诉其新连接建立时应把任务提交给对应的io_context.</p></li><li><p>async_accept(use_awaitable) : </p><p>我们可以看到这里<code>async_accept</code>有对应的协程版本, 传入的<code>use_awaitable</code>代表将协程挂起, 其内部其实也会调用普通版本的<code>async_accept</code>, 只不过是在挂起前调用的回调函数中调用并进行异步处理, 在回调触发后再调用resume唤醒协程, 这些asio库都会在内部帮我们实现. 后面的<code>async_read_some</code>和<code>async_write</code>同理.</p></li></ul><h3 id="strand-串行化"><a href="#strand-串行化" class="headerlink" title="strand(串行化)"></a>strand(串行化)</h3><p>它就是<strong>对executor的进一步封装</strong>, 也就是特殊的调度器. 用这个调度器发布的任务会<strong>串行执行</strong>, 也就是说其真正作用是<strong>帮助协程间共享内存</strong>, 是一种另类高效的<strong>协程间通信</strong>, 甚至你可以理解为一种<strong>另类的锁</strong>.</p><p>下面是一个使用共享map实现name记录的echo服务器, 我们只需要关系里面有关strand和map的内容即可 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/co_spawn.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/detached.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/use_awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/strand.hpp&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio::ip;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<br><br><span class="hljs-keyword">using</span> awaitable_void = awaitable&lt;<span class="hljs-type">void</span>&gt;;<br><span class="hljs-keyword">using</span> <span class="hljs-type">executor_t</span> = any_io_executor;<br><br>std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; nicknames;<br>std::shared_ptr&lt;strand&lt;<span class="hljs-type">executor_t</span>&gt;&gt; strand_ptr;<br>std::atomic&lt;<span class="hljs-type">int</span>&gt; connection_id&#123;<span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-comment">/// 清理昵称（提取到独立协程）</span><br><span class="hljs-function">awaitable_void <span class="hljs-title">cleanup_nickname</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">co_await</span> boost::asio::<span class="hljs-built_in">post</span>(*strand_ptr, use_awaitable);<br>    nicknames.<span class="hljs-built_in">erase</span>(id);<br>    <span class="hljs-keyword">co_return</span>;<br>&#125;<br><br><span class="hljs-function">awaitable_void <span class="hljs-title">handle_client</span><span class="hljs-params">(tcp::socket socket)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> executor = <span class="hljs-keyword">co_await</span> this_coro::executor;<br>    <span class="hljs-type">int</span> id = connection_id.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>];<br>    std::string nickname;<br><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        std::string prompt = <span class="hljs-string">&quot;请输入昵称: &quot;</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(prompt), use_awaitable)</span></span>;<br><br>        std::<span class="hljs-type">size_t</span> n = <span class="hljs-keyword">co_await</span> socket.<span class="hljs-built_in">async_read_some</span>(<span class="hljs-built_in">buffer</span>(data), use_awaitable);<br>        nickname = std::<span class="hljs-built_in">string</span>(data, data + n - <span class="hljs-number">1</span>); <span class="hljs-comment">// 去掉换行符</span><br><br>        <span class="hljs-comment">// 加入 nickname 映射（串行化）</span><br>        <span class="hljs-keyword">co_await</span> boost::asio::<span class="hljs-built_in">post</span>(*strand_ptr, use_awaitable);<br>        nicknames[id] = nickname;<br><br>        std::string hello = <span class="hljs-string">&quot;你好，&quot;</span> + nickname + <span class="hljs-string">&quot;！你现在可以发消息，我会帮你回显。\n&quot;</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(hello), use_awaitable)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (;;)<br>        &#123;<br>            std::<span class="hljs-type">size_t</span> len = <span class="hljs-keyword">co_await</span> socket.<span class="hljs-built_in">async_read_some</span>(<span class="hljs-built_in">buffer</span>(data), use_awaitable);<br>            <span class="hljs-function">std::string <span class="hljs-title">input</span><span class="hljs-params">(data, data + len)</span></span>;<br><br>            std::string name;<br><br>            <span class="hljs-comment">// 获取当前昵称（串行化）</span><br>            <span class="hljs-keyword">co_await</span> boost::asio::<span class="hljs-built_in">post</span>(*strand_ptr, use_awaitable);<br>            name = nicknames[id];<br><br>            std::string msg = <span class="hljs-string">&quot;[&quot;</span> + name + <span class="hljs-string">&quot;] 你说的是：&quot;</span> + input;<br>            <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(msg), use_awaitable)</span></span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (...)<br>    &#123;<br>        <span class="hljs-comment">// 不能在 catch 内使用 co_await，使用 co_spawn 调度清理任务</span><br>        <span class="hljs-built_in">co_spawn</span>(executor, <span class="hljs-built_in">cleanup_nickname</span>(id), detached);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">awaitable_void <span class="hljs-title">listener</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> executor = <span class="hljs-keyword">co_await</span> this_coro::executor;<br>    <span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(executor, &#123;tcp::v4(), port&#125;)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        tcp::socket socket = <span class="hljs-keyword">co_await</span> acceptor.<span class="hljs-built_in">async_accept</span>(use_awaitable);<br>        <span class="hljs-built_in">co_spawn</span>(executor, <span class="hljs-built_in">handle_client</span>(std::<span class="hljs-built_in">move</span>(socket)), detached);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        io_context io;<br><br>        <span class="hljs-comment">// 创建全局 strand</span><br>        strand_ptr = std::make_shared&lt;strand&lt;<span class="hljs-type">executor_t</span>&gt;&gt;(io.<span class="hljs-built_in">get_executor</span>());<br><br>        <span class="hljs-comment">// 启动监听协程</span><br>        <span class="hljs-built_in">co_spawn</span>(io, <span class="hljs-built_in">listener</span>(<span class="hljs-number">12345</span>), detached);<br><br>        <span class="hljs-comment">// 多线程 run</span><br>        std::vector&lt;std::thread&gt; threads;<br>        <span class="hljs-type">int</span> n = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        &#123;<br>            threads.<span class="hljs-built_in">emplace_back</span>([&amp;io]()<br>                                 &#123; io.<span class="hljs-built_in">run</span>(); &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;t : threads)<br>            t.<span class="hljs-built_in">join</span>();<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Server error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>std::shared_ptr&lt;strand&lt;executor_t&gt;&gt; strand_ptr;</code></p><p>在全局设置一个串行化调度器的智能指针.</p></li><li><p><code>strand_ptr = std::make_shared&lt;strand&lt;executor_t&gt;&gt;(io.get_executor());</code></p><p>取出io_context对应的executor.</p></li><li><p><code>co_await boost::asio::post(*strand_ptr, use_awaitable);</code></p><p>在协程函数中, 所有有关全局变量map的操作前都会加这么一段代码, 其post的任务并没有什么实际作用, 其目的只在于<strong>让后面的代码串行化执行</strong>, 以此防止共享资源的竞争. 当我们把这段代码当成一个锁来看, 就会豁然开朗许多, 那么这个锁的范围是什么? 答案是<strong>下一次挂起(co_await)或最后返回(co_return)时</strong>, 在这之后才会串行化执行后面的任务. </p><p>当然这里只是利用strand实现协程间资源共享, 普通的线程间资源共享也是可以实现的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">boost::asio::<span class="hljs-built_in">post</span>(strand, [key, value]() &#123;<br>    shared_map[key] = value;  <span class="hljs-comment">// 串行安全访问</span><br>&#125;); <span class="hljs-comment">// 像这样子普通在一个线程中使用串行也是可行的!</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="boost-asio的优势"><a href="#boost-asio的优势" class="headerlink" title="boost::asio的优势"></a>boost::asio的优势</h3><ul><li>支持回调, 协程等多种异步模型.</li><li>跨平台</li><li>对于C++20协程原生支持</li><li>有strand实现多线程多协程下的资源共享</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>boost::asio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 协程学习笔记</title>
    <link href="/2025/07/07/C++%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2025/07/07/C++%E5%8D%8F%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>协程是可以理解为一个可以被暂停(挂起)和唤醒的函数, 系统会帮助你保存协程函数中的局部变量.</p><h2 id="协程-vs-线程"><a href="#协程-vs-线程" class="headerlink" title="协程 vs 线程"></a>协程 vs 线程</h2><p>协程和线程几乎没有任何联系, 它们是相互独立的. </p><ul><li>对于执行时间比较短的任务, 不建议用线程来处理, 线程的创建, 调度, 销毁都是会占用资源的.</li><li>线程适合那些长时间的任务, 比如轮循或监控.</li><li>线程是一个实际的需要操作系统进行调度的对象, 而协程只是函数外加一些在底层跳来跳去的指令.</li></ul><h2 id="C-协程特性"><a href="#C-协程特性" class="headerlink" title="C++协程特性"></a>C++协程特性</h2><ul><li><p><strong>无栈</strong></p><p>首先要理解每个函数建立都会申请自己的栈帧, 栈帧中存储的是自己当前的局部变量, 当函数调用return后属于该函数的栈帧也会随之销毁, 在栈中有比较明确的后进先出的顺序, 这和函数调用的方式也是一致的. 而协程也可以被视为一个函数, 但是有暂停和唤醒的功能, C++的协程是无栈的, 其实是说协程函数没有自己的栈帧, 取而代之的是其会在堆上申请一片区域代替栈帧的作用, 替自己记录局部变量及协程信息, 在堆上也契合其要暂停唤醒的功能.</p></li></ul><h2 id="C-20协程使用"><a href="#C-20协程使用" class="headerlink" title="C++20协程使用"></a>C++20协程使用</h2><p>现在开始我们将会开始以关键字<code>co_await</code>为中心, 实现一个最简易的协程调用.</p><p>先认识一下<code>co_await</code> :  </p><p>这是在协程函数中进行协程挂起的关键字, 其后方要加上可挂起类(Awaitable)来辅助协程的挂起和恢复, 形如<code>co_wait Awaitable;</code> , 可挂起类后面细讲, 只要知道协程函数执行到co_await处就会进行暂停返回调用方(也不一定非得是调用方)就行了.</p><h3 id="两个核心类"><a href="#两个核心类" class="headerlink" title="两个核心类"></a>两个核心类</h3><p>首先我们要明确实现协程需要两个核心类, 这两个类C++20协程中有明确规定要符合一定的规范 : </p><ul><li><p><strong>返回对象类</strong> : 构建返回对象类的原因有两点.</p><ul><li><p>协程作为函数, 调用方可能需要协程函数返回一些结果, 因此可以存在返回对象类中.</p></li><li><p>协程的效果是可以被暂停和唤醒, 暂停是协程函数内部执行的, 但唤醒需要调用方执行, 因此返回对象类还要有可以恢复协程运行的功能.</p></li><li><p><strong>编写规范</strong> : 形如下 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 返回对象类</span><br><span class="hljs-comment">// 持有整个协程的句柄, 在协程被挂起时其被交给调用方, 用其可再次唤醒协程</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoRet</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span><br>    &#123;<br>        <span class="hljs-comment">// 控制协程开始和结束时是否暂停的函数</span><br>        <span class="hljs-function">suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">suspend_never <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-comment">// 控制发生异常时的调用</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-comment">// 控制协程最后返回得到的对象</span><br>        <span class="hljs-function">CoRet <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)&#125;;<br>        &#125;<br>    &#125;;<br>    coroutine_handle&lt;promise_type&gt; _h;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>类名怎么起都行, 但是内部一定要有名为<code>promise_type</code>的结构体, 其中必须编写所示的四个函数, 功能都有标注, 要注意的是promise_type对象是可以实际被协程句柄调用到的, 也就是说我们可以在其中存自定义句段存储数据. </li><li>前两个函数的返回值可以改, 返回<code>suspend_never</code>代表不暂停, 返回<code>suspend_always</code>代表暂停.</li><li>最后一个函数可以返回当前类对象的指针, 可以让调用方获取返回类对象.</li><li>一定要有类型为<code>coroutine_handle&lt;promise_type&gt;</code>的<code>_h</code>作为协程句柄, 这就是前面说的让调用方可以控制协程唤醒的关键, 这个类型中有成员函数<code>resume()</code>, 调用即可唤醒.</li></ul></li></ul></li><li><p><strong>可挂起类</strong> : </p><p>可挂起类用来辅助co_await进行线程的暂停和唤醒, 那么可以帮些什么呢?</p><ul><li><p>可以用来确定co_await是否生效, 也就是说是否真的要暂停.</p></li><li><p>可以决定线程暂停前和唤醒时调用的回调.</p></li><li><p>编写规范 : 形如下 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Input</span><br>&#123;<br>    Note &amp;note;<br>    <span class="hljs-comment">// 当前对象是否不需要挂起, 返回ture就会立即往下执行, 返回false会立即挂起, 等待外部resume</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-comment">// 如果前面返回false, 在挂起前会调用此函数, 做挂起前的准备</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(coroutine_handle&lt;CoRet::promise_type&gt; h)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// h.promise()</span><br>    &#125;<br>    <span class="hljs-comment">// 被唤醒后调用的函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> note.val; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>还是类名怎么起都行, 先不管Note类, 下面的三个函数必须要有, 作用已经标注.</p></li><li><p>注意三个函数中只有await_suspend可以获取到协程句柄, 也就是说其可以通过句柄控制唤醒的时机(比如异步设置一个回调, 回调中触发resume()). 如果await_resume也想要用句柄, 需要提前在await_suspend中保存下句柄才行.</p></li><li><p>await_resume有一个返回值, 你可以填void, 也就是什么都不返回, 但如果协程被唤醒时, 你有想从调用方获取的数据时, 可以通过此处设置返回类型. 也就是说我们可以这样写 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> g = <span class="hljs-keyword">co_await</span> input;<br></code></pre></td></tr></table></figure><p>我们在await_resume中返回的值就会在协程函数中被g获取.</p></li><li><p>其实前面在返回对象类中前两个函数的返回值suspend_never和suspend_always其实就是协程库内置的标准可挂起类, 没有其他任何作用, 只是为了确定是否要暂停线程. 所以如果完全不需要数据传输等别的功能, 也可以直接<code>co_await suspend_always&#123;&#125;;</code>来实现暂停.</p></li></ul></li></ul></li></ul><h3 id="协程函数与main函数的编写"><a href="#协程函数与main函数的编写" class="headerlink" title="协程函数与main函数的编写"></a>协程函数与main函数的编写</h3><p>在构建出上面两个类后, 我们来考虑编写出一个最简单的协程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 返回对象类</span><br><span class="hljs-comment">// 持有整个协程的句柄, 在协程被挂起时其被交给调用方, 用其可再次唤醒协程</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoRet</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span><br>    &#123;<br>        <span class="hljs-comment">// 控制协程开始和结束时是否跳回的函数</span><br>        <span class="hljs-function">suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">suspend_never <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-comment">// 控制协程最后返回得到的对象</span><br>        <span class="hljs-function">CoRet <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)&#125;;<br>        &#125;<br>    &#125;;<br>    coroutine_handle&lt;promise_type&gt; _h;<br>&#125;;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------------------- //</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Note</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; val = x; &#125;<br>&#125;;<br><br><span class="hljs-comment">// Awaitable 可挂起对象</span><br><span class="hljs-comment">// 协程函数中会有co_await等关键字, 与其相关的类必须符合Awaitable的标准(三个函数)</span><br><span class="hljs-comment">// 其用来帮助执行挂起的行为, 使得调用方可以和协程内部进行数据沟通</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Input</span><br>&#123;<br>    Note &amp;note;<br>    <span class="hljs-comment">// 当前对象是否不需要挂起, 返回ture就会立即往下执行, 返回false会立即挂起, 等待外部resume</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-comment">// 如果前面返回false, 在挂起前会调用此函数, 做挂起前的准备</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(coroutine_handle&lt;CoRet::promise_type&gt; h)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// h.promise()</span><br>    &#125;<br>    <span class="hljs-comment">// 被唤醒后调用的函数</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> note.val; &#125;<br>&#125;;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------------------- //</span><br><span class="hljs-comment">// 协程函数</span><br><span class="hljs-function">CoRet <span class="hljs-title">Guess</span><span class="hljs-params">(Note &amp;note)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 协程函数最初都会生成一个promise_type的对象, 其负责一切管理协程生命周期内的一切行为</span><br>    <span class="hljs-comment">// CoRet::promise_type promise;</span><br>    <span class="hljs-comment">// 设置协程最后的返回对象, 其实就是把协程句柄传出去, 使外部可以获取协程内部的数据.</span><br>    <span class="hljs-comment">// CoRet ret = promise.get_return_object();</span><br>    <span class="hljs-comment">// co_await promise.initial_suspend();</span><br><br>    Input input&#123;note&#125;;<br>    <span class="hljs-type">int</span> g = <span class="hljs-keyword">co_await</span> input;<br>    cout &lt;&lt; <span class="hljs-string">&quot;coroutine: You guess &quot;</span> &lt;&lt; g &lt;&lt; endl;<br><br>    <span class="hljs-comment">// co_await promise.final_suspend();</span><br>&#125;<br><br><span class="hljs-comment">// ----------------------------------------------------------------------------------- //</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Note note;<br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">Guess</span>(note);<br>    cout &lt;&lt; <span class="hljs-string">&quot;main : make a guess ...&quot;</span> &lt;&lt; endl;<br><br>    note.<span class="hljs-built_in">set</span>(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 恢复协程的运行</span><br>    ret._h.<span class="hljs-built_in">resume</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行可执行文件我们可以得到 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">main : make a guess ...<br>coroutine: You guess <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>先说明这个协程干了些什么 : main函数中调用协程函数, 协程函数利用传入的note构造Input对象, 执行到co_await暂停, main函数设置note值后恢复协程, 协程打印我们在main中设置的note值.</p><ul><li><p>这里面有关note值的设置, 目的是为了展示调用方和协程之间的数据交互, 我们可以看到note在main中构造后传入协程函数, 将其记录在input中, 于是我们便可以在main中设置note值让协程中的input看到, 进而提供给协程函数.</p></li><li><p>可以看到协程函数中有很多注释, 这些其实是运行时内部会加上去的代码, 其会根据我们构建的promise_type生成对象, 并以此调用我们设置的函数. 由此我们可以很明显地感觉到, 返回对象类的作用在于整个协程的把握, 其控制住了整个函数的始终与返回值. 而可挂起对象则辅助我们更好地实现协程函数的暂停和唤醒.</p></li></ul><h3 id="co-yield-co-return"><a href="#co-yield-co-return" class="headerlink" title="co_yield &#x2F; co_return"></a>co_yield &#x2F; co_return</h3><p>学习完了<code>co_await</code>后再去学习<code>co_yield</code>就简单多了, 这个其实类似于一个语法糖, 其在底层会被替换为co_await : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">co_yield</span> <span class="hljs-number">42</span>;<br><span class="hljs-keyword">co_await</span> promise.<span class="hljs-built_in">yield_value</span>(<span class="hljs-number">42</span>);  <span class="hljs-comment">// 替换为</span><br></code></pre></td></tr></table></figure><p>根据替换的形式, 可以推断我们需要在promise_type中构造一个yield_value函数, 形如 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> _out;<br><span class="hljs-comment">// ...</span><br><span class="hljs-function">suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>_out = x;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>_out 是我们在promise_type中自定义的句段, 用来存储想告诉调用方的信息.</li><li>yield_value必须返回一个awaitable对象, 这里我们直接使用内部自带的suspend_always, 表示我们需要暂停.</li></ul><p>于是我们就是可以在外部通过句柄取得_out值来进行通信了, 其实 co_yield 在底层只是实现了一层替换, 其他什么都没有做, 但是其本身的目的是<strong>产生一个值并跳转返回给调用方</strong>, 所以我们需要自己在 promise_type中自定义句段存储传入的值, 再在外部取出, 做法相当原始, 但就是这样.</p><p><code>co_return</code>就更简单了, 其只负责让我们自己记录希望给调用方的返回值, 一般被放置在协程函数的最后表示协程的结束, 底层替换如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">co_return</span> res;<br>promise.<span class="hljs-built_in">return_value</span>(res); <span class="hljs-comment">// 替换为</span><br></code></pre></td></tr></table></figure><p>替换完其实就帮我调用了return_value这个函数, 其形如 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> _res;<br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    _res = r;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实还是要我们自己手动记录, 非常原始. </p><p>至此我们可以进行一次简单的猜数字 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoRet</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span><br>    &#123;<br>        <span class="hljs-type">int</span> _out;<br>        <span class="hljs-type">int</span> _res;<br>        <span class="hljs-comment">// 控制协程开始和结束时是否跳回的函数</span><br>        <span class="hljs-function">suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">suspend_always <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-comment">// 控制协程最后返回得到的对象</span><br>        <span class="hljs-function">CoRet <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)&#125;;<br>        &#125;<br><br>        <span class="hljs-function">suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            _out = x;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">        </span>&#123;<br>            _res = r;<br>        &#125;<br>    &#125;;<br>    coroutine_handle&lt;promise_type&gt; _h;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Note</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; val = x; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Input</span><br>&#123;<br>    Note &amp;note;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(coroutine_handle&lt;CoRet::promise_type&gt; h)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> note.val; &#125;<br>&#125;;<br><br><span class="hljs-function">CoRet <span class="hljs-title">Guess</span><span class="hljs-params">(Note &amp;note)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">30</span>) + <span class="hljs-number">1</span>;<br>    Input input&#123;note&#125;;<br>    <span class="hljs-type">int</span> g = <span class="hljs-keyword">co_await</span> input;<br>    cout &lt;&lt; <span class="hljs-string">&quot;coroutine: You guess &quot;</span> &lt;&lt; g &lt;&lt; endl;<br><br>    <span class="hljs-built_in">co_yield</span> (res &lt; g ? <span class="hljs-number">1</span> : (res == g ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>));<br>    <span class="hljs-comment">// co_await promise.yield_value();</span><br><br>    <span class="hljs-keyword">co_return</span> res;<br>    <span class="hljs-comment">// promise.return_value();</span><br>    <span class="hljs-comment">// co_await promise.final_suspend();</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>    Note note;<br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">Guess</span>(note);<br>    cout &lt;&lt; <span class="hljs-string">&quot;main : make a guess ...&quot;</span> &lt;&lt; endl;<br><br>    note.<span class="hljs-built_in">set</span>(<span class="hljs-number">6</span>);<br><br>    <span class="hljs-comment">// 恢复协程的运行</span><br>    ret._h.<span class="hljs-built_in">resume</span>();<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;main: your guess is &quot;</span> &lt;&lt; ((ret._h.<span class="hljs-built_in">promise</span>()._out) == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;larger&quot;</span> : ((ret._h.<span class="hljs-built_in">promise</span>()._out == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;the same&quot;</span> : <span class="hljs-string">&quot;smaller&quot;</span>)) &lt;&lt; endl;<br><br>    ret._h.<span class="hljs-built_in">resume</span>();<br><br>    <span class="hljs-keyword">if</span> (ret._h.<span class="hljs-built_in">done</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;main: the result is &quot;</span> &lt;&lt; ret._h.<span class="hljs-built_in">promise</span>()._res &lt;&lt; endl;<br>    &#125;<br>    ret._h.<span class="hljs-built_in">destory</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后的结果如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">➜  boostasiolearn ./coroutinetest                                            <br>main : make a guess ...<br>coroutine: You guess <span class="hljs-number">6</span><br>main: your guess is smaller<br>main: the result is <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><ul><li>done : 其作用在于<strong>判断当前协程是否进入了 <code>final_suspend()</code> 并且已挂起</strong>, 也就是说这是一个调用方用来判断线程是否结束的函数, 如果已经结束, 就可以通过句柄取出希望的结果.</li><li>destory : 销毁协程资源, 必须调用, 否则会内存泄露.</li></ul><h3 id="完整的猜数字游戏"><a href="#完整的猜数字游戏" class="headerlink" title="完整的猜数字游戏"></a>完整的猜数字游戏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;optional&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoRet</span><br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span><br>    &#123;<br>        <span class="hljs-type">int</span> _out;<br>        <span class="hljs-type">int</span> _res;<br>        <span class="hljs-comment">// 控制协程开始和结束时是否跳回的函数</span><br>        <span class="hljs-function">suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function">suspend_always <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>        <span class="hljs-comment">// 控制协程最后返回得到的对象</span><br>        <span class="hljs-function">CoRet <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> &#123;coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)&#125;;<br>        &#125;<br><br>        <span class="hljs-function">suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">        </span>&#123;<br>            _out = x;<br>            <span class="hljs-keyword">return</span> &#123;&#125;;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function">        </span>&#123;<br>            _res = r;<br>        &#125;<br>    &#125;;<br>    coroutine_handle&lt;promise_type&gt; _h;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Note</span><br>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; val = x; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Input</span><br>&#123;<br>    Note &amp;note;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(coroutine_handle&lt;CoRet::promise_type&gt; h)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> note.val; &#125;<br>&#125;;<br><br><span class="hljs-function">CoRet <span class="hljs-title">Guess</span><span class="hljs-params">(Note &amp;note)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">99</span>) + <span class="hljs-number">1</span>;<br><br>    Input input&#123;note&#125;;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> g = <span class="hljs-keyword">co_await</span> input;<br><br>        <span class="hljs-built_in">co_yield</span> (res &lt; g ? <span class="hljs-number">1</span> : (res == g ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>));<br>        <span class="hljs-keyword">if</span> (res == g)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">co_return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">nullptr</span>));<br>    Note note;<br>    <span class="hljs-keyword">auto</span> ret = <span class="hljs-built_in">Guess</span>(note);<br>    cout &lt;&lt; <span class="hljs-string">&quot;main : make a guess ...&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;please input your guess: &quot;</span>;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        note.<span class="hljs-built_in">set</span>(x);<br>        <span class="hljs-comment">// 恢复协程的运行</span><br>        ret._h.<span class="hljs-built_in">resume</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;your guess is &quot;</span> &lt;&lt; ((ret._h.<span class="hljs-built_in">promise</span>()._out) == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;larger&quot;</span> : ((ret._h.<span class="hljs-built_in">promise</span>()._out == <span class="hljs-number">0</span>) ? <span class="hljs-string">&quot;the same&quot;</span> : <span class="hljs-string">&quot;smaller&quot;</span>)) &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ret._h.<span class="hljs-built_in">promise</span>()._out == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        ret._h.<span class="hljs-built_in">resume</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 执行到co_return</span><br>    ret._h.<span class="hljs-built_in">resume</span>();<br><br>    <span class="hljs-keyword">if</span> (ret._h.<span class="hljs-built_in">done</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;the result is &quot;</span> &lt;&lt; ret._h.<span class="hljs-built_in">promise</span>()._res &lt;&lt; endl;<br>    &#125;<br>    ret._h.<span class="hljs-built_in">destroy</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">➜  boostasiolearn ./coroutinetest                                            <br>main : make a guess ...<br>please input your guess: <span class="hljs-number">50</span><br>your guess is larger<br>please input your guess: <span class="hljs-number">25</span><br>your guess is larger<br>please input your guess: <span class="hljs-number">15</span><br>your guess is smaller<br>please input your guess: <span class="hljs-number">20</span><br>your guess is the same<br>the result is <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="与boost-asio网络库联动"><a href="#与boost-asio网络库联动" class="headerlink" title="与boost::asio网络库联动"></a>与boost::asio网络库联动</h3><p>asio网络库对C++20协程提供了原生支持, 也就是说我们可以用aiso网络库更简便的实现代码编写, 在前面学习协程使用时, 相信大家都会认为为了使用协程还要编写两个核心类很麻烦, 但那很多时候不一定非得是我们的工作, 之后会有更多的协程库会帮我实现这些类的编写, asio网络库就是其中之一, 我们只需要关注于协程函数的编写就行了.</p><p>下面是利用boost::asio网络库编写的简易Tcp回显服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/co_spawn.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/use_awaitable.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio/detached.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> boost::asio::ip::tcp;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> boost::asio;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<br><br><span class="hljs-comment">// Echo 处理协程</span><br><span class="hljs-function">awaitable&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">echo_session</span><span class="hljs-params">(tcp::socket socket)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">for</span> (;;)<br>        &#123;<br>            <span class="hljs-comment">// 异步读取数据</span><br>            std::<span class="hljs-type">size_t</span> n = <span class="hljs-keyword">co_await</span> socket.<span class="hljs-built_in">async_read_some</span>(<span class="hljs-built_in">buffer</span>(data), use_awaitable);<br>            <span class="hljs-comment">// 异步写回数据</span><br>            <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(data, n), use_awaitable)</span></span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Session ended: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 接受连接并启动协程</span><br><span class="hljs-function">awaitable&lt;<span class="hljs-type">void</span>&gt; <span class="hljs-title">listener</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 获取绑定当前协程的executor, 可以通过其获取io_context</span><br>    <span class="hljs-keyword">auto</span> executor = <span class="hljs-keyword">co_await</span> this_coro::executor;<br>    <span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(executor, tcp::endpoint(tcp::v4(), port))</span></span>;<br><br>    <span class="hljs-keyword">for</span> (;;)<br>    &#123;<br>        <span class="hljs-comment">// 异步等待连接事件发生返回socket</span><br>        tcp::socket socket = <span class="hljs-keyword">co_await</span> acceptor.<span class="hljs-built_in">async_accept</span>(use_awaitable);<br>        <span class="hljs-comment">// 再注册新的协程函数并触发</span><br>        <span class="hljs-built_in">co_spawn</span>(executor, <span class="hljs-built_in">echo_session</span>(std::<span class="hljs-built_in">move</span>(socket)), detached);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        io_context io;<br>        <span class="hljs-comment">// 启动协程</span><br>        <span class="hljs-built_in">co_spawn</span>(io, <span class="hljs-built_in">listener</span>(<span class="hljs-number">12345</span>), detached);<br>        io.<span class="hljs-built_in">run</span>(); <span class="hljs-comment">// 开始事件循环</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception &amp;e)<br>    &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Server error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到代码行数非常少, 并且代码风格不像异步那样复杂, 是否解决同步, 但底层却是异步的!</p><p>如果没有学过asio网络库可能有些难以理解, 我之后的博客会出, 最好先学习过再理解.</p><ul><li><p>co_spawn : </p><p>其作用是将协程函数作为任务绑定到事件循环的调度器中去, 会先执行协程函数, 并且这里awaitable在内部promise_type中的起始回调会被设置为suspend_always, 会由调度器发布任务到事件循环中来resume协程.</p></li><li><p>我们可以看到很多co_await后面都会跟着一些网络库函数, 这些其实就是这些网络库函数的协程重载版本, 也可以隐约感觉到其肯定会返回一个awaitable对象, 以<code>async_accept</code>为例, 其返回的对象类型大概是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">awaitable</span>&lt;tcp::socket&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">awaiter</span><br>    &#123;<br>        tcp::acceptor&amp; acceptor_;<br>        tcp::socket socket_;<br>        std::coroutine_handle&lt;&gt; handle_;<br>        boost::system::error_code ec_;<br><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">await_ready</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::coroutine_handle&lt;&gt; h)</span></span><br><span class="hljs-function">        </span>&#123;<br>            handle_ = h;<br>            acceptor_.<span class="hljs-built_in">async_accept</span>(<br>                socket_,<br>                [<span class="hljs-keyword">this</span>](boost::system::error_code ec)<br>                &#123;<br>                    ec_ = ec;<br>                    handle_.<span class="hljs-built_in">resume</span>();<br>                &#125;);<br>        &#125;<br><br>        <span class="hljs-function">tcp::socket <span class="hljs-title">await_resume</span><span class="hljs-params">()</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">if</span> (ec_)<br>                <span class="hljs-keyword">throw</span> boost::system::<span class="hljs-built_in">system_error</span>(ec_);<br>            <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(socket_);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">awaiter <span class="hljs-keyword">operator</span> <span class="hljs-title">co_await</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> awaiter&#123;...&#125;;  <span class="hljs-comment">// 用构造器填入 acceptor/socket 等</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到其在协程暂停前的回调中会调用自己的普通版函数, 将异步任务发布给事件循环, 当socket触发后, 事件循环就会帮我们执行这段代码进而resume协程. 也就是说其思路其实是把resume的时机交给事件循环判断, 非常高明.</p></li></ul><p>回显服务器只是boost::asio网络库与C++20最简单的联动, 还有很多更复杂的设计值得学习, 比如利用strand串行化调度实现协程间资源共享, 这里就不再详述.</p><p>by  天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>libevent事件库</title>
    <link href="/2025/07/04/Libevent%E4%BA%8B%E4%BB%B6%E5%BA%93/"/>
    <url>/2025/07/04/Libevent%E4%BA%8B%E4%BB%B6%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>libevent的主要核心就是一套统一事件源的事件处理, 下面是一个echo服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/util.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8888</span><br><br><span class="hljs-comment">// 设置非阻塞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblock</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> flags = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, flags | O_NONBLOCK);<br>&#125;<br><br><span class="hljs-comment">// 客户端 socket 有数据可读时调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_read</span><span class="hljs-params">(<span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-type">short</span> what, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">write</span>(fd, buf, n); <span class="hljs-comment">// 回显数据</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭连接: fd = %d\n&quot;</span>, fd);<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *ev = (<span class="hljs-keyword">struct</span> event *)arg;<br>        <span class="hljs-built_in">event_free</span>(ev);<br>        <span class="hljs-built_in">close</span>(fd);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;read error&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 有客户端连接时调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_accept</span><span class="hljs-params">(<span class="hljs-type">evutil_socket_t</span> listener, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = (<span class="hljs-keyword">struct</span> event_base *)arg;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br>    <span class="hljs-type">int</span> client_fd = <span class="hljs-built_in">accept</span>(listener, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>    <span class="hljs-keyword">if</span> (client_fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新连接: fd = %d\n&quot;</span>, client_fd);<br>    <span class="hljs-built_in">setnonblock</span>(client_fd);<br><br>    <span class="hljs-comment">// 为这个 client_fd 创建一个读事件</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *read_event = <span class="hljs-built_in">event_new</span>(base, client_fd, EV_READ | EV_PERSIST, on_read, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">event_add</span>(read_event, <span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建监听 socket</span><br>    <span class="hljs-type">int</span> listener = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">evutil_make_socket_nonblocking</span>(listener);<br><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(listener, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>(reuse));<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> sin;<br>    <span class="hljs-built_in">memset</span>(&amp;sin, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sin));<br>    sin.sin_family = AF_INET;<br>    sin.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    sin.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listener, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sin, <span class="hljs-built_in">sizeof</span>(sin)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listener, <span class="hljs-number">16</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建 base 和监听事件</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = <span class="hljs-built_in">event_base_new</span>();<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *listen_event = <span class="hljs-built_in">event_new</span>(base, listener, EV_READ | EV_PERSIST, on_accept, base);<br>    <span class="hljs-built_in">event_add</span>(listen_event, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Echo服务器启动，监听端口 %d...\n&quot;</span>, PORT);<br>    <span class="hljs-built_in">event_base_dispatch</span>(base);<br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-built_in">event_free</span>(listen_event);<br>    <span class="hljs-built_in">event_base_free</span>(base);<br>    <span class="hljs-built_in">close</span>(listener);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>event_base_new : 创建底层句柄, 调用epoll_create.</li><li>event_new : 创建一个事件对象, 对于某些fd上的事件进行关心.</li><li>event_add : 将事件对象加入epoll内核事件表, 调用epoll_ctl.</li><li>event_base_dispatch : 调用epoll_wait进行事件监视.</li></ul><p>这里echo服务器的整体思路就是把先监视listenfd上的连接请求, 传入连接回调, 在连接回调中用accept, 在监视读请求, 读回调中实现信息的回显.</p><h3 id="部分源码剖析"><a href="#部分源码剖析" class="headerlink" title="部分源码剖析"></a>部分源码剖析</h3><ul><li><p>epoll_new : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *<br><span class="hljs-built_in">event_new</span>(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-type">short</span> events, <span class="hljs-built_in">void</span> (*cb)(<span class="hljs-type">evutil_socket_t</span>, <span class="hljs-type">short</span>, <span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *ev;<br>ev = <span class="hljs-built_in">mm_malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> event));<br><span class="hljs-keyword">if</span> (ev == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">event_assign</span>(ev, base, fd, events, cb, arg) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">mm_free</span>(ev);<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">NULL</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> (ev);<br>&#125;<br></code></pre></td></tr></table></figure><p>先构建出要返回的事件结构题, 然后放到event_assign中统一处理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__GNUC__) &amp;&amp; (__GNUC__ == 11 || __GNUC__ == 12)</span><br>__attribute__((noinline))<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">event_assign</span>(<span class="hljs-keyword">struct</span> event *ev, <span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-type">short</span> events, <span class="hljs-built_in">void</span> (*callback)(<span class="hljs-type">evutil_socket_t</span>, <span class="hljs-type">short</span>, <span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)<br>&#123;<br><span class="hljs-keyword">if</span> (!base)<br>base = current_base;<br><span class="hljs-keyword">if</span> (arg == &amp;event_self_cbarg_ptr_)<br>arg = ev;<br><br><span class="hljs-keyword">if</span> (!(events &amp; EV_SIGNAL))<br><span class="hljs-built_in">event_debug_assert_socket_nonblocking_</span>(fd);<br><span class="hljs-built_in">event_debug_assert_not_added_</span>(ev);<br><br>ev-&gt;ev_base = base;<br><br>ev-&gt;ev_callback = callback;<br>ev-&gt;ev_arg = arg;<br>ev-&gt;ev_fd = fd;<br>ev-&gt;ev_events = events;<br>ev-&gt;ev_res = <span class="hljs-number">0</span>;<br>ev-&gt;ev_flags = EVLIST_INIT;<br>ev-&gt;ev_ncalls = <span class="hljs-number">0</span>;<br>ev-&gt;ev_pncalls = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (events &amp; EV_SIGNAL) &#123;<br><span class="hljs-keyword">if</span> ((events &amp; (EV_READ|EV_WRITE|EV_CLOSED)) != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">event_warnx</span>(<span class="hljs-string">&quot;%s: EV_SIGNAL is not compatible with &quot;</span><br>    <span class="hljs-string">&quot;EV_READ, EV_WRITE or EV_CLOSED&quot;</span>, __func__);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br>ev-&gt;ev_closure = EV_CLOSURE_EVENT_SIGNAL;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (events &amp; EV_PERSIST) &#123;<br><span class="hljs-built_in">evutil_timerclear</span>(&amp;ev-&gt;ev_io_timeout);<br>ev-&gt;ev_closure = EV_CLOSURE_EVENT_PERSIST;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ev-&gt;ev_closure = EV_CLOSURE_EVENT;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">min_heap_elem_init_</span>(ev);<br><br><span class="hljs-keyword">if</span> (base != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* by default, we put new events into the middle priority */</span><br>ev-&gt;ev_pri = base-&gt;nactivequeues / <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-built_in">event_debug_note_setup_</span>(ev);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用传入的内容填入ev中.</p></li><li><p>epoll_add</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">event_add</span>(<span class="hljs-keyword">struct</span> event *ev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv)<br>&#123;<br><span class="hljs-type">int</span> res;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">EVUTIL_FAILURE_CHECK</span>(!ev-&gt;ev_base)) &#123;<br><span class="hljs-built_in">event_warnx</span>(<span class="hljs-string">&quot;%s: event has no event_base set.&quot;</span>, __func__);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-built_in">EVBASE_ACQUIRE_LOCK</span>(ev-&gt;ev_base, th_base_lock);<br><br>res = <span class="hljs-built_in">event_add_nolock_</span>(ev, tv, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">EVBASE_RELEASE_LOCK</span>(ev-&gt;ev_base, th_base_lock);<br><br><span class="hljs-keyword">return</span> (res);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span></span><br><span class="hljs-function"><span class="hljs-title">event_add_nolock_</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *ev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> tv_is_absolute)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = ev-&gt;ev_base;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> notify = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// .......</span><br>    <br>    <span class="hljs-comment">// 核心主要是从此处将事件交付给专门处理IO/信号/定时器的专用函数</span><br><span class="hljs-keyword">if</span> ((ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED|EV_SIGNAL)) &amp;&amp;<br>    !(ev-&gt;ev_flags &amp; (EVLIST_INSERTED|EVLIST_ACTIVE|EVLIST_ACTIVE_LATER))) &#123;<br><span class="hljs-keyword">if</span> (ev-&gt;ev_events &amp; (EV_READ|EV_WRITE|EV_CLOSED))<br>res = <span class="hljs-built_in">evmap_io_add_</span>(base, ev-&gt;ev_fd, ev);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ev-&gt;ev_events &amp; EV_SIGNAL)<br>res = <span class="hljs-built_in">evmap_signal_add_</span>(base, (<span class="hljs-type">int</span>)ev-&gt;ev_fd, ev);<br><span class="hljs-keyword">if</span> (res != <span class="hljs-number">-1</span>)<br><span class="hljs-built_in">event_queue_insert_inserted</span>(base, ev);<br><span class="hljs-keyword">if</span> (res == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">/* evmap says we need to notify the main thread. */</span><br>notify = <span class="hljs-number">1</span>;<br>res = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br><br>    <span class="hljs-comment">// ........</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是通过event_add通过函数层层调用, 针对不同的事件进行不同的处理, 最终调用到epoll_ctl.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// io事件调用线路如下 : </span><br><span class="hljs-built_in">event_add_nolock_</span>()<br>└── <span class="hljs-built_in">evmap_io_add_</span>()<br>    └── <span class="hljs-built_in">epoll_nochangelist_add</span>()<br>        └── <span class="hljs-built_in">epoll_apply_one_change</span>()<br>            └── <span class="hljs-built_in">epoll_ctl</span>()  <br></code></pre></td></tr></table></figure></li><li><p>epoll_init</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INITIAL_NEVENT 64</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epollop</span> &#123;<br>    <span class="hljs-type">int</span> epfd;                            <span class="hljs-comment">// epoll 实例的文件描述符</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events;         <span class="hljs-comment">// epoll_wait 用的事件数组</span><br>    <span class="hljs-type">int</span> nevents;                        <span class="hljs-comment">// 当前分配的事件个数</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epollop</span> *<span class="hljs-built_in">epoll_init</span>(<span class="hljs-type">void</span>) &#123;<br>    <span class="hljs-type">int</span> epfd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epollop</span> *epollop;<br><br>    <span class="hljs-comment">// 创建 epoll 实例，使用 epoll_create（内核 &gt; 2.6.8 其参数已无意义）</span><br>    epfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">32000</span>);<br>    <span class="hljs-keyword">if</span> (epfd == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_create failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配 epollop 结构体</span><br>    epollop = (<span class="hljs-keyword">struct</span> epollop *)<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epollop));<br>    <span class="hljs-keyword">if</span> (!epollop) &#123;<br>        <span class="hljs-built_in">close</span>(epfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    epollop-&gt;epfd = epfd;<br><br>    <span class="hljs-comment">// 分配事件数组，用于 epoll_wait 存放就绪事件</span><br>    epollop-&gt;events = (<span class="hljs-keyword">struct</span> epoll_event *)<span class="hljs-built_in">calloc</span>(INITIAL_NEVENT, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br>    <span class="hljs-keyword">if</span> (!epollop-&gt;events) &#123;<br>        <span class="hljs-built_in">close</span>(epfd);<br>        <span class="hljs-built_in">free</span>(epollop);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    epollop-&gt;nevents = INITIAL_NEVENT;<br><br>    <span class="hljs-keyword">return</span> epollop;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>epoll_dispatch : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">simple_epoll_dispatch</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">int</span> timeout_ms)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epollop</span> *epollop = base-&gt;evbase;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *events = epollop-&gt;events;<br>    <span class="hljs-type">int</span> res;<br><br>    <span class="hljs-comment">// ---- 调用 epoll_wait 等待事件就绪</span><br>    res = <span class="hljs-built_in">epoll_wait</span>(epollop-&gt;epfd, events, epollop-&gt;nevents, timeout_ms);<br>    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;epoll_wait failed&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ---- 依次处理返回的所有事件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res; ++i) &#123;<br>        <span class="hljs-type">int</span> what = events[i].events;<br>        <span class="hljs-type">short</span> ev_flags = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// ---- 错误或者断开连接也作为读/写事件处理</span><br>        <span class="hljs-keyword">if</span> (what &amp; EPOLLERR || what &amp; EPOLLHUP) &#123;<br>            ev_flags = EV_READ | EV_WRITE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (what &amp; EPOLLIN)  ev_flags |= EV_READ;<br>            <span class="hljs-keyword">if</span> (what &amp; EPOLLOUT) ev_flags |= EV_WRITE;<br>        &#125;<br><br>        <span class="hljs-comment">// ---- 将事件激活（调用回调或放入激活队列）</span><br>        <span class="hljs-type">int</span> fd = events[i].data.fd;<br>        <span class="hljs-built_in">evmap_io_active_</span>(base, fd, ev_flags);<br>    &#125;<br><br>    <span class="hljs-comment">// ---- 如果满了，扩大事件数组容量</span><br>    <span class="hljs-keyword">if</span> (res == epollop-&gt;nevents &amp;&amp; epollop-&gt;nevents &lt; <span class="hljs-number">4096</span>) &#123;<br>        <span class="hljs-type">int</span> new_nevents = epollop-&gt;nevents * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> *new_events = <span class="hljs-built_in">realloc</span>(epollop-&gt;events, new_nevents * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> epoll_event));<br>        <span class="hljs-keyword">if</span> (new_events) &#123;<br>            epollop-&gt;events = new_events;<br>            epollop-&gt;nevents = new_nevents;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>evmap_io_active_ : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这个函数负责激活所有目标事件</span><br><span class="hljs-built_in">evmap_io_active_</span>(<span class="hljs-keyword">struct</span> event_base *base, <span class="hljs-type">evutil_socket_t</span> fd, <span class="hljs-type">short</span> events)<br>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_io_map</span> *io = &amp;base-&gt;io;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">evmap_io</span> *ctx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *ev;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EVMAP_USE_HT</span><br><span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span> || fd &gt;= io-&gt;nentries)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-built_in">GET_IO_SLOT</span>(ctx, io, fd, evmap_io);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> == ctx)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-built_in">LIST_FOREACH</span>(ev, &amp;ctx-&gt;events, ev_io_next) &#123;<br><span class="hljs-keyword">if</span> (ev-&gt;ev_events &amp; (events &amp; ~EV_ET))<br><span class="hljs-built_in">event_active_nolock_</span>(ev, ev-&gt;ev_events &amp; events, <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>libevent中有专门的buffer类帮助我们进行更简洁高效安全的读写 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/bufferevent.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/util.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PORT 8888</span><br><br><span class="hljs-comment">// 当有数据可读时触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">void</span> *ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">bufferevent_read</span>(bev, buf, <span class="hljs-built_in">sizeof</span>(buf));<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 回显给客户端</span><br>        <span class="hljs-built_in">bufferevent_write</span>(bev, buf, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 当连接断开或发生错误时触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_event</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> bufferevent *bev, <span class="hljs-type">short</span> events, <span class="hljs-type">void</span> *ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (events &amp; BEV_EVENT_EOF)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;客户端关闭连接\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events &amp; BEV_EVENT_ERROR)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;发生错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 释放 bufferevent（自动关闭 fd）</span><br>    <span class="hljs-built_in">bufferevent_free</span>(bev);<br>&#125;<br><br><span class="hljs-comment">// 当有新连接进入时触发</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">on_accept</span><span class="hljs-params">(<span class="hljs-type">evutil_socket_t</span> listener, <span class="hljs-type">short</span> event, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = (<span class="hljs-keyword">struct</span> event_base *)arg;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>    <span class="hljs-type">socklen_t</span> len = <span class="hljs-built_in">sizeof</span>(client);<br><br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">accept</span>(listener, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;len);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;accept&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;新连接: fd = %d\n&quot;</span>, fd);<br>    <span class="hljs-built_in">evutil_make_socket_nonblocking</span>(fd);<br><br>    <span class="hljs-comment">// 创建 bufferevent，自动释放 fd</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">bufferevent</span> *bev = <span class="hljs-built_in">bufferevent_socket_new</span>(base, fd, BEV_OPT_CLOSE_ON_FREE);<br>    <span class="hljs-comment">// 设置回调函数：读、写（可选）、事件</span><br>    <span class="hljs-built_in">bufferevent_setcb</span>(bev, on_read, <span class="hljs-literal">NULL</span>, on_event, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 启用读写事件</span><br>    <span class="hljs-built_in">bufferevent_enable</span>(bev, EV_READ | EV_WRITE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建 socket</span><br>    <span class="hljs-type">int</span> listener = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">evutil_make_socket_nonblocking</span>(listener);<br><br>    <span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(listener, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-built_in">sizeof</span>(reuse));<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> sin;<br>    <span class="hljs-built_in">memset</span>(&amp;sin, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(sin));<br>    sin.sin_family = AF_INET;<br>    sin.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    sin.sin_port = <span class="hljs-built_in">htons</span>(PORT);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(listener, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;sin, <span class="hljs-built_in">sizeof</span>(sin)) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(listener, <span class="hljs-number">16</span>) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 创建事件循环 base</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = <span class="hljs-built_in">event_base_new</span>();<br><br>    <span class="hljs-comment">// 创建监听事件，监听 listener fd 的可读事件</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span> *listen_event = <span class="hljs-built_in">event_new</span>(base, listener, EV_READ | EV_PERSIST, on_accept, base);<br>    <span class="hljs-built_in">event_add</span>(listen_event, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Echo服务器启动，监听端口 %d...\n&quot;</span>, PORT);<br><br>    <span class="hljs-comment">// 进入事件循环</span><br>    <span class="hljs-built_in">event_base_dispatch</span>(base);<br><br>    <span class="hljs-comment">// 清理资源</span><br>    <span class="hljs-built_in">event_free</span>(listen_event);<br>    <span class="hljs-built_in">event_base_free</span>(base);<br>    <span class="hljs-built_in">close</span>(listener);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于上一个回显服务器, 这个版本的主要变动在于on_accept中从新建一个event变为了新建一个bufferevent, 然后在bufferevent中注册回调并开启监视. 读写操作都被改为bufferevent_read和bufferevent_write, 由系统内部处理数据的读入和写出, 处理粘包等问题, 并且必要的资源释放操作也在内部自动完成, 无需使用者关心.</p><h3 id="evdns-—-异步-DNS-解析模块"><a href="#evdns-—-异步-DNS-解析模块" class="headerlink" title="evdns — 异步 DNS 解析模块"></a>evdns — 异步 DNS 解析模块</h3><p>libevent提供原生异步域名解析服务 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/dns.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/util.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 回调函数：解析成功或失败时被调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dns_callback</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode, <span class="hljs-keyword">struct</span> evutil_addrinfo *res, <span class="hljs-type">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (errcode)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;DNS lookup failed: %s\n&quot;</span>, <span class="hljs-built_in">gai_strerror</span>(errcode));<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">128</span>];<br>        <span class="hljs-built_in">evutil_inet_ntop</span>(res-&gt;ai_family,<br>                         &amp;((<span class="hljs-keyword">struct</span> sockaddr_in *)res-&gt;ai_addr)-&gt;sin_addr,<br>                         buf, <span class="hljs-built_in">sizeof</span>(buf));<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Resolved IP: %s\n&quot;</span>, buf);<br>        <span class="hljs-built_in">evutil_freeaddrinfo</span>(res);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = <span class="hljs-built_in">event_base_new</span>();<br><br>    <span class="hljs-comment">// 初始化 DNS 支持</span><br>    evdns_base *dns_base = <span class="hljs-built_in">evdns_base_new</span>(base, <span class="hljs-number">1</span>); <span class="hljs-comment">// 1 = 初始化默认 DNS 服务器</span><br><br>    <span class="hljs-comment">// 启动 DNS 查询（类似 getaddrinfo，但是异步的）</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">evutil_addrinfo</span> hints;<br>    <span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(hints));<br>    hints.ai_family = AF_INET;<br>    hints.ai_socktype = SOCK_STREAM;<br><br>    <span class="hljs-built_in">evdns_getaddrinfo</span>(dns_base, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">NULL</span>, &amp;hints, dns_callback, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">event_base_dispatch</span>(base);<br><br>    <span class="hljs-built_in">evdns_base_free</span>(dns_base, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">event_base_free</span>(base);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以直接在内部进行域名解析, 得到结果后通过传入的回调函数告知结果.</p><h3 id="evhttp-—-内置-HTTP-Server-Client"><a href="#evhttp-—-内置-HTTP-Server-Client" class="headerlink" title="evhttp — 内置 HTTP Server &#x2F; Client"></a>evhttp — 内置 HTTP Server &#x2F; Client</h3><p>libevent提供了内置的HTTP服务, 可以帮助我们快速解析请求与发送响应 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/event.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/http.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;event2/buffer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_handler</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> evhttp_request *req, <span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">evbuffer</span> *buf = <span class="hljs-built_in">evbuffer_new</span>();<br>    <span class="hljs-built_in">evbuffer_add_printf</span>(buf, <span class="hljs-string">&quot;Hello, evhttp!\n&quot;</span>);<br>    <span class="hljs-built_in">evhttp_send_reply</span>(req, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;OK&quot;</span>, buf);<br>    <span class="hljs-built_in">evbuffer_free</span>(buf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">event_base</span> *base = <span class="hljs-built_in">event_base_new</span>();<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">evhttp</span> *http = <span class="hljs-built_in">evhttp_new</span>(base);<br><br>    <span class="hljs-comment">// 监听 0.0.0.0:8888</span><br>    <span class="hljs-built_in">evhttp_bind_socket</span>(http, <span class="hljs-string">&quot;0.0.0.0&quot;</span>, <span class="hljs-number">8888</span>);<br><br>    <span class="hljs-comment">// 设置 URI 回调</span><br>    <span class="hljs-built_in">evhttp_set_cb</span>(http, <span class="hljs-string">&quot;/hello&quot;</span>, hello_handler, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;HTTP Server running on http://localhost:8888/hello\n&quot;</span>);<br><br>    <span class="hljs-built_in">event_base_dispatch</span>(base);<br><br>    <span class="hljs-built_in">evhttp_free</span>(http);<br>    <span class="hljs-built_in">event_base_free</span>(base);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><ul><li>事件回调模型 : 单线程 + 非阻塞epoll + 事件驱动回调.</li><li>采用统一事件源的核心思想, 可跨平台, 单线程一定线程安全.</li><li>劣势 : 以单线程为主, windows上只能用select不合适.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>libevent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg音视频学习(2) QtAPI</title>
    <link href="/2025/06/28/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0(2)%20QtAPI/"/>
    <url>/2025/06/28/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0(2)%20QtAPI/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章介绍部分Qt中用于音视频解码的api</p></blockquote><p>本章我们将会在qtcreator中写一段代码实现对一个mp4文件的解码, 所谓解码就是把其中存储的每个视频帧和音频帧取出, 本章先不做展示界面, 只是先读取这些帧的数据.</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ul><li>qtcreator</li><li>安装ffmpeg</li></ul><p>在.pro文件中加入相关依赖 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">INCLUDEPATH += /usr/include<br>LIBS += -lavformat -lavcodec -lavutil -lswresample -lswscale<br></code></pre></td></tr></table></figure><p>接下来添加相应头文件就可以进行ffmpeg的使用了.</p><h3 id="基础API学习"><a href="#基础API学习" class="headerlink" title="基础API学习"></a>基础API学习</h3><p>先放出整段代码, 我们一句一句分析 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mainwindow.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavformat/avformat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavcodec/avcodec.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/frame.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;libavutil/avutil.h&gt;</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename = <span class="hljs-string">&quot;/home/lth/learn/ffmpegLearning/fflearn/9.mp4&quot;</span>; <span class="hljs-comment">// 替换为你的视频路径</span><br>    AVFormatContext* fmt_ctx = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 打开文件</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">avformat_open_input</span>(&amp;fmt_ctx, filename, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法打开文件&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 读取流信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">avformat_find_stream_info</span>(fmt_ctx, <span class="hljs-literal">nullptr</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;无法找到流信息&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查找视频流和音频流</span><br>    <span class="hljs-type">int</span> video_stream_index = <span class="hljs-built_in">av_find_best_stream</span>(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> audio_stream_index = <span class="hljs-built_in">av_find_best_stream</span>(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br><br>    AVCodecParameters* video_codecpar = fmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar;<br>    <span class="hljs-type">const</span> AVCodec* video_codec = <span class="hljs-built_in">avcodec_find_decoder</span>(video_codecpar-&gt;codec_id);<br>    AVCodecContext* video_ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(video_codec);<br>    <span class="hljs-built_in">avcodec_parameters_to_context</span>(video_ctx, video_codecpar);<br>    <span class="hljs-built_in">avcodec_open2</span>(video_ctx, video_codec, <span class="hljs-literal">nullptr</span>);<br><br>    AVCodecParameters* audio_codecpar = fmt_ctx-&gt;streams[audio_stream_index]-&gt;codecpar;<br>    <span class="hljs-type">const</span> AVCodec* audio_codec = <span class="hljs-built_in">avcodec_find_decoder</span>(audio_codecpar-&gt;codec_id);<br>    AVCodecContext* audio_ctx = <span class="hljs-built_in">avcodec_alloc_context3</span>(audio_codec);<br>    <span class="hljs-built_in">avcodec_parameters_to_context</span>(audio_ctx, audio_codecpar);<br>    <span class="hljs-built_in">avcodec_open2</span>(audio_ctx, audio_codec, <span class="hljs-literal">nullptr</span>);<br><br>    AVPacket* pkt = <span class="hljs-built_in">av_packet_alloc</span>();<br>    AVFrame* frame = <span class="hljs-built_in">av_frame_alloc</span>();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">av_read_frame</span>(fmt_ctx, pkt) &gt;= <span class="hljs-number">0</span>) &#123;<br>        AVCodecContext* ctx = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == video_stream_index) &#123;<br>            ctx = video_ctx;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pkt-&gt;stream_index == audio_stream_index) &#123;<br>            ctx = audio_ctx;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">avcodec_send_packet</span>(ctx, pkt);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">avcodec_receive_frame</span>(ctx, frame) == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (ctx == video_ctx) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[Video] PTS=&quot;</span> &lt;&lt; frame-&gt;pts<br>                          &lt;&lt; <span class="hljs-string">&quot; size=&quot;</span> &lt;&lt; frame-&gt;width &lt;&lt; <span class="hljs-string">&quot;x&quot;</span> &lt;&lt; frame-&gt;height &lt;&lt; std::endl;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;[Audio] PTS=&quot;</span> &lt;&lt; frame-&gt;pts<br>                          &lt;&lt; <span class="hljs-string">&quot; nb_samples=&quot;</span> &lt;&lt; frame-&gt;nb_samples<br>                          &lt;&lt; <span class="hljs-string">&quot; channels=&quot;</span> &lt;&lt; frame-&gt;channels &lt;&lt; std::endl;<br>            &#125;<br>            <span class="hljs-built_in">av_frame_unref</span>(frame);<br>        &#125;<br><br>        <span class="hljs-built_in">av_packet_unref</span>(pkt);<br>    &#125;<br><br>    <span class="hljs-built_in">av_frame_free</span>(&amp;frame);<br>    <span class="hljs-built_in">av_packet_free</span>(&amp;pkt);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;video_ctx);<br>    <span class="hljs-built_in">avcodec_free_context</span>(&amp;audio_ctx);<br>    <span class="hljs-built_in">avformat_close_input</span>(&amp;fmt_ctx);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>[打开文件和流查找]</strong></p><ul><li><p>首先明确你要解码的文件路径, 我这里直接用的绝对路径, 用相对路径需要看一下起始路径怎么设置.</p></li><li><p><code>AVFormatContext* fmt_ctx = nullptr;</code></p><p>这个是我们进行音视频处理的核心句柄, 其会链接本次解码相关的所有资源, 我们接下来就会用其打开我们要解码的文件.</p></li><li><pre><code class="cpp">avformat_open_input(&amp;fmt_ctx, filename, nullptr, nullptr)<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  第一个核心函数, 传入句柄与路径, 就可以打开对应文件. 打开失败会返回&lt;<span class="hljs-number">0</span>.<br><br>- ```cpp<br>  avformat_find_stream_info(fmt_ctx, nullptr)<br></code></pre></td></tr></table></figure>第二个核心函数, 从文件中找到各种流, 并把所有流信息存入核心句柄, 也是失败返回&lt;0;</code></pre></li><li><pre><code class="c++">int video_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, -1, -1, nullptr, 0);int audio_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, -1, -1, nullptr, 0);<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs prolog"><br>  一个文件中可以有很多流, 这里的函数就是帮我们找到最合适的视频流和音频流, 并给出对应流的下标.<br><br>  - 在fmt_ctx中会有一个数组指针数组streams, 每个元素都会指向一个流, 这里的下标就是数组指针的下标.<br><br>**[解码前准备]**<br><br>- <span class="hljs-string">``</span><span class="hljs-string">`cpp</span><br><span class="hljs-string">  AVCodecParameters* video_codecpar = fmt_ctx-&gt;streams[video_stream_index]-&gt;codecpar;</span><br></code></pre></td></tr></table></figure>根据上文我们可以知道`fmt_ctx-&gt;streams[video_stream_index]`就是最佳视频流, 这个一步就是从这个最佳视频流中取出其**编码器参数**, 并存入video_codecpar对象中.</code></pre></li><li><pre><code class="cpp">const AVCodec* video_codec = avcodec_find_decoder(video_codecpar-&gt;codec_id);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  有了编码器参数, 我们就可以**从库中找到对应的解码器**了.<br><br>- ```cpp<br>  AVCodecContext* video_ctx = avcodec_alloc_context3(video_codec)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>这里`video_ctx`官方叫做解码器上下文, 说人话就是一个对应我们目标解码器的句柄, 其代表了最佳视频流的解码器.</code></pre></li><li><pre><code class="cpp">avcodec_parameters_to_context(video_ctx, video_codecpar);<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>  把我们先前的编码器参数存入video<span class="hljs-emphasis">_ctx中, 便于之后开启正式的解码.</span><br><span class="hljs-emphasis"></span><br><span class="hljs-emphasis">- `avcodec_</span>open2(audio<span class="hljs-emphasis">_ctx, audio_</span>codec, nullptr);`<br><br>​传入我们的解码器句柄和解码器, 这个函数会开始准备对于对应包的解码, 如果有多线程就会开辟线程池准备多线程解码.<br><br><span class="hljs-strong">**[解码过程]**</span><br><br><span class="hljs-bullet">-</span> 在解释下面的过程前, 我们要先认识些概念 : <br><span class="hljs-bullet">  -</span> 包 : 是从流中压缩出来的数据块, 可以从其中解码出帧. 也就是<span class="hljs-code">`流 -&gt; 包 -&gt; 帧`</span>.<br><span class="hljs-bullet">  -</span> 存在<span class="hljs-strong">**一包多帧**</span>(比如音频帧), 也存在<span class="hljs-strong">**一帧多包**</span>(比如高质量视频帧). <br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```cpp</span><br><span class="hljs-code">  AVPacket* pkt = av_packet_alloc();</span><br><span class="hljs-code">  AVFrame* frame = av_frame_alloc();</span><br></code></pre></td></tr></table></figure>提前准备出包对象和帧对象.</code></pre></li><li><pre><code class="cpp">while (av_read_frame(fmt_ctx, pkt) &gt;= 0)<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br>  这里会循环向pkt中存入按顺序读出的包, 这些包可以属于不同流, 并且相邻包的时间相近.<br><br>- ```cpp<br>  AVCodecContext* ctx = nullptr;<br>  <span class="hljs-keyword">if</span> (pkt<span class="hljs-punctuation">-&gt;</span>stream_index == video_stream_index) &#123;<br>      ctx = video_ctx;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pkt<span class="hljs-punctuation">-&gt;</span>stream_index == audio_stream_index) &#123;<br>      ctx = audio_ctx;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_ invoke__">av_packet_unref</span>(pkt);<br>      <span class="hljs-keyword">continue</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>这里是对包的筛选,  每个包都可以读出其归属的流, 如果属于我们需求的两条最佳流, 就分配其对应最佳流的解码器句柄, 如果不属于就弃掉继续读.</code></pre></li><li><pre><code class="cpp">avcodec_send_packet(ctx, pkt);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  这个函数就是将包根据解码器句柄传入其对应的解码器中.<br><br>- ```cpp<br>  while (avcodec_receive_frame(ctx, frame) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>会在这里循环接收我们对于上一句传入包的结果, 也就是帧, 其会将解码出的内容填入我们传入的frame.需要注意的是, 只要这里是0, 就代表填充了一个完整帧, 可以对帧进行处理, 在一包多帧的情况下就可以循环到所有帧都处理完毕. 而在一帧多包的情况下, 不会返回0, 也就是说不会进行帧处理, 直到接收到的包可以合成一个完整帧.</code></pre></li><li><p>关于帧frame, 我们只在这里打印其基础参数, 实际我们可以进行更深入的处理使其作为图像和音频表示出来, 这些之后再详解.</p></li></ul><p>至此我们实现了用ffmpeg解码视频文件, 实现了”文件 -&gt; 流 -&gt; 包 -&gt; 帧”的过程.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FFmpeg音视频学习(1) 理论准备</title>
    <link href="/2025/06/27/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0(1)%20%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/"/>
    <url>/2025/06/27/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0(1)%20%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理论准备</p></blockquote><h3 id="PCM-—-Pulse-Code-Modulation-脉冲调制编码"><a href="#PCM-—-Pulse-Code-Modulation-脉冲调制编码" class="headerlink" title="PCM — Pulse-Code Modulation 脉冲调制编码"></a>PCM — Pulse-Code Modulation 脉冲调制编码</h3><p>一种用数字表示采样模拟信号的方法.</p><p>要将一段音频模拟信号转换为数字表示，包含如下三个步骤：</p><ul><li>1、Sampling(采样)</li><li>2、Quantization(量化)</li><li>3、Coding(编码)</li></ul><p>PCM常用指标 :</p><ul><li><p>采样率(Sample rate)：每秒钟采样多少次，以Hz为单位。</p></li><li><p>位深度(Bit-depth)：表示用多少个二进制位来描述采样数据，一般为16bit。</p></li><li><p>字节序：表示音频PCM数据存储的字节序是大端存储（big-endian）还是小端存储（little-endian），为了数据处理效率的高效，通常为小端存储。</p></li><li><p>声道数（channel number）：当前PCM文件中包含的声道数，是单声道（mono）、双声道（stereo），此外还有5.1声道（常用于影院立体环绕声）等。</p></li><li><p>采样数据是否有符号（Sign）：要表达的就是字面上的意思，需要注意的是，使用有符号的采样数据不能用无符号的方式播放。</p></li></ul><p>以FFmpeg中常见的PCM数据格式s16le为例：它描述的是有符号16位小端PCM数据。</p><p>s表示有符号，16表示位深，le表示小端存储。</p><hr><p>如果我们有一个PCM文件，在代码中，我们可以通过以下方式来读取这样的PCM数据流（Stream）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE *file<br><span class="hljs-type">int8_t</span> *buffer;<br>file = fopen(<span class="hljs-string">&quot;PCM file path&quot;</span>);<br>buffer = <span class="hljs-built_in">malloc</span>(fileSize);<br>fread(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int8_t</span>), fileSize / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int8_t</span>), file);<br></code></pre></td></tr></table></figure><p>伪代码仅仅表示一种加载方式。但在代码中，一开始就将整个文件加载到了内存中，这是不对的。因为我们的音频数据量往往会比较大，一次性全部加载增加了内存负担，而且并不必要。</p><p>通常我们会为buffer分配一个固定的长度，例如2048字节，通过循环的方式一边从文件中加载PCM数据，一边播放。</p><p>加载好PCM数据后，需要送到音频设备驱动程序中播放，这时我们应该能听到声音。与PCM数数据一同到达驱动程序的通常还有采样率（sample rate），用来告诉驱动每秒钟应该播放多少个采样数据。如果传递给驱动程序的采样率大于PCM实际采样率，那么声音的播放速度将比实际速度快，反之亦然。</p><h3 id="YUV-—-亮度-色度模型"><a href="#YUV-—-亮度-色度模型" class="headerlink" title="YUV — 亮度&#x2F;色度模型"></a>YUV — 亮度&#x2F;色度模型</h3><p>这种模型可以描述每一帧画面的每个像素的亮度和色度, 以此排列起来就组成了视频.</p><ul><li>Y代表亮度, 人对亮度更敏感, 因此要更细致, 对存储占比大.</li><li>UV代表色度, 分别代表蓝红色度, 可以组合成各种颜色.</li></ul><p><strong>格式及存储方式(排列方式) :</strong> </p><p>最经典的格式是 <code>YUV420P</code> , 是FFmpeg的默认输出.</p><p>在这种排列方式中 : </p><ul><li>每个像素都有独立的Y, 也就是说 x * y 的画面中有 x * y字节的Y数据.</li><li>每四个(2 * 2)像素中有独立的一组UV, 也就是说 x * y 的画面中有 (x &#x2F; 2) * (y &#x2F; 2) 字节的U数据, V等同.</li></ul><p>因此一个YUV420p格式的视频帧的内存分布可以表示如下 : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[Y, 大小 W×H]</span><span class="hljs-selector-attr">[U, 大小 (W/2)×(H/2)]</span><span class="hljs-selector-attr">[V, 大小 (W/2)×(H/2)]</span><br></code></pre></td></tr></table></figure><p>其实就是每个4个像素需要花费6个字节来存储(4Y + 1U + 1V).</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li><p>帧率 : </p><p>fps — 每秒播放的图像帧数.</p><p>数据大小 &#x3D; 每帧字节数 × 帧率 × 秒数.</p></li><li><p>采样率 : </p><p>Hz — 每秒采集多少个音频样本点. 用于 音频信号的时间分辨率.</p></li><li><p>位深 : </p><p>每个音频样本用多少个 <strong>bit</strong> 表示. 控制声音的动态范围(响度).</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>ffmpeg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(8) Logger</title>
    <link href="/2025/06/26/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(8)%20Logger/"/>
    <url>/2025/06/26/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(8)%20Logger/</url>
    
    <content type="html"><![CDATA[<blockquote><p>asyncqueue + Logger</p></blockquote><p>本章处理一下Rpc框架的遗留问题—日志处理. </p><p>最普通的日志处理就是直接在一个文件中写入, 但是这属于磁盘I&#x2F;O, 效率极低, 我们不会希望在高性能Rpc通信框架中仅仅为了日志在过程中加入磁盘I&#x2F;O的过程, 那么如何解决呢?</p><ul><li><strong>可以将要写入磁盘文件的日志先存入队列, 再开一个专门进行日志磁盘I&#x2F;O的线程从队列取出进行写入.</strong></li></ul><p>很经典的c&#x2F;s模型, 并且把业务和日志分配到两个线程中, 不会影响到业务速度.</p><p>另外还有一个问题, 我们的RpcProvider借用muduo网络库实现网络功能, 其内部是epoll多线程的, 也就是说有可能会有多个线程同时向队列中插入日志, 为了线程安全, 我们需要<strong>用互斥锁保证线程安全</strong>. </p><p>细节已经详述清楚, 接下来展示代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// asyncqueue.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncQueue</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;data)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        _queue.<span class="hljs-built_in">push</span>(data);<br>        _cond.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <span class="hljs-keyword">while</span> (_queue.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            _cond.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br><br>        T top = _queue.<span class="hljs-built_in">front</span>();<br>        _queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::queue&lt;T&gt; _queue;<br>    std::mutex _mutex;<br>    std::condition_variable _cond;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个简单的线程安全队列, 保证插入和弹出操作是安全的, 并且利用条件变量在队列中没有日志时会挂起等待, 有日志插入时再唤醒.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;asyncqueue.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> mprpc<br>&#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RpcLogLevel</span><br>    &#123;<br>        info,<br>        error,<br>    &#125;;<br><br>    <span class="hljs-comment">// Rpc框架提供的日志系统</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcLogger</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetLogLevel</span><span class="hljs-params">(RpcLogLevel lv)</span></span>;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Log</span><span class="hljs-params">(std::string msg)</span></span>;<br><br>        <span class="hljs-function"><span class="hljs-type">static</span> RpcLogger &amp;<span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-built_in">RpcLogger</span>();<br>        <span class="hljs-built_in">RpcLogger</span>(<span class="hljs-type">const</span> RpcLogger &amp;) = <span class="hljs-keyword">delete</span>;<br>        <span class="hljs-built_in">RpcLogger</span>(RpcLogger &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>        <span class="hljs-type">int</span> _loglevel; <span class="hljs-comment">// 记录日志级别</span><br>        AsyncQueue&lt;std::string&gt; _asyncQueue;<br>    &#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> log_info(logmsgformat, ...)                     \</span><br><span class="hljs-meta">    do                                                  \</span><br><span class="hljs-meta">    &#123;                                                   \</span><br><span class="hljs-meta">        RpcLogger &amp;logger = RpcLogger::getInstance();   \</span><br><span class="hljs-meta">        logger.SetLogLevel(info);                       \</span><br><span class="hljs-meta">        char c[1024] = &#123;0&#125;;                             \</span><br><span class="hljs-meta">        snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span><br><span class="hljs-meta">        logger.Log(c);                                  \</span><br><span class="hljs-meta">    &#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> log_error(logmsgformat, ...)                    \</span><br><span class="hljs-meta">    do                                                  \</span><br><span class="hljs-meta">    &#123;                                                   \</span><br><span class="hljs-meta">        RpcLogger &amp;logger = RpcLogger::getInstance();   \</span><br><span class="hljs-meta">        logger.SetLogLevel(<span class="hljs-keyword">error</span>);                      \</span><br><span class="hljs-meta">        char c[1024] = &#123;0&#125;;                             \</span><br><span class="hljs-meta">        snprintf(c, 1024, logmsgformat, ##__VA_ARGS__); \</span><br><span class="hljs-meta">        logger.Log(c);                                  \</span><br><span class="hljs-meta">    &#125; while (0)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>日志系统保证单例, 另外还define了两种快捷写日志的方式.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> mprpc<br>&#123;<br>    RpcLogger::<span class="hljs-built_in">RpcLogger</span>()<br>    &#123;<br>        <span class="hljs-comment">// 启动专门的写日志线程</span><br>        <span class="hljs-function">std::thread <span class="hljs-title">writeLogTask</span><span class="hljs-params">([&amp;]()</span></span><br><span class="hljs-params"><span class="hljs-function">                                 &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)</span></span><br><span class="hljs-params"><span class="hljs-function">        &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-comment">// 获取当前的日期, 然后获取日志信息, 写入相应的日志文件</span></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">time_t</span> now = time(<span class="hljs-literal">nullptr</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            tm* nowtm = localtime(&amp;now);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">char</span> file_name[<span class="hljs-number">128</span>];</span></span><br><span class="hljs-params"><span class="hljs-function">            sprintf(file_name, <span class="hljs-string">&quot;%d-%d-%d-log.txt&quot;</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                nowtm-&gt;tm_year + <span class="hljs-number">1900</span>, nowtm-&gt;tm_mon + <span class="hljs-number">1</span>, nowtm-&gt;tm_mday);</span></span><br><span class="hljs-params"><span class="hljs-function">            FILE* pf = fopen(file_name, <span class="hljs-string">&quot;a+&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span>(!pf)</span></span><br><span class="hljs-params"><span class="hljs-function">            &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                cout &lt;&lt; <span class="hljs-string">&quot;logger file: &quot;</span> &lt;&lt; file_name &lt;&lt; <span class="hljs-string">&quot; open error!&quot;</span> &lt;&lt; endl;</span></span><br><span class="hljs-params"><span class="hljs-function">                exit(EXIT_FAILURE);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            std::string msg = _asyncQueue.pop();</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-type">char</span> time_buf[<span class="hljs-number">128</span>] = &#123;<span class="hljs-number">0</span>&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            sprintf(time_buf, <span class="hljs-string">&quot;%d:%d:%d =&gt;[%s] &quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec,</span></span><br><span class="hljs-params"><span class="hljs-function">                (_loglevel == info ? <span class="hljs-string">&quot;info&quot;</span> : <span class="hljs-string">&quot;error&quot;</span>));</span></span><br><span class="hljs-params"><span class="hljs-function">            msg.insert(<span class="hljs-number">0</span>, time_buf);</span></span><br><span class="hljs-params"><span class="hljs-function">            msg.append(<span class="hljs-string">&quot;\n&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function">            fputs(msg.c_str(), pf);</span></span><br><span class="hljs-params"><span class="hljs-function">            fclose(pf);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125; &#125;)</span></span>;<br>        <span class="hljs-comment">// 设置线程分离</span><br>        writeLogTask.<span class="hljs-built_in">detach</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcLogger::SetLogLevel</span><span class="hljs-params">(RpcLogLevel lv)</span></span><br><span class="hljs-function">    </span>&#123;<br>        _loglevel = lv;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcLogger::Log</span><span class="hljs-params">(std::string msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        _asyncQueue.<span class="hljs-built_in">push</span>(msg);<br>    &#125;<br><br>    <span class="hljs-function">RpcLogger &amp;<span class="hljs-title">RpcLogger::getInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> RpcLogger logger;<br>        <span class="hljs-keyword">return</span> logger;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里一旦日志系统的单例被构造, 就会开辟一个线程持续从队列中取出日志进行磁盘写入, 在没有日志会阻塞在<code>_asyncQueue.pop()</code>处.</p><p>至此只要带上日志头文件, 就是可以在这个高性能且多线程的框架中快捷进行日志操作了.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
      <tag>日志系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(7) Zookeeper</title>
    <link href="/2025/06/26/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(7)%20Zookeeper/"/>
    <url>/2025/06/26/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(7)%20Zookeeper/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本章了解zookeeper的作用与简易的使用方式.</p></blockquote><p>Zookeeper是一个使用非常广泛的<strong>服务发现中间件</strong>. 这个中间件为c&#x2F;s模式, 也就是其会运行在一个服务器上, 其内部维护了一个特殊的文件系统, 可以存储大量的服务信息, 供客户端提取.</p><p>以本项目为例, 在上一章RpcChannel想要获取远程调用服务, 就必须知道提供该服务服务器的ip和port并存入配置文件中, 这样操作是非常原始且低效的. Zookeeper提供的解决方案是 : 我自己在服务器上提供一个服务, 可以存储各种服务名, 方法名及其对应的ip, port和各种服务信息, 供外部查询, 这样只要有了zookeeper的ip和port, 去这里查询有没有对应的服务及其方法就可以了, 在服务和方法量大时这种方式的处理就会尤其高效.</p><h3 id="znode节点"><a href="#znode节点" class="headerlink" title="znode节点"></a>znode节点</h3><p>zookeeper服务专属的数据存储节点, 类似一个树, 用来存储服务, 一个节点最多存储1兆数据. 这就是zookeeper来存储服务方法信息的数据结构.</p><p>这些节点分为永久性节点和临时性节点, 永久性节点zk服务器不会删, 临时性节点在与zk服务器断连一段时间后就会自动删除, 我们一般非常乐意使用临时性节点, 在服务端正常提供服务时zk服务器可以正常搜索到, 在不提供服务时zk服务器就会及时删除.</p><p>另外我们在这里同时存储服务和方法, 你可以理解为方法一定是叶节点, 服务则都可.</p><h3 id="ZkCli使用"><a href="#ZkCli使用" class="headerlink" title="ZkCli使用"></a>ZkCli使用</h3><p>安装好zookeeper后, 我可以通过指令打开zookeeper的客户端 : </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./ZkCli.sh<br></code></pre></td></tr></table></figure><p>zookeeper的主要操作就是在一棵树上创建&#x2F;删除节点并设置数据 : </p><ul><li><p>ls + 路径  :  查询当该处路径的所有子节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">14</span>] ls /<br>[UserServiceRpc, sl, zookeeper]<br></code></pre></td></tr></table></figure><p>这里就表示根目录下有三个节点.</p></li><li><p>create + 路径 + (数据) : 在指定路径创造节点并存入数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zookeeper">[zk: localhost:2181(CONNECTED) 15] create /aaa 1<br>Created /aaa<br>[zk: localhost:2181(CONNECTED) 16] ls /<br>[UserServiceRpc, aaa, sl, zookeeper]<br></code></pre></td></tr></table></figure></li><li><p>get + 路径 : 获取当前节点数据.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">17</span>] get /aaa<br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>delete + 路径 : 删除指定节点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">18</span>] <span class="hljs-keyword">delete</span> /aaa<br>[zk: localhost:<span class="hljs-number">2181</span>(CONNECTED) <span class="hljs-number">19</span>] ls /<br>[UserServiceRpc, sl, zookeeper]<br></code></pre></td></tr></table></figure></li></ul><h3 id="watcher机制"><a href="#watcher机制" class="headerlink" title="watcher机制"></a>watcher机制</h3><p>如其名, 这个机制用来监视zookeeper变化, 客户端可以编写watcher函数作为回调函数, <strong>当zookeeper中发生你关注的变化时, 会触发该回调</strong>. 这种变化非常多样, 大到连接的建立, 小到各种节点的增删改查, 我们可以通过编写不同的watcher函数产生作用各异的监视效果.</p><p>这个机制可以挖掘的地方非常多, 但本项目先只用其帮助我们建立于zk服务器的连接, 在之后会细讲.</p><h3 id="Zookeeper-原生-CAPI-使用"><a href="#Zookeeper-原生-CAPI-使用" class="headerlink" title="Zookeeper 原生 CAPI 使用"></a>Zookeeper 原生 CAPI 使用</h3><p>下面介绍一下我们之后会用的原生API接口 : </p><ul><li><p>zookeeper_init : 初始化 Zookeeper 客户端连接，返回一个 <code>zhandle_t*</code> 的句柄。所有操作都依赖这个句柄。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">zhandle_t</span>* <span class="hljs-title">zookeeper_init</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* host,                  <span class="hljs-comment">// ip:port, 如 &quot;127.0.0.1:2181&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">    watcher_fn watcher,                <span class="hljs-comment">// 默认的 watcher 回调函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> recv_timeout,                  <span class="hljs-comment">// session 超时时间（毫秒）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">clientid_t</span>* clientid,        <span class="hljs-comment">// 恢复会话时使用，首次连接传 nullptr</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">void</span>* context,                     <span class="hljs-comment">// 可传任意上下文信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> flags                          <span class="hljs-comment">// 通常传 0</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>这里host字符串必须是<code>&quot;ip:port&quot;</code>这个样式, 属于一种约定.</p></li><li><p>这里watcher需要我们填入一个默认的全局watcher回调函数, 这个函数的实际作用是帮我们<strong>监听与zk服务器的会话状态</strong>, 也就是连接相关的事物, 其参数是固定的, 我们在后文会深入说明.</p></li></ul></li><li><p>zoo_create : 建立一个znode节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zoo_create</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">zhandle_t</span>* zh,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path,                 <span class="hljs-comment">// 节点路径</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data,                 <span class="hljs-comment">// 要存的数据</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> datalen,                      <span class="hljs-comment">// 数据长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> ACL_vector* acl,    <span class="hljs-comment">// 权限，通常传 &amp;ZOO_OPEN_ACL_UNSAFE</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> flags,                        <span class="hljs-comment">// 创建类型（见下）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">char</span>* path_buffer,                <span class="hljs-comment">// 实际创建的路径（可为顺序节点）</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> path_buffer_len</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>这里flags控制节点类型, 0为永久节点, <code>ZOO_EPHEMERAL</code>为临时节点.</li></ul></li><li><p>zoo_get : 获取目标节点下的数据.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">zoo_get</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">zhandle_t</span>* zh,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> watch,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">char</span>* buffer,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span>* buffer_len,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">struct</span> Stat* stat</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>注意这里watch填0无效果, 填1会帮你监视目标节点变化, 变化就调用我们在zoo_init中填入的默认watcher, 一般不会用, 如果真的需要监视节点变化, 一般会再写一个另外的watcher函数配合zoo_awget函数进行监视, 这里不再详述.</li></ul></li></ul><h3 id="封装zookeeper类"><a href="#封装zookeeper类" class="headerlink" title="封装zookeeper类"></a>封装zookeeper类</h3><p>因为zookeeper的原生API使用还是有些繁琐, 我们一般会写一个类封装这些行为 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// zkcil.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span> <span class="hljs-comment">// 与zk客户端建立连接需要用到信号量</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> THREADED</span><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span><br>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;zookeeper/zookeeper.h&gt;</span></span><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkClient</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ZkClient</span>();<br>    ~<span class="hljs-built_in">ZkClient</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> datalen, <span class="hljs-type">int</span> state = <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">getData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">zhandle_t</span> *_zhandle; <span class="hljs-comment">// 存储zoo_init返回的zk句柄</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// zkcil.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;zookeepercli.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">global_watcher</span><span class="hljs-params">(<span class="hljs-type">zhandle_t</span> *zh, <span class="hljs-type">int</span> type, <span class="hljs-type">int</span> state, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">void</span> *watcherCtx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (type == ZOO_SESSION_EVENT &amp;&amp; state == ZOO_CONNECTED_STATE)<br>    &#123;<br>        <span class="hljs-type">sem_t</span> *sem = (<span class="hljs-type">sem_t</span> *)<span class="hljs-built_in">zoo_get_context</span>(zh);<br>        <span class="hljs-built_in">sem_post</span>(sem);<br>    &#125;<br>&#125;<br><br>ZkClient::<span class="hljs-built_in">ZkClient</span>() : _zhandle(<span class="hljs-literal">nullptr</span>)<br>&#123;<br>&#125;<br><br>ZkClient::~<span class="hljs-built_in">ZkClient</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_zhandle != <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">zookeeper_close</span>(_zhandle);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZkClient::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string ip = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;zookeeperip&quot;</span>);<br>    std::string port = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;zookeeperport&quot;</span>);<br>    std::string connstr = ip + <span class="hljs-string">&quot;:&quot;</span> + port;<br><br>    <span class="hljs-comment">// zookeeper_mt 多线程版本</span><br>    <span class="hljs-comment">// zookeeper的API提供三个线程</span><br>    <span class="hljs-comment">// API调用线程 / 网络IO线程 / watchar回调线程</span><br><br>    <span class="hljs-comment">// 这部分只是本地内容准备, 需要后面等待连接服务端</span><br>    _zhandle = <span class="hljs-built_in">zookeeper_init</span>(connstr.<span class="hljs-built_in">c_str</span>(), global_watcher, <span class="hljs-number">30000</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!_zhandle)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;zookeeper init fail!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-type">sem_t</span> sem;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">zoo_set_context</span>(_zhandle, &amp;sem);<br><br>    <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;zookeeper init success!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 要新开辟的路径, 存入对应路径节点的数据(ip/port), 数据长度, 是永久还是临时</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ZkClient::create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">int</span> datalen, <span class="hljs-type">int</span> state)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> path_buf[<span class="hljs-number">128</span>];<br>    <span class="hljs-type">int</span> bufferlen = <span class="hljs-keyword">sizeof</span> path_buf;<br>    <span class="hljs-comment">// 先判断path表示的节点是否存在</span><br>    <span class="hljs-type">int</span> flag = <span class="hljs-built_in">zoo_exists</span>(_zhandle, path, <span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">if</span> (ZNONODE == flag)<br>    &#123;<br>        flag = <span class="hljs-built_in">zoo_create</span>(_zhandle, path, data, datalen,<br>                          &amp;ZOO_OPEN_ACL_UNSAFE, state, path_buf, bufferlen);<br>        <span class="hljs-keyword">if</span> (flag == ZOK)<br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;znode create success, path: &quot;</span> &lt;&lt; path &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;znode create error, path &quot;</span> &lt;&lt; path &lt;&lt; std::endl;<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 访问一个服务</span><br><span class="hljs-function">std::string <span class="hljs-title">ZkClient::getData</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>];<br>    <span class="hljs-type">int</span> buflen = <span class="hljs-keyword">sizeof</span> buf;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-built_in">zoo_get</span>(_zhandle, path, <span class="hljs-number">0</span>, buf, &amp;buflen, <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-keyword">if</span> (flag == ZOK)<br>        <span class="hljs-keyword">return</span> buf;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;get znode error!&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要额外解释一下有关watcher和信号量的问题 : </p><p><strong>为什么要使用信号量</strong> : 目的是为了实现线程间通信, 因为我们这里使用的是zk的多线程版本, 你可以理解为有三个线程会存在, 一个是调用api的当前线程, 一个是进行网络IO的线程, 一个是准备调用watcher回调的线程. 我们当前线程需要获知网络IO线程是否与zk服务器建立了连接, 需要信号量来保持同步.</p><p><strong>信号量使用过程</strong> : </p><ul><li><p>API调用线程 使用<code>zoo_set_context(_zhandle, &amp;sem)</code>, 将句柄与信号量绑定, 你可以认为其将信号量存入了一块共享内存中.</p></li><li><p>API调用线程 使用<code>sem_wait(&amp;sem)</code>进行等待.</p></li><li><p>网络IO线程 与zk服务器成功建立连接后, 会通过系列操作触发watcher回调线程.</p></li><li><p>watcher回调线程 使用<code>sem_t *sem = (sem_t *)zoo_get_context(zh);</code>从共享内存中取出了信号量并激活.</p></li><li><p>API调用线程 被唤醒并继续执行.</p></li></ul><p><strong>watcher的作用</strong> : 就是很单纯的用来监视会话是否成功建立, watcher还有很多可以开发的用法, 这里不再详述.</p><h3 id="Zookeeper在本框架中的应用"><a href="#Zookeeper在本框架中的应用" class="headerlink" title="Zookeeper在本框架中的应用"></a>Zookeeper在本框架中的应用</h3><p>在解释了zookeeper相关细节后, 我们将在框架中引用zookeeper的服务.</p><p>首先我们要明晰应该在哪里应用zookeeper : </p><ul><li>服务提供端, 也就是RpcProvider, 需要将发布的远程服务发布到zk服务器上. (具体到细节就是在zk服务器中添加多个znode节点, 存入自己的ip&#x2F;port).</li><li>服务调用端, 也就是RpcChannel, 不再通过配置文件获取目标服务器路径, 而是通过配置文件获取zk服务器路径, 同zk服务器进行服务发现.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcProvider::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string ip = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverip&quot;</span>);<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverport&quot;</span>).<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-function">InetAddress <span class="hljs-title">address</span><span class="hljs-params">(port, ip)</span></span>;<br>    <span class="hljs-function">TcpServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;m_eventLoop, address, <span class="hljs-string">&quot;RpcProvider&quot;</span>)</span></span>;<br><br>    server.<span class="hljs-built_in">setConnectionCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br><br>    server.<span class="hljs-built_in">setMessageCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="hljs-keyword">this</span>,<br>                                        std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));<br><br>    server.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 把当前rpc节点要发布的所有服务都注册到zk上, 让客户端通过zk发现服务而不是ip/port</span><br>    <span class="hljs-comment">// 服务节点设置为永久, 方法节点设置为暂时, 只要rpc节点断开连接, 方法节点就会失效</span><br>    ZkClient zkCli;<br>    zkCli.<span class="hljs-built_in">start</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[name, service_info] : m_serviceMap)<br>    &#123;<br>        std::string service_path = <span class="hljs-string">&quot;/&quot;</span> + name;<br>        zkCli.<span class="hljs-built_in">create</span>(service_path.<span class="hljs-built_in">c_str</span>(), <span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[method_name, ptr] : service_info.m_methodMap)<br>        &#123;<br>            std::string method_path = service_path + <span class="hljs-string">&quot;/&quot;</span> + method_name;<br>            <span class="hljs-type">char</span> method_data[<span class="hljs-number">129</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-built_in">sprintf</span>(method_data, <span class="hljs-string">&quot;%s:%d&quot;</span>, ip.<span class="hljs-built_in">c_str</span>(), port);<br>            zkCli.<span class="hljs-built_in">create</span>(method_path.<span class="hljs-built_in">c_str</span>(), method_data, <span class="hljs-built_in">strlen</span>(method_data), ZOO_EPHEMERAL);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="hljs-string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; endl;<br><br>    server.<span class="hljs-built_in">start</span>();<br>    m_eventLoop.<span class="hljs-built_in">loop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>聚焦到RpcProvider的Run函数, 在自己启动对于方法远程调用服务的同时, 要将自己发布的所有服务和方法发布到zk中(从<code>m_serviceMapzh</code>中获取), 注意我们把服务节点设置为永久节点, 方法都设置为临时节点, 这意味着一旦服务提供端与zk服务器断连, zk服务器便会删除这些方法节点.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcChannel::CallMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> google::protobuf::MethodDescriptor *method,</span></span><br><span class="hljs-params"><span class="hljs-function">                              google::protobuf::RpcController *controller, <span class="hljs-type">const</span> google::protobuf::Message *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                              google::protobuf::Message *response, google::protobuf::Closure *done)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> google::protobuf::ServiceDescriptor *sd = method-&gt;<span class="hljs-built_in">service</span>();<br>    <span class="hljs-function">std::string <span class="hljs-title">service_name</span><span class="hljs-params">(sd-&gt;name())</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">method_name</span><span class="hljs-params">(method-&gt;name())</span></span>;<br><br>    <span class="hljs-comment">// 获取参数的序列化字符串长度</span><br>    <span class="hljs-type">uint32_t</span> args_size = <span class="hljs-number">0</span>;<br>    std::string args_str;<br>    <span class="hljs-keyword">if</span> (request-&gt;<span class="hljs-built_in">SerializeToString</span>(&amp;args_str))<br>    &#123;<br>        args_size = args_str.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;serialize request error!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    mprpc::RpcHeader rpcHeader;<br>    rpcHeader.<span class="hljs-built_in">set_service_name</span>(service_name);<br>    rpcHeader.<span class="hljs-built_in">set_method_name</span>(method_name);<br>    rpcHeader.<span class="hljs-built_in">set_args_size</span>(args_size);<br><br>    <span class="hljs-type">uint32_t</span> header_size = <span class="hljs-number">0</span>;<br>    std::string rpc_header_str;<br>    <span class="hljs-keyword">if</span> (rpcHeader.<span class="hljs-built_in">SerializeToString</span>(&amp;rpc_header_str))<br>    &#123;<br>        header_size = rpc_header_str.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;serialize header error&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    std::string send_rpc_str;<br>    send_rpc_str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">string</span>((<span class="hljs-type">char</span> *)&amp;header_size, <span class="hljs-number">4</span>));<br>    send_rpc_str += rpc_header_str;<br>    send_rpc_str += args_str;<br><br>    <span class="hljs-type">int</span> clientfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;create socket error!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 最普通就是直接从配置文件中读取rpcserver的消息</span><br>    <span class="hljs-comment">// std::string ip = MprpcApplication::GetInstance().getConfig().Load(&quot;rpcserverip&quot;);</span><br>    <span class="hljs-comment">// std::string port = MprpcApplication::GetInstance().getConfig().Load(&quot;rpcserverport&quot;);</span><br><br>    <span class="hljs-comment">// 还可以通过服务名和方法名从zookeeper上查询</span><br>    ZkClient zkCli;<br>    zkCli.<span class="hljs-built_in">start</span>();<br><br>    std::string path = <span class="hljs-string">&quot;/&quot;</span> + service_name + <span class="hljs-string">&quot;/&quot;</span> + method_name;<br>    std::string data = zkCli.<span class="hljs-built_in">getData</span>(path.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-keyword">if</span> (data == <span class="hljs-string">&quot;&quot;</span>)<br>    &#123;<br>        std::string str = <span class="hljs-string">&quot;no method found in path: &quot;</span> + path;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(str);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> idx = data.<span class="hljs-built_in">find_first_of</span>(<span class="hljs-string">&quot;:&quot;</span>);<br>    std::string ip = data.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx);<br>    std::string port = data.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(port.<span class="hljs-built_in">c_str</span>()));<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(ip.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == <span class="hljs-built_in">connect</span>(clientfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr)))<br>    &#123;<br>        std::string str = <span class="hljs-string">&quot;connection error! errno:&quot;</span> + std::<span class="hljs-built_in">to_string</span>(errno) + <span class="hljs-string">&quot; errmsg:&quot;</span> + <span class="hljs-built_in">strerror</span>(errno);<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(str);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == <span class="hljs-built_in">send</span>(clientfd, send_rpc_str.<span class="hljs-built_in">c_str</span>(), send_rpc_str.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>))<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;send error&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收rpc请求的响应值</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(clientfd, buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == n)<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;receive error&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!response-&gt;<span class="hljs-built_in">ParseFromArray</span>(buf, n))<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;parse error!&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(clientfd);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们知道RpcChannel中的CallMethod方法负责汇聚不同的远程方法请求并发送出去, 那么寻求目标服务提供端的方式就是在zk上查询对应服务名和方法名, 如果服务提供端确实将服务发布在了zk上, 那么调用端就确实可以查询到并且获取到节点中的data, 从data中提取出服务端的ip&#x2F;port就可以进行正常的发送了.</p><p>至此Zookeeper在本框架项目中的应用已分析完毕.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(6) RpcChannel</title>
    <link href="/2025/06/25/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(6)%20RpcChannel/"/>
    <url>/2025/06/25/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(6)%20RpcChannel/</url>
    
    <content type="html"><![CDATA[<blockquote><p>RpcChannel</p></blockquote><p>RpcChannel是客户调用端的核心类, 其控制了客户端该如何向服务端发出远程方法调用.</p><p>让我们先回顾一下客户端是如何调用我们的框架的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.pb.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 想要使用rpc服务, 就要调用框架的初始化服务</span><br>    MprpcApplication::<span class="hljs-built_in">Init</span>(argc, argv);<br><br>    <span class="hljs-comment">// 演示调用远程发布的rpc方法的Login</span><br>    <span class="hljs-function">fixbug::UserServiceRpc_Stub <span class="hljs-title">stub</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MprpcChannel())</span></span>;<br><br>    fixbug::LoginRequest request;<br>    request.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br>    request.<span class="hljs-built_in">set_pwd</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>    fixbug::LoginResponse response;<br><br>    MprpcController controller;<br><br>    stub.<span class="hljs-built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 如果rpc服务确实成功再继续接下来的内容</span><br>    <span class="hljs-keyword">if</span> (controller.<span class="hljs-built_in">Failed</span>())<br>    &#123;<br>        std::cout &lt;&lt; controller.<span class="hljs-built_in">ErrorText</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// rpc方法调用完成, 读响应</span><br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errcode</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response:&quot;</span> &lt;&lt; response.<span class="hljs-built_in">success</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response error : &quot;</span> &lt;&lt; response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errmsg</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里最核心的就是要构建一个桩对象stub, 并且必须要用框架提供的RpcChannel类对象进行构造, 你可以把其简单理解为一个帮助我们实现远程调用的类.</p><p><code>UserServiceRpc_Stub</code>类中会有我们先前封装的函数, 但是其只是一个包装, 我们可以看其生成的内容 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UserServiceRpc_Stub::Login</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    ::google::protobuf::RpcController* PROTOBUF_NULLABLE controller,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> ::fixbug::LoginRequest* PROTOBUF_NONNULL request, ::fixbug::LoginResponse* PROTOBUF_NONNULL response,</span></span><br><span class="hljs-params"><span class="hljs-function">    ::google::protobuf::Closure* PROTOBUF_NULLABLE done)</span> </span>&#123;<br>  channel_-&gt;<span class="hljs-built_in">CallMethod</span>(<span class="hljs-built_in">descriptor</span>()-&gt;<span class="hljs-built_in">method</span>(<span class="hljs-number">0</span>), controller,<br>                       request, response, done);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实都是统一调用channel_中的CallMethod函数, 不同函数只是在某些参数上有所不同, 注意这里的CallMethod方法和上一章RpcProvider的CallMethod不是一个东西, 前者代表调用端, 后者代表服务提供端.</p><p>如此处理可以让不同远程方法的调用应用到同一段请求发送的代码, 也就是channel_ 的CallMethod, 这里 channel_ 就是我们先前在构造时传入的RpcChannel类对象, 让我们来了解这个类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mprpcchannel.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;google/protobuf/service.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;google/protobuf/descriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;google/protobuf/message.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MprpcChannel</span> : <span class="hljs-keyword">public</span> google::protobuf::RpcChannel<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CallMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> google::protobuf::MethodDescriptor *method,</span></span><br><span class="hljs-params"><span class="hljs-function">                    google::protobuf::RpcController *controller, <span class="hljs-type">const</span> google::protobuf::Message *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                    google::protobuf::Message *response, google::protobuf::Closure *done)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>整个类只有一个函数且继承于<code>google::protobuf::RpcChannel</code>, 我们先要了解CallMethod这个函数的职责, 就是<strong>将要请求的服务, 方法和对应参数封装并序列化, 再通过网络将这个请求发送给提供该服务的服务器(也就是使用了RpcProvider), 最后接收服务器返回的结果存入响应对象</strong>, 下面是具体代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcChannel::CallMethod</span><span class="hljs-params">(<span class="hljs-type">const</span> google::protobuf::MethodDescriptor *method,</span></span><br><span class="hljs-params"><span class="hljs-function">                              google::protobuf::RpcController *controller, <span class="hljs-type">const</span> google::protobuf::Message *request,</span></span><br><span class="hljs-params"><span class="hljs-function">                              google::protobuf::Message *response, google::protobuf::Closure *done)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> google::protobuf::ServiceDescriptor *sd = method-&gt;<span class="hljs-built_in">service</span>();<br>    <span class="hljs-function">std::string <span class="hljs-title">service_name</span><span class="hljs-params">(sd-&gt;name())</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">method_name</span><span class="hljs-params">(method-&gt;name())</span></span>;<br><br>    <span class="hljs-comment">// 获取参数的序列化字符串长度</span><br>    <span class="hljs-type">uint32_t</span> args_size = <span class="hljs-number">0</span>;<br>    std::string args_str;<br>    <span class="hljs-keyword">if</span> (request-&gt;<span class="hljs-built_in">SerializeToString</span>(&amp;args_str))<br>    &#123;<br>        args_size = args_str.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;serialize request error!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    mprpc::RpcHeader rpcHeader;<br>    rpcHeader.<span class="hljs-built_in">set_service_name</span>(service_name);<br>    rpcHeader.<span class="hljs-built_in">set_method_name</span>(method_name);<br>    rpcHeader.<span class="hljs-built_in">set_args_size</span>(args_size);<br><br>    <span class="hljs-type">uint32_t</span> header_size = <span class="hljs-number">0</span>;<br>    std::string rpc_header_str;<br>    <span class="hljs-keyword">if</span> (rpcHeader.<span class="hljs-built_in">SerializeToString</span>(&amp;rpc_header_str))<br>    &#123;<br>        header_size = rpc_header_str.<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;serialize header error&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    std::string send_rpc_str;<br>    send_rpc_str.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>, std::<span class="hljs-built_in">string</span>((<span class="hljs-type">char</span> *)&amp;header_size, <span class="hljs-number">4</span>));<br>    send_rpc_str += rpc_header_str;<br>    send_rpc_str += args_str;<br><br>    <span class="hljs-type">int</span> clientfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (clientfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;create socket error!&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-comment">// 最普通就是直接从配置文件中读取rpcserver的消息</span><br>    std::string ip = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverip&quot;</span>);<br>    std::string port = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverport&quot;</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server_addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr));<br>    server_addr.sin_family = AF_INET;<br>    server_addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-built_in">atoi</span>(port.<span class="hljs-built_in">c_str</span>()));<br>    server_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(ip.<span class="hljs-built_in">c_str</span>());<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == <span class="hljs-built_in">connect</span>(clientfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server_addr, <span class="hljs-built_in">sizeof</span>(server_addr)))<br>    &#123;<br>        std::string str = <span class="hljs-string">&quot;connection error! errno:&quot;</span> + std::<span class="hljs-built_in">to_string</span>(errno) + <span class="hljs-string">&quot; errmsg:&quot;</span> + <span class="hljs-built_in">strerror</span>(errno);<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(str);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == <span class="hljs-built_in">send</span>(clientfd, send_rpc_str.<span class="hljs-built_in">c_str</span>(), send_rpc_str.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>))<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;send error&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接收rpc请求的响应值</span><br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">recv</span>(clientfd, buf, <span class="hljs-number">1024</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == n)<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;receive error&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!response-&gt;<span class="hljs-built_in">ParseFromArray</span>(buf, n))<br>    &#123;<br>        controller-&gt;<span class="hljs-built_in">SetFailed</span>(<span class="hljs-string">&quot;parse error!&quot;</span>);<br>        <span class="hljs-built_in">close</span>(clientfd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(clientfd);<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们再盘点一下这个函数干了些什么 : </p><ul><li>取出服务名, 方法名, 参数长度, 以此构成报头类对象, 再转换成二进制字符串(对于双端信息交互的格式在上一章已经说明, 这里不再详述).</li><li>组合要发送的字符串, 包含 : 报头长度 + 报头二进制字符串 + 参数二进制字符串.</li><li>获取提供目标远程调用服务器的ip和端口(这里默认配置文件中有提供, 在引入zookeeper后会有改动).</li><li>构建网络结构体, 进行正常的Tcp客户端发送.</li><li>接收对端返回的字符串, 并将其存入响应对象.</li></ul><p>至此客户端进行远程方法调用的逻辑链路已经完善, 整体思路就是<strong>将发送服务调用请求的任务通过stub汇聚到RpcChannel类上</strong>.</p><p>另外在前面没有对<code>Controller</code>这个类型进行讲解, 因为其并非核心, 其作用在于检测rpc服务是否正常进行, 如果不正常就不会继续后面的代码并且发出错误信息, 这里给出其内部实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mprpccontroller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;google/protobuf/service.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MprpcController</span> : <span class="hljs-keyword">public</span> google::protobuf::RpcController<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MprpcController</span>();<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Failed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">ErrorText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetFailed</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;reason)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">StartCancel</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsCanceled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NotifyOnCancel</span><span class="hljs-params">(google::protobuf::Closure *)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">bool</span> _failed;<br>    std::string _errText;<br>&#125;;<br><br><span class="hljs-comment">// // mprpccontroller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpccontroller.h&quot;</span></span><br><br>MprpcController::<span class="hljs-built_in">MprpcController</span>()<br>&#123;<br>    _failed = <span class="hljs-literal">false</span>;<br>    _errText = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcController::Reset</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _failed = <span class="hljs-literal">false</span>;<br>    _errText = <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MprpcController::Failed</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _failed;<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">MprpcController::ErrorText</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _errText;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcController::SetFailed</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;reason)</span></span><br><span class="hljs-function"></span>&#123;<br>    _failed = <span class="hljs-literal">true</span>;<br>    _errText = reason;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcController::StartCancel</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">MprpcController::IsCanceled</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcController::NotifyOnCancel</span><span class="hljs-params">(google::protobuf::Closure *)</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(5) RpcProdvider</title>
    <link href="/2025/06/23/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(5)%20RpcProdvider/"/>
    <url>/2025/06/23/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(5)%20RpcProdvider/</url>
    
    <content type="html"><![CDATA[<blockquote><p>RpcProdvider</p></blockquote><p><code>RpcProdvider</code>是提供给服务发布端的核心类. </p><p>既然想把方法发布为远程方法被外部调用, 那么发布端需要做的无非就是作为一个服务器持续接收外部的方法调用请求, 根据请求在本地调用对应的方法, 最后再将响应发送回去, 可以当作一个简易的webServer, 但是需要配合我们先前protobuf的Service类, 使其对于方法调用更加便捷与通用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// rpcprodvider.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;google/protobuf/service.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/TcpServer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/EventLoop.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;muduo/net/InetAddress.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> muduo::net;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;google/protobuf/descriptor.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RpcProvider</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 所有rpc服务都会继承于goole::protobuf::Service</span><br>    <span class="hljs-comment">// 选其为类型可以接收任意服务</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NotifyService</span><span class="hljs-params">(google::protobuf::Service *service)</span></span>;<br><br>    <span class="hljs-comment">// 启动Rpc节点, 开始启动远程网络调用服务</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;, Buffer *, Timestamp)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SendRpcResponse</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;, google::protobuf::Message *)</span></span>;<br><br>    std::unique_ptr&lt;TcpServer&gt; m_tcpserverPtr;<br>    EventLoop m_eventLoop;<br><br>    <span class="hljs-comment">// service服务类型信息</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ServiceInfo</span><br>    &#123;<br>        google::protobuf::Service *m_service;<br>        std::unordered_map&lt;std::string, <span class="hljs-type">const</span> google::protobuf::MethodDescriptor *&gt; m_methodMap;<br>    &#125;;<br>    std::unordered_map&lt;std::string, ServiceInfo&gt; m_serviceMap;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>NotifyService : </p><p>这个函数用于在远程调用服务启动前记录需要发布出去的服务及对应方法.</p></li><li><p>Run : </p><p>这个函数用于启动远程调用服务, 实际上就是监听指定的读端口, 接收外部的请求, 我们这里直接使用Muduo网络库执行网络层的行动.</p></li><li><p>OnConnection &#x2F; OnMessage : 分别对应Muduo网络库在连接建立和读事件触发时的回调.</p></li><li><p>SendRpcResponse : 在函数调用完成后会调用此回调函数将响应发送回去.</p></li></ul><p>再看成员变量 : </p><ul><li><p>m_tcpserverPtr &#x2F; m_eventLoop : 使用Muduo网络库的必要变量.</p></li><li><p>m_serviceMap : </p><p>每个服务名对应一个服务结构体<code>ServiceInfo</code>, 每一个服务结构体中又包含了以<strong>方法名与方法结构体指针</strong>为键值对的结构体. 通过<code>NotifyService</code>向其中存储, 在收到请求后, 根据解析出来的服务名和方法进行查询和取出指针的操作.</p></li></ul><p>接下来展示每个函数的细节 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcProvider::NotifyService</span><span class="hljs-params">(google::protobuf::Service *service)</span></span><br><span class="hljs-function"></span>&#123;<br>    ServiceInfo service_info;<br>    <span class="hljs-comment">// 获取服务对象的描述信息</span><br>    <span class="hljs-type">const</span> google::protobuf::ServiceDescriptor *serviceDesc = service-&gt;<span class="hljs-built_in">GetDescriptor</span>();<br>    <span class="hljs-function">std::string <span class="hljs-title">service_name</span><span class="hljs-params">(serviceDesc-&gt;name())</span></span>;<br>    <span class="hljs-type">int</span> methodCnt = serviceDesc-&gt;<span class="hljs-built_in">method_count</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;service name : &quot;</span> &lt;&lt; service_name &lt;&lt; endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; methodCnt; i++)<br>    &#123;<br>        <span class="hljs-comment">// 获取指定下标的服务方法的描述</span><br>        <span class="hljs-type">const</span> google::protobuf::MethodDescriptor *methodDesc = serviceDesc-&gt;<span class="hljs-built_in">method</span>(i);<br>        <span class="hljs-function">std::string <span class="hljs-title">method_name</span><span class="hljs-params">(methodDesc-&gt;name())</span></span>;<br>        service_info.m_methodMap.<span class="hljs-built_in">insert</span>(&#123;method_name, methodDesc&#125;);<br>        cout &lt;&lt; <span class="hljs-string">&quot;method name : &quot;</span> &lt;&lt; method_name &lt;&lt; endl;<br>    &#125;<br>    service_info.m_service = service;<br>    m_serviceMap.<span class="hljs-built_in">insert</span>(&#123;service_name, service_info&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过protobuf中内置的方法, 可以直接从Service对象中通过GetDescriptor()获取服务指针, 进而获取服务名, 方法数目及其下的每个方法指针. 本函数要做的就是将这些信息存储到我们上面提到的m_serviceMap中, 步骤比较麻烦, 但是不难懂.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 启动Rpc节点, 开始启动远程网络调用服务</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcProvider::Run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string ip = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverip&quot;</span>);<br>    <span class="hljs-type">uint16_t</span> port = <span class="hljs-built_in">atoi</span>(MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverport&quot;</span>).<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-function">InetAddress <span class="hljs-title">address</span><span class="hljs-params">(port, ip)</span></span>;<br>    <span class="hljs-function">TcpServer <span class="hljs-title">server</span><span class="hljs-params">(&amp;m_eventLoop, address, <span class="hljs-string">&quot;RpcProvider&quot;</span>)</span></span>;<br><br>    server.<span class="hljs-built_in">setConnectionCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;RpcProvider::OnConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br><br>    server.<span class="hljs-built_in">setMessageCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;RpcProvider::OnMessage, <span class="hljs-keyword">this</span>,<br>                                        std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));<br><br>    server.<span class="hljs-built_in">setThreadNum</span>(<span class="hljs-number">3</span>);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;RpcProvider start service at ip:&quot;</span> &lt;&lt; ip &lt;&lt; <span class="hljs-string">&quot; port:&quot;</span> &lt;&lt; port &lt;&lt; endl;<br><br>    server.<span class="hljs-built_in">start</span>();<br>    m_eventLoop.<span class="hljs-built_in">loop</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里就是一个比较常规的开启网络服务的步骤了, 先通过<code>MprpcApplication</code>取出配置文件中的ip与port, 然后构造Muduo网络库的TcpServer对象, 设置连接建立回调和读事件回调, 最后开启服务器并启动循环, 这里需要对Muduo网络库有使用经验才容易理解.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 已建立连接用户的读事件回调, 如果远程有一个rpc服务的调用请求, 会响应该方法</span><br><span class="hljs-comment">// 执行请求的反序列化 和 响应的序列化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcProvider::OnMessage</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, Buffer *buf, Timestamp timestamp)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string recv_buf = buf-&gt;<span class="hljs-built_in">retrieveAllAsString</span>();<br><br>    <span class="hljs-comment">// 约定请求rpc服务需要 service_name / method_name / args_size / args_str</span><br>    <span class="hljs-comment">// args_size是为了解决粘包问题</span><br>    <span class="hljs-type">uint32_t</span> header_size = <span class="hljs-number">0</span>;<br>    recv_buf.<span class="hljs-built_in">copy</span>((<span class="hljs-type">char</span> *)&amp;header_size, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>);<br>    string rpc_header_str = recv_buf.<span class="hljs-built_in">substr</span>(<span class="hljs-number">4</span>, header_size);<br>    mprpc::RpcHeader rpcHeader;<br>    string service_name, method_name;<br>    <span class="hljs-type">uint32_t</span> args_size;<br>    <span class="hljs-keyword">if</span> (rpcHeader.<span class="hljs-built_in">ParseFromString</span>(rpc_header_str))<br>    &#123;<br>        service_name = rpcHeader.<span class="hljs-built_in">service_name</span>();<br>        method_name = rpcHeader.<span class="hljs-built_in">method_name</span>();<br>        args_size = rpcHeader.<span class="hljs-built_in">args_size</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc_header_str:&quot;</span> &lt;&lt; rpc_header_str &lt;&lt; <span class="hljs-string">&quot;parse error!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    string args_str = recv_buf.<span class="hljs-built_in">substr</span>(<span class="hljs-number">4</span> + header_size, args_size);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;=============================================&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;header_size&quot;</span> &lt;&lt; header_size &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;service_name&quot;</span> &lt;&lt; service_name &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;method_name&quot;</span> &lt;&lt; method_name &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;args_str&quot;</span> &lt;&lt; args_str &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;=============================================&quot;</span> &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 获取service对象和method对象</span><br>    <span class="hljs-keyword">auto</span> it = m_serviceMap.<span class="hljs-built_in">find</span>(service_name);<br>    <span class="hljs-keyword">if</span> (it == m_serviceMap.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        cout &lt;&lt; service_name &lt;&lt; <span class="hljs-string">&quot;is not exist!&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> mit = it-&gt;second.m_methodMap.<span class="hljs-built_in">find</span>(method_name);<br>    <span class="hljs-keyword">if</span> (mit == it-&gt;second.m_methodMap.<span class="hljs-built_in">end</span>())<br>    &#123;<br>        std::cout &lt;&lt; service_name &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; method_name &lt;&lt; <span class="hljs-string">&quot;is not exist&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    google::protobuf::Service *service = it-&gt;second.m_service;<br>    <span class="hljs-type">const</span> google::protobuf::MethodDescriptor *method = mit-&gt;second;<br><br>    <span class="hljs-comment">// 生成rpc方法调用的请求request和response</span><br>    <span class="hljs-comment">// 生成一个message对象, 设定其内部对应目标method的参数</span><br>    google::protobuf::Message *request = service-&gt;<span class="hljs-built_in">GetRequestPrototype</span>(method).<span class="hljs-built_in">New</span>();<br>    <span class="hljs-keyword">if</span> (!request-&gt;<span class="hljs-built_in">ParseFromString</span>(args_str)) <span class="hljs-comment">// 反序列化存储到request中</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;request prase error&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    google::protobuf::Message *response = service-&gt;<span class="hljs-built_in">GetResponsePrototype</span>(method).<span class="hljs-built_in">New</span>();<br><br>    <span class="hljs-comment">// 给下面的method方法调用绑定一个Closure的回调函数</span><br>    google::protobuf::Closure *done = google::protobuf::<span class="hljs-built_in">NewCallback</span>&lt;RpcProvider, <span class="hljs-type">const</span> TcpConnectionPtr &amp;, google::protobuf::Message *&gt;(<span class="hljs-keyword">this</span>, &amp;RpcProvider::SendRpcResponse, conn, response);<br><br>    <span class="hljs-comment">// 在框架上根据远端rpc的请求, 调用当前rpc节点上发布的方法</span><br>    service-&gt;<span class="hljs-built_in">CallMethod</span>(method, <span class="hljs-literal">nullptr</span>, request, response, done);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是读事件的回调, 我们来整理一下当读事件回调触发时我们的行为 : </p><ul><li><p><strong>正确读入字段, 取出需求的信息.</strong></p><p>为了达到此目的, 我们必须和客户端达成对于请求格式的一致,  具体规定为分为报头部分和参数部分.</p><ul><li>报头部分包含 <em>service_name &#x2F; method_name &#x2F; args_size</em> (服务名, 方法名, 参数部分大小), 这些被包含在<em>RpcHeader</em> 这个对象中, 该对象也由protobuf生成, 具体细节不表.</li><li>参数部分就是客户端的请求对象序列化成的二进制字符串.</li></ul><p>我们先读出报头部分的三个参数, 在利用args_size取出参数部分, 这样可以防止tcp的粘包问题.</p></li><li><p>在我们事先准备好存储服务信息的map中<strong>找寻请求的服务</strong>, 再<strong>将对应服务和对应方法的操作指针取出</strong>.</p></li><li><p><strong>利用指针构造请求对象和响应对象</strong>.</p></li></ul><p>  注意需要将参数部分的字符串放到请求对象中反序列化, 就是这段代码 : </p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">request-&gt;<span class="hljs-built_in">ParseFromString</span>(args_str)<br></code></pre></td></tr></table></figure><ul><li><p><strong>构造Closure(控制器)并存入回调函数</strong>.</p><p>构造出来的done参数主要用来在合适的时机调用先前设置的回调函数. 其作用是确保在响应对象填充完毕后才执行发送. 我们先来看看回调函数我们具体是怎么写的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RpcProvider::SendRpcResponse</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn, google::protobuf::Message *response)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string response_str;<br>    <span class="hljs-keyword">if</span> (response-&gt;<span class="hljs-built_in">SerializeToString</span>(&amp;response_str))<br>    &#123;<br>        conn-&gt;<span class="hljs-built_in">send</span>(response_str);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;serialize response_str error!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    conn-&gt;<span class="hljs-built_in">shutdown</span>(); <span class="hljs-comment">// rpc服务的提供方主动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其实很简单, 就是把响应对象序列化成二进制字符串发送出去罢了.</p></li><li><p><strong>调用目标服务专门的<code>CallMethod</code>方法</strong>.</p><p>这里其实就是在调用我们发布方法的远程版, 其依赖于protobuf对每个服务方法的封装, 通过多态, CallMethod又会调用到对应服务的版本, 然后再根据我们传入的method通过switch语句选择调用正确的远程方法. 假如我们请求的是UserService的Login方法, 那么最后就会调用到我们先前用protobuf自动生成的源文件中的这个函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UserServiceRpc::CallMethod</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> ::google::protobuf::MethodDescriptor* PROTOBUF_NONNULL method,</span></span><br><span class="hljs-params"><span class="hljs-function">    ::google::protobuf::RpcController* PROTOBUF_NULLABLE controller,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">const</span> ::google::protobuf::Message* PROTOBUF_NONNULL request,</span></span><br><span class="hljs-params"><span class="hljs-function">    ::google::protobuf::Message* PROTOBUF_NONNULL response, ::google::protobuf::Closure* PROTOBUF_NULLABLE done)</span> </span>&#123;<br>  <span class="hljs-built_in">ABSL_DCHECK_EQ</span>(method-&gt;<span class="hljs-built_in">service</span>(), file_level_service_descriptors_user_2eproto[<span class="hljs-number">0</span>]);<br>  <span class="hljs-keyword">switch</span> (method-&gt;<span class="hljs-built_in">index</span>()) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">Login</span>(controller, ::google::protobuf::<span class="hljs-built_in">DownCastMessage</span>&lt;::fixbug::LoginRequest&gt;(request),<br>                   ::google::protobuf::<span class="hljs-built_in">DownCastMessage</span>&lt;::fixbug::LoginResponse&gt;(response), done);<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-built_in">ABSL_LOG</span>(FATAL) &lt;&lt; <span class="hljs-string">&quot;Bad method index; this should never happen.&quot;</span>;<br>      <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>至此对于整个<code>RpcProvider</code>的构建思路基本完善, 主要就是配合protobuf构建的服务封装体系, 先把要发布的服务方法记录下来, 然后设置epoll服务器接收请求, 分析请求并查找是否有对应的远程方法, 有就利用多态直接通过CallMethod函数调用对应远程方法.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(4) RpcApplication</title>
    <link href="/2025/05/20/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(4)%20RpcApplication/"/>
    <url>/2025/05/20/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(4)%20RpcApplication/</url>
    
    <content type="html"><![CDATA[<blockquote><p>RpcApplication</p></blockquote><p>本章讲解第一个核心类<code>RpcApplication</code>, 该类的主要任务是解析传入的配置文件, 并可以取出解析到的内容, 简单来说就是执行初始化任务.</p><ul><li><p>为什么要传入并解析配置文件?</p><p>网络通信是点到点的, 你必须要知道对端的ip和port才能真正实现通信. 在本框架中, 配置文件主要存储的就是我们的目标服务器的ip与port, 当然如果我们使用zookeeper, 也会存储对应zk的ip与port, 关于zk我们之后再讲.</p></li></ul><p>那么在认识了what和why后, 对于配置文件的解析其实就是很普通的字符串处理了, 让我们通过代码来了解 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mprpcapplication.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcconfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcchannel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpccontroller.h&quot;</span></span><br><br><span class="hljs-comment">// mprpc框架的初始类, 用来加载配置文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MprpcApplication</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> MprpcApplication &amp;<span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">static</span> MprpcConfig &amp;<span class="hljs-title">getConfig</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">MprpcApplication</span>() &#123;&#125;<br>    <span class="hljs-built_in">MprpcApplication</span>(<span class="hljs-type">const</span> MprpcApplication &amp;) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">MprpcApplication</span>(MprpcApplication &amp;&amp;) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">static</span> MprpcConfig _config;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>init : 不管是客户端还是服务端, 在最初构造完MprpcApplication对象后都要调用此函数, 用来加载配置文件.</p><ul><li><p>其参数就是上级main函数传入的命令参数, 这里默认选项为<code>-i</code>, 需要传入配置文件信息,例如 :</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./consumer -i ./test.conf<br></code></pre></td></tr></table></figure><p>test.conf配置约定如下 : </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">rpcserverip=82.156.254.74<br>rpcserverport=8888<br>zookeeperip=82.156.254.74<br>zookeeperport=2181<br></code></pre></td></tr></table></figure></li></ul></li><li><p>GetInstance : 本类采取单例模式, 因为获取配置始终只需要一个对象即可, 唯一对象都通过该函数获取.</p></li><li><p>getConfig : 获取解析完成的配置对象.</p></li><li><p>_config : 配置对象, 之后会分析.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br>MprpcConfig MprpcApplication::_config;<br><br><span class="hljs-function">MprpcApplication &amp;<span class="hljs-title">MprpcApplication::GetInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> MprpcApplication app;<br>    <span class="hljs-keyword">return</span> app;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcApplication::Init</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;format: command -i &lt;configfile&gt;&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>    std::string config_file;<br>    <span class="hljs-keyword">while</span> ((c = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;i:&quot;</span>)) != <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;i&#x27;</span>:<br>            config_file = optarg;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 开始加载配置文件 rpcserver_ip= rpcserver_port= zookeeper_ip= zookeeper_port=</span><br>    _config.<span class="hljs-built_in">LoadConfigFile</span>(config_file.<span class="hljs-built_in">c_str</span>());<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;rpcserverip:&quot;</span> &lt;&lt; _config.<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverip&quot;</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;rpcserverport:&quot;</span> &lt;&lt; _config.<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverport&quot;</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;zookeeperip:&quot;</span> &lt;&lt; _config.<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;zookeeperip&quot;</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;zookeeperport:&quot;</span> &lt;&lt; _config.<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;zookeeperport&quot;</span>) &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function">MprpcConfig &amp;<span class="hljs-title">MprpcApplication::getConfig</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _config;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>MprpcApplication</code>只负责对传入的参数进行合法性检验并执行生成配置对象, 真正的细节在MprpcConfig中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mprpcconfig.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">// rpcserver_ip= rpcserver_port= zookeeper_ip= zookeeper_port=</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MprpcConfig</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 解析加载配置文件</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LoadConfigFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *config_file)</span></span>;<br>    <span class="hljs-comment">// 查询配置项信息</span><br>    <span class="hljs-function">std::string <span class="hljs-title">Load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    std::unordered_map&lt;std::string, std::string&gt; _configMap;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// mprpcconfig.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcconfig.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 解析加载配置文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MprpcConfig::LoadConfigFile</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *config_file)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE *pf = <span class="hljs-built_in">fopen</span>(config_file, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == pf)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">feof</span>(pf))<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">fgets</span>(buf, <span class="hljs-number">512</span>, pf);<br>        <span class="hljs-function">std::string <span class="hljs-title">sbuf</span><span class="hljs-params">(buf)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sbuf.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (sbuf[i] == <span class="hljs-string">&#x27; &#x27;</span> || sbuf[i] == <span class="hljs-string">&#x27;\r&#x27;</span> || sbuf[i] == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>                sbuf.<span class="hljs-built_in">erase</span>(i, <span class="hljs-number">1</span>), i--;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sbuf[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> idx = sbuf.<span class="hljs-built_in">find</span>(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        std::string key = sbuf.<span class="hljs-built_in">substr</span>(<span class="hljs-number">0</span>, idx);<br>        std::string value = sbuf.<span class="hljs-built_in">substr</span>(idx + <span class="hljs-number">1</span>);<br>        _configMap[key] = value;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 查询配置项信息</span><br><span class="hljs-function">std::string <span class="hljs-title">MprpcConfig::Load</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string &amp;key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_configMap.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">return</span> _configMap[key];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>LoadConfigFile : </p><p>在该函数中, 通过传入的配置文件路径打开文件并进行字符串处理, 将每个键值对存入<code>_configMap</code>.</p></li><li><p>Load : </p><p>该函数用于查询, 传入代表键的string, 就会返回解析出来的值string.</p></li></ul><p>经过这样子解析配置文件, 我们就可以通过类似下面的操作取出配置文件中的参数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string ip = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverip&quot;</span>);<br>std::string port = MprpcApplication::<span class="hljs-built_in">GetInstance</span>().<span class="hljs-built_in">getConfig</span>().<span class="hljs-built_in">Load</span>(<span class="hljs-string">&quot;rpcserverport&quot;</span>);<br></code></pre></td></tr></table></figure><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(3) 使用方式</title>
    <link href="/2025/05/15/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(3)%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/05/15/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(3)%20%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在构建通信框架前,  一定要先了解我们的框架该怎么使用, 大体有哪几个部件, 在本章将会先写出一个简易的客户端和服务端, 让我们了解该设计出什么样的网络通信框架.</p></blockquote><h3 id="统一通信标准"><a href="#统一通信标准" class="headerlink" title="统一通信标准"></a>统一通信标准</h3><p>首先双方如果需要通信, 那么<strong>统一通信标准</strong>必不可少, 这也是为什么讲解proto的原因, 所以我们的第一步是编写proto文件并且生成.h和.cpp文件, 这里还是已先前的登录服务为例 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> fixbug;<br><br><span class="hljs-keyword">option</span> cc_generic_services = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ResultCode</span><br>&#123;<br>    <span class="hljs-type">int32</span> errcode = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> errmsg = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginRequest</span> <br>&#123;<br>    <span class="hljs-type">bytes</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> pwd = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginResponse</span><br>&#123;<br>    ResultCode result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">UserServiceRpc</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(LoginRequest) <span class="hljs-keyword">returns</span>(LoginResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们通过终端命令获得.h和.cpp文件后, 这个文件会共享给客户端和服务端, 你也许会觉得这增加了远程调用的难度, 因为这意味着客户端还要获取这些文件, 但是这是必须前提.</p><h3 id="服务端发布服务"><a href="#服务端发布服务" class="headerlink" title="服务端发布服务"></a>服务端发布服务</h3><p>当我们想给一个方法或一类方法提供远程调用服务时, 我们要把其包装进一个Service(服务类)中, 这个类提供远程调用版本的方法, 并且这个类还要继承自我们先前用proto生成的服务类封装, 我们具体看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// UserServic原本是一个本地服务</span><br><span class="hljs-comment">// 只要继承UserServiceRpc再重写一个虚函数就可以实现rpc服务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> : <span class="hljs-keyword">public</span> fixbug::UserServiceRpc<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Login</span><span class="hljs-params">(std::string name, std::string pwd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;doing local servie : Login&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; pwd:&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(::google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">const</span> ::fixbug::LoginRequest *request,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::fixbug::LoginResponse *response,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::google::protobuf::Closure *done)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>        std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br><br>        <span class="hljs-type">bool</span> login_result = <span class="hljs-built_in">Login</span>(name, pwd);<br><br>        <span class="hljs-comment">// 把结果response</span><br>        ResultCode *code = response-&gt;<span class="hljs-built_in">mutable_result</span>();<br>        code-&gt;<span class="hljs-built_in">set_errcode</span>(<span class="hljs-number">0</span>);<br>        code-&gt;<span class="hljs-built_in">set_errmsg</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        response-&gt;<span class="hljs-built_in">set_success</span>(login_result);<br><br>        <span class="hljs-comment">// 执行回调操作 直接执行响应对象数据的序列化和网络发送</span><br>        done-&gt;<span class="hljs-built_in">Run</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>fixbug : 这个就是我们先前在proto中设置的命名空间, 在这个命名空间中就会有我们设置的<code>UserServiceRpc服务类</code>.</p></li><li><p>继承后我们就要写一个Login函数重写版本, 相当于一个远程调用版本, 其参数是固定的 : </p><p>RpcController + 先前设定的请求参数类型 + 响应参数类型 + Closure.</p><p>中间两个我们很熟悉, 第一个我们先不用关心, 最后一个你可以理解为执行类型, 帮我们执行最后发送操作.</p></li></ul><p>在写完我们要发布的服务类后我们来看具体如何发布 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;../user.pb.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;rpcprovider.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;logger.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> fixbug;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mprpc;<br><br><span class="hljs-comment">// UserServic原本是一个本地服务</span><br><span class="hljs-comment">// 只要继承UserServiceRpc再重写一个虚函数就可以实现rpc服务</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> : <span class="hljs-keyword">public</span> fixbug::UserServiceRpc<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Login</span><span class="hljs-params">(std::string name, std::string pwd)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;doing local servie : Login&quot;</span> &lt;&lt; std::endl;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">&quot; pwd:&quot;</span> &lt;&lt; pwd &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Login</span><span class="hljs-params">(::google::protobuf::RpcController *controller,</span></span><br><span class="hljs-params"><span class="hljs-function">               <span class="hljs-type">const</span> ::fixbug::LoginRequest *request,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::fixbug::LoginResponse *response,</span></span><br><span class="hljs-params"><span class="hljs-function">               ::google::protobuf::Closure *done)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>        std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br><br>        <span class="hljs-type">bool</span> login_result = <span class="hljs-built_in">Login</span>(name, pwd);<br><br>        <span class="hljs-comment">// 把结果response</span><br>        ResultCode *code = response-&gt;<span class="hljs-built_in">mutable_result</span>();<br>        code-&gt;<span class="hljs-built_in">set_errcode</span>(<span class="hljs-number">0</span>);<br>        code-&gt;<span class="hljs-built_in">set_errmsg</span>(<span class="hljs-string">&quot;&quot;</span>);<br>        response-&gt;<span class="hljs-built_in">set_success</span>(login_result);<br><br>        <span class="hljs-comment">// 执行回调操作 直接执行响应对象数据的序列化和网络发送</span><br>        done-&gt;<span class="hljs-built_in">Run</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 调用框架初始化操作</span><br>    MprpcApplication::<span class="hljs-built_in">Init</span>(argc, argv);<br><br>    <span class="hljs-built_in">log_info</span>(<span class="hljs-string">&quot;first log message.&quot;</span>);<br><br>    <span class="hljs-comment">// 把UserService发布到rpc节点上</span><br>    RpcProvider provider;<br>    provider.<span class="hljs-built_in">NotifyService</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">UserService</span>());<br>    <span class="hljs-comment">// 启动一个rpc服务发布节点</span><br>    provider.<span class="hljs-built_in">Run</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里引出两个关键类 :  <code>MprpcApplication</code> 和 <code>RpcProvider</code> .</p><ul><li>MprpcApplication : 负责框架的初始化, 其更多的功能在于加载配置文件, 后面会详细介绍.</li><li>RpcProvider : 核心类, 其作用在于将服务发布到rpc节点上, 发布成功后就可以持续监听对于该服务的请求并做出响应.<ul><li>NotifyService : 将服务中的信息的记录下来, 在运行后以供查询.</li><li>Run : 调用网络库的网络服务, 开始接收外部调用请求.</li></ul></li></ul><h3 id="客户端调用远程服务"><a href="#客户端调用远程服务" class="headerlink" title="客户端调用远程服务"></a>客户端调用远程服务</h3><p>客户端的调用就相对方便了, 设置好请求对象就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mprpcapplication.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.pb.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 想要使用rpc服务, 就要调用框架的初始化服务</span><br>    MprpcApplication::<span class="hljs-built_in">Init</span>(argc, argv);<br><br>    <span class="hljs-comment">// 演示调用远程发布的rpc方法的Login</span><br>    <span class="hljs-function">fixbug::UserServiceRpc_Stub <span class="hljs-title">stub</span><span class="hljs-params">(<span class="hljs-keyword">new</span> MprpcChannel())</span></span>;<br><br>    fixbug::LoginRequest request;<br>    request.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br>    request.<span class="hljs-built_in">set_pwd</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br>    fixbug::LoginResponse response;<br><br>    MprpcController controller;<br><br>    stub.<span class="hljs-built_in">Login</span>(&amp;controller, &amp;request, &amp;response, <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-comment">// 如果rpc服务确实成功再继续接下来的内容</span><br>    <span class="hljs-keyword">if</span> (controller.<span class="hljs-built_in">Failed</span>())<br>    &#123;<br>        std::cout &lt;&lt; controller.<span class="hljs-built_in">ErrorText</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// rpc方法调用完成, 读响应</span><br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errcode</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response:&quot;</span> &lt;&lt; response.<span class="hljs-built_in">success</span>() &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;rpc login response error : &quot;</span> &lt;&lt; response.<span class="hljs-built_in">result</span>().<span class="hljs-built_in">errmsg</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>fixbug::UserServiceRpc_Stub stub(new MprpcChannel());</code></p><p>stub其目的在于帮助我们调用到我们需求函数的远程版本, 其构造必须传入一个MprpcChannel类型的参数, 这个也是框架的核心类, 在之后会详细讲解.</p></li><li><p>之后就是正常的设置请求对象, 将响应对象一并放入远程调用函数, 如果框架帮我们调用成功, 这里便可以从响应对象中取出我们想要的响应.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(2) protobuf</title>
    <link href="/2025/05/11/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(2)%20protobuf/"/>
    <url>/2025/05/11/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(2)%20protobuf/</url>
    
    <content type="html"><![CDATA[<blockquote><p>protobuf部分</p></blockquote><p>protobuf的功效和json相似, 都是便利数据的序列化和反序列化用于网络传输, 在rpc分布式网络通信中可以使用protobuf, 让我们先了解其优势 : </p><ul><li>传输数据由二进制存储, 节省空间且效率更高.</li><li>有专门对于服务&#x2F;方法的封装, 可以更方便地传输一个方法的信息.</li></ul><p>当然其劣势在于需要编写.proto文件, 安装和使用都麻烦些, 不过这并不妨碍我们学习.</p><h3 id="proto文件"><a href="#proto文件" class="headerlink" title=".proto文件"></a>.proto文件</h3><p>首先我们要知道, 写一个.proto文件实际就是类似c++中写几个类, 每个类都是对你要传输数据的封装, 下面是一个对于登录所需数据的.proto文件 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;  <span class="hljs-comment">// 声明proto版本</span><br><br><span class="hljs-keyword">package</span> fixbug;  <span class="hljs-comment">// 类似namespace</span><br><br><span class="hljs-keyword">option</span> cc_generic_services = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 这个是在你想要使用service类型时添加</span><br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">ResultCode</span><br>&#123;<br>    <span class="hljs-type">int32</span> errcode = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> errmsg = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginRequest</span> <br>&#123;<br>    <span class="hljs-type">bytes</span> name = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bytes</span> pwd = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">message </span><span class="hljs-title class_">LoginResponse</span><br>&#123;<br>    ResultCode result = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> success = <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-keyword">service </span><span class="hljs-title class_">UserServiceRpc</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> Login(LoginRequest) <span class="hljs-keyword">returns</span>(LoginResponse)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出, 普通数据封装都是message类型, 里面可以存, int, bool等类型, 注意这里bytes实际就是string类型, 当然直接写string也可以, 但是使用bytes效率更佳.</p><p>最后sevice类型用来描述一个服务, 其中可以有多个方法(函数), 其中每个方法的写法是 : </p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-function"><span class="hljs-keyword">rpc</span> 函数名(参数类型) <span class="hljs-keyword">returns</span>(返回类型)</span>;<br></code></pre></td></tr></table></figure><p>为什么要封装方法? 假设我们要调用一个远程服务, 作为客户端, 我们就要告诉服务端我们要调用什么服务的什么方法. 假设我们要发布服务, 那么为了让我们的服务可以被更多的客户端找到, 我们所封装的服务格式就应当符合一些广为人知的标准, 而这个标准一般就是proto所封装的服务.</p><h3 id="生成头文件和源文件"><a href="#生成头文件和源文件" class="headerlink" title="生成头文件和源文件"></a>生成头文件和源文件</h3><p>在写完.proto文件后, 我们就可以执行终端命令来自动生成头文件和源文件了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">protoc xxx.proto --cpp_out=./<br></code></pre></td></tr></table></figure><p>调用该命令便可以在当前目录下生成 xxx.pb.h 和 xxx.pb.cpp 文件了, 这两个文件才是我们真正使用的文件.</p><h3 id="使用proto进行序列化和反序列化"><a href="#使用proto进行序列化和反序列化" class="headerlink" title="使用proto进行序列化和反序列化"></a>使用proto进行序列化和反序列化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 在客户端, 我们可以这样构建请求类型</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user.pb.h&quot;</span></span><br><br>fixbug::LoginRequest request;<br>request.<span class="hljs-built_in">set_name</span>(<span class="hljs-string">&quot;zhang san&quot;</span>);<br>request.<span class="hljs-built_in">set_pwd</span>(<span class="hljs-string">&quot;123456&quot;</span>);<br><br><span class="hljs-comment">// 在服务端, 可以这样取出请求类型</span><br>std::string name = request-&gt;<span class="hljs-built_in">name</span>();<br>std::string pwd = request-&gt;<span class="hljs-built_in">pwd</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法细节复习(2)</title>
    <link href="/2025/05/06/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(2)/"/>
    <url>/2025/05/06/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(2)/</url>
    
    <content type="html"><![CDATA[<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>其本质是利用栈上对象出作用域自动析构的特性自动释放堆上的内存.</p><h3 id="weak-ptr-shared-ptr"><a href="#weak-ptr-shared-ptr" class="headerlink" title="weak_ptr &#x2F; shared_ptr"></a>weak_ptr &#x2F; shared_ptr</h3><ul><li><p>weak_ptr : 弱智能指针, 观察者, 不影响引用计数, 作用在于观察一个指针, 并在关键时刻可以通过提升得到使用权.</p></li><li><p>shared_ptr : 强智能指针, 拥有者, 影响引用计数, 确实拥有并可以使用指针.</p></li><li><p>weak_ptr.lock() : 检测观察对象的引用计数, 不为0则将弱智能指针提升为强智能指针, 可以检测指针指向的资源是否还存在.</p></li><li><p>可以很好地接近多线程环境下共享对象的线程安全问题, 主线程掌握shared_ptr, 调用其他线程时将shared_ptr强转成weak_ptr, 也就是说其他线程中都是观测者, 在想要使用时调用lock, 看是否还存在, 存在就提升为shared_ptr.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">int</span> w) :<span class="hljs-built_in">x</span>(w) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testA</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发testA, x : &quot;</span> &lt;&lt; x &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(weak_ptr&lt;A&gt; pw)</span></span><br><span class="hljs-function"></span>&#123;<br>    shared_ptr&lt;A&gt; sp = pw.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span>(sp != <span class="hljs-literal">nullptr</span>) sp-&gt;<span class="hljs-built_in">testA</span>();<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;A对象已析构, 不能再访问&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">shared_ptr&lt;A&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">new</span> A())</span></span>;<br>        <span class="hljs-function">thread <span class="hljs-title">t1</span><span class="hljs-params">(handler, weak_ptr(p))</span></span>;<br>        t<span class="hljs-number">1.</span><span class="hljs-built_in">detach</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>unique_ptr : 无引用计数, 拥有并独占一个指针.</li><li>拷贝只支持移动拷贝构造, 会转移独占权.</li></ul><h3 id="make-shared"><a href="#make-shared" class="headerlink" title="make_shared"></a>make_shared</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">shared_ptr&lt;T&gt; <span class="hljs-title">sp1</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T(<span class="hljs-number">10</span>))</span></span>;<span class="hljs-comment">// 1</span><br><span class="hljs-keyword">auto</span> sp2 = <span class="hljs-built_in">make_shared</span>&lt;T&gt;(<span class="hljs-number">10</span>);<span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>普通的shared_ptr构造存在缺陷 : </p><ul><li>shared_ptr存在两部分资源, 一部分是所管理对象new出来的资源, 一部分是存放引用计数new出来的资源, 由于两部分都有可能出错, 如果出现部分成功部分失败就有内存泄漏的风险.</li></ul><p>make_shared可以做到以下改进 : </p><ul><li>将管理对象和引用计数对象包装进一个对象, 只new这个对象, 可以保证全失败或全成功. 以此提高内存分配效率并且防止内存泄露风险.</li></ul><p>make_shared缺点 : </p><ul><li>无法自定义删除器.</li><li>托管的内存会延迟释放, 因为如果有弱智能指针会等到弱指针移除才全部析构.</li></ul><h3 id="deletor-自定义"><a href="#deletor-自定义" class="headerlink" title="deletor(自定义)"></a>deletor(自定义)</h3><p>unique_ptr和shared_ptr等智能指针在要销毁内存时, 其析构函数其实是在调用默认的deletor, 类似如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">~<span class="hljs-built_in">unique_ptr</span>() &#123; <span class="hljs-built_in">deletor</span>(ptr); &#125;<br></code></pre></td></tr></table></figure><p>而这个默认的deletor就重载了(), 其默认操作的就<strong>对ptr执行普通的delete</strong>.</p><p>自定义deletor的必要性在于, 有很多资源的释放方式并不是普通的delete, 那么这个这种默认方式就不可以用在这些资源上, 比如数组资源就要 <code>delete []</code>, 文件资源就要fclose, socket要close等.</p><p>因此我们可以通过写一个自定义deletor, 重载(), 就可以实现特殊资源的特殊释放.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDeletor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;MyDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> []ptr;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFileDeletor</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(T* ptr)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;MyFileDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;<br>&#125;;<br><br>unique_ptr&lt;<span class="hljs-type">int</span>, MyDeletor&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>]);<br>unique_ptr&lt;FILE, MyFileDeletor&lt;FILE&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然上面是旧做法, 现在我们可以通过function + lambda快捷实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里使用的是第二种构造函数 unique_ptr(T* ptr, Deleter d); </span><br><span class="hljs-comment">// 这个Deleter要和前面第二个模板参数匹配, 这样就可以推导出lambda表达式的类型.</span><br>unique_ptr&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>*)&gt;&gt; <span class="hljs-built_in">ptr1</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], <br>[](<span class="hljs-type">int</span>* ptr)-&gt;<span class="hljs-type">void</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;lambda MyDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span>[] ptr;<br>    &#125;);<br><br>unique_ptr&lt;FILE*, function&lt;<span class="hljs-type">void</span>(FILE*)&gt;&gt; <span class="hljs-built_in">ptr2</span>(<span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <br>[](FILE* ptr)-&gt;<span class="hljs-type">void</span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;lambda MyFileDeletor&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">fclose</span>(ptr);<br>    &#125;);<br></code></pre></td></tr></table></figure><p>还可以通过decltype + lambda实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span>* ptr)&#123; <span class="hljs-keyword">delete</span>[] ptr; &#125;;<br><span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(lambda)</span>&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>], lambda)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h2><h3 id="function-绑定器"><a href="#function-绑定器" class="headerlink" title="function(绑定器)"></a>function(绑定器)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 模板 + 可变参数</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span>... Args&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfunction</span>&lt;<span class="hljs-built_in">R</span>(Args...)&gt; <span class="hljs-comment">// 函数类型实例化类模板</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> PFUNC = <span class="hljs-built_in">R</span>(*)(Args...);<br>    <span class="hljs-built_in">myfunction</span>(PFUNC pfunc) :_pfunc(pfunc)&#123;&#125;<br>    <br>    <span class="hljs-function">R <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(Args... arg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> _pfunc(arg...);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    PFUNC _pfunc;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>绑定成员函数必须依赖于一个对象 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(string str)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; str &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    fuction&lt;<span class="hljs-built_in">void</span>(Test*, string)&gt; func = &amp;Test::hello;<br>    <span class="hljs-built_in">func</span>(&amp;<span class="hljs-built_in">Test</span>(), <span class="hljs-string">&quot;call Test::hello!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p><code>[捕获外部变量](形参列表)-&gt;返回值&#123;代码&#125;</code></p><ul><li>[&#x3D;] 以传值方式捕获外部所有变量.</li><li>[&amp;] 以传引用方式捕获外部所有变量.</li><li>[&#x3D;, &amp;a] 除a传引用, 其他变量都传值.</li><li>[a, &amp;b] a传值, b传引用.</li><li>[this] 捕获this指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 找第一个小于65的值</span><br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">find_if</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a)&#123;<br>    <span class="hljs-keyword">return</span> a &lt; <span class="hljs-number">65</span>;<br>&#125;);<br><span class="hljs-keyword">if</span>(it != v.<span class="hljs-built_in">end</span>()) cout &lt;&lt; <span class="hljs-string">&quot;find less than 65&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">// 输出所有奇数</span><br>for_each(v.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">int</span> a)&#123;<br>    <span class="hljs-keyword">if</span>(a &amp; <span class="hljs-number">1</span>) cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;); <br></code></pre></td></tr></table></figure><ul><li><p>可以用fuction类型表示lambda表达式类型.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;<span class="hljs-type">int</span>, function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt;&gt; cal;<br>cal[<span class="hljs-number">1</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>cal[<span class="hljs-number">2</span>] = [](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)&#123; <span class="hljs-keyword">return</span> a - b; &#125;;<br></code></pre></td></tr></table></figure></li><li><p>优先级队列自定义比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Data</span>(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2) :<span class="hljs-built_in">a</span>(v1) ,<span class="hljs-built_in">b</span>(v2) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a, b;<br>&#125;;<br><br><span class="hljs-keyword">using</span> FUNC = function&lt;<span class="hljs-built_in">bool</span>(Data&amp;, Data&amp;)&gt;;<br>priority_queue&lt;Data, vector&lt;data&gt;, FUNC&gt; <span class="hljs-built_in">Heap</span>([](Data&amp; d1, Data&amp;d2)&#123;<br>    <span class="hljs-keyword">return</span> d<span class="hljs-number">1.</span>ma &gt; d<span class="hljs-number">2.</span>ma;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>lambda默认const, 其不可修改任何捕获到的变量, 但是可以用mutable使得可以修改 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">boost::asio::<span class="hljs-built_in">post</span>(worker-&gt;io_context, [sock = std::<span class="hljs-built_in">move</span>(socket)]() <span class="hljs-keyword">mutable</span> &#123; std::<span class="hljs-built_in">make_shared</span>&lt;Session&gt;(std::<span class="hljs-built_in">move</span>(sock))-&gt;<span class="hljs-built_in">start</span>(); &#125;);<br></code></pre></td></tr></table></figure></li></ul><hr><ul><li><p>malloc只负责分配内存, 而new则实现了分配+构造, 其内部会调用malloc, 然后再分配到的内存上执行对应的构造函数.</p></li><li><p>c++中一个对象会在什么时候会被释放掉?</p><ul><li>栈上对象离开作用领域会自动析构</li><li>堆上对象必须手动析构, 可以利用智能指针实现自动析构.</li><li>静态对象程序结束时析构</li></ul></li><li><p>什么会引起内存泄露 : </p><ul><li>不成对使用new和delete</li><li>智能指针相互引用</li></ul></li><li><p>自动检测内存泄露 : </p><ul><li>如果想自己写, 可以自己重写自定义的new和delete, 可以配合全局变量进行计数.</li><li>Linux有常用的内存检测工具<code>valgrind</code>.</li></ul></li><li><p>磁盘翻译到内存的过程效率是很低的, 有什么优化思路 : </p><ul><li>使用内存池或者写一个LRU缓存.</li><li>减少频繁调用malloc.</li><li>使用mmap将磁盘上的文件映射到一段虚拟内存地址中.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>shared_ptr</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++语法细节复习(1)</title>
    <link href="/2025/04/28/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(1)/"/>
    <url>/2025/04/28/C++%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82%E5%A4%8D%E4%B9%A0(1)/</url>
    
    <content type="html"><![CDATA[<h2 id="MyString"><a href="#MyString" class="headerlink" title="MyString"></a>MyString</h2><p>最普通的String模仿, 没有追加功能函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!str)<br>        &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">1</span>];<br>            *mptr = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br>            <span class="hljs-built_in">memcpy</span>(mptr, str, <span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyString</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (!mptr)<br>            <span class="hljs-keyword">delete</span>[] mptr;<br>    &#125;<br><br>    <span class="hljs-built_in">MyString</span>(<span class="hljs-type">const</span> MyString &amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发左值拷贝&quot;</span> &lt;&lt; endl;<br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(mptr, cp.mptr, <span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">MyString</span>(MyString &amp;&amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发右值拷贝&quot;</span> &lt;&lt; endl;<br>        mptr = cp.mptr;<br>        cp.mptr = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyString &amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发左值赋值重载&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;cp)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-keyword">delete</span>[] mptr;<br><br>        mptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">memcpy</span>(mptr, cp.mptr, <span class="hljs-built_in">strlen</span>(cp.mptr) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    MyString &amp;<span class="hljs-keyword">operator</span>=(MyString &amp;&amp;cp)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;触发右值赋值重载&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;cp)<br>            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br><br>        <span class="hljs-keyword">delete</span>[] mptr;<br><br>        mptr = cp.mptr;<br>        cp.mptr = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> *&amp;<span class="hljs-title">getPtr</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> mptr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">getPtr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> mptr; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *mptr;<br>&#125;;<br><br>MyString <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> MyString &amp;first, <span class="hljs-type">const</span> MyString &amp;second)<br>&#123;<br>    MyString tmp;<br>    tmp.<span class="hljs-built_in">getPtr</span>() = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(first.<span class="hljs-built_in">getPtr</span>()) + <span class="hljs-built_in">strlen</span>(second.<span class="hljs-built_in">getPtr</span>()) + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">strcpy</span>(tmp.<span class="hljs-built_in">getPtr</span>(), first.<span class="hljs-built_in">getPtr</span>());<br>    <span class="hljs-built_in">strcat</span>(tmp.<span class="hljs-built_in">getPtr</span>(), second.<span class="hljs-built_in">getPtr</span>());<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-type">const</span> MyString &amp;str)<br>&#123;<br>    out &lt;&lt; str.<span class="hljs-built_in">getPtr</span>();<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">MyString <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>    <span class="hljs-function">MyString <span class="hljs-title">str2</span><span class="hljs-params">(<span class="hljs-string">&quot; world!&quot;</span>)</span></span>;<br>    str = <span class="hljs-built_in">move</span>(str2);<br>    <span class="hljs-function">MyString <span class="hljs-title">str3</span><span class="hljs-params">(MyString(<span class="hljs-string">&quot;222&quot;</span>))</span></span>;<br>    MyString str4 = <span class="hljs-built_in">MyString</span>(<span class="hljs-string">&quot;111&quot;</span>);<br>    cout &lt;&lt; str4 &lt;&lt; endl;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ul><li>左值 : 有内存, 有名字 |  右值 : 没内存, 没名字</li><li>int&amp;&amp; d &#x3D; 20; <ul><li>一个右值引用变量本身是一个左值, 只不过引用了一个右值而已.</li><li>20是右值, d是左值, 也是右值引用变量.</li></ul></li></ul><h2 id="引用折叠-完美转发"><a href="#引用折叠-完美转发" class="headerlink" title="引用折叠 &#x2F; 完美转发"></a>引用折叠 &#x2F; 完美转发</h2><p>我们先引入一个例子 : vector的push_back, 其可以有两个版本, 分别对应接收左值和右值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, val);<br>    _last++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T&amp;&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, std::<span class="hljs-built_in">move</span>(val));<br>    _last++;<br>&#125;<br></code></pre></td></tr></table></figure><p>其区别在于, 因为右值在使用时会降级为左值, 所以在右值版本必须通过move保证传递的依然是个左值. 而引用折叠 + 完美转发可以帮助我们合并这两个版本.</p><h3 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h3><ul><li><p>&amp; + &amp; &#x3D; &amp;</p></li><li><p>&amp; + &amp;&amp; &#x3D; &amp;</p></li><li><p>&amp;&amp; + &amp;&amp; &#x3D; &amp;&amp;</p></li></ul><h3 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h3><ul><li>forward<T>() : 使用这个函数可以保证右值不会降级.</li></ul><h3 id="函数模板类型推导-引用折叠-完美转发-实现左右值版本合并"><a href="#函数模板类型推导-引用折叠-完美转发-实现左右值版本合并" class="headerlink" title="函数模板类型推导 + 引用折叠 + 完美转发 实现左右值版本合并"></a>函数模板类型推导 + 引用折叠 + 完美转发 实现左右值版本合并</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Ty&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(Ty&amp;&amp; val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">full</span>()) <span class="hljs-built_in">expand</span>();<br>    <br>    _allocator.<span class="hljs-built_in">construct</span>(_last, std::forward&lt;Ty&gt;(val);<br>    _last++;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本等同于我们以上两个版本, 这里的逻辑是 : </p><ul><li>使用函数模板开启类型推导, 不再按照定死的类型判断, 也就是可以使用引用折叠了.</li><li>如果传入左值, T&amp;  &amp;&amp; -&gt; T&amp;.</li><li>如果传入右值, T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;.</li><li>forward将val按照原来的类型完美转发出去, 不改变其左右值类型.</li></ul><p>于是我们通过 <strong>函数模板类型推导 + 引用折叠 + 完美转发</strong> 实现了代码简化, 让其可以同时处理左右值情况, 这种操作适用于希望同时接受左右值同时对左右值没有操作上的区别的函数, 你可以认为这就是<strong>引用折叠和完美转发最主要的作用</strong>了.</p><p>当然完美转发的用途更加广泛一些, 比如 : </p><ul><li><p>在工厂函数中根据不同类型转发不同的参数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function">T* <span class="hljs-title">create</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>create就在分析完T的类型后向T的构造函数中完美转发参数包, 也就是说, 他可以为任何类型在堆上开辟空间, 只用参数和其构造函数匹配.</p></li><li><p>原地构造, 最经典的就是vector的emplace_back.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span> </span>&#123;<br>    <span class="hljs-built_in">construct_at</span>(<span class="hljs-built_in">end</span>(), std::forward&lt;Args&gt;(args)...);<br>&#125;<br></code></pre></td></tr></table></figure><p>在以前push_back只可以传入对应类型的对象, 这样还要进行拷贝再填入到开辟的空间中, 而有了完美转发, 就可以直接在开辟的空间上用传入的参数直接调用对应类型的构造函数, 这样更加快速.</p></li></ul><h2 id="对象优化的原则"><a href="#对象优化的原则" class="headerlink" title="对象优化的原则"></a>对象优化的原则</h2><ul><li><p>函数参数传递过程中, 对象优先传引用传参, 不要传值传参.</p></li><li><p>当函数返回对象时, 返回临时对象效率最优, 而非先定义局部对象然后返回局部对象.</p><ul><li>返回临时对象会直接在main函数栈帧上构建该对象, 不受这个函数影响. 如果是后者还要将原本构建的局部对象拷贝构造到main函数的栈帧上, 离开函数作用域还要调用局部对象的析构, 也就是说会多两个函数调用.</li></ul></li><li><p>当函数返回对象时, 优先按初始化方式接收, 而非初始化完了再赋值.</p><ul><li>因为这个返回的对象肯定是右值, 所以可以直接拿来用来构建, 都省去了再拷贝操作. 不过如果有了移动语义, 右值进行拷贝或赋值重载的消耗很小, 其实也可以忽略不计.</li><li>在C++17中有RVO机制, 要求强制返回值优化, 也就说上面的行为在C++17以前可能算是编译器优化, 但在C++17以后就算是语言特性了.</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>string</tag>
      
      <tag>移动语义</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rpc分布式网络通信框架(1) 理论准备</title>
    <link href="/2025/04/27/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(1)%20%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/"/>
    <url>/2025/04/27/Rpc%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A1%86%E6%9E%B6(1)%20%E7%90%86%E8%AE%BA%E5%87%86%E5%A4%87/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理论准备</p></blockquote><p><strong>单机聊天服务器的缺点 :</strong> </p><ul><li>受限于硬件资源, 并发量有限制  -&gt;  集群服务器解决</li><li>任意模块的修改都会导致整体的编译部署  -&gt; 分布式解决</li><li>有些模块是CPU密集型, 有些是IO密集型, 对硬件资源不一样  -&gt; 分布式解决</li></ul><p><strong>集群与分布式 :</strong> </p><ul><li>集群 : 每个里面都运行了一个独立系统, 有全套的服务.</li><li>分布式 : 将不同服务搭载在不同的服务器上, 还可以对单个分布式节点集群.</li></ul><p><strong>分布式面临问题 :</strong> </p><ul><li>模块如何划分?</li><li>各模块之间如何访问? -&gt; 涉及网络传输</li></ul><h3 id="RPC-remote-procedure-call-远程过程调用-通信原理"><a href="#RPC-remote-procedure-call-远程过程调用-通信原理" class="headerlink" title="RPC(remote procedure call 远程过程调用)通信原理"></a>RPC(remote procedure call 远程过程调用)通信原理</h3><ul><li>将请求序列化, 经由服务发现将请求通过网络发送到目标服务器, 对端接收并反序列化, 调用目标函数并返回, 返回也要经历上述过程.</li></ul><h3 id="RPC分布式网络通信框架"><a href="#RPC分布式网络通信框架" class="headerlink" title="RPC分布式网络通信框架"></a>RPC分布式网络通信框架</h3><p>这只是一个框架, 可以帮助我们将自己的服务发布为rpc节点, 或帮助我们调用其他发布者发布的rpc节点中的方法, 接下来让我们深入了解.</p><h4 id="服务与方法"><a href="#服务与方法" class="headerlink" title="服务与方法"></a>服务与方法</h4><p>这只是一个标准的概念, 服务包含方法, 一个服务可以有很多方法, 一个方法就对应一个函数, 其实服务就是起到一个分类的作用, 在rpc中通常以此作为分类标准.</p><h4 id="具体框架"><a href="#具体框架" class="headerlink" title="具体框架"></a>具体框架</h4><ul><li><p>假如我们要调用一个远程服务, 也就是调用一个远程服务器上的函数并将参数传入, 获取该函数返回的内容, 在这之中函数发布者和函数调用者都会有一些特定的操作.</p></li><li><p>Provider(发布者)</p><p>将自己想发布的方法包装进服务中, 发布该服务, 意味着自己作为服务器持续接收远端通过网络发送来的调用请求, 接收请求的处理逻辑如下 : </p><ul><li>利用muduo库进行网络消息的接收 -&gt; 反序列化取出请求的服务&#x2F;方法&#x2F;参数 -&gt; 调用对应函数并产生返回值 -&gt; 将返回值序列化 -&gt; 通过muduo库将返回值发送回去</li></ul></li><li><p>Consumer(调用者)</p><p>只要知道了发布rpc服务节点的地址, 就可以通过接近普通方法的调用方式调用到远程方法.</p><ul><li>直接获知目标rpc的地址或通过服务发现获取地址 -&gt; 将服务&#x2F;方法&#x2F;参数序列化发送给目标地址 -&gt; 等待接收返回值并反序列化.</li></ul></li></ul><p>这其中我们有两大工具必不可少 : </p><ul><li><p>Protobuf </p><p>类似于json用于网络通信的序列化和反序列化的工具, 不过其支持对rpc服务的序列化和反序列化, 可以使框架的构建更加简便.</p></li><li><p>Zookeeper</p><p>服务发现工具, 帮助客户端找到目标服务方法的地址.</p></li></ul><h2 id="Zookeeper分布式协调服务"><a href="#Zookeeper分布式协调服务" class="headerlink" title="Zookeeper分布式协调服务"></a>Zookeeper分布式协调服务</h2><blockquote><p>服务发现 &#x2F; 分布式锁</p></blockquote><p>一个注册中心, 保存了所有可获得的服务和其对应的URL(ip &#x2F; port).</p><h3 id="znode节点"><a href="#znode节点" class="headerlink" title="znode节点"></a>znode节点</h3><p>zookeeper服务专属的数据存储节点, 类似一个树, 用来存储服务, 一个节点最多存储1兆数据</p><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>在节点变化时使用Watcher的客户端会得到通知.</p>]]></content>
    
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(6) TcpServer</title>
    <link href="/2025/04/23/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(6)%20TcpServer/"/>
    <url>/2025/04/23/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(6)%20TcpServer/</url>
    
    <content type="html"><![CDATA[<blockquote><p>TcpServer类详解</p></blockquote><p>TcpServer将会作为Muduo库对外开放的核心类, 其提供接口开启服务器并设置设置回调函数与线程数量.</p><p>我们可以先预测一下TcpServer将要实现的功能 : </p><ul><li>构造Acceptor并控制listen决定开始监听的时机.</li><li>构造EventLoopThreadPool并开辟设置的线程数量.</li><li>处理Acceptor监听到的每个connfd, 构建对应的TcpConnection, 并把该连接保存下来.</li><li>对外提供开始监听, 设置回调, 设置线程数量等接口.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Accept.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Callbacks.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpConnection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpServer</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Option</span> <span class="hljs-comment">// 表明对端口是否可重用</span><br>    &#123;<br>        kNoReusePort,<br>        kReusePort,<br>    &#125;;<br><br>    <span class="hljs-built_in">TcpServer</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">const</span> std::string name, Option option = kNoReusePort);<br>    ~<span class="hljs-built_in">TcpServer</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadInitcallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb)</span> </span>&#123; _threadInitCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; _connectionCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp;cb)</span> </span>&#123; _messageCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCommpleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; _writeCompleteCallback = cb; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadNum</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span> </span>&#123; _threadPool-&gt;<span class="hljs-built_in">setThreadNum</span>(numThreads); &#125;<br><br>    <span class="hljs-comment">// 开启服务器监听</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span>;<br><br>    <span class="hljs-keyword">using</span> ConnectionMap = std::unordered_map&lt;std::string, TcpConnectionPtr&gt;;<br><br>    EventLoop *_mainloop;<br>    <span class="hljs-type">const</span> std::string _ipPort;<br>    <span class="hljs-type">const</span> std::string _name;<br><br>    std::unique_ptr&lt;Acceptor&gt; _acceptor;<br>    std::shared_ptr&lt;EventLoopThreadPool&gt; _threadPool; <span class="hljs-comment">// one loop per thread</span><br><br>    ConnectionCallback _connectionCallback;<br>    MessageCallback _messageCallback;<br>    WriteCompleteCallback _writeCompleteCallback;<br><br>    ThreadInitCallback _threadInitCallback;<br><br>    std::atomic_int _started;<br><br>    <span class="hljs-type">int</span> _nextConnId;<br>    ConnectionMap _connections;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们先来看成员变量 : </p><ul><li>_mainloop : 这个mainloop是由用户传入的, 用户会决定何时调用<code>loop.loop();</code>来开启循环.</li><li>_acceptor : 维护listensocketfd对新连接进行监听.</li><li>_threadPool : 维护线程池提供subloop的指针, 在建立TcpConnection时为其轮询挑提供subloop.</li><li>各类回调函数 : 这里主要是用户提供给TcpConnection建立时设置的各种回调.</li><li>_connections : 维护所有建立的连接.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TcpServer.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpServer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> EventLoop *<span class="hljs-title">CheckLoopNotNull</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (loop == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d mainLoop is null!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>TcpServer::<span class="hljs-built_in">TcpServer</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">const</span> std::string name, Option option)<br>    : _mainloop(<span class="hljs-built_in">CheckLoopNotNull</span>(loop))<br>    , _ipPort(listenAddr.<span class="hljs-built_in">toIpPort</span>())<br>    , _name(name)<br>    , _acceptor(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Acceptor</span>(loop, listenAddr, option == kReusePort))<br>    , _threadPool(<span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThreadPool</span>(loop, name))<br>    , _connectionCallback()<br>    , _messageCallback()<br>    , _nextConnId(<span class="hljs-number">1</span>)<br>    , _started(<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">// 当有新用户连接时, 会执行newConnection</span><br>    _acceptor-&gt;<span class="hljs-built_in">setNewConnectionCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::newConnection, <span class="hljs-keyword">this</span>,<br>          std::placeholders::_1, std::placeholders::_2));<br>&#125;<br><br>TcpServer::~<span class="hljs-built_in">TcpServer</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : _connections)<br>    &#123;<br>        <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(item.second)</span></span>; <span class="hljs-comment">// 局部强智能指针对象会自动释放</span><br>        item.second.<span class="hljs-built_in">reset</span>();                <span class="hljs-comment">// 原map中放弃对强指针的使用</span><br><br>        conn-&gt;<span class="hljs-built_in">getLoop</span>()-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestoryed, conn));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_started++ == <span class="hljs-number">0</span>) <span class="hljs-comment">// 防止被重复启动多次</span><br>    &#123;<br>        _threadPool-&gt;<span class="hljs-built_in">start</span>(_threadInitCallback);<br>        _mainloop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::listen, _acceptor.<span class="hljs-built_in">get</span>()));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在TcpServer中具体是轮询找到subLoop, 唤醒该loop</span><br><span class="hljs-comment">// 把sockfd封装成channel加入到subLoop中</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::newConnection</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    EventLoop *subLoop = _threadPool-&gt;<span class="hljs-built_in">getNextLoop</span>();<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">64</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;-%s#%d&quot;</span>, _ipPort.<span class="hljs-built_in">c_str</span>(), _nextConnId);<br>    ++_nextConnId;<br>    std::string connName = _name + buf;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpServer::newConnection [%s] - new connection [%s] from %s \n&quot;</span>,<br>             _name.<span class="hljs-built_in">c_str</span>(), connName.<span class="hljs-built_in">c_str</span>(), peerAddr.<span class="hljs-built_in">toIpPort</span>().<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-comment">// 通过sockfd直接获取绑定的ip+port</span><br>    sockaddr_in local;<br>    <span class="hljs-built_in">bzero</span>(&amp;local, <span class="hljs-keyword">sizeof</span> local);<br>    <span class="hljs-type">socklen_t</span> addrlen = <span class="hljs-keyword">sizeof</span> local;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getsockname</span>(sockfd, (sockaddr *)&amp;local, &amp;addrlen) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;sockets::getLocalAddr&quot;</span>);<br><br>    <span class="hljs-function">InetAddress <span class="hljs-title">localAddr</span><span class="hljs-params">(local)</span></span>;<br><br>    <span class="hljs-comment">// 根据连接成功的sockfd, 创建TcpConnection连接对象</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">conn</span><span class="hljs-params">(<span class="hljs-keyword">new</span> TcpConnection(subLoop, connName, sockfd, localAddr, peerAddr))</span></span>;<br>    <span class="hljs-comment">// 存储连接名字与对应连接的映射</span><br>    _connections[connName] = conn;<br>    <span class="hljs-comment">// 下面的回调都是用户设置给TcpServer的</span><br>    conn-&gt;<span class="hljs-built_in">setConnectionCallback</span>(_connectionCallback);<br>    conn-&gt;<span class="hljs-built_in">setMessageCallback</span>(_messageCallback);<br>    conn-&gt;<span class="hljs-built_in">setWriteCompleteCallback</span>(_writeCompleteCallback);<br>    <span class="hljs-comment">// 设置了如何关闭连接的回调</span><br>    conn-&gt;<span class="hljs-built_in">setCloseCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br>    <span class="hljs-comment">// 直接调用TcpConnection::connectEstablished</span><br>    <span class="hljs-comment">// 代表连接建立成功</span><br>    subLoop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnection</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    _mainloop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpServer::removeConnectionInLoop, <span class="hljs-keyword">this</span>, conn));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpServer::removeConnectionInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> TcpConnectionPtr &amp;conn)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpServer::removeConnectionInLoop [%s] - connection %s\n&quot;</span>,<br>             _name.<span class="hljs-built_in">c_str</span>(), conn-&gt;<span class="hljs-built_in">name</span>().<span class="hljs-built_in">c_str</span>());<br><br>    _connections.<span class="hljs-built_in">erase</span>(conn-&gt;<span class="hljs-built_in">name</span>());<br>    EventLoop *subloop = conn-&gt;<span class="hljs-built_in">getLoop</span>();<br>    subloop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::connectDestoryed, conn));<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源文件来分析成员函数 : </p><ul><li><p>构造函数 : </p><p>接收loop, ip端口, 服务器名, 利用接收到的loop和ip端口直接构造_acceptor, 利用接收到的loop和name直接构造ThreadPool. 这里为 _acceptor中设置了其新连接建立回调函数, 这个函数会在listensocketfd读事件触发时被调用, 回调函数newConnection是TcpServer的核心函数, 我们将会再后面着重讲解.</p></li><li><p>析构函数 : </p><p>这里就是遍历_connections对每个连接进行销毁, 将每个智能指针做完局部变量取出再让原map放弃对该指针的使用, 这样调用对应的connectDestoryed后就会离开作用域自动析构.</p></li><li><p>start : </p><p>调用_threadPool的start, 让其构造出多个线程备用. 调用 _acceptor的listen, 开启对listensocketf的监听.</p></li><li><p>newConnection :</p><p>核心函数, 在_acceptor接收到新连接后调用, 其从 _threadPool中轮询取出一个工作线程, 再将自身的地址取出, 并以此构造出对应的TcpConnection, 然后将用户设置的回调函数再设置到TcpConnection中, 一切设置完毕后, 调用connectEstablished注册其内部 _channel中的读事件以真正开启对socket读事件的监听.</p></li><li><p>removeConnection &#x2F; removeConnectionInLoop : </p><p>先将该连接从_connections中移除,再去调用connectDestoryed.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(5) TcpConnection</title>
    <link href="/2025/04/21/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(5)%20TcpConnection/"/>
    <url>/2025/04/21/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(5)%20TcpConnection/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Buffer 和 TcpConnection 详解</p></blockquote><p>本章我们将学习Buffer类和其上级类TcpConnection, 先了解两个类的职能 : </p><ul><li><p>Buffer</p><p>和通常的缓冲区认知类似, 目的在于提升传入传出的效率, 就是在read中可以提前把数据从内核接收缓冲区中读出, 便于对端再向内核接收缓冲区输入. 在write中可以提前把要写入的数据存进缓冲区, 等待内核发送缓冲区空余.</p></li><li><p>TcpConnection</p><p>专门用来维护每条与客户端的连接的类, 也就是对Acceptor中得到的connfd进行封装, 包括其对应的Socket和Channel类. 并且连接也代表了<strong>有连接的建立与断开, 数据的传入与传出等</strong>活动, 这些活动中, 一部分需要<strong>上级设置的回调函数</strong>来处理(例如连接建立断开, 数据传入, 都需要网络库调用者设置), 一部分需要TcpConnection<strong>利用自己手头的资源自行处理</strong>(例如数据传出, 需要调用自己的send函数). 既然与数据的传入传出有关, 其内部也内置Buffer类来优化传入传出的效率.</p></li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>先看源码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Buffer.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Buffer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kCheapPrepend = <span class="hljs-number">8</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kInitialSize = <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Buffer</span><span class="hljs-params">(<span class="hljs-type">size_t</span> initialSize = kInitialSize)</span></span><br><span class="hljs-function">        : _buffer(kCheapPrepend + initialSize), _readerIndex(kCheapPrepend), _writerIndex(kCheapPrepend)</span><br><span class="hljs-function">    &#123;</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">readableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _writerIndex - _readerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">writableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _buffer.<span class="hljs-built_in">size</span>() - _writerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">prependableBytes</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _readerIndex; &#125;<br>    <span class="hljs-comment">// 返回缓冲区中可读区域的起始地址</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">peek</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _readerIndex; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieve</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (len &lt; <span class="hljs-built_in">readableBytes</span>())<br>            _readerIndex += len; <span class="hljs-comment">// 只读取了可读缓冲区的一部分</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">retrieveAll</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">retrieveAll</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        _readerIndex = _writerIndex = kCheapPrepend; <span class="hljs-comment">// 全读了, 复位</span><br>    &#125;<br>    <span class="hljs-comment">// Buffer -&gt; string</span><br>    <span class="hljs-function">std::string <span class="hljs-title">retrieveAllAsString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">retrieveAsString</span>(<span class="hljs-built_in">readableBytes</span>()); &#125;<br><br>    <span class="hljs-function">std::string <span class="hljs-title">retrieveAsString</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-function">std::string <span class="hljs-title">res</span><span class="hljs-params">(peek(), len)</span></span>;<br>        <span class="hljs-built_in">retrieve</span>(len);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ensureWriteableBytes</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() &lt; len)<br>            <span class="hljs-built_in">makeSpace</span>(len);<br>    &#125;<br><br>    <span class="hljs-comment">// 向缓冲区中追加数据[data, data + len]</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-built_in">ensureWriteableBytes</span>(len);<br>        std::<span class="hljs-built_in">copy</span>(data, data + len, <span class="hljs-built_in">beginWrite</span>());<br>        _writerIndex += len;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">beginWrite</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _writerIndex; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">beginWrite</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">begin</span>() + _writerIndex; &#125;<br><br>    <span class="hljs-comment">// 从fd上读取数据, Poller工作在LT模式</span><br>    <span class="hljs-comment">// Buffer缓冲区是有大小的, 但从fd上读数据时却不知道tcp数据最终的大小</span><br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">writeFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;*_buffer.<span class="hljs-built_in">begin</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> &amp;*_buffer.<span class="hljs-built_in">begin</span>(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeSpace</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 后面真正可写的 + 前面读出来空余的 &lt; 要求的大小</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">writableBytes</span>() + _readerIndex &lt; len + kCheapPrepend)<br>            _buffer.<span class="hljs-built_in">resize</span>(_writerIndex + len);<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// 如果够, 把后面未读的移到前面, 给后面空出来</span><br>        &#123;<br>            <span class="hljs-type">size_t</span> readable = <span class="hljs-built_in">readableBytes</span>();<br>            std::<span class="hljs-built_in">copy</span>(<span class="hljs-built_in">begin</span>() + _readerIndex, <span class="hljs-built_in">begin</span>() + _writerIndex, <span class="hljs-built_in">begin</span>() + kCheapPrepend);<br>            _readerIndex = kCheapPrepend;<br>            _writerIndex = kCheapPrepend + readable;<br>        &#125;<br>    &#125;<br><br>    std::vector&lt;<span class="hljs-type">char</span>&gt; _buffer;<br>    <span class="hljs-type">size_t</span> _readerIndex;<br>    <span class="hljs-type">size_t</span> _writerIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Buffer.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::readFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> extrabuf[<span class="hljs-number">65536</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 栈上的内存空间 64k</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> vec[<span class="hljs-number">2</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> writable = <span class="hljs-built_in">writableBytes</span>();<br>    vec[<span class="hljs-number">0</span>].iov_base = <span class="hljs-built_in">begin</span>() + _writerIndex;<br>    vec[<span class="hljs-number">0</span>].iov_len = writable;<br>    vec[<span class="hljs-number">1</span>].iov_base = extrabuf;<br>    vec[<span class="hljs-number">1</span>].iov_len = <span class="hljs-keyword">sizeof</span> extrabuf;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> iovcnt = (writable &lt; <span class="hljs-keyword">sizeof</span> extrabuf) ? <span class="hljs-number">2</span> : <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 在非连续的区块中依次写入同一个fd传入的信息</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">ssize_t</span> n = ::<span class="hljs-built_in">readv</span>(fd, vec, iovcnt);<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>        *saveErrno = errno;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt;= writable) <span class="hljs-comment">// 已经够了不需要扩容</span><br>    &#123;<br>        _writerIndex += n;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// extrabuf中也写入了数据, 需要扩容加进去</span><br>    &#123;<br>        _writerIndex = _buffer.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-built_in">append</span>(extrabuf, n - writable);<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">Buffer::writeFd</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> *saveErrno)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = ::<span class="hljs-built_in">write</span>(fd, <span class="hljs-built_in">peek</span>(), <span class="hljs-built_in">readableBytes</span>());<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        *saveErrno = errno;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看成员变量 : </p><ul><li><p>_buffer : 用vector存储数据, 便于扩容.</p></li><li><p>_readerIndex &#x2F; _writerIndex : </p><p>这两个参数标定了可读区域和可写区域的大小. 想要理解这两个参数, 需要理解Buffer中对_buffer的划分 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">|&lt;---- prependable ----&gt;|&lt;---- readable ----&gt;|&lt;---- writable ----&gt;|<br>|-----------------------|--------------------|--------------------|<br>^                        ^                    ^                     <br><span class="hljs-built_in">begin</span>()           _readerIndex          _writerIndex         <br></code></pre></td></tr></table></figure><ul><li>prependable : 前置空余区域, 当我们发送消息时, 如果向要加一些报头之类的信息, 可以便于向其中填入, 在Muduo库中作用不大.</li><li>readable : 已经有数据存入的部分, 如果当前要读出, 则这部分是可读部分, 如果当前要写入, 则这部分是已填充完毕的区域.</li><li>writeable : 还没有数据的部分, 如果当前要读入, 则这部分是空余空间, 如果当前要写入, 则这部分是可以继续写入的部分.</li></ul><p>我们可以看出Buffer既可以处理read也可以处理write, 其对应的readable和writeable区域也有不同的作用. 在TcpConnection就封装了两个Buffer, _inputBuffer和 _outputBuffer, 共同处理了缓冲任务.</p></li></ul><p>再看成员函数 :</p><ul><li><p>readable&#x2F;writable&#x2F;prependableBytes : 返回对应区域的字节数大小.</p></li><li><p>begin : 返回_buffer的首元素地址.</p></li><li><p>peek :  返回缓冲区中可读区域的起始地址.</p></li><li><p>makespace :</p><p>扩容函数, 确保_buffer有参数len的大小使write成功, 如果可写的空间不够就扩容, 够用就经过调整把前面的空余和后面的空余合并一块放在后面.</p></li><li><p>retrieve &#x2F; retrieveAll :</p></li></ul><p>​这个函数一般会在下面的retrieveAsString中使用, 或是调用readfd&#x2F;writefd后使用, 用来进行两个Index的置位.</p><ul><li><p>retrieveAsString &#x2F; retrieveAllAsString : </p><p><strong>从_buffer中读出数据的函数</strong>, 这个函数会将可读区域中len长度的数据当作string读出来, 并在调用retrieve后返回, 通常被客户用来从Buffer中直接读出接收到的数据.</p></li><li><p>ensureWriteableBytes : 对makeSpace的调用.</p></li><li><p>append :</p><p><strong>从_buffer中追加数据的函数</strong>, 向缓冲区中追加数据[data, data + len], 空间不够时会调用ensureWriteableBytes.</p></li><li><p>readFd : </p><p>核心函数, 目的是<strong>高效从一个fd上读取传来的数据到 _buffer 中</strong>, 其高效在于使用到了readv函数, 这个函数不细讲, 不知道可以去查, 简单来说就是就是其实现了<strong>在非连续的区块中依次写入同一个fd传入的信息</strong>, 函数中划分了两块区域, 一块是 _buffer的可写区域, 一块是我们在栈上开辟的64K临时空间, readv可以实现先向可写区域中写, 可写区域写满了再读入我们开辟的临时空间, 读完后加入临时空间有读入, 我们再用append加进去就行, 这样实现了灵活应对读入不同大小的情况.</p></li><li><p>writeFd : </p><p>这个就比较简单了, 因为网络输出缓冲区就一个, 就不需要考虑writev的使用, 直接调用write从Buffer中将有数据的部分发送出去即可.</p></li></ul><h2 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h2><blockquote><p>专门用来维护每条与客户端的连接的类, 也就是对Acceptor中得到的connfd进行封装, 包括其对应的Socket和Channel类. 并且连接也代表了<strong>有连接的建立与断开, 数据的传入与传出等</strong>活动, 这些活动中, 一部分需要<strong>上级设置的回调函数</strong>来处理(例如连接建立断开, 数据传入, 都需要网络库调用者设置), 一部分需要TcpConnection<strong>利用自己手头的资源自行处理</strong>(例如数据传出, 需要调用自己的send函数). 既然与数据的传入传出有关, 其内部也内置Buffer类来优化传入传出的效率.</p></blockquote><p>通过上文我们的对TcpConnection的描述, 我们可以将其分为以下几个功能模块 : </p><ul><li>构造 &#x2F; 析构函数</li><li>TcpServer对TcpConnection设置连接建立回调, 断开回调, 消息回调等, 正式开启&#x2F;关闭连接.</li><li>TcpConnection对自己负责的connfd相关联的Channel类设置读&#x2F;写&#x2F;关闭&#x2F;错误回调.</li><li>用户发送信息所调用的send函数, 手动关闭连接所调用的shutdown函数.</li></ul><p>让我们先分析头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Callbacks.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Buffer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span>;<br><br><span class="hljs-comment">// TcpServer -&gt; Acceptor -&gt; 新连接 -&gt; accept得到connfd -&gt; 打包回调到TcpConnection</span><br><span class="hljs-comment">// -&gt; 回调设置给Channel -&gt; Poller -&gt; Channel的回调操作</span><br><br><span class="hljs-comment">// 各种回调函数 : 用户 -&gt; TcpServer -&gt; TcpConnection -&gt; Channel</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpConnection</span> : UnCopyable, <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TcpConnection&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TcpConnection</span>(EventLoop *loop, <span class="hljs-type">const</span> std::string name, <span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;LocalAddr, <span class="hljs-type">const</span> InetAddress &amp;peerAddr);<br>    ~<span class="hljs-built_in">TcpConnection</span>();<br><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">getLoop</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _loop; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> InetAddress &amp;<span class="hljs-title">localAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _localAddr; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> InetAddress &amp;<span class="hljs-title">peerAddress</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _peerAddr; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">connected</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _state == kConnected; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> ConnectionCallback &amp;cb)</span> </span>&#123; _connectionCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setMessageCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> MessageCallback &amp;cb)</span> </span>&#123; _messageCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCompleteCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> WriteCompleteCallback &amp;cb)</span> </span>&#123; _writeCompleteCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHighWaterMarkCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> HighWaterMarkCallback &amp;cb)</span> </span>&#123; _highWaterMarkCallback = cb; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> CloseCallback &amp;cb)</span> </span>&#123; _closeCallback = cb; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectEstablished</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 连接建立</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">connectDestoryed</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 连接销毁</span><br><br>    <span class="hljs-comment">// 发送数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">send</span><span class="hljs-params">(std::string buf)</span></span>;<br>    <span class="hljs-comment">// 关闭Tcp连接</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleWrite</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleClose</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *message, <span class="hljs-type">size_t</span> len)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownInLoop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">StateE</span><br>    &#123;<br>        kDisconnected,<br>        kConnecting,<br>        kConnected,<br>        kDisconnecting<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(StateE state)</span> </span>&#123; _state = state; &#125;<br><br>    EventLoop *_loop; <span class="hljs-comment">// 这里只会是subLoop</span><br>    <span class="hljs-type">const</span> std::string _name;<br>    std::atomic_int _state;<br>    <span class="hljs-type">bool</span> _reading;<br>    <span class="hljs-comment">// 管理的_socket / _channel</span><br>    std::unique_ptr&lt;Socket&gt; _socket;<br>    std::unique_ptr&lt;Channel&gt; _channel;<br><br>    <span class="hljs-type">const</span> InetAddress _localAddr; <span class="hljs-comment">// 主机addr</span><br>    <span class="hljs-type">const</span> InetAddress _peerAddr;  <span class="hljs-comment">// 对端客户addr</span><br>    <span class="hljs-comment">// 回调</span><br>    ConnectionCallback _connectionCallback;<br>    MessageCallback _messageCallback;<br>    WriteCompleteCallback _writeCompleteCallback;<br>    HighWaterMarkCallback _highWaterMarkCallback;<br>    CloseCallback _closeCallback;<br>    <span class="hljs-type">size_t</span> _highWaterMark;<br>    <span class="hljs-comment">// 缓冲区</span><br>    Buffer _inputBuffer;<br>    Buffer _outputBuffer;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里先介绍一下公开继承enable_shared_from_this的作用 : </p><p>其可以让继承其的类的成员函数可以调用shared_from_this()函数, 作用是返回当前类对象的智能指针封装, 也就是把this指针包到智能指针中再传出来, 所以使用他的原因主要是TcpConnection对象可能随使销毁, 传出的this指针随时可能失效, 但如果我们本身传出的就是智能指针, 就可以有效防止提前销毁.</p><p>了解一下成员变量 : </p><ul><li>_loop : 这里保存自己所在subLoop的指针, 是为了将需要调用的函数加入到事件循环中.</li><li>_state : 用来记录一个连接的各种状态, 状态同一时间只能有一种, 所以是atomic类型.</li><li>_socket &#x2F; _channel : 将Acceptor接收到的connfd封装为Socket和Channel.</li><li>…Callback : 各种有关于连接的事件回调.</li><li>_inputBuffer &#x2F; _outputBuffer : 分别处理TcpConnection的消息接受和发送.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TcpConnection.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-comment">// 为什么用static可防止名字冲突</span><br><span class="hljs-function"><span class="hljs-type">static</span> EventLoop *<span class="hljs-title">CheckLoopNotNull</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (loop == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d mainLoop is null!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>TcpConnection::<span class="hljs-built_in">TcpConnection</span>(EventLoop *loop, <span class="hljs-type">const</span> std::string name, <span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;localAddr, <span class="hljs-type">const</span> InetAddress &amp;peerAddr)<br>    : _loop(<span class="hljs-built_in">CheckLoopNotNull</span>(loop)), _name(name), _state(kConnecting), _reading(<span class="hljs-literal">true</span>), _socket(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Socket</span>(sockfd)), _channel(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Channel</span>(loop, sockfd)), _localAddr(localAddr), _peerAddr(peerAddr), _highWaterMark(<span class="hljs-number">64</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>) <span class="hljs-comment">// 64MB</span><br>&#123;<br>    <span class="hljs-comment">// 把回调设置进channel, TcpConnection有一套自己的回调函数</span><br>    _channel-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="hljs-keyword">this</span>, std::placeholders::_1));<br>    _channel-&gt;<span class="hljs-built_in">setWriteCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="hljs-keyword">this</span>));<br>    _channel-&gt;<span class="hljs-built_in">setCloseCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="hljs-keyword">this</span>));<br>    _channel-&gt;<span class="hljs-built_in">setErrorCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::handleError, <span class="hljs-keyword">this</span>));<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;TcpConnection::ctor[%s] at fd=%d\n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), sockfd);<br>    _socket-&gt;<span class="hljs-built_in">setKeepAlive</span>(<span class="hljs-literal">true</span>);<br>&#125;<br><br>TcpConnection::~<span class="hljs-built_in">TcpConnection</span>()<br>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;Tcpconnection::dtor[%s] at fd=%d state=%d \n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), _channel-&gt;<span class="hljs-built_in">fd</span>(), (<span class="hljs-type">int</span>)_state);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleRead</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">ssize_t</span> n = _inputBuffer.<span class="hljs-built_in">readFd</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 有可读事件发生, 调用用户传入的回调操作</span><br>        _messageCallback(<span class="hljs-built_in">shared_from_this</span>(), &amp;_inputBuffer, receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">handleClose</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        errno = savedErrno;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleRead&quot;</span>);<br>        <span class="hljs-built_in">handleError</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleWrite</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_channel-&gt;<span class="hljs-built_in">isWriting</span>())<br>    &#123;<br>        <span class="hljs-type">int</span> savedErrno = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">ssize_t</span> n = _outputBuffer.<span class="hljs-built_in">writeFd</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), &amp;savedErrno);<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            _outputBuffer.<span class="hljs-built_in">retrieve</span>(n);<br>            <span class="hljs-keyword">if</span> (_outputBuffer.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>) <span class="hljs-comment">// 已经发送完成</span><br>            &#123;<br>                _channel-&gt;<span class="hljs-built_in">disableWriting</span>();<br>                <span class="hljs-keyword">if</span> (_writeCompleteCallback)<br>                &#123;<br>                    _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_writeCompleteCallback, <span class="hljs-built_in">shared_from_this</span>()));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (_state == kDisconnecting)<br>                &#123;<br>                    <span class="hljs-built_in">shutdownInLoop</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleWrite&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection fd=%d is down, no more writing&quot;</span>, _channel-&gt;<span class="hljs-built_in">fd</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleClose</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;fd=%d state=%d \n&quot;</span>, _channel-&gt;<span class="hljs-built_in">fd</span>(), (<span class="hljs-type">int</span>)_state);<br>    <span class="hljs-built_in">setState</span>(kDisconnected);<br>    _channel-&gt;<span class="hljs-built_in">disableAll</span>();<br><br>    <span class="hljs-comment">// 获取当前的Connention对象</span><br>    <span class="hljs-function">TcpConnectionPtr <span class="hljs-title">connPtr</span><span class="hljs-params">(shared_from_this())</span></span>;<br>    _connectionCallback(connPtr);<br>    _closeCallback(connPtr); <span class="hljs-comment">// 关闭连接, 执行TcpServer::removeConnection</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::handleError</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-type">socklen_t</span> optlen = <span class="hljs-keyword">sizeof</span> op;<br>    <span class="hljs-type">int</span> err = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getsockopt</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), SOL_SOCKET, SO_ERROR, &amp;op, &amp;optlen) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        err = errno;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        err = op;<br><br>    <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::handleErrno name:%s - SO_ERROR:%d \n&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), err);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectEstablished</span><span class="hljs-params">()</span> <span class="hljs-comment">// 连接建立</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">setState</span>(kConnected);<br>    <span class="hljs-comment">// 把自己的指针传给负责的channel, 让其知晓自己的存在状态</span><br>    <span class="hljs-comment">// 防止上层TcpConnection析构后下层channel依旧运行</span><br>    <span class="hljs-comment">// 根本原因是TcpConnection要给到用户手里, 不确定何时析构</span><br>    _channel-&gt;<span class="hljs-built_in">tie</span>(<span class="hljs-built_in">shared_from_this</span>());<br>    _channel-&gt;<span class="hljs-built_in">enableReading</span>(); <span class="hljs-comment">// 注册Channel读事件</span><br><br>    <span class="hljs-comment">// 新连接已经建立, 执行连接建立回调</span><br>    _connectionCallback(<span class="hljs-built_in">shared_from_this</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::connectDestoryed</span><span class="hljs-params">()</span> <span class="hljs-comment">// 连接销毁</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnected);<br>        _channel-&gt;<span class="hljs-built_in">disableAll</span>();<br>        _connectionCallback(<span class="hljs-built_in">shared_from_this</span>());<br>    &#125;<br>    _channel-&gt;<span class="hljs-built_in">remove</span>();<br>&#125;<br><br><span class="hljs-comment">// 发送数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::send</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string buf)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_loop-&gt;<span class="hljs-built_in">isInLoopThread</span>())<br>        &#123;<br>            <span class="hljs-built_in">sendInLoop</span>(buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">size</span>());<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            _loop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::sendInLoop, <span class="hljs-keyword">this</span>, buf.<span class="hljs-built_in">c_str</span>(), buf.<span class="hljs-built_in">size</span>()));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 发送数据时, 应用写的快, 而内核发送数据慢, 需要把待发送的数据写入缓冲区并设置水位回调</span><br><span class="hljs-comment">// 该函数实现对写事件的缓冲</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::sendInLoop</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *data, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">ssize_t</span> nwrite = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">size_t</span> remaining = len;<br>    <span class="hljs-type">bool</span> faultError = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 之前调用过shutdown</span><br>    <span class="hljs-keyword">if</span> (_state == kDisconnected)<br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;disconnected, give up writing!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// _channel第一次开始写数据, 并且缓冲区没有待发送数据</span><br>    <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>() &amp;&amp; _outputBuffer.<span class="hljs-built_in">readableBytes</span>() == <span class="hljs-number">0</span>)<br>    &#123;<br>        nwrite = ::<span class="hljs-built_in">write</span>(_channel-&gt;<span class="hljs-built_in">fd</span>(), data, len);<br>        <span class="hljs-keyword">if</span> (nwrite &gt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            remaining = len - nwrite;<br>            <span class="hljs-comment">// 如果已经直接发送完了, 不需要缓冲, 如果有设置写入完成回调就触发</span><br>            <span class="hljs-keyword">if</span> (remaining == <span class="hljs-number">0</span> &amp;&amp; _writeCompleteCallback)<br>                _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_writeCompleteCallback, <span class="hljs-built_in">shared_from_this</span>()));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">// nwrote &lt; 0</span><br>        &#123;<br>            nwrite = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (errno != EWOULDBLOCK)<br>            &#123;<br>                <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;TcpConnection::sendInLoop&quot;</span>);<br>                <span class="hljs-keyword">if</span> (errno == EPIPE || errno == ECONNRESET)<br>                    faultError = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 一次write并没有一次发送出去, 需要保存到缓冲区</span><br>    <span class="hljs-comment">// 要给channel设置epollout事件, poller发现tcp发送缓冲区有空间</span><br>    <span class="hljs-comment">// 调用writeCallback -&gt; handleWrite, 把发送缓冲区的数据全部发送完成</span><br>    <span class="hljs-keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 目前发送缓冲区剩余的待发送数据长度</span><br>        <span class="hljs-type">size_t</span> oldlen = _outputBuffer.<span class="hljs-built_in">readableBytes</span>();<br>        <span class="hljs-keyword">if</span> (oldlen + remaining &gt;= _highWaterMark &amp;&amp; oldlen &lt; _highWaterMark &amp;&amp; _highWaterMark)<br>            _loop-&gt;<span class="hljs-built_in">queueInLoop</span>(std::<span class="hljs-built_in">bind</span>(_highWaterMarkCallback, <span class="hljs-built_in">shared_from_this</span>(), oldlen + remaining));<br>        _outputBuffer.<span class="hljs-built_in">append</span>((<span class="hljs-type">char</span> *)data + nwrite, remaining);<br>        <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>())<br>        &#123;<br>            _channel-&gt;<span class="hljs-built_in">enableWriting</span>(); <span class="hljs-comment">// 注册channel的写事件, 否则poller不会给channel通知EPOLLOUT,</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 关闭Tcp连接</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdown</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_state == kConnected)<br>    &#123;<br>        <span class="hljs-built_in">setState</span>(kDisconnecting);<br>        _loop-&gt;<span class="hljs-built_in">runInLoop</span>(std::<span class="hljs-built_in">bind</span>(&amp;TcpConnection::shutdownInLoop, <span class="hljs-keyword">this</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">TcpConnection::shutdownInLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!_channel-&gt;<span class="hljs-built_in">isWriting</span>()) <span class="hljs-comment">// 说明发送缓冲区已经全部发送完成</span><br>    &#123;<br>        _socket-&gt;<span class="hljs-built_in">shutdownWrite</span>(); <span class="hljs-comment">// 关闭写端</span><br>        <span class="hljs-comment">// 之后poller会通知channel触发_closeCallback, 会触发TcpConnection中的handleClose</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配合源文件来分析成员函数 : </p><ul><li><p>构造函数 :</p><p>掌握一个不为空的loop指针, 利用传进的connfd构造_socket和 _channel. 随后设置 _channel的读写关闭错误回调, 就像Acceptor对 listensocketfd 设置读事件回调一样, 普通连接connfd四种事件都要关注, 所以我们四种事件都设置回调, 而回调函数分别是下面的handleRead&#x2F;Write&#x2F;Colse&#x2F;Error.</p></li><li><p>handleRead :</p><p>当connfd的读事件触发时, 会触发该函数, 向 _inputBuffer中读入数据, 然后调用TcpServer设置的消息回调函数, 这个回调函数中一般会调用retrieveAsString从 _inputBuffer中读出数据然后进行客户希望的处理.</p></li><li><p>handleWrite : </p><p>当connfd的读事件触发时, 说明对端可写, 从_outputBuffer中读出所有或部分向对端写入, 如果全写了, 就取消对 _channel的写事件关心然后调用写完回调(如果有的话); 如果没写完就不做处理.</p></li><li><p>handleClose :</p><p>当我们关闭connfd的写端时, 就会默认触发EPOLLHUP事件, 进而调用该函数, 取消_channel对所有事件的关心, 然后调用连接建立&#x2F;断开回调.</p></li><li><p>connectEstablished : </p><p>这个函数用来开启_channel读事件的关注, 也就是说在这之后就可以读connfd上传来的信息了. 至于为什么单独分出一个函数处理, 原因是在TcpConntion对象在TcpServer中创建后不能直接开启读事件, 还要进行回调函数的设置和数据处理, 在这些准备工作都做完后才可以真正开启读事件.</p></li><li><p>connectDestoryed : </p><p>这个函数用于在最后销毁连接并移除_channel, 属于销毁链路的最后一环, 由TcpServer在合适时机调用, 我们可以在后面的shutdownInLoop中有更深的认识.</p></li><li><p>send : </p><p>这个函数是提供给用户调用的, 所以调用时不一定在当前线程, 所以需要判断是否换线程.</p></li><li><p>sendInLoop : </p><p>前面handleWrite函数是在写事件触发时从_outputBuffer中读取数据, 那么这个函数就是直接发送或将要发送的数据写入 _outputBuffer.</p><p>首先如果_channel第一次开始写数据, 并且缓冲区没有待发送数据, 就直接先写一部分, 最后如果还是没写完, 说明对端接收缓冲区已经满了, 就追加到 _outputBuffer中, 再关注读事件, 那么当对端接收缓冲区可写时就会调用handleWrite从 _outputBuffer中读取数据.</p></li><li><p>shutdown : </p><p>这个函数也是提供给用户调用的, 需要判断换线程.</p></li><li><p>shutdownInLoop : </p><p>这里操作很简单, 关闭connfd写端就行, 主要是了解其中的连锁反应 : </p><p>关闭写端 -&gt; 触发EPOLLHUP -&gt; _channel调用handleClose -&gt; handleClose调用TcpServer设置的回调函数 -&gt; TcpServer设置的回调函数再调用TcpConnection中的connectDestoryed.</p><p>这样一看这个过程非常繁琐, 其主要是为了让TcpServer可以及时对关闭的连接进行反应并修改内部资源.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库源码剖析(4) Acceptor</title>
    <link href="/2025/04/17/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(4)%20Acceptor/"/>
    <url>/2025/04/17/Muduo%E5%BA%93%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90(4)%20Acceptor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Socket + Acceptor 详解</p></blockquote><p>本章我们将学习Socket类和Acceptor类, 首先应当明确其在Muduo库中的职责所在 : </p><ul><li><p>Socket就是对原生socketAPI的封装, 供Acceptor使用. </p></li><li><p>Acceptor简单来说是用来处理新连接的建立的. 我们来认识一下Acceptor的调用流程</p><p>TcpServer中会维护一个Acceptor作为成员变量, 由TcpServer向Acceptor设置建立新连接的回调函数, Acceptor则内含一个Socket和一个Channel, 其利用Socket维护listensocketfd, 控制listen的时机, 也利用Channel让Poller帮自己监听listensocketfd上的读事件, 设置的读事件回调就会调用accept获取新连接的connfd, 然后利用得到的connfd去调用TcpServer传入的回调函数, 让TcpServer帮自己处理新连接事务.</p></li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Socket.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Socket</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Socket</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd)</span> : _sockfd(sockfd) &#123;</span>&#125;<br>    ~<span class="hljs-built_in">Socket</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _sockfd; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress &amp;localaddr)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(InetAddress *peeraddr)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">shutdownWrite</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> _sockfd;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Socket.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;strings.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><br>Socket::~<span class="hljs-built_in">Socket</span>()<br>&#123;<br>    ::<span class="hljs-built_in">close</span>(_sockfd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::bindAddress</span><span class="hljs-params">(<span class="hljs-type">const</span> InetAddress &amp;localaddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ::<span class="hljs-built_in">bind</span>(_sockfd, (sockaddr *)localaddr.<span class="hljs-built_in">getSockAddr</span>(), <span class="hljs-built_in">sizeof</span>(sockaddr_in)))<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;bind sockfd:%d fail \n&quot;</span>, _sockfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::listen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != ::<span class="hljs-built_in">listen</span>(_sockfd, <span class="hljs-number">1024</span>))<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;listen sockfd:%d fail \n&quot;</span>, _sockfd);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Socket::accept</span><span class="hljs-params">(InetAddress *peeraddr)</span></span><br><span class="hljs-function"></span>&#123;<br>    sockaddr_in addr;<br>    <span class="hljs-built_in">bzero</span>(&amp;addr, <span class="hljs-keyword">sizeof</span> addr);<br>    <span class="hljs-function"><span class="hljs-type">socklen_t</span> <span class="hljs-title">len</span><span class="hljs-params">(<span class="hljs-keyword">sizeof</span> addr)</span></span>;<br>    <span class="hljs-comment">// accept4可以直接给接受到的sockfd设置选项(非阻塞)</span><br>    <span class="hljs-type">int</span> connfd = ::<span class="hljs-built_in">accept4</span>(_sockfd, (sockaddr *)&amp;addr, &amp;len, SOCK_CLOEXEC | SOCK_NONBLOCK);<br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        peeraddr-&gt;<span class="hljs-built_in">setSockAddr</span>(addr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> connfd;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::shutdownWrite</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ::<span class="hljs-built_in">shutdown</span>(_sockfd, SHUT_WR);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setTcpNoDelay</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, IPPROTO_TCP, TCP_NODELAY, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setReuseAddr</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setReusePort</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_REUSEPORT, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Socket::setKeepAlive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> op = on ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    ::<span class="hljs-built_in">setsockopt</span>(_sockfd, SOL_SOCKET, SO_KEEPALIVE, &amp;op, <span class="hljs-keyword">sizeof</span> op);<br>&#125;<br></code></pre></td></tr></table></figure><p>外部通过socket函数将listensocketfd传入Socket, 将其维护在Socket内, 便于简便的调用bind &#x2F; listen &#x2F; accept.</p><h2 id="Acceptor"><a href="#Acceptor" class="headerlink" title="Acceptor"></a>Acceptor</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Socket.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;InetAddress.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> NewConnectionCallback = std::function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> InetAddress &amp;)&gt;;<br><br>    <span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport);<br>    ~<span class="hljs-built_in">Acceptor</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNewConnectionCallback</span><span class="hljs-params">(<span class="hljs-type">const</span> NewConnectionCallback &amp;cb)</span> </span>&#123; _newConnectionCallback = <span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">listenning</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _listenning; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">listen</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;<br><br>    EventLoop *_loop;<span class="hljs-comment">// 用来标注这个Acceptor属于的mainLoop</span><br>    Socket _acceptSocket;<span class="hljs-comment">// 存储listensocketfd</span><br>    Channel _acceptChannel;<span class="hljs-comment">// 对listensocketfd进行封装的Channel, 便于注册读事件</span><br>    NewConnectionCallback _newConnectionCallback;<span class="hljs-comment">// TcpServer给其设置的新连接回调函数</span><br>    <span class="hljs-type">bool</span> _listenning;<span class="hljs-comment">// 是否正在监听</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Acceptor.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Accept.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">createNonblocking</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;%s:%s:%d listen socket create error:%d&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);<br>    &#125;<br>    <span class="hljs-keyword">return</span> sockfd;<br>&#125;<br><br><span class="hljs-comment">// 创建socket, 封装进Channel, 往当前loop的poller中添加</span><br>Acceptor::<span class="hljs-built_in">Acceptor</span>(EventLoop *loop, <span class="hljs-type">const</span> InetAddress &amp;listenAddr, <span class="hljs-type">bool</span> reuseport)<br>    : _loop(loop), _acceptSocket(()), _acceptChannel(loop, _acceptSocket.<span class="hljs-built_in">fd</span>()), _listenning(<span class="hljs-literal">false</span>)<br>&#123;<br>    _acceptSocket.<span class="hljs-built_in">setReuseAddr</span>(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (reuseport)<br>        _acceptSocket.<span class="hljs-built_in">setReusePort</span>(<span class="hljs-literal">true</span>);<br>    _acceptSocket.<span class="hljs-built_in">bindAddress</span>(listenAddr);<br><br>    <span class="hljs-comment">// 一旦有一个新用户的连接, 就需要执行回调, connfd -&gt; channel -&gt; subloop</span><br>    <span class="hljs-comment">// 具体回调由TcpServer给出</span><br>    _acceptChannel.<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;Acceptor::handleRead, <span class="hljs-keyword">this</span>));<br>&#125;<br>Acceptor::~<span class="hljs-built_in">Acceptor</span>()<br>&#123;<br>    _acceptChannel.<span class="hljs-built_in">disableAll</span>();<br>    _acceptChannel.<span class="hljs-built_in">remove</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::listen</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _listenning = <span class="hljs-literal">true</span>;<br>    _acceptSocket.<span class="hljs-built_in">listen</span>();<br>    _acceptChannel.<span class="hljs-built_in">enableReading</span>(); <span class="hljs-comment">// 把acceptChannel注册到poller中监听读事件</span><br>&#125;<br><br><span class="hljs-comment">// 在listenfd读事件触发时调用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Acceptor::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    InetAddress peerAddr;<br>    <span class="hljs-type">int</span> connfd = _acceptSocket.<span class="hljs-built_in">accept</span>(&amp;peerAddr);<br>    <span class="hljs-keyword">if</span> (connfd &gt;= <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">// 在TcpServer中具体是轮询找到subLoop, 唤醒该loop, 将该sockfd分发到其中</span><br>        <span class="hljs-keyword">if</span> (_newConnectionCallback)<br>            _newConnectionCallback(connfd, peerAddr);<br>        <span class="hljs-keyword">else</span><br>            ::<span class="hljs-built_in">close</span>(connfd);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:%s:%d accept error:%d&quot;</span>, __FILE__, __FUNCTION__, __LINE__, errno);<br>        <span class="hljs-keyword">if</span> (errno == EMFILE)<br>        &#123;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;%s:%s:%d sockfd reached limit!&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>createNonblocking : 我们可以看到这个函数在Accept构造函数中被调用, 也就是说在Acceptor构造时会调用该函数构造一个非阻塞的listensocketfd.</li><li>构造函数 : 首先是调用createNonblocking构造出listensocketfd存入Socket, 随后将listensocketfd封装进Channel, 接下来设置Socket中fd的各种属性并bind, 最后将handleRead读事件回调注册进Channel.</li><li>listen : 该函数控制何时开始监听listensocketfd并注册读事件, 一般由上层TcpServer控制.</li><li>handleRead : listensocketfd封装的Channel将被放到mainLoop的Poller中监听读事件, 而触发的回调就是该函数, handleRead将调用accept获取新连接的connfd, 随后将其传给TcpServer设置的回调函数.</li></ul><p>为什么要调用TcpServer的新连接回调呢? 因为Acceptor的职责仅仅在于构造listensocketfd和对新连接及时做出反应并报告给TcpServer, TcpServer才是真正处理新连接的核心, 其拥有的资源远超过Acceptor(例如线程池), 有了这些资源才能真正处理新连接.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(3) ThreadPool</title>
    <link href="/2025/04/16/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(3)%20ThreadPool/"/>
    <url>/2025/04/16/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(3)%20ThreadPool/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ThreadPool相关</p></blockquote><p>本章我们将把EventLoop和C++11的thread结合, 实现Thread &#x2F; EventLoopThread &#x2F; EventLoopThreadPool. </p><p>首先我们应当明晰将创建的三个类的意义何在 : </p><ul><li><p>Thread : 这是对thread库的封装, 会增加对各种线程运行状态与数据的维护.</p></li><li><p>EventLoopThread :</p><p>将Thread和EventLoop组合, 真正实现 <strong>one loop per thread</strong> 思想的地方, 最终达成的效果就是创建一个线程并在线程中创建一个loop并运行该loop.</p></li><li><p>EventLoopThreadPool : </p><p>学到这里线程池的作用应该都知道, 就是提前创建线程以减少运行开销, 这里就是开一个池填充EventLoopThread, 我们最后的TcpServer中就会维护这样一个线程池存放subLoop.</p></li></ul><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>对C++11的thread库封装 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 一个Thread对象记录的就是一个新线程的详细信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadFunc = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> std::string &amp;name = std::string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _tid; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">bool</span> _joined;<br>    std::shared_ptr&lt;std::thread&gt; _thread;<br>    <span class="hljs-type">pid_t</span> _tid;<br>    ThreadFunc _func;<br>    std::string _name;<br>    <span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated; <span class="hljs-comment">// 记录产生的线程个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br>std::atomic_int Thread::_numCreated(<span class="hljs-number">0</span>);<br><br>Thread::<span class="hljs-built_in">Thread</span>(ThreadFunc func, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _started(<span class="hljs-literal">false</span>), _joined(<span class="hljs-literal">false</span>), _tid(<span class="hljs-number">0</span>), _func(std::<span class="hljs-built_in">move</span>(func)), _name(name)<br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br>Thread::~<span class="hljs-built_in">Thread</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_started &amp;&amp; !_joined)<br>        _thread-&gt;<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">sem_t</span> sem;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>    _thread = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;([<span class="hljs-keyword">this</span>, &amp;sem]()&#123;<br>        _tid = CurrentThread::<span class="hljs-built_in">tid</span>();<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<br>        _func(); <br>    &#125;);<br>    <span class="hljs-comment">// 确保子线程tid已经确定</span><br>    <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _joined = <span class="hljs-literal">true</span>;<br>    _thread-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = ++_numCreated;<br>    <span class="hljs-keyword">if</span> (_name.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        _name = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行封装的主要目的除了进行信息记录之外, 就是可以<strong>控制创建线程的时机</strong>. 对于C++11thread库中的thread类来说, 只要创建出对象就代表了线程开启, 这样就没有进行初始化准备的时间了, 我们在封装中用智能指针维护thread类, 在start中才真正传入回调函数并创建thread对象开启线程.</p><p>这里还需要注意的一点就是为了在Thread对象中维护线程的tid, 需要使用条件变量进行线程间通信, 以获取到创建线程的tid并存储在Thread对象中.</p><p>这里补充一下CurrentThread类, 其可以获取当前线程的tid, 在上一章的EventLoop中也有使用过, 用来判断是不是当前进程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// CurrentThread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">namespace</span> CurrentThread<br>&#123;<br>    <span class="hljs-keyword">extern</span> __thread <span class="hljs-type">int</span> t_cachedTid;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cacheTid</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (__builtin_expect(t_cachedTid == <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))<br>            <span class="hljs-built_in">cacheTid</span>();<br>        <span class="hljs-keyword">return</span> t_cachedTid;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// CurrentThread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/syscall.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> CurrentThread<br>&#123;<br>    __thread <span class="hljs-type">int</span> t_cachedTid = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cacheTid</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (t_cachedTid == <span class="hljs-number">0</span>)<br>        &#123;<br>            t_cachedTid = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">pid_t</span>&gt;(::<span class="hljs-built_in">syscall</span>(SYS_gettid));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="EventLoopThread"><a href="#EventLoopThread" class="headerlink" title="EventLoopThread"></a>EventLoopThread</h2><p>EventLoopThread类内部提供了线程函数来实现构建一个EventLoop并运行的效果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopThread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br>    <span class="hljs-built_in">EventLoopThread</span>(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb = <span class="hljs-built_in">ThreadInitCallback</span>(),<br>                    <span class="hljs-type">const</span> std::string &amp;name = std::<span class="hljs-built_in">string</span>());<br>    ~<span class="hljs-built_in">EventLoopThread</span>();<br><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">startLoop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">threadFunc</span><span class="hljs-params">()</span></span>;<br><br>    EventLoop *_loop;<span class="hljs-comment">// 记录Thread中创建出来的唯一的loop的指针</span><br>    <span class="hljs-type">bool</span> _exiting;<br>    Thread _thread;<br>    std::mutex _mutex;<br>    std::condition_variable _cond;<br>    ThreadInitCallback _cb;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br>EventLoopThread::<span class="hljs-built_in">EventLoopThread</span>(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb,<br>                                 <span class="hljs-type">const</span> std::string &amp;name)<br>    : _loop(<span class="hljs-literal">nullptr</span>)<br>    , _exiting(<span class="hljs-literal">false</span>)<br>    , _thread(std::<span class="hljs-built_in">bind</span>(&amp;EventLoopThread::threadFunc, <span class="hljs-keyword">this</span>), name)<br>    , _mutex()<br>    , _cond()<br>    , _cb(cb)<br>&#123;&#125;<br><br>EventLoopThread::~<span class="hljs-built_in">EventLoopThread</span>()<br>&#123;<br>    _exiting = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (_loop != <span class="hljs-literal">nullptr</span>)<br>    &#123;<br>        _loop-&gt;<span class="hljs-built_in">quit</span>();<br>        _thread.<span class="hljs-built_in">join</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 获取一个新线程中单独运行的EventLoop对象指针</span><br><span class="hljs-comment">// 利用条件变量 + 共享内存实现了线程间通信</span><br><span class="hljs-function">EventLoop *<span class="hljs-title">EventLoopThread::startLoop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _thread.<span class="hljs-built_in">start</span>();<br><br>    EventLoop *loop = <span class="hljs-literal">nullptr</span>;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        <span class="hljs-keyword">while</span> (_loop == <span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            _cond.<span class="hljs-built_in">wait</span>(lock);<br>        &#125;<br>        loop = _loop;<br>    &#125;<br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br><span class="hljs-comment">// 在单独的新线程里面运行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoopThread::threadFunc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// one loop per thread</span><br>    EventLoop loop;<br>    <span class="hljs-keyword">if</span> (_cb) _cb(&amp;loop);<br><br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        _loop = &amp;loop;<br>        _cond.<span class="hljs-built_in">notify_one</span>();<br>    &#125;<br><br>    loop.<span class="hljs-built_in">loop</span>();<br>    <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>    _loop = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>threadFunc :</p><p>该函数是Muduo库的核心函数, 是每个线程中将要执行的代码, 里面有很多需要学习的设计 : </p><ul><li><p><code>EventLoop loop;</code>  </p><p>我们知道线程的栈空间是独立的, 这里就是直接在栈上开辟了这个loop, 使得这个loop和当前线程强绑定, 线程结束该loop也会析构, 遵循了 one loop per thread 的理念.</p></li><li><p><code>if (_cb) _cb(&amp;loop);</code> </p><p>_cb的类型是<code>ThreadInitCallback</code>, 其并不是必要的, 只是如果有在线程刚建立时的初始化需求的话, 可以在构造函数中传入想执行的初始化操作.</p></li><li><p>接下来的代码中, 线程将在栈上构造出的loop的指针存储到_loop中, 这里使用条件变量进行线程通信, 主线程就可以知道它所开辟的新线程上loop的指针何在了.</p></li><li><p><code>loop.loop();</code></p><p>这里直接调用loop开启事件循环.</p></li><li><p><code>, _thread(std::bind(&amp;EventLoopThread::threadFunc, this), name)</code></p><p>还需要注意的一点是这个函数会在构造函数构造_thread时绑定到 _thread中, 在startLoop中被触发.</p></li></ul></li></ul><p>我们来梳理一遍EventLoopThread的使用流程 :</p><p>已知其上层还有EventLoopThreadPool会存入很多EventLoopThread, 并且其内部也会记录每个EventLoopThread中loop的指针, 那么实际调用流程就是 : </p><ul><li><p>EventLoopThreadPool创建EventLoopThread对象.</p></li><li><p>调用startLoop函数, 创建线程并执行threadFunc.</p></li><li><p>threadFunc中, 在栈上构造loop并将_loop修改, 用条件变量唤醒startLoop.</p></li><li><p>startLoop将获取到的_loop作为返回值传出.</p></li></ul><p>而这个返回值将被存入EventLoopThreadPool的_loops中.</p><h2 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h2><p>EventLoopThreadPool会构建多个EventLoopThread并储存, 而在Muduo库中是通过轮询的方式实现subLoopd的选择的, 也就是说这个线程池内部提供了轮询方法将loop指针提供出去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoopThreadPool</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadInitCallback = std::function&lt;<span class="hljs-built_in">void</span>(EventLoop *)&gt;;<br><br>    <span class="hljs-built_in">EventLoopThreadPool</span>(EventLoop *mainloop, <span class="hljs-type">const</span> std::string &amp;name);<br>    ~<span class="hljs-built_in">EventLoopThreadPool</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setThreadNum</span><span class="hljs-params">(<span class="hljs-type">int</span> numThreads)</span> </span>&#123; _numThreads = numThreads; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb = ThreadInitCallback())</span></span>;<br><br>    <span class="hljs-comment">// 如果工作在多线程中, ThreadPool以轮循的方式分配subloop</span><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">getNextLoop</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">std::vector&lt;EventLoop *&gt; <span class="hljs-title">getAllLoops</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    EventLoop *_mainLoop;<br>    std::string _name;<br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">int</span> _numThreads;<br>    <span class="hljs-type">int</span> _next;<br>    std::vector&lt;std::unique_ptr&lt;EventLoopThread&gt;&gt; _threads;<br>    std::vector&lt;EventLoop *&gt; _loops;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先来介绍一下成员变量 : </p><ul><li>_mainLoop : 这就是主线程构建的loop, 也就是我们作为用户一开始向TcpServer手动传入的loop的指针, 在EventLoopThreadPool中其存在价值在于当线程池中创建线程数为0时, 作为替补方案用来执行subLoop的工作.</li><li>_numThreads : 我们可以通过setThreadNum来设置线程池中需要有多少个线程, 也就是有多少个subLoop.</li><li>_threads : 存储线程对象的vector.</li><li>_loops : 存储每个线程中构建的loop指针.</li><li>_next : 记录当前轮询到 _loop中的哪一个.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThreadPool.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoopThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br>EventLoopThreadPool::<span class="hljs-built_in">EventLoopThreadPool</span>(EventLoop *mainloop, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _mainLoop(mainloop), _name(name), _started(<span class="hljs-literal">false</span>), _numThreads(<span class="hljs-number">0</span>), _next(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>EventLoopThreadPool::~<span class="hljs-built_in">EventLoopThreadPool</span>()<br>&#123;<br>    <span class="hljs-comment">// 线程上绑定的对象都是栈上的的对象, 无需关心析构</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoopThreadPool::start</span><span class="hljs-params">(<span class="hljs-type">const</span> ThreadInitCallback &amp;cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _numThreads; i++)<br>    &#123;<br>        <span class="hljs-type">char</span> buf[_name.<span class="hljs-built_in">size</span>() + <span class="hljs-number">32</span>];<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;%s%d&quot;</span>, _name.<span class="hljs-built_in">c_str</span>(), i);<br>        EventLoopThread *t = <span class="hljs-keyword">new</span> <span class="hljs-built_in">EventLoopThread</span>(cb, buf);<br>        _threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">unique_ptr</span>&lt;EventLoopThread&gt;(t));<br>        _loops.<span class="hljs-built_in">push_back</span>(t-&gt;<span class="hljs-built_in">startLoop</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 整个服务端只有一个线程, 让mainloop来运行</span><br>    <span class="hljs-keyword">if</span> (_numThreads == <span class="hljs-number">0</span> &amp;&amp; cb)<br>    &#123;<br>        <span class="hljs-built_in">cb</span>(_mainLoop);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果工作在多线程中, mainLoop以轮询的方式分配channel给subloop</span><br>EventLoop *EventLoopThreadPool::EventLoopThreadPool::<span class="hljs-built_in">getNextLoop</span>()<br>&#123;<br>    EventLoop *loop = _mainLoop;<br><br>    <span class="hljs-comment">// 轮询</span><br>    <span class="hljs-keyword">if</span> (!_loops.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        loop = _loops[_next];<br>        ++_next;<br>        <span class="hljs-keyword">if</span> (_next &gt;= _loops.<span class="hljs-built_in">size</span>())<br>            _next = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> loop;<br>&#125;<br><br>std::vector&lt;EventLoop *&gt; EventLoopThreadPool::EventLoopThreadPool::<span class="hljs-built_in">getAllLoops</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_loops.<span class="hljs-built_in">empty</span>())<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">vector</span>&lt;EventLoop *&gt;(<span class="hljs-number">1</span>, _mainLoop);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> _loops;<br>&#125;<br></code></pre></td></tr></table></figure><p>总共有两个重要的函数要解释 : </p><ul><li><p>start : </p><p>可以见得其依据_numThreads的数目构建EventLoopThread, 将创建出的对象存入 _threads, 然后再调用该对象的startLoop方法, 开启线程中的事件循环, 将其返回的loop指针存入 _loops.</p></li><li><p>getNextLoop : </p><p>这个函数将供给上层TcpServer调用, 以轮询方式提供出一个subLoop的指针, TcpServer则会将利用runInLoop将任务发配到该subLoop上, 当然如果一个subLoop都没有, 就还由mainLoop执行这些任务.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(2) EventLoop</title>
    <link href="/2025/04/15/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(2)%20EventLoop/"/>
    <url>/2025/04/15/Muduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(2)%20EventLoop/</url>
    
    <content type="html"><![CDATA[<blockquote><p>EventLoop 详解</p></blockquote><p>EventLoop类似于Reactor模型中的<strong>反应堆</strong>(Reactor)和<strong>事件分发器</strong>(Demultiplex)的合并, 其目的在于高效的接收事件, 并正确分配给对应的事件处理器.</p><p>EventLoop中有两类关键的子控件 : <strong>Channel 和 Poller</strong>.</p><ul><li><p>Channel 即通道, 其负责对单个文件描述符的事件管理, 存储该文件描述符感兴趣的事件与对应回调函数, 该类与EventLoop类联通, EventLoop会将从Poller中得到的发生的事件传给Channel, Channel再调用对应的回调.</p></li><li><p>Poller 即轮询器或检测器, 其负责IO复用函数(poll &#x2F; epoll)的调用, 将从epoll上检测到的事件发生传递给Channel和EventLoop, 如果选用epoll, 其内部会封装epoll系列函数.</p></li><li><p>EventLoop 即一个事件循环, 其内部维护了一个事件循环要关心和处理的所有信息.</p><ul><li>一个EventLoop包含多个Channel, 维护多个文件描述符的资源.</li><li>一个EventLoop包含一个Poller, 使用该轮循器执行核心的IO复用函数.</li><li>EventLoop负责管理事件循环的开始, 结束, 线程管理与Channel和Poller之间的互动.</li></ul></li></ul><hr><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>可以先通过头文件来了解其功能 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span>;<br><br><span class="hljs-comment">// 通道, 封装了sockfd和其感兴趣的event, 如EPOLLIN, EPOLLOUT</span><br><span class="hljs-comment">// 需要和Poller互动, Channel向Poller设置感兴趣的事件, Poller向Channel返回发生的事件</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> EventCallback = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br>    <span class="hljs-keyword">using</span> ReadEventCallback = std::function&lt;<span class="hljs-built_in">void</span>(Timestamp)&gt;;<br><br>    <span class="hljs-built_in">Channel</span>(EventLoop *Loop, <span class="hljs-type">int</span> fd);<br>    ~<span class="hljs-built_in">Channel</span>();<br><br>    <span class="hljs-comment">// fd得到poller通知以后, 处理事件的函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEvent</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-comment">// 这个函数暂不解释</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; &amp;)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fd</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _fd; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">events</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events; &#125;<br>    <span class="hljs-comment">// Channel本身无法取得发生的事件, 是Poller取得发生的事件设置到Channel中的</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_revents</span><span class="hljs-params">(<span class="hljs-type">int</span> revt)</span> </span>&#123; _revents = revt; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isNoneEvent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events == kNoneEvent; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isWriting</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events &amp; kWriteEvent; &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isReading</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _events &amp; kReadEvent; &#125;<br>    <br>    <span class="hljs-comment">// 设置回调函数对象</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setReadCallback</span><span class="hljs-params">(ReadEventCallback cb)</span> </span>&#123; _readCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setWriteCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _writeCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCloseCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _closeCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setErrorCallback</span><span class="hljs-params">(EventCallback cb)</span> </span>&#123; _errorCallback = std::<span class="hljs-built_in">move</span>(cb); &#125;<br><br>    <span class="hljs-comment">// 设置fd相应的事件状态</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableReading</span><span class="hljs-params">()</span> </span>&#123; _events |= kReadEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableReading</span><span class="hljs-params">()</span> </span>&#123; _events &amp;= ~kReadEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enableWriting</span><span class="hljs-params">()</span> </span>&#123; _events |= kWriteEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableWriting</span><span class="hljs-params">()</span> </span>&#123; _events &amp;= ~kWriteEvent, <span class="hljs-built_in">update</span>(); &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disableAll</span><span class="hljs-params">()</span> </span>&#123; _events = kNoneEvent, <span class="hljs-built_in">update</span>(); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">state</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _state; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_state</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123; _state = idx; &#125;<br><br>    <span class="hljs-comment">// 每个Channel都属于一个EventPool, EventPool可以有多个Channel</span><br>    <span class="hljs-function">EventLoop *<span class="hljs-title">ownerLoop</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _loop; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span>;<br><br>    <span class="hljs-comment">// 表示当前fd的状态</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kNoneEvent;  <span class="hljs-comment">// 没有对任何事件感兴趣</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kReadEvent;  <span class="hljs-comment">// 对读事件感兴趣</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kWriteEvent; <span class="hljs-comment">// 对写事件感兴趣</span><br><br>    EventLoop *_loop; <span class="hljs-comment">// 事件循环</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> _fd;    <span class="hljs-comment">// 监听对象</span><br>    <span class="hljs-type">int</span> _events;      <span class="hljs-comment">// 注册fd感兴趣的事件</span><br>    <span class="hljs-type">int</span> _revents;     <span class="hljs-comment">// fd上发生的事件</span><br>    <span class="hljs-type">int</span> _state;<br><br>    <span class="hljs-comment">// 防止回调函数在 Channel 所绑定的对象已析构的情况下仍然被调用</span><br>    std::weak_ptr&lt;<span class="hljs-type">void</span>&gt; _tie;<br>    <span class="hljs-type">bool</span> _tied;<br><br>    <span class="hljs-comment">// 因为channel通道里可以获知fd发生的具体事件, 所以其负责调用具体的事件回调</span><br>    ReadEventCallback _readCallback;<br>    EventCallback _writeCallback;<br>    EventCallback _closeCallback;<br>    EventCallback _errorCallback;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先从成员变量分析 : </p><ul><li><p>_loop : 维护一个loop指针便于通过EventLoop与Poller互动.</p></li><li><p>_fd &#x2F; _events &#x2F; _revents : 维护的文件描述符, 其上关心的事件, 通过Poller获知的真正发生的事件.</p></li><li><p>_state : 这个变量用于表示与Poller互动的状态, 因为Poller中要存储Channel*, 可以通过该变量判断将要采取的行为, 现在不理解也没关系, 后面会见到.</p></li><li><p>各种Callback : Channel会持有各种事件处理的回调函数.</p></li><li><p>_tie &#x2F; _tied : 防止回调函数在 Channel 所绑定的对象已析构的情况下仍然被调用, 这样看可能比较抽象, 在后文配合cpp文件理解.</p></li></ul><p>再看成员函数 ： </p><ul><li>set_revents : 当Poller监听到有事件发生时, 会先触发该函数给对应Channel设置revents, 可以让之后触发的handleEvent知道要处理哪些事件.</li><li>handleEvent : 当Poller监听到有事件发生时, 会通知EventLoop, EventLoop会调用对应Channel的该函数以执行回调函数.</li></ul><p>set_revents 供 Poller 调用, 因为Poller是轮询器, 它的作用是检测状态, 职责是把检测到的状态传递给目标类, 其内部不做任何其他操作. handleEvent 供 EventLoop 调用, 因为其负责事件的分发与调配, 触发回调函数是其的职责, 因此Poller检测到事件发生应当将其提供给EventLoop, 让EventLoop判断是否调用回调函数. 这涉及到职责分配和设计哲学.</p><ul><li>setXXXCallback系列函数 : 提供给EventLoop用来从外部传入各种事件回调函数的事件.</li><li>eable &#x2F; disable 系列函数 : 确定当前Channel中fd真正关心的事件, 当前不关心的事件就算被设置了也不会被触发.</li></ul><p>接下来给出cpp文件, 之后再继续深入解释一些细节 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kNoneEvent = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kReadEvent = EPOLLIN | EPOLLPRI;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Channel::kWriteEvent = EPOLLOUT;<br><br>Channel::<span class="hljs-built_in">Channel</span>(EventLoop *Loop, <span class="hljs-type">int</span> fd)<br>    : _loop(Loop), _fd(fd), _events(<span class="hljs-number">0</span>), _revents(<span class="hljs-number">0</span>), _state(<span class="hljs-number">-1</span>), _tied(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;<br><br>Channel::~<span class="hljs-built_in">Channel</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::tie</span><span class="hljs-params">(<span class="hljs-type">const</span> std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; &amp;obj)</span></span><br><span class="hljs-function"></span>&#123;<br>    _tie = obj;<br>    _tied = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::update</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过channel所属的EventLoop, 调用poller对应的方法, 注册fd的事件</span><br>    _loop-&gt;<span class="hljs-built_in">updateChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 在channel所属的EventLoop中删除该channel</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::remove</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _loop-&gt;<span class="hljs-built_in">removeChannel</span>(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEvent</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (_tied)<br>    &#123;<br>        std::shared_ptr&lt;<span class="hljs-type">void</span>&gt; guard = _tie.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (guard)<br>            <span class="hljs-built_in">handleEventWithGuard</span>(receiveTime);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">handleEventWithGuard</span>(receiveTime);<br>&#125;<br><br><span class="hljs-comment">// 根据当前设置的事件执行相应的回调操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Channel::handleEventWithGuard</span><span class="hljs-params">(Timestamp receiveTime)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;channle handleEvent revents: %d\n&quot;</span>, _revents);<br>    <span class="hljs-keyword">if</span> ((_revents &amp; EPOLLHUP) &amp;&amp; !(_revents &amp; EPOLLIN))<br>    &#123;<br>        <span class="hljs-comment">// 回调不为空则执行回调</span><br>        <span class="hljs-keyword">if</span> (_closeCallback)<br>            _closeCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; EPOLLERR)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_errorCallback)<br>            _errorCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; EPOLLOUT)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_writeCallback)<br>            _writeCallback();<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (_revents &amp; (EPOLLIN | EPOLLPRI))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (_readCallback)<br>            _readCallback(receiveTime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>上面还没有解释update&#x2F;remove, 这里可以看到其中调用了_loop的成员函数, 其实 _loop 也会继续调用其内部的poller, 从宏观角度来看就是Channel一旦设定&#x2F;改变&#x2F;删除了自己关心的事件, 就应当通知poller对监听事件进行相应的改变, 细致说就是再poller中调用epoll_ctl修改内核事件表.</li><li>继续解释一下上文的_tie,  这是一个weak_ptr, 再handleEvent中调用了<code>std::shared_ptr&lt;void&gt; guard = _tie.lock();</code>  , 这里lock()函数的作用是<strong>尝试将一个 <code>weak_ptr</code> 升级为 <code>shared_ptr</code>, 前提是被观察的对象还没有被析构</strong>, 因此就算对象已经被析构也不会崩溃, guard也只会变为nullptr. <strong>所以为什么Channel可能调用到已析构对象的成员函数呢?</strong> 是因为Muduo还有个类叫做TcpConnection, 这个类类似于Channel的上级部件, 其内部会封装一个channel, 而这个channel的各种回调函数是由TcpConnection设定的, 然而<strong>TcpConnection是一个用户可以使用的类, 用户可以随时销毁它</strong>, 因此一旦TcpConnection对象开始销毁, 而还没有来得及从Poller上移除Channel, 如果有对应事件到来, 调用的回调函数还在那个对象中, 如果不利用tie提前检测, 一旦调用就会崩溃.</li></ul><h2 id="Poller"><a href="#Poller" class="headerlink" title="Poller"></a>Poller</h2><p>Poller主要管理对IO复用函数的调用, 这里Muduo库为了实现对poll和epoll共同支持, 先写了一个抽象基类Poller, 之后再分别写了调用poll和epoll的子类, 这里只介绍epoll的EPollPoller类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Poller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-comment">// muduo库中多路事件分发器中的核心, 用于触发IO复用</span><br><span class="hljs-comment">// 此层为抽象基类, 用于作为Epoll和Poll的基类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ChannelList = std::vector&lt;Channel *&gt;;<br>    <span class="hljs-built_in">Poller</span>(EventLoop *loop) : _ownerLoop(loop) &#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Poller</span>() = <span class="hljs-keyword">default</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 判断参数channel是否在当前Poller中</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-comment">// EventLoop可以通过该接口获取默认Poller</span><br>    <span class="hljs-function"><span class="hljs-type">static</span> Poller *<span class="hljs-title">newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-keyword">using</span> ChannelMap = std::unordered_map&lt;<span class="hljs-type">int</span>, Channel *&gt;;<br>    <span class="hljs-comment">// 每个loop真正是在这里维护监听的channel</span><br>    ChannelMap _channels;<br><br><span class="hljs-keyword">public</span>:<br>    EventLoop *_ownerLoop;<br>&#125;;<br></code></pre></td></tr></table></figure><p>先看成员变量 : </p><ul><li>_channels : 其类型底层是<code>vector&lt;Channel*&gt;</code>,  其作用在于储存了所有监视过的Channel, 其作用仅在提供安全性检查(例如检查某个Channel是否已经注册在内核事件表中), 也可以为上层提供这种检查的方法.</li></ul><p>再看一些关键的成员函数 : </p><ul><li><p>Poller构造函数 : 既然要调用epoll系列函数, 那么epoll_create一般就会在构造函数中直接调用.</p></li><li><p>poll : 执行轮询的核心函数, 在epoll中就是调用epoll_wait, 传入的<code>ChannelList *activeChannels</code>就会用做epoll_wait的第二个输出型参数, 返回活跃的事件.</p></li><li><p>update&#x2F;removeChannel : 可以感觉到这就是在调用epoll_ctl.</p></li><li><p>newDefaultPoller : 这个函数使poller在堆上开辟默认的poller对象, 这里默认EPollPoller.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EPollPoller.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EPollPoller</span> : <span class="hljs-keyword">public</span> Poller<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">EPollPoller</span>(EventLoop *loop);<br>    ~<span class="hljs-built_in">EPollPoller</span>() <span class="hljs-keyword">override</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Timestamp <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-keyword">override</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span> <span class="hljs-keyword">override</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kInitEventListSize = <span class="hljs-number">16</span>;<br><br>    <span class="hljs-comment">// epoll_wait得到活跃的事件进行填入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// 更新epoll的内核事件表, 就是使用epoll_ctl</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel *channel)</span></span>;<br><br>    <span class="hljs-keyword">using</span> EventList = std::vector&lt;epoll_event&gt;;<br>    <span class="hljs-type">int</span> _epollfd;<br>    EventList _events; <span class="hljs-comment">// 存储发生的事件</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>fillActiveChannels : 这个是EPollPoller独有的函数, 一旦监视到活跃的事件就会触发该函数, 其向EventLoop传递活跃的Channel, 让其执行回调函数的调用, 同时还重新设置每个活跃Channel的revents, 切实做到了其作为轮询器的检测职能.</li></ul><p>以下是cpp具体实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// EPollPoller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EPollPoller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Channel.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-comment">// 有一个channel还没有添加到poller里, 与channel的成员_index初始值相同</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kNew = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">// channel已添加到poller中</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kAdded = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// channel从poller中删除</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kDeleted = <span class="hljs-number">2</span>;<br><br>EPollPoller::<span class="hljs-built_in">EPollPoller</span>(EventLoop *loop)<br>    : <span class="hljs-built_in">Poller</span>(loop), _epollfd(::<span class="hljs-built_in">epoll_create1</span>(EPOLL_CLOEXEC)) <span class="hljs-comment">// 子进程继承的epid会在调用exec后关闭</span><br>    , _events(kInitEventListSize) <span class="hljs-comment">// vector初始长度设置为16</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (_epollfd &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;epoll_create error: %d\n&quot;</span>, errno);<br>&#125;<br><br>EPollPoller::~<span class="hljs-built_in">EPollPoller</span>()<br>&#123;<br>    ::<span class="hljs-built_in">close</span>(_epollfd);<br>&#125;<br><br><span class="hljs-comment">// virtual Timestamp poll(int timeoutMs, ChannelList *activeChannels) override;</span><br><br><span class="hljs-comment">// 对应epoll_ctl</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> state = channel-&gt;<span class="hljs-built_in">state</span>();<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s fd=%d events=%d index=%d \n&quot;</span>, __FUNCTION__, channel-&gt;<span class="hljs-built_in">fd</span>(), channel-&gt;<span class="hljs-built_in">events</span>(), state);<br><br>    <span class="hljs-keyword">if</span> (state == kNew || state == kDeleted)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (state == kNew)<br>        &#123;<br>            <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>            _channels[fd] = channel;<br>        &#125;<br>        channel-&gt;<span class="hljs-built_in">set_state</span>(kAdded);<br>        <span class="hljs-built_in">update</span>(EPOLL_CTL_ADD, channel);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>        <span class="hljs-comment">// 不是新增, 如果发现fd已经没有关心的事件, 就直接取消对fd的监视</span><br>        <span class="hljs-keyword">if</span> (channel-&gt;<span class="hljs-built_in">isNoneEvent</span>())<br>        &#123;<br>            <span class="hljs-built_in">update</span>(EPOLL_CTL_DEL, channel);<br>            channel-&gt;<span class="hljs-built_in">set_state</span>(kDeleted);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">update</span>(EPOLL_CTL_MOD, channel);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::update</span><span class="hljs-params">(<span class="hljs-type">int</span> operation, Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 这里通过ctl将event存入内核中, 之后会通过wait把data原封不动地返回回来</span><br>    epoll_event event;<br>    <span class="hljs-built_in">bzero</span>(&amp;event, <span class="hljs-keyword">sizeof</span> event);<br>    event.events = channel-&gt;<span class="hljs-built_in">events</span>();<br>    event.data.ptr = channel;<br>    <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br><br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">epoll_ctl</span>(_epollfd, operation, fd, &amp;event) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (operation == EPOLL_CTL_DEL)<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;epoll_ctl del error: %d\n&quot;</span>, errno);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;epoll_ctl add/mod: %d\n&quot;</span>, errno);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fd = channel-&gt;<span class="hljs-built_in">fd</span>();<br>    _channels.<span class="hljs-built_in">erase</span>(fd);<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s fd=%d\n&quot;</span>, __FUNCTION__, fd);<br><br>    <span class="hljs-type">int</span> state = channel-&gt;<span class="hljs-built_in">state</span>();<br>    <span class="hljs-keyword">if</span> (state == kAdded)<br>        <span class="hljs-built_in">update</span>(EPOLL_CTL_DEL, channel);<br>    channel-&gt;<span class="hljs-built_in">set_state</span>(kNew);<br>&#125;<br><br><span class="hljs-comment">// 通过epoll_wait监听到哪些事件发生, 并把发生的事件填入EventLoop提供的ChannelList中</span><br><span class="hljs-function">Timestamp <span class="hljs-title">EPollPoller::poll</span><span class="hljs-params">(<span class="hljs-type">int</span> timeoutMs, ChannelList *activeChannels)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;func=%s =&gt; fd total count: %lu \n&quot;</span>, __FUNCTION__, _channels.<span class="hljs-built_in">size</span>());<br>    <span class="hljs-comment">// epoll_wait第二个参数要求原生数组, 但是用下面的方式可以改为使用vector, 便于扩容</span><br>    <span class="hljs-type">int</span> numEvents = ::<span class="hljs-built_in">epoll_wait</span>(_epollfd, &amp;*_events.<span class="hljs-built_in">begin</span>(), <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(_events.<span class="hljs-built_in">size</span>()), timeoutMs);<br>    <span class="hljs-type">int</span> saveErron = errno; <span class="hljs-comment">// errno是全局变量, 可以先存起来防止线程问题</span><br>    <span class="hljs-function">Timestamp <span class="hljs-title">now</span><span class="hljs-params">(Timestamp::now())</span></span>;<br><br>    <span class="hljs-keyword">if</span> (numEvents &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;%d events happened \n&quot;</span>, numEvents);<br>        <span class="hljs-built_in">fillActiveChannels</span>(numEvents, activeChannels);<br>        <span class="hljs-comment">// 如果监听到发生的事件数量已经等于数组大小</span><br>        <span class="hljs-comment">// 说明有可能更多, 需要扩容</span><br>        <span class="hljs-keyword">if</span> (numEvents == _events.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            _events.<span class="hljs-built_in">resize</span>(_events.<span class="hljs-built_in">size</span>() * <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (numEvents == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">LOG_DEBUG</span>(<span class="hljs-string">&quot;%s timeout! \n&quot;</span>, __FUNCTION__);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (saveErron != EINTR)<br>        &#123;<br>            errno = saveErron;<br>            <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;poll() error!&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EPollPoller::fillActiveChannels</span><span class="hljs-params">(<span class="hljs-type">int</span> numEvents, ChannelList *activeChannels)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 遍历返回的活跃事件, 将每个事件存入EventLoop的活跃数组, 并修改对应Channel</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numEvents; i++)<br>    &#123;<br>        Channel *channel = <span class="hljs-built_in">static_cast</span>&lt;Channel *&gt;(_events[i].data.ptr);<br>        channel-&gt;<span class="hljs-built_in">set_revents</span>(_events[i].events);<br>        activeChannels-&gt;<span class="hljs-built_in">push_back</span>(channel);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// DefaultPoller.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EPollPoller.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// EventLoop可以通过该接口获取默认Poller</span><br><span class="hljs-function">Poller *<span class="hljs-title">Poller::newDefaultPoller</span><span class="hljs-params">(EventLoop *loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (::<span class="hljs-built_in">getenv</span>(<span class="hljs-string">&quot;MUDUO_USE_POLL&quot;</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">EPollPoller</span>(loop);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里再摘出源文件中需要进一步理解的点 : </p><ul><li><p>epoll_create1 : </p><p>这里使用的是epoll_create1而非epoll_create, 目的是向其中传入<code>EPOLL_CLOEXEC</code>这个选项, 使得调用了exec系列函数就会直接关闭传出的epfd, 防止子进程继承该文件描述符, 使其变为当前进程独享.</p></li><li><p>kNew &#x2F; KAdded &#x2F; KDetele : </p><p>这里三个const变量的作用更像是enum类型, 其表示了每个Channel类型对于Poller可能有的三种状态(新 &#x2F; 已添加 &#x2F; 没有关心的事件), 而我们在updateChannel和removeChannel中就会通过调用Channel的state()获取其状态并与这三个const变量做对比, 进而实现不同的epoll_ctl操作.</p></li><li><p>updateChannel和removeChannel中都是在通过上面的三种const变量决定epoll_ctl的参数如何设置, 在update函数才执行真正的epoll_ctl函数, 并且这里需要注意的一点是 : <code>event.data.ptr = channel;</code>这里直接将channel指针存入了内核事件表中, 实际是非常便利快捷的操作, 后续使用中可以在epoll_wait返回的活跃事件中直接调用.</p></li></ul><h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>EventLoop内含Poller实现Demultiplex(事件分发器)的作用, Poller的内核事件表中维护了所有关心的Channel,  而EventLoop(事件循环)本身所起到作用类似于Reactor模型中的Reactor(反应堆).</p><p>我们首先要明晰EventLoop的职能, 主要就是三部分 : </p><ol><li>决定事件循环的开始和结束(loop &#x2F; quit).</li><li>使用Poller和Channel(接受Poller的状态检测结果并调用Channel的回调函数, 这就是所谓的”反应”).</li><li>线程调度(最难懂的部分, 有关one loop per thread的设计哲学).</li></ol><p>先来看头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Timestamp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Channel</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Poller</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventLoop</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Functor = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-built_in">EventLoop</span>();<br>    ~<span class="hljs-built_in">EventLoop</span>();<br>    <br>    <span class="hljs-function">Timestamp <span class="hljs-title">pollReturnTime</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _pollReturnTime; &#125;<br><br>    <span class="hljs-comment">// 1</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">loop</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 开启事件循环</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 退出事件循环</span><br>    <br>    <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">// Channel -&gt; EventLoop -&gt; Poller的方法</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hansChannel</span><span class="hljs-params">(Channel *channel)</span></span>;<br><br>    <span class="hljs-comment">// 3</span><br>    <span class="hljs-comment">// 判断对象是否在自己的线程里</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInLoopThread</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _threadId == CurrentThread::<span class="hljs-built_in">tid</span>(); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runInLoop</span><span class="hljs-params">(Functor cb)</span></span>;   <span class="hljs-comment">// 先判断是否是在自己的线程中, 是就使用回调, 不是就放入队列</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">queueInLoop</span><span class="hljs-params">(Functor cb)</span></span>; <span class="hljs-comment">// 把cb放入队列中, 唤醒loop所在的线程, 执行cb</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleRead</span><span class="hljs-params">()</span></span>;        <span class="hljs-comment">// weak up</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPendingFunctors</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 执行回调</span><br><br>    <span class="hljs-keyword">using</span> ChannelList = std::vector&lt;Channel *&gt;;<br>    std::atomic_bool _looping;<br>    std::atomic_bool _quit;                   <span class="hljs-comment">// 标识退出loop循环</span><br>    std::atomic_bool _callingPendingFunctors; <span class="hljs-comment">// 标识当前loop是否有需要执行的回调操作</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">pid_t</span> _threadId;                    <span class="hljs-comment">// 记录创建该loop所在的线程id</span><br>    Timestamp _pollReturnTime;                <span class="hljs-comment">// poller返回发生事件的channels的时间点</span><br>    <br>    std::unique_ptr&lt;Poller&gt; _poller;<br>    <span class="hljs-comment">// 由eventfd()创建, 当mainLoop获取一个新用户的channel, 通过轮循算法选择一个subLoop, 唤醒该成员</span><br>    <span class="hljs-type">int</span> _wakeupFd;<br>    std::unique_ptr&lt;Channel&gt; _wakeupChannel;<br><br>    ChannelList _activeChannels;<br><br>    <span class="hljs-comment">// 这个资源有可能被其他线程访问, 需要上锁</span><br>    std::vector&lt;Functor&gt; _pendingFunctors; <span class="hljs-comment">// 存储loop需要执行的所有回调操作d</span><br>    std::mutex _mutex;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以先理解部分函数 : </p><ul><li><p>_poller + loop() &#x2F; quit() :</p><p>这里可以理解到loop中就是再一个循环中调用_poller的poll方法, quit可以打破循环.</p></li><li><p>_activeChannels + update &#x2F; removeChannel() : </p><p>这里的逻辑链路是 : EventLoop会将_activeChannels传给Poller的poll中, EventLoop会及时得到活跃的事件, </p><p>然后调用原先设置的Channel对应的回调.</p></li></ul><p>接下来我们需要静下心来理解EventLoop中线程调度的必要性 : </p><p>首先是Muduo库的设计哲学 : <strong>one loop per thread</strong>.</p><p>每个线程只运作一个事件循环, 可以达到非常高的处理效率, 而一个loop中会内含一个poller和多个channel, 包括我们看到的成员变量(各种状态判断标记 &#x2F; _activeChannels &#x2F; _pendingFunctors等), 这些资源都是每个loop<strong>独有</strong>的.</p><p>也就是说其实<strong>每个loop和创建其的线程其实是绑定的</strong>, 如果一个loop的功能如果不在创建其的线程中被调用, 就会导致逻辑不一致而失败甚至崩溃. <strong>因此如果产生这种情况, 我们要将线程切换到loop对应的线程</strong>. 而切换的方法就是利用_wakeupfd , _wakeupChannel, 和第三部分的一系列函数, 具体实现我们一会再说. </p><p>那么问题来了,  <strong>一个loop为什么会不在创建其的线程中被调用呢?</strong> 答案在于Muduo库的框架设计中有两种EventLoop, 一种是mainLoop(一个), 处理连接与分配, 一种是subLoop(多个), 处理每个连接的回调事务. 我们在使用Muduo库时创建并传入TcpServer的loop就是mainLoop, 而当mainLoop接收到新连接时, 就会分配给subLoop(实现会存储每个subLoop的指针), 而分配的方式就是<strong>把希望subLoop执行的回调函数加入其线程专属的_pendingFunctors中, 然后通过某种方式切换到subLoop所在的线程并且执行该回调</strong>(例如将新连接注册到自己的Poller中), 而这就是 <strong>runInLoop &#x2F; queueInLoop &#x2F; wakeup</strong> 这一系列函数可以实现的事情.  </p><p>我们来看cpp文件了解他们的具体实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;EventLoop.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Logger.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Poller.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/eventfd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-comment">// 线程局部全局变量指针</span><br><span class="hljs-comment">// 防止一个线程创建多个EventLoop</span><br>__thread EventLoop *t_loopInThread = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">// 定义默认IO复用接口的超时时间</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kPollTimeMs = <span class="hljs-number">10000</span>;<br><br><span class="hljs-comment">// 创建wakeupfd, 用来notify唤醒subReactor处理新来的channel</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">createEventfd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> efd = ::<span class="hljs-built_in">eventfd</span>(<span class="hljs-number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);<br>    <span class="hljs-keyword">if</span> (efd &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;eventfd error: %d \n&quot;</span>, errno);<br>    <span class="hljs-keyword">return</span> efd;<br>&#125;<br><br><span class="hljs-comment">// 一个线程启用一个EventLoop, 一个EventLoop在创立之初确立一个该线程该loop专属的_weakfd</span><br>EventLoop::<span class="hljs-built_in">EventLoop</span>()<br>    : _looping(<span class="hljs-literal">false</span>)<br>    , _quit(<span class="hljs-literal">false</span>)<br>    , _callingPendingFunctors(<span class="hljs-literal">false</span>)<br>    , _threadId(CurrentThread::<span class="hljs-built_in">tid</span>())<br>    , _poller(Poller::<span class="hljs-built_in">newDefaultPoller</span>(<span class="hljs-keyword">this</span>))<br>    , _wakeupFd(<span class="hljs-built_in">createEventfd</span>())<br>    , _wakeupChannel(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Channel</span>(<span class="hljs-keyword">this</span>, _wakeupFd))<br>&#123;<br>    <span class="hljs-keyword">if</span> (t_loopInThread)<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;Another EventLoop %p exists int this thread %d \n&quot;</span>, t_loopInThread, _threadId);<br>    <span class="hljs-keyword">else</span><br>        t_loopInThread = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-comment">// 设置wakeupfd的读事件回调</span><br>    _wakeupChannel-&gt;<span class="hljs-built_in">setReadCallback</span>(std::<span class="hljs-built_in">bind</span>(&amp;EventLoop::handleRead, <span class="hljs-keyword">this</span>));<br>    <span class="hljs-comment">// 使当前loop监听_wakeupfd的EPOLLIN读事件</span><br>    _wakeupChannel-&gt;<span class="hljs-built_in">enableReading</span>();<br>&#125;<br><br>EventLoop::~<span class="hljs-built_in">EventLoop</span>()<br>&#123;<br>    _wakeupChannel-&gt;<span class="hljs-built_in">disableAll</span>();<br>    _wakeupChannel-&gt;<span class="hljs-built_in">remove</span>();<br>    ::<span class="hljs-built_in">close</span>(_wakeupFd);<br>    t_loopInThread = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 触发这个事件只是为了触发离开循环后的回调</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::handleRead</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">read</span>(_wakeupFd, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-keyword">sizeof</span> one)<br>    &#123;<br>        <span class="hljs-built_in">LOG_FATAL</span>(<span class="hljs-string">&quot;EventLoop::handleRead() reads %lu bytes instead of 8&quot;</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::loop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _looping = <span class="hljs-literal">true</span>;<br>    _quit = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;EventLoop %p start looping \n&quot;</span>, <span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-keyword">while</span> (!_quit)<br>    &#123;<br>        _activeChannels.<span class="hljs-built_in">clear</span>();<br>        _pollReturnTime = _poller-&gt;<span class="hljs-built_in">poll</span>(kPollTimeMs, &amp;_activeChannels);<br>        <span class="hljs-comment">// 处理自己本身监听的事件</span><br>        <span class="hljs-keyword">for</span> (Channel *channel : _activeChannels)<br>        &#123;<br>            <span class="hljs-comment">// 通知每个channel处理对应的事件</span><br>            channel-&gt;<span class="hljs-built_in">handleEvent</span>(_pollReturnTime);<br>        &#125;<br>        <span class="hljs-comment">// 处理mainLoop/其他subLoop发配给自己的任务(注册新channel, 修改channel)</span><br>        <span class="hljs-comment">// 执行当前EventLoop事件循环需要处理的回调操作</span><br>        <span class="hljs-built_in">doPendingFunctors</span>();<br>    &#125;<br>    <span class="hljs-built_in">LOG_INFO</span>(<span class="hljs-string">&quot;EventLoop %p stop looping \n&quot;</span>, <span class="hljs-keyword">this</span>);<br>    _looping = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::quit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _quit = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 要判断当前工作线程是不是IO线程, 如果不是, 则唤醒主线程</span><br>    <span class="hljs-comment">// 由于_quit线程是共享资源的, 在工作线程修改的_quit会在IO线程产生效果, 从而真正在主线程quit</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>())<br>        <span class="hljs-built_in">wakeup</span>();<br>&#125;<br><br><span class="hljs-comment">// Channel -&gt; EventLoop -&gt; Poller的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::updateChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    _poller-&gt;<span class="hljs-built_in">updateChannel</span>(channel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::removeChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    _poller-&gt;<span class="hljs-built_in">removeChannel</span>(channel);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">EventLoop::hansChannel</span><span class="hljs-params">(Channel *channel)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> _poller-&gt;<span class="hljs-built_in">hasChannel</span>(channel);<br>&#125;<br><br><span class="hljs-comment">// 在当前的loop执行cb</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::runInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInLoopThread</span>())<br>        <span class="hljs-built_in">cb</span>();<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">queueInLoop</span>(cb);<br>&#125;<br><br><span class="hljs-comment">// 把cb放入队列中, 唤醒loop所在的线程, 执行cb</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::queueInLoop</span><span class="hljs-params">(Functor cb)</span></span><br><span class="hljs-function"></span>&#123;<br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        _pendingFunctors.<span class="hljs-built_in">emplace_back</span>(cb);<br>    &#125;<br><br>    <span class="hljs-comment">// 唤醒相应loop</span><br>    <span class="hljs-comment">// 不在对应线程 | 在对应线程但是正在执行回调(执行完会回到阻塞, 可用wakeup触发)</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isInLoopThread</span>() || _callingPendingFunctors)<br>        <span class="hljs-built_in">wakeup</span>();<br>&#125;<br><br><span class="hljs-comment">// 唤醒loop所在的线程 向wakeupfd写一个数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::wakeup</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">uint64_t</span> one = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">ssize_t</span> n = <span class="hljs-built_in">write</span>(_wakeupFd, &amp;one, <span class="hljs-keyword">sizeof</span> one);<br>    <span class="hljs-keyword">if</span> (n != <span class="hljs-keyword">sizeof</span> one)<br>    &#123;<br>        <span class="hljs-built_in">LOG_ERROR</span>(<span class="hljs-string">&quot;EventLoop::wakeup() writes %lu bytes instead of 8 \n&quot;</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">EventLoop::doPendingFunctors</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::vector&lt;Functor&gt; functors;<br>    _callingPendingFunctors = <span class="hljs-literal">true</span>;<br><br>    &#123;<br>        <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(_mutex)</span></span>;<br>        functors.<span class="hljs-built_in">swap</span>(_pendingFunctors);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> Functor &amp;functor : functors)<br>    &#123;<br>        <span class="hljs-built_in">functor</span>(); <span class="hljs-comment">// 执行当前loop需要执行的回调操作</span><br>    &#125;<br><br>    _callingPendingFunctors = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们逐一讲解重要的实现 : </p><ul><li><p>构造函数 : </p><p>在这里new出了内部调用的Poller, 创建出了每个线程专属的_wakeupfd, 并且把这个fd封装进了 _wakeupChannel中, 在其中设置了这个fd读事件发送的回调函数并且关注读事件, 至于这里为什么创建 _wakeupfd和设置回调, 后面详述.</p><ul><li>eventfd() : 你可以理解为一个类似于socket可以创建出fd的函数, 但是该fd只能发送64位数据用于线程间通信.</li></ul></li><li><p>loop : </p><p>这里循环调用poller的poll函数, 是整个EventLoop的核心逻辑, 当有事件发生就会离开阻塞, 然后处理两类事件:</p><ul><li>其一处理poll返回的loop本身关心的事件.</li><li>其二处理mainLoop或其他subLoop希望当前subLoop执行的加入到_pendingFunctors中的回调函数.</li></ul></li><li><p>quit : </p><p>这里quit希望退出循环, 就把目标subLoop的_quit置成true, 然后唤醒目标subLoop的线程, 目标线程的loop中就会感知到 _quit的变化并作出判断.</p></li><li><p>update &#x2F; remove &#x2F; hasChannel : </p><p>这里其实就是Channel通过EventLoop修改Poller的途径, 具体可以再回忆一下Poller中对应的函数.</p></li><li><p>runInLoop &#x2F; queueInLoop &#x2F; wakeup &#x2F; doPendingFunctors : </p><p>这一部分是线程调度的核心 : </p><ul><li>当mainLoop&#x2F;subLoop希望某个Loop执行某个函数时, 其就会调用该loop的runInLoop把回调函数传进去.</li><li>如果当前线程就是创建该loop的线程, 则会直接执行该函数.</li><li>反之就会执行以下逻辑 : <ul><li>将该函数加入该loop的_pendingFunctors.</li><li>调用wakeup()向该loop的_wakeupfd发送一个数据.</li><li>在上文中我们知道在构造函数中已经设置了对应_wakeupfd的读事件回调, 那么这个loop如果原来阻塞在epoll_wait, 就会离开阻塞向下执行.</li><li>关键不在我们设置的读事件回调handleRead(它只是读了一个没有用的数据而已), 而在于loop的事件循环不再处于阻塞状态, 就可以继续执行之后的doPendingFunctors函数了 !</li><li>而在doPendingFunctors函数中就会执行我们在第一步存入_pendingFunctors中的回调函数 !</li></ul></li></ul><p>这里确实比较难懂, 如果想真正理解, 最好认识到每个Loop的资源都是独立且和线程绑定的, 在运行中会有很多不同的Loop资源存在, <strong>当mainLoop希望subLoop执行函数时, 其手上会有目标subLoop的指针, 借着这个指针找到该subLoop对应的资源, 利用该资源中的_weakupfd唤醒该subLoop, 也就是切换到subLoop对应线程, 让这个subLoop执行函数.</strong></p></li></ul><h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>至此整个EvnetLoop已经讲解完毕, 但我认为很多地方还是比较晦涩难懂的.</p><p>在整体框架上就是一个EventLoop内置一个Poller管理多个Channel上发生事件的模型, Poller负责轮询, EvnetLoop根据Poller返回的活跃事件进行函数回调.</p><p>在此基础上, 由于mainLoop和subLoop的设计理念, 需要实现Loop之间的互动与函数传递, 其实这种行为用生产者消费者模型就可以实现(例如mainLoop当S, subLoop当C, 中间维护一个任务队列), 但这种模型其实效率并不高, 肉眼可见的要使用很多锁来维护任务队列.</p><p>反观Muduo库的设计, 虽然设计比较复杂, 但是几乎没有用到锁的地方, 除了_pendingFunctors的使用, 因为有可能有多个线程同时使用 _pendingFunctors 向其中加入回调函数, 而且对于线程的切换由于weakup()的存在, 都是精确且没有过多消耗的, 避免了主动轮询或额外线程开销, 足以见得其效率. </p><p>而且和libevent库很像的一点是都有<strong>统一事件源</strong>的思想内核, 比如这里设计的基于Channel&#x2F;Poller&#x2F;EventLoop的一套监测&#x2F;分发&#x2F;处理的流程, 既可以用在处理普通socketfd的读写事件上, 也可以处理_weakupfd这种线程切换事件上, 在之后还可以用来处理Acceptor的listensocketfd的连接建立事件上, 其实就是掌握了不同事件之间的相通点(用fd进行事件读写), 进而转化为统一的处理方式.</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Muduo库代码剖析(1)</title>
    <link href="/2025/04/07/Moduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(1)/"/>
    <url>/2025/04/07/Moduo%E5%BA%93%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>理论知识</p></blockquote><h2 id="阻塞-非阻塞-同步-异步"><a href="#阻塞-非阻塞-同步-异步" class="headerlink" title="阻塞, 非阻塞, 同步, 异步"></a>阻塞, 非阻塞, 同步, 异步</h2><h3 id="数据准备-网络IO阶段1"><a href="#数据准备-网络IO阶段1" class="headerlink" title="数据准备 - 网络IO阶段1"></a>数据准备 - 网络IO阶段1</h3><ul><li>阻塞 : 当前线程调用IO方法的线程进入阻塞状态</li><li>非阻塞 : 不会改变线程状态, 通过返回值判断<ul><li>size &#x3D;&#x3D; 0 对端关闭了连接</li><li>size &gt; 0 接收到资源</li><li>size &#x3D;&#x3D; 0 &amp;&amp; errno &#x3D; EAGAIN</li></ul></li></ul><h3 id="数据读写-网络IO阶段2"><a href="#数据读写-网络IO阶段2" class="headerlink" title="数据读写 - 网络IO阶段2"></a>数据读写 - 网络IO阶段2</h3><ul><li>并发同步 : 同步IO接口 - 应用程序自己把数据从接收缓冲区搬过来  select &#x2F; poll &#x2F; epoll</li><li>并发异步 : 异步IO接口 - 应用程序发出请求, 传入sockfd, buf和sigio信号(通知方式), 由系统把数据搬到buf中, 当系统搬完后, 对应用程序发送sigio通知, 告诉应用程序有数据发来且已经搬运完成.</li></ul><blockquote><p>在处理IO时, 阻塞和非阻塞都是同步IO, 只有使用了特殊的的API才是异步.</p></blockquote><hr><h2 id="Linux上的五种IO模型"><a href="#Linux上的五种IO模型" class="headerlink" title="Linux上的五种IO模型"></a>Linux上的五种IO模型</h2><ul><li>阻塞 : 同步阻塞</li><li>非阻塞 : 同步非阻塞</li><li>IO复用 : select &#x2F; poll &#x2F; epoll 监听fd是否可读, 返回可读fd.</li><li>信号驱动 : 注册SIGIO信号, 发起请求, 拷贝过程还是自己承担</li><li>异步 : 同上</li></ul><hr><h2 id="一个好的网络服务器"><a href="#一个好的网络服务器" class="headerlink" title="一个好的网络服务器"></a>一个好的网络服务器</h2><ul><li>非阻塞 + IO复用 : 就是用IO复用替代轮询操作</li><li>epoll + 非阻塞IO + 线程池</li></ul><hr><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250115173257202.png" alt="image-20250115173257202"></p><hr><h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><ul><li>select : 会设置一个保存句柄的数组, 会轮循扫描数组, 拷贝句柄数据结构会有巨大开销</li><li>epoll :<ul><li>调用epoll_create()在内核申请一个文件系统的数据结构, 结构包括红黑树(存储socketfd)和双向链表(存储发生事件的fd)</li><li>调用epoll_ctl()像对象中(红黑树)添加要监视的所有socketfd</li><li>调用epoll_wait()收集发生事件的fd资源</li></ul></li></ul><hr><h2 id="事件触发模式"><a href="#事件触发模式" class="headerlink" title="事件触发模式"></a>事件触发模式</h2><ul><li>LT模式(水平触发) : 只要内核数据没被读完, 处于可读可写的状态, 就会一直上报数据(默认)</li><li>ET模式(边缘触发) : 仅在状态变化时(不可读-&gt;可读)进行通知</li><li>Muduo库采用的LT模式<ul><li>不会丢失数据或消息</li><li>低延迟处理, ET会针对一个事件一直读取, 有可能分配不均, LT就非常公平, 延迟较低.</li><li>便于跨平台使用</li></ul></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Muduo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 状压dp | 区间dp | 树形dp</title>
    <link href="/2025/04/03/%5B%E7%AE%97%E6%B3%95%5D%20%E7%8A%B6%E5%8E%8Bdp%20%20%E5%8C%BA%E9%97%B4dp%20%20%E6%A0%91%E5%BD%A2dp/"/>
    <url>/2025/04/03/%5B%E7%AE%97%E6%B3%95%5D%20%E7%8A%B6%E5%8E%8Bdp%20%20%E5%8C%BA%E9%97%B4dp%20%20%E6%A0%91%E5%BD%A2dp/</url>
    
    <content type="html"><![CDATA[<h2 id="状压dp"><a href="#状压dp" class="headerlink" title="状压dp"></a>状压dp</h2><p>棋盘型状压,  重点考虑行与行之间的转移.</p><ul><li><p>首先枚举每行可能的状态, <strong>预处理出合法行状态</strong>. </p></li><li><p>可以选择预处理出行与行之间的合法转移</p></li><li><p><code>f[i][j]</code>代表处理完前i行, 第i行状态为j的xxx.</p></li><li><p>转移方程通过枚举前状态k来实现, 看k是否可以合法转移为j</p></li></ul><blockquote><p>玉米田 : 十字型 + 地图机制</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">13</span>, mod = <span class="hljs-number">1e8</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; state; <span class="hljs-comment">// 记录初始每行合法状态!</span><br><span class="hljs-type">int</span> g[N]; <span class="hljs-comment">// 记录原图每行的状态</span><br>vector&lt;<span class="hljs-type">int</span>&gt; trans[<span class="hljs-number">1</span> &lt;&lt; N];<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">1</span> &lt;&lt; N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span>(i)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;<br>        i &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) <br>        &#123;<br>            <span class="hljs-type">int</span> y; cin &gt;&gt; y;<br>            x += !y &lt;&lt; j;<br>        &#125;<br>        g[i] = x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; m; i ++ )<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(i)) state.<span class="hljs-built_in">push_back</span>(i);<br>        <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : state)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : state)<br>            <span class="hljs-keyword">if</span>((a &amp; b) == <span class="hljs-number">0</span>) trans[a].<span class="hljs-built_in">push_back</span>(b);<br>    <br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> a : state)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> b : trans[a])<br>                <span class="hljs-keyword">if</span>((a &amp; g[i]) == <span class="hljs-number">0</span>) <span class="hljs-comment">// 要求不能种在不育土壤上</span><br>                    f[i][a] = (f[i][a] + f[i - <span class="hljs-number">1</span>][b]) % mod;<br>                    <br>    cout &lt;&lt; f[n + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] % mod &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h3 id="环状区间dp"><a href="#环状区间dp" class="headerlink" title="环状区间dp"></a>环状区间dp</h3><p>破环成链 + 区间dp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">410</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> f1[N][N], f2[N][N]; <span class="hljs-comment">// 最小, 最大</span><br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] = a[i - n];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] += a[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-built_in">memset</span>(f1, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f1);<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) f1[i][i] = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">2</span>; len &lt;= n; len ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= <span class="hljs-number">2</span> * n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt; r; k ++ )<br>            &#123;<br>                f1[l][r] = <span class="hljs-built_in">min</span>(f1[l][r], f1[l][k] + f1[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>                f2[l][r] = <span class="hljs-built_in">max</span>(f2[l][r], f2[l][k] + f2[k + <span class="hljs-number">1</span>][r] + a[r] - a[l - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-type">int</span> mi = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) mi = <span class="hljs-built_in">min</span>(mi, f1[i][i + n - <span class="hljs-number">1</span>]);<br>    <span class="hljs-type">int</span> ma = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>) ma = <span class="hljs-built_in">max</span>(ma, f2[i][i + n - <span class="hljs-number">1</span>]);<br>    cout &lt;&lt; mi &lt;&lt; endl;<br>    cout &lt;&lt; ma &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="有关二叉树的区间dp"><a href="#有关二叉树的区间dp" class="headerlink" title="有关二叉树的区间dp"></a>有关二叉树的区间dp</h3><blockquote><p>加分二叉树 : 给出中序遍历,  求出加分最高的二叉树并给出最高分和其前序遍历. 加分规则 : 根 + 左子树 * 右子树.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">35</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> ord[N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> root[N][N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">return</span>;<br>    cout &lt;&lt; root[l][r] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-built_in">dfs</span>(l, root[l][r] - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(root[l][r] + <span class="hljs-number">1</span>, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>     cin &gt;&gt; n;<br>     <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; ord[i];<br>     <br>     <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; len ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>; l + len - <span class="hljs-number">1</span> &lt;= n; l ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(len == <span class="hljs-number">1</span>) f[l][r] = ord[l], root[l][r] = l;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-type">int</span> sum;<br>                <span class="hljs-comment">// 枚举根节点</span><br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = l; k &lt;= r; k ++ )<br>                &#123;<br>                    sum = ord[k];<br>                    <span class="hljs-type">int</span> left = k == l ? <span class="hljs-number">1</span> : f[l][k - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> right = k == r ? <span class="hljs-number">1</span> : f[k + <span class="hljs-number">1</span>][r];<br>                    sum += left * right;<br>                    <span class="hljs-keyword">if</span>(sum &gt; f[l][r])<br>                    &#123;<br>                        f[l][r] = sum;<br>                        root[l][r] = k;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维区间dp"><a href="#二维区间dp" class="headerlink" title="二维区间dp"></a>二维区间dp</h3><p>dfs + 区间dp</p><blockquote><p>棋盘划分 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">9</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[M][M];<br><span class="hljs-type">double</span> f[M][M][M][M][<span class="hljs-number">15</span>]; <span class="hljs-comment">// x1, y1, x2, y2, 还有k块</span><br><span class="hljs-type">double</span> X;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span> sum = s[x2][y2] - s[x1 - <span class="hljs-number">1</span>][y2] - s[x2][y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>][y1 - <span class="hljs-number">1</span>] - X;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>)sum * sum / n;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2, <span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">double</span>&amp; v = f[x1][y1][x2][y2][k];<br>    <span class="hljs-keyword">if</span>(v &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> v = <span class="hljs-built_in">get</span>(x1, y1, x2, y2);<br>    <br>    v = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-comment">// 横切</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x1; i &lt; x2; i ++ )<br>    &#123;<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, y1, i, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(i + <span class="hljs-number">1</span>, y1, x2, y2));<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, y1, x2, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, y1, i, y2));<br>    &#125;<br>    <span class="hljs-comment">// 纵切</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = y1; i &lt; y2; i ++ )<br>    &#123;<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, y1, x2, i, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, i + <span class="hljs-number">1</span>, x2, y2));<br>        v = <span class="hljs-built_in">min</span>(v, <span class="hljs-built_in">dfs</span>(x1, i + <span class="hljs-number">1</span>, x2, y2, k - <span class="hljs-number">1</span>) + <span class="hljs-built_in">get</span>(x1, y1, x2, i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>) <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>)<br>    &#123;<br>        cin &gt;&gt; s[i][j];<br>        s[i][j] += s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span>] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> f);<br>    <br>    X = (<span class="hljs-type">double</span>)s[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>] / n;<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.3lf&quot;</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, n)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h3><blockquote><p>树的中心 : 求中心到其他所有点的最远距离, 中心是到所有点最远距离最小的点.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>, M = N * <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> h[N], e[M], ne[M], idx;<br><span class="hljs-type">int</span> w[M];<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> d1[N], d2[N];<br><span class="hljs-type">int</span> p[N];  <span class="hljs-comment">// 记录当前子树的最长路径从哪个点来</span><br><span class="hljs-type">int</span> up[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs_d</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">dfs_d</span>(j, u) + w[i];<br>        <span class="hljs-keyword">if</span>(ret &gt; d1[u]) d2[u] = d1[u], d1[u] = ret, p[u] = j;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ret &gt; d2[u]) d2[u] = ret;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d1[u];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs_up</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 先处理up</span><br>        <span class="hljs-keyword">if</span>(p[u] == j) up[j] = <span class="hljs-built_in">max</span>(up[u], d2[u]) + w[i];<br>        <span class="hljs-keyword">else</span> up[j] = <span class="hljs-built_in">max</span>(up[u], d1[u]) + w[i];<br>        <span class="hljs-built_in">dfs_up</span>(j, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs_d</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">dfs_up</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(d1[i], up[i]));<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形dp-分组背包"><a href="#树形dp-分组背包" class="headerlink" title="树形dp + 分组背包"></a>树形dp + 分组背包</h3><blockquote><p>二叉苹果树 : 给定一棵含有 n 个结点的树，树根编号为 1，且树上的每条边有一个边权 wedge j, 要求我们只保留树中的 m 条边，使得 树根 所在的 连通块 的所有边 边权之和 最大.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dfs + 分组背包</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], w[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">// 根节点为i, 要保留j根树枝的max</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> x = e[i];<br>        <span class="hljs-keyword">if</span>(x == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(x, u);<br>        <span class="hljs-comment">// 每个子树就是一组, 选择保留当前子树中多少个树枝就是分组</span><br>        <span class="hljs-comment">// u-&gt;j也需要一条树枝 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j -- )<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; j; k ++ )<br>                f[u][j] = <span class="hljs-built_in">max</span>(f[u][j], f[u][j - k - <span class="hljs-number">1</span>] + f[x][k] + w[i]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-built_in">add</span>(a, b, c), <span class="hljs-built_in">add</span>(b, a, c);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树形dp-状态机"><a href="#树形dp-状态机" class="headerlink" title="树形dp + 状态机"></a>树形dp + 状态机</h3><p>重点在于列举出状态, 以及状态之间的转移.</p><blockquote><p>战略游戏 : 给出一个树, 一个人可以观察到所在点所连的所有边, 求观察到所有边的最小人数.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> f[N][<span class="hljs-number">2</span>]; <span class="hljs-comment">// 根节点为i, 此处不放/放士兵 士兵数的最小值</span><br><span class="hljs-comment">// 必须要接触所有的边</span><br><span class="hljs-comment">// f[i][0] += f[j][1] 必须放置</span><br><span class="hljs-comment">// f[i][1] += min(f[j][0], f[j][1])所有都是可放可不放</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, f[u][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-keyword">if</span>(j == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(j, u);<br>        f[u][<span class="hljs-number">0</span>] += f[j][<span class="hljs-number">1</span>];<br>        f[u][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">0</span>], f[j][<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(cin &gt;&gt; n)<br>    &#123;<br>        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>        idx = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>        &#123;<br>            <span class="hljs-type">int</span> u; cin &gt;&gt; u;<br>            <span class="hljs-type">char</span> ch; cin &gt;&gt; ch &gt;&gt; ch;<br>            <span class="hljs-type">int</span> k; cin &gt;&gt; k &gt;&gt; ch;<br>            <span class="hljs-keyword">while</span>(k -- )<br>            &#123;<br>                <span class="hljs-type">int</span> v; cin &gt;&gt; v;<br>                <span class="hljs-built_in">add</span>(u, v), <span class="hljs-built_in">add</span>(v, u);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        cout &lt;&lt; <span class="hljs-built_in">min</span>(f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>皇宫看守 : 给出一个树, 一个人可以观察到当前点和所有邻点, 花销为当前点对应花销, 求观察到所有点的最小花销.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1510</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[N], e[N * <span class="hljs-number">2</span>], ne[N * <span class="hljs-number">2</span>], idx;<br><span class="hljs-type">int</span> p[N]; <span class="hljs-comment">// 记录安排侍卫的花销</span><br><span class="hljs-type">int</span> f[N][<span class="hljs-number">3</span>];  <span class="hljs-comment">// 根节点为i, 不放但父节点放/不放但子节点放/放</span><br><span class="hljs-comment">// f[i][0] += min(f[j][1], f[j][2]) -&gt; 子节点可以放或子节点的子节点放</span><br><span class="hljs-comment">// f[i][1] += min(f[j][2] + 集合min(f[k][2], f[k][1]))  -&gt; 子节点有一个放, 其他可放可不放</span><br><span class="hljs-comment">// f[i][2] += min(f[j][1], f[j][2], f[j][0]);</span><br><span class="hljs-type">bool</span> st[N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    f[u][<span class="hljs-number">2</span>] = p[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j);<br>        f[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]);<br>        f[u][<span class="hljs-number">2</span>] += <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">2</span>], f[j][<span class="hljs-number">0</span>]));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分别每个子节点为必2点</span><br>    f[u][<span class="hljs-number">1</span>] = <span class="hljs-number">0x3f3f3f3f</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        f[u][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(f[u][<span class="hljs-number">1</span>], f[u][<span class="hljs-number">0</span>] - <span class="hljs-built_in">min</span>(f[j][<span class="hljs-number">1</span>], f[j][<span class="hljs-number">2</span>]) + f[j][<span class="hljs-number">2</span>]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> t = n;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-type">int</span> i, k;<br>        cin &gt;&gt; i &gt;&gt; p[i] &gt;&gt; k;<br>        <span class="hljs-keyword">while</span>(k -- )<br>        &#123;<br>            <span class="hljs-type">int</span> r; cin &gt;&gt; r;<br>            <span class="hljs-built_in">add</span>(i, r);<br>            st[r] = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> root = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(st[root]) root++;<br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(f[root][<span class="hljs-number">1</span>], f[root][<span class="hljs-number">2</span>]) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 背包dp</title>
    <link href="/2025/03/30/%5B%E7%AE%97%E6%B3%95%5D%20%E8%83%8C%E5%8C%85dp/"/>
    <url>/2025/03/30/%5B%E7%AE%97%E6%B3%95%5D%20%E8%83%8C%E5%8C%85dp/</url>
    
    <content type="html"><![CDATA[<h2 id="关于”不大于””恰好””至少是”的讨论"><a href="#关于”不大于””恰好””至少是”的讨论" class="headerlink" title="关于”不大于””恰好””至少是”的讨论"></a>关于”不大于””恰好””至少是”的讨论</h2><p>最标准的背包问题中, 装入背包的体积是要不大于m的, 但有些题目要求装入体积恰好是m, 或者至少是m, 思路一样, 但是初始化和最终获取答案的方式有区别.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 不大于</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>这是最普通的一维优化01背包, 针对不大于的情况, 我们保证的是j - v[i]一定大于等于0, 因为体积不可能不大于负数, 初始化都是0, 至于原因, 是因为”什么都不装”也是”不大于”中的一种合法条件, 什么都不装值一定是0, 也就是说没个状态一定都有值为0这个合法条件, 可以取得并使用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 恰好</span><br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ ) ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>cout &lt;&lt; ans &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>恰好相比于不大于, 对f全部进行了最小化, 只有f[0] &#x3D; 0, 原因依旧从定义分析 : 初始化的 F 数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为 0 的背包可以在什么也不装且价值为 0 的情况下被“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，应该被赋值为 -∞ 了.</p><p>另外这种恰好得到结果不会涵盖前面的状态, 每个状态是相互独立的, 如果没有明确指明是恰好为多少, 通常要遍历统计一遍.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">0</span>; j -- )<br>        f[j] = <span class="hljs-built_in">max</span>(f[j], f[<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, j - v[i])] + w[i]);<br>cout &lt;&lt; f[m] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>“至少是”相比于前两者, 多了j - v[i] &lt; 0的情况, 因为”至少是负数”在理论上来说是正确的, 所以我们应当将小于0的情况也纳入考虑, 由于数组下标限制, 小于0的情况就当0处理.</p><h2 id="背包问题求具体方案"><a href="#背包问题求具体方案" class="headerlink" title="背包问题求具体方案"></a>背包问题求具体方案</h2><p>求具体方案是一种提醒, 其解法在于通过背包dp得到的f数组倒推选择从而得到方案.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> w[N][N];<br><span class="hljs-type">int</span> f[N][N];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">rep</span>(j, <span class="hljs-number">1</span>, m) cin &gt;&gt; w[i][j];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; j ++ )<br>        &#123;<br>            f[i][j] = f[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++ )<br>                <span class="hljs-keyword">if</span>(j - k &gt;= <span class="hljs-number">0</span>) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - k] + w[i][k]);<br>        &#125;<br>    <br>    cout &lt;&lt; f[n][m] &lt;&lt; endl;<br>    <br>    <span class="hljs-type">int</span> j = m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= m; k ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j - k &gt;= <span class="hljs-number">0</span> &amp;&amp; f[i][j] == f[i - <span class="hljs-number">1</span>][j - k] + w[i][k])<br>            &#123;<br>                ans[i] = k;<br>                j -= k;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans[i] &lt;&lt; endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个分组背包的方案倒推, 可以掌握到关键在于找到<code>f[i][j] == f[i - 1][j - k] + w[i][k]</code>, 这说明在最后的方案选择一定选择了第i件, 然后<code>j -= k;</code>就是原来怎么加的, 现在怎么减回去, 就这样一直到这推就可以得到方案.</p><h2 id="背包问题求最优方案数"><a href="#背包问题求最优方案数" class="headerlink" title="背包问题求最优方案数"></a>背包问题求最优方案数</h2><p>关键在于维护另外一个dp, 用来记录体积为j时的方案数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 从方案数变成最优方案数, 需要再用一个dp维护使用前i个物品的最优方案数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[N], g[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; v[i] &gt;&gt; w[i];<br>    <br>    <br>    <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">-0x3f</span>, <span class="hljs-keyword">sizeof</span> f);<br>    f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>        &#123;<br>            <span class="hljs-type">int</span> ma = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(ma == f[j]) cnt = g[j];<br>            <span class="hljs-keyword">if</span>(ma == f[j - v[i]] + w[i]) cnt += g[j - v[i]];<br>            g[j] = cnt % mod;<br>            f[j] = ma;<br>        &#125;<br>    <br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) ans = <span class="hljs-built_in">max</span>(ans, f[i]);<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">0</span>, m) <br>        <span class="hljs-keyword">if</span>(ans == f[i])<br>            cnt += g[i];<br>    cout &lt;&lt; cnt % mod &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到g[i]是根据f[j]的两个源状态所对应的结果所改变的, 思路很简单, 就是谁大就记录谁的方案数, 一样大就一起记录.</p><h2 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h2><p>不同物品对应不同的处理方法, 其实就是分别对待就行, 可以把01背包当成特殊的多重背包处理, 这样就只用处理完全背包和多重背包了, 更具n大小判断多重背包用哪个版本的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>, W = <span class="hljs-number">6010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], s[N], w[N];<br><span class="hljs-type">int</span> f[W];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> op;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <br>    &#123;<br>        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">-1</span>) s[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) s[i] = <span class="hljs-number">1010</span>;<br>        <span class="hljs-keyword">else</span> s[i] = op;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-number">0</span>) <span class="hljs-comment">// 完全背包</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = v[i]; j &lt;= m; j ++ ) f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 多重背包</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= s[i]; k *= <span class="hljs-number">2</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= k * v[i]; j -- )<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - k * v[i]] + k * w[i]);<br>                s[i] -= k;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s[i])<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j &gt;= s[i] * v[i]; j --)<br>                    f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - s[i] * v[i]] + s[i] * w[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>        <br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h2><p>当使用物品间存在树形依赖关系, 需要用到树形dp.</p><ul><li><code>f[i][j]</code>的定义将转变为 : <strong>根节点为u的子树, 且选中节点u, 总体积不超过j的最大价值</strong>.</li></ul><p>至于为什么要选中节点u, 也是因为题目性质, 选中也可以方便计算, 因为如果不选中u, 那么它的所有子树也就不能选, 就没有意义了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-comment">// 想选一定要选根节点, 所以无需担心不选中root的结果</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">// 根节点为u的子树, 且选中节点u, 总体积不超过j的最大价值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i != <span class="hljs-number">-1</span>; i = ne[i])<br>    &#123;<br>        <span class="hljs-type">int</span> j = e[i];<br>        <span class="hljs-built_in">dfs</span>(j); <span class="hljs-comment">// 先往里走把前置子树都更新完</span><br>        <br>        <span class="hljs-comment">// 每个子树做一次分组背包, 枚举当前子树不超过的体积[0, 100], 再枚举从该子树中选中多少体积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = m - v[u]; x &gt;= <span class="hljs-number">0</span>; x -- )<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y ++ )<br>                f[u][x] = <span class="hljs-built_in">max</span>(f[u][x], f[u][x - y] + f[j][y]); <span class="hljs-comment">// 子树体积不超过x, 从该子树选中y体积总和物品</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 我们假定一定要选中u, 将分组背包的结果加上u</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = m; i &gt;= v[u]; i -- ) f[u][i] = f[u][i - v[u]] + w[u];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v[u]; i ++ ) f[u][i] = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-type">int</span> root;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, fa;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; fa;<br>        v[i] = a, w[i] = b;<br>        <span class="hljs-keyword">if</span>(fa == <span class="hljs-number">-1</span>) root = i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(fa, i);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(root);<br>    <br>    cout &lt;&lt; f[root][m] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里分组背包相当于每次dfs得到的一个子树就是新的一组, 但当根节点想要知道子节点子树的答案是, 子节点可能很多如果枚举子节点的使用与否将是2的幂次级, n &lt; 100, 2的100次有很大问题. 解决问题是不枚举状态, 改为枚举体积, 因为所有枚举的结果最后一定都会落在体积范围内, 也就是[0, 100].</p><p>所以先枚举根节点子树打算占用多少体积, 再枚举当前子节点子树打算占用多少体积, 就可以得到状态转移方程了.</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 树状数组|线段树</title>
    <link href="/2025/03/29/%5B%E7%AE%97%E6%B3%95%5D%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2025/03/29/%5B%E7%AE%97%E6%B3%95%5D%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="树状数组-O-logn"><a href="#树状数组-O-logn" class="headerlink" title="树状数组 O(logn)"></a>树状数组 O(logn)</h2><ol><li>在某个位置上的数加上一个数, <strong>单点修改</strong></li><li>求任意某区间的前缀和, <strong>区间查询</strong></li></ol><p>如果想用前缀和实现单点修改+区间查询, 需要O(n) + O(1) &#x3D; O(n), 而树状数组中两种操作都是O(logn).</p><ul><li><p>tr[x] &#x3D; ( x - lowbit(x), x ] , 每个tr[x]代表了这个一个区间内的前缀和</p></li><li><p>三大操作 : lowbit + add + query</p></li><li><p>query(x) 查询的是x前的所有前缀和</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单点修改 + 区间查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N], tr[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= n; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) ret += tr[i];<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, a[i]);<br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y; cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-built_in">query</span>(y) - <span class="hljs-built_in">query</span>(x - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x, y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改-单点查询"><a href="#区间修改-单点查询" class="headerlink" title="区间修改 + 单点查询"></a>区间修改 + 单点查询</h3><p>原来树状数组维护的是原数组a, query得到的结果的前缀和s, 整体过程是 <strong>a -&gt; s</strong>. 那么 <strong>b-&gt;a</strong> 也有相同的积分关系, 也就是差分数组到原数组, 我们可以将add改为两个点的修改操作(b), query得到的结果是a, 这就是单点的值.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间修改 + 单点查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++)</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, a[i] - a[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">// tr要维护的是差分数组</span><br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        string op; cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;C&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> l, r, d;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;<br>            <span class="hljs-built_in">add</span>(l, d), <span class="hljs-built_in">add</span>(r + <span class="hljs-number">1</span>, -d);  <span class="hljs-comment">// 用两个单点操作取代区间操作</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            cout &lt;&lt; <span class="hljs-built_in">query</span>(x) &lt;&lt; endl;<span class="hljs-comment">// 单点查询求a</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="区间修改-区间查询"><a href="#区间修改-区间查询" class="headerlink" title="区间修改 + 区间查询"></a>区间修改 + 区间查询</h3><p>这种操作实际希望我们达到的效果是 <strong>b -&gt; s</strong>, 也就是我们通过修改差分数组, 之后就可以通过O(logn)的时间得到前缀和, 想要实现b-&gt;s, 是通过分析数学公式得到的 : </p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20250323101825181.png" alt="image-20250323101825181"></p><p>这里的d可以当作b, 我们看图可以分析出 si &#x3D; (d1 + d2 + … + dn) * (x + 1) - (1 * d1 + 2 * d2 + .. + n * dn);</p><p>前半部和后半部要求我们各维护一个树状数组, 整体过程可以理解为b —树状数组O(logn)—&gt; 特殊的a —数学计算O(1)—&gt; s.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 区间修改 + 区间查询</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr1[N * <span class="hljs-number">2</span>], tr2[N * <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span> <span class="hljs-comment">// 修改b</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> tr[], <span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 获取a</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span><span class="hljs-comment">// 通过a再获取s</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(tr1, x) * (x + <span class="hljs-number">1</span>) - <span class="hljs-built_in">query</span>(tr2, x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <br>    &#123;<br>        <span class="hljs-type">int</span> b = a[i] - a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">add</span>(tr1, i, b);<br>        <span class="hljs-built_in">add</span>(tr2, i, i * b);<br>    &#125;<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        string op;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;C&quot;</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> d; cin &gt;&gt; d;<br>            <span class="hljs-built_in">add</span>(tr1, l, d), <span class="hljs-built_in">add</span>(tr2, l, l * d);<br>            <span class="hljs-built_in">add</span>(tr1, r + <span class="hljs-number">1</span>, -d), <span class="hljs-built_in">add</span>(tr2, r + <span class="hljs-number">1</span>, (r + <span class="hljs-number">1</span>) * -d);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">sum</span>(r) - <span class="hljs-built_in">sum</span>(l - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="树状数组-二分答案"><a href="#树状数组-二分答案" class="headerlink" title="树状数组 + 二分答案"></a>树状数组 + 二分答案</h3><p>这种算法一般是 遍历 + 树状数组 + 二分, 时间复杂度是O(nlognlogn), 其实非常快捷, 1e5 - 1e6的数据都可以解决.</p><p>该算法常用来获取第k大元素, 相比于小根堆, 其优势在于k值非常灵活, 小根堆的k值必须固定, 但是这种算法的k可以是任意的.</p><blockquote><p>&lt;L3-002 特殊堆栈&gt; 堆栈是一种经典的后进先出的线性结构，相关的操作主要有“入栈”（在堆栈顶插入一个元素）和“出栈”（将栈顶元素返回并从堆栈中删除）。本题要求你实现另一个附加的操作：“取中值”——即返回所有堆栈中元素键值的中值。给定 N 个元素，如果 N 是偶数，则中值定义为第 N&#x2F;2 小元；若是奇数，则为第 (N+1)&#x2F;2 小元。</p></blockquote><p>该题在普通栈的基础上可以求中值, 中值在这里近似于第k大元素, k 可以通过计算得来, 是灵活可变的. 并且这里入堆的值只到1e5, 于是我们就可以用树状数组维护[1 - 1e5]区间上在堆中的元素个数, push就单点修改 + 1, pop就单点修改 - 1, query(x)得到的就是堆中有的范围在[1, x] 中的元素个数.</p><p>有了这样的树状数组, 当我需要求第k大元素时, 我们可以发现, 假如我们二分答案, 只有在mid大于等于第k大元素时query(mid)的结果才会大于等于k, 这个过程是单增的可以二分.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">// 求第k大元素(k可灵活) -&gt; 树状数组 + 二分</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br>stack&lt;<span class="hljs-type">int</span>&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt;= N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += v;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        string op;<br>        cin &gt;&gt; op;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;Pop&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">size</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cout &lt;&lt; st.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br>                <span class="hljs-built_in">add</span>(st.<span class="hljs-built_in">top</span>(), <span class="hljs-number">-1</span>);<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-string">&quot;PeekMedian&quot;</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(!st.<span class="hljs-built_in">size</span>()) cout &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-comment">// 计算中值k</span><br>                <span class="hljs-type">int</span> sz = st.<span class="hljs-built_in">size</span>();<br>                <span class="hljs-type">int</span> k;<br>                <span class="hljs-keyword">if</span>(sz &amp; <span class="hljs-number">1</span>) k = (sz + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> k = sz / <span class="hljs-number">2</span>;<br>                <span class="hljs-comment">// 二分答案, 找第k个元素的元素值</span><br>                <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = N;<br>                <span class="hljs-keyword">while</span>(l &lt; r)<br>                &#123;<br>                    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) &gt;= k) r = mid;<br>                    <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>                &#125;<br>                cout &lt;&lt; l &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> x; cin &gt;&gt; x;<br>            st.<span class="hljs-built_in">push</span>(x);<br>            <span class="hljs-built_in">add</span>(x, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing244> 有 n 头奶牛，已知它们的身高为 1∼n 且各不相同，但不知道每头奶牛的具体身高。</p><p>现在这 n 头奶牛站成一列，已知第 i 头牛前面有 Ai 头牛比它低，求每头奶牛的身高。</p></blockquote><p>这道题就更意识流了, 没有告诉你每头奶牛对应的值, 只是告诉你范围在[1, n]和每头奶牛左边比其低的个数. </p><p>首先要从边界考虑, 我从右往左思考, 第n头奶牛右边包含所有的牛, 那么a[n] + 1一定代表其名次, 并且由于范围是[1, n]并且不重样, 那么第n头奶牛的值就是a[n] + 1.</p><p>我们继续考虑n - 1, 其名次其实是受n影响的, 也就是说a[n - 1]  + 1不一定可以代表n - 1的名次的, 但是有一种方法可以让我们确定n - 1的名次, 那就是树状数组 + 二分, 这里该算法做到的是 : </p><ul><li>树状数组维护区间[1, n], 表示区间上未被使用的值有多少个, 从右往左遍历, 和上题一样二分答案, 找到第a[i] + 1大的值, 这个值就是第i头的值 , 一旦确定了第i头的值, 就把该值从tr中删去, 这样在以后的遍历中, i右边的牛就不会再影响到结果了.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 树状数组 + 二分</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> tr[N * <span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> ans[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &lt; N; i += <span class="hljs-built_in">lowbit</span>(i)) tr[i] += c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = x; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-built_in">lowbit</span>(i)) res += tr[i];<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">2</span>, n) cin &gt;&gt; a[i];<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">add</span>(i, <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        <span class="hljs-type">int</span> rk = a[i] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>        <span class="hljs-keyword">while</span>(l &lt; r) <br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(mid) &gt;= rk) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(l, <span class="hljs-number">-1</span>);<br>        ans[i] = l;<br>    &#125;<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>作用依旧是单点修改 + 区间查询, 但是相比于树状数组只能对数值进行维护, 线段树可以维护各种区间的性质, 比如最大值, 最小值, 最长连续子序列和等等.</p><ul><li>pushup : 用子节点信息更新当前节点</li><li>build : 在一段区间上初始化线段树</li><li>modify : 修改</li><li>query : 查询</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum;<br>&#125;tr[N * <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    tr[u].sum = tr[u &lt;&lt; <span class="hljs-number">1</span>].sum + tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r)<br>    &#123;<br>        tr[u] = &#123;l, r, a[l]&#125;;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    tr[u] = &#123;l, r&#125;;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, tr[u].l, mid);<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, tr[u].r);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r) <span class="hljs-keyword">return</span> tr[u].sum;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(l &lt;= mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">if</span>(r &gt; mid) res += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(tr[u].l == tr[u].r &amp;&amp; tr[u].l == x) <br>    &#123;<br>        tr[u].sum += v;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = tr[u].l + tr[u].r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, x, v);<br>    <span class="hljs-built_in">pushup</span>(u);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <br>    <span class="hljs-keyword">while</span>(m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> op, x, y;<br>        cin &gt;&gt; op &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-keyword">if</span>(op == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, x, y) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, x, y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 差分</title>
    <link href="/2025/03/17/%5B%E7%AE%97%E6%B3%95%5D%20%E5%B7%AE%E5%88%86/"/>
    <url>/2025/03/17/%5B%E7%AE%97%E6%B3%95%5D%20%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>普通的差分其实很好理解, 就是将一次区间的加减操作换成了两个点的操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设数组大小为n, 其对时间复杂度的贡献发生在区间操作很多时, 假定操作数为m, 那么差分就可以将时间复杂度O(nm)降到O(n), 一般不可以降到O(1), 因为差分完要强绑定一次前缀和(除非你就是要差分数组).</p><p>对于差分的深入理解, 可以把其看作一种积分和求导的过程 : </p><ul><li>差分数组(b) -&gt; 原数组(a) -&gt; 前缀和数组(s),  你可以把这种过程看作一种<strong>积分</strong>(从前往后累加).</li><li>差分数组 &lt;- 原数组 &lt;- 前缀和数组,  你可以把这种过程看作一种<strong>求导</strong>(从后往前累减).</li></ul><p>虽然他们数值不同, 但他们同根同源, 你可以理解为是一种事物的不同观察方式, 每种观察方式都有一些特殊的作用和关联. 在比较基础的算法题中, 一般都是站在差分数值的角度去想如何积分成原数组, 但在一些差分题中也会要求你站在原数组角度去求导成差分数组, 接下来给出例题.</p><blockquote><p><acwing4262> 空调 : 给出一个原数组x, 再给出一个目标数组y, 你可以选择x中任意的一段区间加减一, 求x转变为y的最小操作数.</p></blockquote><p>我们可以感觉到这道题确实是在进行大量的区间操作, 和差分脱不了干系, 但是并不是让我们求出原数组的什么, 而是求区间操作的最小操作数, 而差分数组中的每次加减就是一次区间操作, 那么这道题其实是希望我们把原数组求导成差分数组, 用差分数组得到答案.</p><p>将题目变形一下会更好理解, 题目要求是x-&gt;y的区间操作, 我们可转变为x - y -&gt; 0的区间操作, 就是将两个数组相减, 然后求得到的数组d变为0的操作数, 我们还可以将思路逆转一下, 0 -&gt; d的区间操作也一定等同于他, 就是说我们可以把d看作是一个原数组, 对其求导得到差分数组, 差分数组就是我们要的答案.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; b[i]; <span class="hljs-comment">// 读入x</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-comment">// 读入y直接 x - y</span><br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br>        b[i] -= x;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n + <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i -- ) b[i] -= b[i - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 求导</span><br>    <br>    <span class="hljs-comment">// 因为差分数组一定是一加一减, 并且sum(+) + sum(-)一定等于0, 那么操作次数其实就是看正数总和就行</span><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n + <span class="hljs-number">1</span>; i ++ )<br>        <span class="hljs-keyword">if</span>(b[i] &gt; <span class="hljs-number">0</span>) sum += b[i];<br>    cout &lt;&lt; sum &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing4889> 给定 𝑛 次操作，每次操作会让区间 [𝑠𝑖,𝑡𝑖] 区间减 𝑐𝑖，并且给定 𝑚 次付费操作，其中第 𝑖 个操作可以让区间 [𝑎𝑖,𝑏𝑖] 加上 𝑝𝑖，代价为 𝑚𝑖，求让全集非负的最小代价。</p></blockquote><p>这题就是很正常的思路, 是从差分数组求积分变为原数组的过程, 不过加入了空调, 需要通过dfs得到最小代价.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> p[<span class="hljs-number">200</span>]; <span class="hljs-comment">// 所有牛栏的降温需求</span><br><span class="hljs-type">int</span> b[<span class="hljs-number">200</span>]; <span class="hljs-comment">// 枚举的空调的降温</span><br><span class="hljs-type">int</span> a[<span class="hljs-number">200</span>];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> a, b, p, m;  <span class="hljs-comment">// 范围, 降温, 花销</span><br>&#125;nodes[<span class="hljs-number">20</span>];<br><br><span class="hljs-comment">// 空调只有10个枚举用不用就行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> b[])</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l] += c;<br>    b[r + <span class="hljs-number">1</span>] -= c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> sum)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u &gt; m)<br>    &#123;<br>        <span class="hljs-comment">// 将两个差分数组对比, 符合条件就和ans比较</span><br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) a[i] = b[i] + a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) <br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i] &lt; p[i] &amp;&amp; p[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ans = <span class="hljs-built_in">min</span>(ans, sum);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 不选</span><br>    <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, sum);<br>    <span class="hljs-comment">// 选</span><br>    <span class="hljs-built_in">insert</span>(nodes[u].a, nodes[u].b, nodes[u].p, b);<br>    <span class="hljs-built_in">dfs</span>(u + <span class="hljs-number">1</span>, sum + nodes[u].m);<br>    <span class="hljs-built_in">insert</span>(nodes[u].a, nodes[u].b, -nodes[u].p, b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> s, t, c;<br>        cin &gt;&gt; s &gt;&gt; t &gt;&gt; c;<br>        <span class="hljs-built_in">insert</span>(s, t, c, p);<br>    &#125;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>) p[i] += p[i - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, m)<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, p, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p &gt;&gt; c;<br>        nodes[i] = &#123;a, b, p, c&#125;;<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><acwing5526> 给定一个序列 𝑎𝑖，每次操作可以选择一个位置 𝑝，令从 𝑎𝑝 开始的每个数都加上一个以 1 或者 -1 为公差的从 1&#x2F;-1 开始的等差数列。最小化让序列归零的操作次数。</p></blockquote><p>这题也是让我们求区间操作的次数的, 如果我们做过第一题应该可以很敏锐地察觉到这应该是求导到差分数组, 但是和第一题不一样的是, 我们的区间操作所构成的结果是一个从1开始公差为1等差数列而不是1! 这时我们应当认识到, 是我们的操作做了积分.</p><p>假设我们的操作本来就是对一个区间加减一, 现在是差分数组 : </p><ul><li>1  0  0  0  0  0  (边界)</li></ul><p>然后我们对其积分, 变成原数组 : </p><ul><li>1  1  1  1  1  1  (边界)</li></ul><p>我们再对其积分, 变成前缀和数组 : </p><ul><li>1  2  3  4  5  6  (边界)</li></ul><p>我们发现, 只要积分两次, 那么我们普通的差分操作就会变成题目中的等差数列区间操作.</p><p>我们的目的是a -&gt; 0, 那么也可以翻转成 0 -&gt; a, 这个过程是通过等差数列区间操作实现的.</p><p>那么只要我们把a求导两次, 就可以把这种操作转化成普通的差分操作.</p><p>由于本题操作区间一定到最右, 所以右边的边界问题就不用考虑了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> s[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; s[i];  <span class="hljs-comment">// s</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i -- ) s[i] -= s[i - <span class="hljs-number">1</span>];<span class="hljs-comment">// s -&gt; a</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i -- ) s[i] -= s[i - <span class="hljs-number">1</span>];<span class="hljs-comment">// a -&gt; b</span><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) ans += <span class="hljs-built_in">abs</span>(s[i]); <span class="hljs-comment">// 正负操作都算</span><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 链表相关</title>
    <link href="/2025/03/04/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/03/04/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>将一个链表的前k个节点反转, 返回反转后的头节点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">reverseKList</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    k--;<br>    ListNode* prev = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>    ListNode* next = head-&gt;next;<br>    <span class="hljs-keyword">while</span>(k --)<br>    &#123;<br>        cur-&gt;next = prev;<br>        prev = cur;<br>        cur = next;<br>        next = next-&gt;next;<br>    &#125;<br>    cur-&gt;next = prev;<br>    head-&gt;next = next;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><p>链表反转的每个操作需要关联三个节点, prev, cur, next, 这里没有做长度判断, list长度最少为2.</p><blockquote><p><lc148><code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = head;<br>        ListNode* slow = head;<br>        ListNode* fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            pre = slow; <span class="hljs-comment">// 记录 slow 的前一个节点</span><br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        pre-&gt;next = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 断开 slow 的前一个节点和 slow 的连接</span><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        ListNode dummy; <span class="hljs-comment">// 用哨兵节点简化代码逻辑</span><br>        ListNode* cur = &amp;dummy; <span class="hljs-comment">// cur 指向新链表的末尾</span><br>        <span class="hljs-keyword">while</span> (list1 &amp;&amp; list2) &#123;<br>            <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>                cur-&gt;next = list1; <span class="hljs-comment">// 把 list1 加到新链表中</span><br>                list1 = list1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 注：相等的情况加哪个节点都是可以的</span><br>                cur-&gt;next = list2; <span class="hljs-comment">// 把 list2 加到新链表中</span><br>                list2 = list2-&gt;next;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur-&gt;next = list1 ? list1 : list2; <span class="hljs-comment">// 拼接剩余链表</span><br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 如果链表为空或者只有一个节点，无需排序</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">// 找到中间节点，并断开 head2 与其前一个节点的连接</span><br>        <span class="hljs-comment">// 比如 head=[4,2,1,3]，那么 middleNode 调用结束后 head=[4,2] head2=[1,3]</span><br>        ListNode* head2 = <span class="hljs-built_in">middleNode</span>(head);<br>        <span class="hljs-comment">// 分治</span><br>        head = <span class="hljs-built_in">sortList</span>(head);<br>        head2 = <span class="hljs-built_in">sortList</span>(head2);<br>        <span class="hljs-comment">// 合并</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">mergeTwoLists</span>(head, head2);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是对链表进行归并排序, 每个链表的中点用快慢指针法最优找出, 然后分治划分空间, 回溯时左右两个区间的链表一定都是升序的, 排序问题就演变为合并升序链表.</p><blockquote><p><lc138>复制随机链表</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    unordered_map&lt;Node*, Node*&gt; cachedNode;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!cachedNode.<span class="hljs-built_in">count</span>(head)) &#123;<br>            Node* headNew = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>            cachedNode[head] = headNew;<br>            headNew-&gt;next = <span class="hljs-built_in">copyRandomList</span>(head-&gt;next);<br>            headNew-&gt;random = <span class="hljs-built_in">copyRandomList</span>(head-&gt;random);<br>        &#125;<br>        <span class="hljs-keyword">return</span> cachedNode[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个是递归做法, 实际就是用一个哈希表保存所有原链表和新链表节点的对应, 如果原节点和新节点已有对应, 那么就是直接返回保存的新节点, 假如还没有新节点, 就造一个新节点.</p><blockquote><p><lc146>LRC缓存, 存储键值对, 有容量限制, 超出容量删除使用最少的节点, 要求查询和插入都是O(1).</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span>&#123;<br>        <span class="hljs-type">int</span> key, val;<br>        ListNode* next;<br>        ListNode* prev;<br>        <br>        <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> v)<br>            :<span class="hljs-built_in">key</span>(k), <span class="hljs-built_in">val</span>(v)<br>        &#123;<br>            next = prev = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-type">int</span> capacity) &#123;<br>        cap = capacity;<br>        cnt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(key) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-comment">// 把查询的节点头插回前面</span><br>        <span class="hljs-keyword">auto</span> node = mp[key];<br>        <span class="hljs-type">int</span> ret = node-&gt;val;<br>        <span class="hljs-built_in">push_front</span>(node-&gt;key, node-&gt;val);<br>        <span class="hljs-built_in">erase</span>(node);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!mp.<span class="hljs-built_in">count</span>(key))  <span class="hljs-comment">// 新插入</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(cnt == cap) <br>            &#123;<br>                <span class="hljs-type">int</span> tmp = head-&gt;prev-&gt;key;<br>                <span class="hljs-built_in">erase</span>(head-&gt;prev), cnt--;<br>                <span class="hljs-comment">// 把mp中的对应删除</span><br>                mp.<span class="hljs-built_in">erase</span>(tmp);<br>            &#125;<br>            <span class="hljs-built_in">push_front</span>(key, value);<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">// 修改值</span><br>        &#123;<br>            mp[key]-&gt;val = value;<br>            <span class="hljs-keyword">auto</span> node = mp[key];<br>            <span class="hljs-built_in">push_front</span>(node-&gt;key, node-&gt;val);<br>            <span class="hljs-built_in">erase</span>(node);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_front</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head)<br>        &#123;<br>            ListNode* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(key, value);<br>            newnode-&gt;next = newnode;<br>            newnode-&gt;prev = newnode;<br>            head = newnode;<br>            mp[key] = newnode;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        ListNode* newnode = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(key, value);<br>        newnode-&gt;next = head;<br>        newnode-&gt;prev = head-&gt;prev;<br>        head-&gt;prev-&gt;next = newnode;<br>        head-&gt;prev = newnode;<br>        head = newnode;<br><br>        <span class="hljs-comment">// 头插完顺便插入map</span><br>        mp[key] = newnode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">erase</span><span class="hljs-params">(ListNode* cur)</span></span><br><span class="hljs-function">    </span>&#123;<br>        cur-&gt;prev-&gt;next = cur-&gt;next;<br>        cur-&gt;next-&gt;prev = cur-&gt;prev;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> cap;<br>    <span class="hljs-type">int</span> cnt;<br>    ListNode* head = <span class="hljs-literal">nullptr</span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, ListNode*&gt; mp; <span class="hljs-comment">// key, 对应list中的指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是维护一个双向链表和一个哈希表, 哈希表和双向链表的插入都是O(1)(最优情况下), 利用双向链表做类似队列的操作,  哈希表存key和链表节点的映射, 查找时用哈希表O1找到链表节点, 将该节点从当前位置移到队头, 就可以使使用少的节点都往后排, 删除时就删队尾就行.</p>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非暴力沟通 读书摘录</title>
    <link href="/2025/03/01/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/"/>
    <url>/2025/03/01/%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<ul><li>非暴力沟通帮助我们重新构建表达自己和聆听他人的方式, 使我们的言行不再只是出于自动化反应, 而是牢固地建立在觉察感受和需要的基础上, 做出有意识的回应, 我们既能诚实清晰地表达自己, 也能带着尊重与同理心关注他人, 从而在任何交流中听见自己和他内心深处的呼声.</li><li>由衷的给予和接受, 是人类天性所乐见的.</li></ul><h3 id="疏离生命的语言"><a href="#疏离生命的语言" class="headerlink" title="疏离生命的语言"></a>疏离生命的语言</h3><h4 id="道德评判-作比较-推卸责任-要求-贴标签"><a href="#道德评判-作比较-推卸责任-要求-贴标签" class="headerlink" title="道德评判  作比较 推卸责任 要求 贴标签"></a>道德评判  作比较 推卸责任 要求 贴标签</h4><ul><li>疏离生命的语言让我们陷入充满评判的对与错的世界, 这时候我们关注的往往只是好与坏, 正常还是不正常, 负责还是不负责, 聪明还是愚蠢等等.</li><li>我们一心都在分析和追究自己和他人有什么问题, 却不曾思索自己和他人有什么需要没有得到满足.</li><li>我们在分析和评判时, 其实都是在表达自身的价值观和需要, 但这样的表达方式却是悲剧性的, 引发的是对方的防卫和抗拒. 就算他人遵从了我们, 很有可能是处于恐惧, 内疚或羞愧, 而非发自内心.</li><li>重要的是不要把”价值判断”和”道德评判”混为一谈. </li><li>当我们将行动的原因归咎于外部因素时, 我们便试图推卸自己的责任.</li></ul><h3 id="观察而非评论"><a href="#观察而非评论" class="headerlink" title="观察而非评论"></a>观察而非评论</h3><ul><li>非暴力沟通并不要求我们保持完全客观, 不做任何评论. 他只是强调, 我们要区分观察与评论.</li><li>即使是像”厨师”这样所谓正向或者看上去中性的标签, 也会妨碍我们全面地看到一个人.</li><li>不带评论的观察提倡我们在描述观察时, 清楚地说出特定的时间和情景.</li></ul><h3 id="感受连结需要"><a href="#感受连结需要" class="headerlink" title="感受连结需要"></a>感受连结需要</h3><ul><li><p>我们要学会区感受和想法, 感受不是动词, 名词, 行为, 那其实是想法, 表述一个想法的效果远没有表达感受来得直接.</p></li><li><p>感受源自我们如何看待他人的言行以及我们当时的需要和期待.</p></li><li><p>利用内疚感来推动他人的基本机制, 是通过把自己的感受归咎于他人实现的, 那么改变也只是为了避免愧疚, 而非出自真心.</p></li><li><p>人们更善于分析对方的错, 而非清晰地表达自己的需要.</p></li><li><p>我们既不再为他人的感受承担责任, 又能全然地为自己的意愿, 感受和行为负责.</p></li></ul><h3 id="请求而非要求"><a href="#请求而非要求" class="headerlink" title="请求而非要求"></a>请求而非要求</h3><ul><li>除了使用正向语言, 我们提出的请求越具体越好.</li><li>人们习惯于使用含糊, 抽象的语言将自己的愿望暗示给他人, 却不提及希望对方采取哪些具体的行动.</li><li>要让他人明白我们提出是真正的请求, 最重要的沟通方式是即便在他人拒绝时我们也能同理他们的感受和需要.</li><li>选择请求意味着, 我们首先同理他人为什么没有说是, 而不是要说服他们必须答应我们.</li></ul><h3 id="同理"><a href="#同理" class="headerlink" title="同理"></a>同理</h3><ul><li><p>同理意味着, 以尊重的态度来了解他人的体验, 不去做什么, 只是在哪里.</p></li><li><p>如果一个人需要同理, 我们却试图通过安慰或建议来”搞定”对方的问题, 他人往往会感到沮丧. 所以在给予安慰或建议前, 先核实那是不是对方想要的.</p></li><li><p>事实上, 试图分析问题无法让我们与他人同在. 如果我们只是关心别人的话是否符合我们的理论, 我们是在审视他们, 而没有与他们同在.</p></li><li><p>同理的核心是”临在”, 全然地与他人以及他们当下的体验同在.</p></li><li><p>当我们对他人表达同情时, 就不是在同理他们, 这其实不利于接下来的沟通的.</p></li><li><p>腾出”他人如何看待我”这个想法的空间给天赐之福.</p></li><li><p>同理可以帮助我袒露内心, 平息潜在的暴力, 让乏味变为有趣, 对不和沉默有所应对.</p></li><li><p>痛苦阻碍聆听, 同理舒缓痛苦. 当人们心烦意乱时, 往往需要先得到同理, 才有可能听进去别人的话, 重要的是居于他们足够多的同理, 让他们感受自己的痛苦被看见且理解了.</p></li></ul><h3 id="爱自己"><a href="#爱自己" class="headerlink" title="爱自己"></a>爱自己</h3><ul><li>我们若用暴力或类似暴力的方式对待自己, 就很难真正做到善待他人.</li></ul><h3 id="愤怒"><a href="#愤怒" class="headerlink" title="愤怒"></a>愤怒</h3><ul><li>非暴力沟通并不鼓励我们忽视, 否定或压抑愤怒, 而是通过了解让我们愤怒的核心本质来充分且诚挚地表达自己.</li><li>导致我们愤怒的是那些指责的想法, 它切断了我们和需要的连结.</li><li>暴力之所以产生, 都是因为人们误以为自己的痛苦是由他人造成的, 他人应当受到惩罚.</li><li>如果我们满脑子的实非对错, 评判和分析, 认为别人不好, 贪婪, 不负责任, 说谎, 作弊, 污染环境, 要钱不要命或做了不对的事……不管我们说的和事实有多贴近, 他人并不太可能对我们的需要有兴趣.</li><li>指责和评判使人倾向于自我保护, 并变得更有攻击性, 日后也不可能关心我们的需要.</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在当今的文化中, 人们已经习惯了基于买卖, 有偿或估值来运作的关系, 以至于对于纯粹的施与受, 我们多半会感到不适.</p>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>非暴力沟通</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 不等式 | 同余 + 破换成链</title>
    <link href="/2025/02/28/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E4%B8%8D%E7%AD%89%E5%BC%8F%20%20%E5%90%8C%E4%BD%99%20+%20%E7%A0%B4%E6%8D%A2%E6%88%90%E9%93%BE/"/>
    <url>/2025/02/28/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E4%B8%8D%E7%AD%89%E5%BC%8F%20%20%E5%90%8C%E4%BD%99%20+%20%E7%A0%B4%E6%8D%A2%E6%88%90%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p><acwing5439>给定 𝑛 个整数 ℎ𝑖，每次操作会使 ℎ𝑖←ℎ𝑖+𝑎𝑖，求能否在若干次操作后使得 ℎ𝑖 的排名（从大到小）为 𝑡𝑖+1(就是前面有ti个)，如果可以，求最小操作次数，否则输出-1。</p></blockquote><p>这个关键在维护一个区间集, 利用给出的目标排名确定不等式, 每个不等式成立都会给出一个区间, 然后加到这个区间集中</p><p>最后得到的区间集如果成立, 就是符合所有不等式的答案</p><ul><li><p>设经过的天数为x</p></li><li><p>不等式中按照顺序每个不等式都是这样的形式 : <code>h1 + x * a1 &gt; h2 + x * a2</code></p></li><li><p>可以转化为 : <code>x &lt; (h1 - h2) / (a2 - a1)</code></p></li><li><p>于是就要判断<code>a2 - a1</code>, 是否大于0 : </p><ul><li><p><code>&gt; 0</code>  :  <code>x &lt; (h1 - h2) / (a2 - a1)</code> , 小于缩右区间.</p></li><li><p><code>&lt; 0</code> : <code>x &gt; (h1 - h2) / (a2 - a1)</code>, 大于缩左区间.</p></li><li><p><code>= 0</code> : 这时比较h1和h2, 如果h1 &gt; h2, 则 <code>x * 0 &lt; (h1 - h2)</code>永远成立, 如果h1 &lt; h2, 则<code>x * 0 &lt; (h1 - h2)</code>永远无解.</p><p>无解的话则排名不可能实现, 直接退出就行.</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i,a,b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n; <br><span class="hljs-type">int</span> h[N], a[N], rk[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; h[i];   <span class="hljs-comment">// 高度</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i];   <span class="hljs-comment">// 增量</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)                <br>    &#123;<br>        <span class="hljs-type">int</span> w;<br>        cin &gt;&gt; w;<br>        rk[w + <span class="hljs-number">1</span>] = i;  <span class="hljs-comment">// i目标的目标排名</span><br>    &#125;<br>    <br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> A = h[rk[i]] - h[rk[i + <span class="hljs-number">1</span>]];<br>        <span class="hljs-type">int</span> B = a[rk[i + <span class="hljs-number">1</span>]] - a[rk[i]];<br>        <span class="hljs-comment">// 我们对于边界只取整数</span><br>        <span class="hljs-comment">// x &lt; w -&gt; x &lt;= ceil(w) - 1  (x &lt; 1.1 -&gt; x &lt;= 1)</span><br>        <span class="hljs-keyword">if</span>(B &gt; <span class="hljs-number">0</span>) r = <span class="hljs-built_in">min</span>(r, (<span class="hljs-type">int</span>)<span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)A / B) - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// x &gt; w -&gt; x &gt;= floor(w) + 1  (x &gt; 1.1 -&gt; x &gt;= 2)</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(B &lt; <span class="hljs-number">0</span>) l = <span class="hljs-built_in">max</span>(l, (<span class="hljs-type">int</span>)<span class="hljs-built_in">floor</span>((<span class="hljs-type">double</span>)A / B) + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A &lt;= <span class="hljs-number">0</span>)<br>        &#123;<br>            r = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l &lt;= r) cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p><acwing6131>给定一个序列 𝑎𝑖，每次操作可以让序列中一个元素加一或者减一，求让所有元素减去某个数 𝑥 之后可以被 𝑚 整除的最小操作数。</p></blockquote><p>这道题的关键在于整除可以转化为同余关系, 在同余下对元素的加减一可以被视为一个循环.</p><p>由题可得, <code>a - x ≡ 0 (mod m)</code> , 所以<code>a ≡ x(mod m)</code>.</p><p>现在问题就转化为了求使ai全部变成x要的最小操作数.</p><p>这种问题有常规解法, 就是排序取中位数, 然后两边可以用前缀和求.</p><p>但这道题是建立在同余的前提下的, 我们其实无法准确判断中位数到底是哪个, 因为每个a的循环的, 到达同一个数可以是加也可以是减, 所以我们无法按照中位数的来决定每个a必定是加还是减.</p><p>于是我们就要遍历每个点, 把每个点都当作中位数进行一次判断, 这种操作在长度为n的数组的中很难实现, 所以可以把数组复制到后面, 使长度变成2n, 这样就可以固定一定区间长度, 移动区间来进行判断.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rep(i, a, b) for(int i = (a); i &lt;= (b); i ++ )</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i], a[i] %= m; <span class="hljs-comment">// 由于a和x同余m, 所以可以先都 % m</span><br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, a.<span class="hljs-built_in">begin</span>() + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 破环成链</span><br>    <span class="hljs-comment">// 这里至于为什么加m, 其实比较模糊</span><br>    <span class="hljs-comment">// 可以理解为是为了保证a升序, 之后的前缀和计算可以正确进行</span><br>    <span class="hljs-comment">// 我的感觉就是由于所有a都是在0到m-1之间循环, 虽然不确定在正确答案中是向上加还是向下减, </span><br>    <span class="hljs-comment">// 但是还是一定只有两个方向, 这样复制数组再整体加m的做法其实就是促成一个加一个减.</span><br>    <span class="hljs-built_in">rep</span>(i, n + <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) a[i] = a[i - n] + m;<br>    <span class="hljs-comment">// 记录前缀和</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-number">2</span> * n + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) pre[i] = a[i] + pre[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1E18</span>;<br>    <span class="hljs-comment">// 枚举环上每个点</span><br>    <span class="hljs-built_in">rep</span>(i, <span class="hljs-number">1</span>, n)<br>    &#123;<br>        <span class="hljs-type">int</span> l = i, r = i + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mid = (l + r + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> res;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 偶数的时候，[mid, r] - [l, mid - 1];</span><br>            res = pre[r] - <span class="hljs-number">2</span> * pre[mid - <span class="hljs-number">1</span>] + pre[l - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 奇数的时候，[mid + 1, r] - [l, mid - 1]; </span><br>            res = pre[r] - pre[mid] - pre[mid - <span class="hljs-number">1</span>] + pre[l - <span class="hljs-number">1</span>];<br>        &#125;<br>        ans = std::<span class="hljs-built_in">min</span>(ans, res);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++线程库使用详解</title>
    <link href="/2025/02/27/C++%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/02/27/C++%E7%BA%BF%E7%A8%8B%E5%BA%93%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="核心操作"><a href="#核心操作" class="headerlink" title="核心操作"></a>核心操作</h2><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 需要传入回调函数, 如果有参数紧跟在后面</span><br><span class="hljs-function">std::thread <span class="hljs-title">t1</span><span class="hljs-params">(print_hello, <span class="hljs-number">1</span>)</span></span>;  <br><span class="hljs-comment">// 当然lambda也可以当作回调函数传进去</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from lambda thread!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><span class="hljs-comment">// 也可以创建时传入回调函数</span><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(calculate_sum, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, print_result)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t<span class="hljs-number">1.</span><span class="hljs-built_in">join</span>();<br></code></pre></td></tr></table></figure><ul><li><p>为什么需要线程等待?</p><p>目的在于<strong>接收信息和同步</strong>.</p><p> join中并没有实际和接收信息相关的操作, 信息交流是靠其他几种线程间通信的方式来实现的. 关键在于如果不用join, 将无法安全使用线程间通信得来的信息, 因为如果不等待子线程运行结束, 主线程和子线程并发运行, 主线程没有办法确定什么时候子线程会得到结果并发送过来, 简单来说就是无法实现同步.</p></li><li><p>可以通过joinable()函数来确定线程是否可join而未被分离.</p></li></ul><h3 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">t<span class="hljs-number">1.</span><span class="hljs-built_in">detach</span>();<br></code></pre></td></tr></table></figure><p>线程分离就是为了实现和线程等待相反的目的, 也就是不需要同步的情况, 当代码不需要和主线程互通有无的时候便可以调用detach, 让线程自己干自己的去.</p><hr><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>这里线程间通信的定义其实很广泛, 可以细化为线程间权限申请, 数据交互, 函数调用等.</p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>互斥锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mutex mtx;<br>mtx.<span class="hljs-built_in">lock</span>();<br><span class="hljs-comment">//....</span><br>mtx.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><ul><li>RAII风格的锁</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mutex mtx;<br>&#123;<br><span class="hljs-function">lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// 离开作用域自动调用析构函数解锁</span><br> <span class="hljs-comment">// ... 使用lock_guard需要控制作用域   </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Predicate&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">(std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred)</span></span>;<br></code></pre></td></tr></table></figure><p>条件变量需要和互斥锁绑定, 并且需要条件撑腰, 在等待时是否原先持有的锁, 被唤醒时重新取回拥有的锁并进行之后的代码, 有两种方式判断条件 : </p><ul><li>直接套在while循环里, 只有符合条件才能离开循环, 这里循环不是意味着要频繁判断, wait本身是阻塞的, 而是为了避免虚假唤醒的情况, 可以理解为系统问题.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::mutex mtx;                    <span class="hljs-comment">// 互斥量</span><br>std::condition_variable cv;         <span class="hljs-comment">// 条件变量</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lck</span><span class="hljs-params">(mtx)</span></span>;<br><span class="hljs-keyword">while</span> (!ready) &#123;               <span class="hljs-comment">// 使用while循环避免虚假唤醒</span><br>    cv.<span class="hljs-built_in">wait</span>(lck);               <span class="hljs-comment">// 等待通知</span><br>&#125;<br><span class="hljs-comment">// ... 另一个线程</span><br>cv.<span class="hljs-built_in">notify_all</span>(); <br>cv.<span class="hljs-built_in">notify_one</span>();<br></code></pre></td></tr></table></figure><ul><li><p>使用wait的第二个参数, 传入一个返回值为bool类型的回调函数, 官方称其为谓词.</p><p>谓词只在第一次触发wait和被唤醒之后发生, 如果谓词返回值为true, 则继续后面的代码, 反之继续阻塞挂起.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;  <span class="hljs-comment">// 捕获this,使之可以使用成员函数和变量</span><br>    <span class="hljs-keyword">return</span> stop || !taskQueue.<span class="hljs-built_in">empty</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>其实底层就是对C风格互斥锁和条件变量的封装.</p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>这是一个非常宽泛的概念, 我们知道一个进程的不同线程间数据块,堆都是共享的, 所以在其中申请的资源都是共享内存, 锁也是为了应对使用共享内存的情况而被设计的.</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>其实就是STL中的queue, 这个容器其实非常强大, 因为其是线程安全的, 例如我们就可以直接在生产者线程中将产物push进queue, 然后直接在消费者线程中从queue中取出, 这其中没有任何线程安全问题!</p><h3 id="future和promise"><a href="#future和promise" class="headerlink" title="future和promise"></a>future和promise</h3><p>future可以得到未来从其他线程传来的一个结果. </p><p>这里只介绍future在线程中的普通用法, 一般和promise共用.</p><ul><li>future : 未来, 用于表示在未来这里会获取一个结果.</li><li>promise : 承诺, 可以和future关联, 承诺会设置future要获取的结果.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::promise&lt;<span class="hljs-type">int</span>&gt; prom;  <br>std::future&lt;<span class="hljs-type">int</span>&gt; fut = prom.<span class="hljs-built_in">get_future</span>(); <span class="hljs-comment">// 将promise和future关联</span><br><br><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([&amp;prom]() &#123; <span class="hljs-comment">// 捕获prom传入线程</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 模拟计算</span></span></span><br><span class="hljs-params"><span class="hljs-function">    prom.set_value(result); <span class="hljs-comment">// promise将结果传递给future</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;)</span></span>;<br><br><span class="hljs-type">int</span> value = fut.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 阻塞直到获取结果</span><br>t.<span class="hljs-built_in">join</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li><p>async  : <code>async</code> 是 <strong>asynchronous</strong> 的缩写，表示“异步”的意思. 不过异步这个意义很宽泛, 很多都可以被视为异步. 有些异步相对复杂, 比如异步I&#x2F;O, 有些有十分简单, 比如我们现在学的async.</p><p>其实它的实际功效就是上面future + promise + thread的统合, 可以理解为<strong>和future强绑定的thread</strong>.</p><p>可以向async中传入一个回调函数, async会直接在一个新线程中运行它, 会返回一个future对象, 新线程运行结束会将结果设置到future对象中.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>, <span class="hljs-keyword">class</span>... Args &gt;<br>std::future&lt;std::<span class="hljs-type">invoke_result_t</span>&lt;F, Args...&gt;&gt; <br>  <span class="hljs-built_in">async</span>(F&amp;&amp; f, Args&amp;&amp;... args);<br></code></pre></td></tr></table></figure><ul><li>f : 用于确定async的启动策略, 一般写<code>std::launch::async</code>, 代表强制任务在新线程中执行.</li><li>args : 可变参数, 传入回调函数需要的参数.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 使用 std::async 启动一个异步任务</span><br>std::future&lt;<span class="hljs-type">int</span>&gt; fut = std::<span class="hljs-built_in">async</span>(std::launch::async, []() &#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">42</span>; <span class="hljs-comment">// 模拟计算</span><br>    <span class="hljs-keyword">return</span> result;   <span class="hljs-comment">// 返回结果</span><br>&#125;);<br><span class="hljs-comment">// 获取结果（会阻塞直到任务完成）</span><br><span class="hljs-type">int</span> value = fut.<span class="hljs-built_in">get</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="共享内存-vs-消息队列-vs-future"><a href="#共享内存-vs-消息队列-vs-future" class="headerlink" title="共享内存 vs 消息队列 vs future"></a>共享内存 vs 消息队列 vs future</h3><p>这三个其实都可以做到线程间传递数据, 但是应用场景不同.</p><ul><li>共享内存 : 用于多数据, 需求复杂的情况, 需要互斥锁和条件变量维护.</li><li>消息队列 : 适合生产者消费者模型, 简单易用, 线程安全, 但是需要排队, 可能需要条件变量配合.</li><li>future : 只传递单数据, 简单易用, 并且线程安全不需要考虑额外内容.</li></ul><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a>atomic</h3><p>原子操作本身和线程间通信没关系, 只是它本身就是为了服务多线程环境的一种语法, 可以减少线程间通信的发生, 取消部分资源对互斥锁的使用, 毕竟它是原子的, 根本不需要锁.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::atomic&lt;<span class="hljs-type">int</span>&gt; x&#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">// 初始化原子变量</span><br>x.<span class="hljs-built_in">store</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 使用 store 进行赋值</span><br><span class="hljs-type">int</span> value = x.<span class="hljs-built_in">load</span>();  <span class="hljs-comment">// 返回原子变量 x 的值</span><br><span class="hljs-type">int</span> old1 = x.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 先返回 x 的值，然后将其加 1</span><br><span class="hljs-type">int</span> old2 = x.<span class="hljs-built_in">fetch_sub</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 先返回 x 的值，然后将其减 1</span><br><span class="hljs-type">int</span> old_value = x.<span class="hljs-built_in">exchange</span>(<span class="hljs-number">20</span>);  <span class="hljs-comment">// 将 x 的值设为 20，返回原来的值</span><br><span class="hljs-comment">// 如果当前值等于 expected，则将其替换为 desired，返回是否成功</span><br><span class="hljs-type">bool</span> success = x.<span class="hljs-built_in">compare_exchange_strong</span>(expected, desired); <br><span class="hljs-type">int</span> old3 = x.<span class="hljs-built_in">fetch_and</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位与操作</span><br><span class="hljs-type">int</span> old4 = x.<span class="hljs-built_in">fetch_or</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位或操作</span><br><span class="hljs-type">int</span> old5 = x.<span class="hljs-built_in">fetch_xor</span>(<span class="hljs-number">0xFF</span>);  <span class="hljs-comment">// 与 0xFF 进行按位异或操作</span><br></code></pre></td></tr></table></figure><p>需要注意的atomic的模板类必须是普通类型, 还有一种情况是 : 在一个自定义类型中全是普通类型允许填入, 术语叫做POD.</p><hr><h2 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h2><p>这是 C++11 引入的一个命名空间，用来提供一些和当前线程相关的操作.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep_for</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::duration&amp; d)</span></span>; <span class="hljs-comment">// 使当前线程挂起指定的时间</span><br>std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">2</span>));  <span class="hljs-comment">// 休眠2秒</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sleep_until</span><span class="hljs-params">(<span class="hljs-type">const</span> std::chrono::time_point&amp; t)</span></span>;  <span class="hljs-comment">// 使进程挂起到指定的时间</span><br><span class="hljs-keyword">auto</span> wakeup_time = std::chrono::system_clock::<span class="hljs-built_in">now</span>() + std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3秒后</span><br>std::this_thread::<span class="hljs-built_in">sleep_until</span>(wakeup_time);  <span class="hljs-comment">// 休眠直到指定时间</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">yield</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 一个请求, 表示当前线程愿意让出cpu的时间片, 假如线程间的优先度不同可以使用</span><br>std::this_thread::<span class="hljs-built_in">yield</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="thread的移动语义"><a href="#thread的移动语义" class="headerlink" title="thread的移动语义"></a>thread的移动语义</h2><p>线程对象不可复制, 因为线程本身就不好复制, 从底层来讲thread类的拷贝构造函数本身就是删除的.</p><p>但是thread类可以被移动, 其实就相当于转移控制权, 可以使用move转换.</p><p>假如我们想把多个线程存入一个vector中, 可以使用emplace_back在vector中直接构建, 也可以选择在外部构建然后用move移动进去.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">(task)</span></span>;  <span class="hljs-comment">// 创建一个线程对象 t</span><br>threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(t));<br></code></pre></td></tr></table></figure><hr><h2 id="简易线程池"><a href="#简易线程池" class="headerlink" title="简易线程池"></a>简易线程池</h2><p>AI生成仅供学习 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;condition_variable&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">size_t</span> numThreads) &#123;<br>        <span class="hljs-comment">// 启动指定数量的工作线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; ++i) &#123;<br>            workers.<span class="hljs-built_in">emplace_back</span>([<span class="hljs-keyword">this</span>] &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    std::function&lt;<span class="hljs-built_in">void</span>()&gt; task;<br>                    &#123;<br>                        std::unique_lock&lt;std::mutex&gt; <span class="hljs-built_in">lock</span>(queueMutex);<br>                        condition.<span class="hljs-built_in">wait</span>(lock, [<span class="hljs-keyword">this</span>] &#123;<br>                            <span class="hljs-keyword">return</span> stop || !taskQueue.<span class="hljs-built_in">empty</span>();<br>                        &#125;); <span class="hljs-comment">// 直到return 返回 ture才能进行</span><br>                        <br>                        <span class="hljs-comment">// 如果线程池停止且任务队列为空，退出线程</span><br>                        <span class="hljs-keyword">if</span> (stop &amp;&amp; taskQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br><span class="hljs-comment">// 取出队列不能拷贝, 要移动</span><br>                        task = std::<span class="hljs-built_in">move</span>(taskQueue.<span class="hljs-built_in">front</span>()); <br>                        taskQueue.<span class="hljs-built_in">pop</span>();<br>                    &#125;<br>                    <span class="hljs-comment">// 执行任务</span><br>                    <span class="hljs-built_in">task</span>();<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 提交任务</span><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span>&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(F&amp;&amp; f)</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex)</span></span>;<br>            <span class="hljs-keyword">if</span> (stop) &#123;<br>                <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;ThreadPool is stopped&quot;</span>);<br>            &#125;<br>            taskQueue.<span class="hljs-built_in">push</span>(std::forward&lt;F&gt;(f)); <span class="hljs-comment">// 完美转发到队列中</span><br>        &#125;<br>        condition.<span class="hljs-built_in">notify_one</span>(); <span class="hljs-comment">// 传入一个任务, 就激活等待中的一个线程</span><br>    &#125;<br><br>    <span class="hljs-comment">// 停止线程池</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stopPool</span><span class="hljs-params">()</span> </span>&#123;<br>        &#123;<br>            <span class="hljs-function">std::unique_lock&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(queueMutex)</span></span>;<br>            stop = <span class="hljs-literal">true</span>;<br>        &#125;<br>        condition.<span class="hljs-built_in">notify_all</span>();<br><br>        <span class="hljs-keyword">for</span> (std::thread&amp; worker : workers) &#123;<br>            worker.<span class="hljs-built_in">join</span>();<br>        &#125;<br>    &#125;<br><br>    ~<span class="hljs-built_in">ThreadPool</span>() &#123;<br>        <span class="hljs-keyword">if</span> (!stop) &#123;<br>            <span class="hljs-built_in">stopPool</span>();<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::thread&gt; workers;           <span class="hljs-comment">// 工作线程</span><br>    std::queue&lt;std::function&lt;<span class="hljs-type">void</span>()&gt;&gt; taskQueue;  <span class="hljs-comment">// 任务队列</span><br>    std::mutex queueMutex;                      <span class="hljs-comment">// 任务队列互斥锁</span><br>    std::condition_variable condition;          <span class="hljs-comment">// 条件变量</span><br>    std::atomic&lt;<span class="hljs-type">bool</span>&gt; stop&#123;<span class="hljs-literal">false</span>&#125;;              <span class="hljs-comment">// 是否停止线程池</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ThreadPool <span class="hljs-title">pool</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;  <span class="hljs-comment">// 创建一个包含4个线程的线程池</span><br>    <span class="hljs-comment">// 提交几个任务给线程池执行</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        pool.<span class="hljs-built_in">enqueue</span>([i] &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Task &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; is being executed by thread &quot;</span> <br>                      &lt;&lt; std::this_thread::<span class="hljs-built_in">get_id</span>() &lt;&lt; std::endl;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 停止线程池</span><br>    pool.<span class="hljs-built_in">stopPool</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于对线程库的进一步封装"><a href="#关于对线程库的进一步封装" class="headerlink" title="关于对线程库的进一步封装"></a>关于对线程库的进一步封装</h2><p>通过对线程库的使用我们可以发现, 一旦我们生成thread对象, 线程就已经开始了, 这其实不利于我们对每个线程做精细化处理与记录线程的状态, 我们可以对线程库做进一步封装, 让我们可以随时控制线程的开始与结束并记录线程的状态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;UnCopyable.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-comment">// 一个Thread对象记录的就是一个新线程的详细信息</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> : UnCopyable<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> ThreadFunc = std::function&lt;<span class="hljs-built_in">void</span>()&gt;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Thread</span><span class="hljs-params">(ThreadFunc, <span class="hljs-type">const</span> std::string &amp;name = std::string())</span></span>;<br>    ~<span class="hljs-built_in">Thread</span>();<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">join</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">started</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _started; &#125;<br>    <span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">tid</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _tid; &#125;<br>    <span class="hljs-function"><span class="hljs-type">const</span> std::string &amp;<span class="hljs-title">name</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDefaultName</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-type">bool</span> _started;<br>    <span class="hljs-type">bool</span> _joined;<br>    std::shared_ptr&lt;std::thread&gt; _thread;<br>    <span class="hljs-type">pid_t</span> _tid;<br>    ThreadFunc _func;<br>    std::string _name;<br>    <span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated; <span class="hljs-comment">// 记录产生的线程个数</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Thread.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Thread.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CurrentThread.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><br><span class="hljs-type">static</span> std::<span class="hljs-type">atomic_int32_t</span> _numCreated = <span class="hljs-number">0</span>;<br><br>Thread::<span class="hljs-built_in">Thread</span>(ThreadFunc func, <span class="hljs-type">const</span> std::string &amp;name)<br>    : _started(<span class="hljs-literal">false</span>), _joined(<span class="hljs-literal">false</span>), _tid(<span class="hljs-number">0</span>), _func(std::<span class="hljs-built_in">move</span>(func)), _name(name)<br>&#123;<br>    <span class="hljs-built_in">setDefaultName</span>();<br>&#125;<br><br>Thread::~<span class="hljs-built_in">Thread</span>()<br>&#123;<br>    <span class="hljs-keyword">if</span> (_started &amp;&amp; !_joined)<br>        _thread-&gt;<span class="hljs-built_in">detach</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::start</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _started = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">sem_t</span> sem;<br>    <span class="hljs-built_in">sem_init</span>(&amp;sem, <span class="hljs-literal">false</span>, <span class="hljs-number">0</span>);<br>    _thread = std::<span class="hljs-built_in">make_shared</span>&lt;std::thread&gt;(<span class="hljs-keyword">new</span> std::<span class="hljs-built_in">thread</span>([&amp;]()&#123;<br>        _tid = CurrentThread::<span class="hljs-built_in">tid</span>();<br>        <span class="hljs-built_in">sem_post</span>(&amp;sem);<br>        _func(); <span class="hljs-comment">// 在这里真正执行传入的回调函数</span><br>    &#125;));<br><br>    <span class="hljs-comment">// 确保子线程tid已经确定</span><br>    <span class="hljs-built_in">sem_wait</span>(&amp;sem);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::join</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    _joined = <span class="hljs-literal">true</span>;<br>    _thread-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Thread::setDefaultName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> num = ++_numCreated;<br>    <span class="hljs-keyword">if</span> (_name.<span class="hljs-built_in">empty</span>())<br>    &#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">32</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-keyword">sizeof</span> buf, <span class="hljs-string">&quot;Thread%d&quot;</span>, num);<br>        _name = buf;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用智能指针控制thread, 直到我们使用start()才会时线程真正开始, 并且也记录了线程的运作状态与线程id.</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 前缀和|滑动窗口|合并区间</title>
    <link href="/2025/02/25/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E5%89%8D%E7%BC%80%E5%92%8C%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%20%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/"/>
    <url>/2025/02/25/%5B%E7%AE%97%E6%B3%95%E5%A4%8D%E5%81%A5%5D%20%E5%89%8D%E7%BC%80%E5%92%8C%20%20%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%20%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><blockquote><p><lc560>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 <em>该数组中和为 <code>k</code> 的子数组的个数</em> 。子数组是数组中元素的连续非空序列。O(nlogn)  </p></blockquote><p>这道题的关键在于如何以O(1)的复杂度发现和为k的子数组个数, 重点在于子数组一定连续, 连续的一段区间的和可以用前缀以O(1)求得, 问题在于如何知道这样的数的个数.</p><p>对于运算到第i处的前缀per[i], 前面可以和其相减得到k的per, 有或没有, 有多少都是问题, 那么就可以进行per值的存储, 要把其数量也一并记录, 那么用map就可以了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">subarraySum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span></span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(nums.size() + <span class="hljs-number">10</span>)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp; <span class="hljs-comment">// &lt;前缀和, 出现的次数&gt;</span><br>        mp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            pre[i] = nums[i];<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) pre[i] += pre[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(mp.<span class="hljs-built_in">count</span>(pre[i] - k)) ans += mp[pre[i] - k];<br>            mp[pre[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><blockquote><p><lc239>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。返回 <em>滑动窗口中的最大值</em> 。</p></blockquote><p>标准例题, 深入理解的关键在于这里的滑动窗口是一个固定值, 就要把控制窗口的变量和队列的操作分清楚.</p><ul><li><p>队列 : 本题中要维护的是一个单减队列, 就是为了保证队头一定是最大值, 为了实现这个目的, 只要新元素比队尾元素小就要弹出队尾元素, 直到遇到大于等于的.</p></li><li><p>窗口 : 窗口的移动在遍历中实现, 可以想到只要<code>i - k &gt;= 0</code>, 每次向后移动一格就一定会离开一个加入一个.</p></li><li><p>问题的关键在于队列会提前弹出部分元素, 所以队列的实际大小和原窗口是匹配不上的, 也就是说, 即使<code>i - k &gt;= 0</code>, 如果队头还没有到应该弹出的时间, 就不能弹出, 而到了应该弹出的时候就必须弹出.</p></li><li><p>问题就转化成了 : <strong>随着窗口的移动, 如何确定队头所在的元素是否离开了区域?</strong></p><p>其实只需要对比当前要离开的元素是否和队头元素值相等就行了, 因为如果是其他值, 就一定是还没轮到队头, 不然不可能会出现这个队头存在的情况.</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">// 将k范围的内容先入队, 求最大值</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        &#123;<br>            <span class="hljs-comment">// 把小的都去掉, 因为不会影响最大值, 当前最大值就一定在队头</span><br>            <span class="hljs-keyword">while</span>(dq.<span class="hljs-built_in">size</span>() &amp;&amp; dq.<span class="hljs-built_in">back</span>() &lt; nums[i]) dq.<span class="hljs-built_in">pop_back</span>();<br>            dq.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(i - k  &gt;= <span class="hljs-number">0</span> &amp;&amp; dq.<span class="hljs-built_in">front</span>() == nums[i - k]) dq.<span class="hljs-built_in">pop_front</span>();<br>            <span class="hljs-keyword">if</span>(i - k + <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span>) ret.<span class="hljs-built_in">push_back</span>(dq.<span class="hljs-built_in">front</span>());<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><blockquote><p><lc56>以数组 <code>intervals</code> 表示若干个区间的集合，其中单个区间为 <code>intervals[i] = [starti, endi]</code> 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p></blockquote><p>例题, 核心在于区间需要排序, 我们需要在左端点从小到达排列的前提下去分析才能有效.</p><p>剩下的其实就是控制住当前区间的左右端点[nl, nr], 对新加入的区间[l, r]进行分析 : </p><ul><li>加入l &gt; nr, 那么区间根本不相交, 这是一个新的区间, 于是将大权转移.</li><li>l &lt;&#x3D; nr, 那么区间相交, 接着就是看右端点还需不需要更新 : <ul><li>r &gt; nr,  新的右边界更大, 右边界主权转移.</li><li>r &lt;&#x3D; nr, 说明这个新区间完全被包含在原区间中, 不做调整.</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">merge</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; intervals) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ret;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; a = intervals;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> nl = <span class="hljs-number">-1</span>, nr = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> l = a[i][<span class="hljs-number">0</span>], r = a[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(l &gt; nr)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nr != <span class="hljs-number">-1</span>)<br>                &#123;<br>                    vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;nl, nr&#125;;<br>                    ret.<span class="hljs-built_in">push_back</span>(v);<br>                &#125;<br>                nl = l, nr = r;<br>            &#125; <br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                <span class="hljs-keyword">if</span>(nr &lt; r) nr = r;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; v = &#123;nl, nr&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> e : ret)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(e[<span class="hljs-number">0</span>] == nl) <br>            &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) ret.<span class="hljs-built_in">push_back</span>(v);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(8)</title>
    <link href="/2025/02/23/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)/"/>
    <url>/2025/02/23/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(8)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第14章 多线程编程</p></blockquote><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>线程是轻量级的进程, 想要理解线程的关键, 首先要理解线程和进程之间的区别.</p><p>一个进程在创建之初其实就可以看作是一个主线程, 其创建出的线程其实和其本质无很大差别, 其实就多了一个线程共享资源罢了, 我们要明晰的是一个进程创建的不同线程之间, 什么是共享的, 什么是独立的.</p><p>线程间共享的 : </p><ul><li>进程地址空间中的代码段, 数据段, 堆</li><li>文件描述符</li><li>信号处理</li><li>环境变量</li><li>进程id</li></ul><p>线程间独立的 : </p><ul><li>线程id</li><li>进程地址空间中的栈</li><li>寄存器状态</li><li>信号掩码(会继承但独立)</li><li>线程局部存储(TLS)</li><li>errno</li></ul><p>只有理解了这些, 我们才可以分析出线程相比于进程, 我们还需要关心什么, 例如 : </p><ul><li>数据段 + 文件描述符共享 -&gt; 需要锁来限制共享内存的访问</li><li>信号处理共享 + 信号掩码独立 -&gt; 可以创建一个线程单独管理信号.</li></ul><hr><h2 id="线程创建及使用"><a href="#线程创建及使用" class="headerlink" title="线程创建及使用"></a>线程创建及使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span>*thread,<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span>*attr,<span class="hljs-type">void</span>*(*start_routine)(<span class="hljs-type">void</span>*),<span class="hljs-type">void</span>*arg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>*retval)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread,<span class="hljs-type">void</span>**retval)</span></span>;<br></code></pre></td></tr></table></figure><hr><h2 id="线程同步-线程间通信"><a href="#线程同步-线程间通信" class="headerlink" title="线程同步(线程间通信)"></a>线程同步(线程间通信)</h2><p>和线程同步相关的要点也有三种 : </p><h3 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h3><p>进程间通信中已经将了System V信号量l, POSIX信号量的理念和使用方法也相似, 还是可以理解为一种可计数的高级互斥锁.</p><p>POSIX信号量的使用会更加方便一些 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜semaphore.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_init</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem,<span class="hljs-type">int</span> pshared,<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_destroy</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_trywait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span>*sem)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>sem : 就是标定唯一的信号量的一个标准, 直接创建即可<code>sem_t sem;</code>;</li><li>pshared : 用于指定信号量类型, 如果为0代表是进程局部的信号量, 不为0可以实现进程间共享, 不过这个信号量一般用于线程间通信, 所以用0即可.</li><li>value : 设置信号量的值, 和System V中semctl的作用一致.</li></ul><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>这个就是常用的普通锁, 只能被一个线程持有.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_init</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex,<span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span>*mutexattr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>可以用宏的方式替代init : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <br></code></pre></td></tr></table></figure><p>init的第二个参数用于设置互斥锁属性, 一般是NULL.</p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_init</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond,<span class="hljs-type">const</span> <span class="hljs-type">pthread_condattr_t</span>*cond_attr)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_broadcast</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;    <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_signal</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cond_wait</span><span class="hljs-params">(<span class="hljs-type">pthread_cond_t</span>*cond,<span class="hljs-type">pthread_mutex_t</span>*mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>这个名称起的比较晦涩, 但是确实是和”条件”有关, 这个东西是和互斥锁绑定使用的, 你可以理解为互斥锁只负责确保当前只有一个线程可以持有锁, 也就是只用一个线程可以访问共享资源. 而条件变量是在<strong>确保这个共享资源属于可用状态</strong>, <strong>可用状态的判断是靠条件实现的</strong>, 更具体的说就是通过if判断是否触发<code>pthread_cond_wait</code>函数.</p><p>以生产者消费者模型为例, 生产者将产物存入共享内存中, 消费者从共享内存中取出产物, 那么互斥锁可以保证同时只能由一个生产者或消费者访问共享内存, </p><ul><li>但是如果共享内存满了, 生产者再去生产就是浪费, </li><li>如果内存为空, 消费者去取也是徒劳.</li></ul><p>这时条件变量就可以发挥作用 : </p><ul><li>当共享内存满了, 可以将生产者挂起, 直到共享内存有产物被取走为止,</li><li>当共享内存为空, 可以将消费者挂起, 直到共享内存不为空为止.</li></ul><h4 id="函数使用"><a href="#函数使用" class="headerlink" title="函数使用"></a>函数使用</h4><p>函数使用和互斥锁相似, init的第二个参数还是设置为NULL就行, 并且也可以用下面的代码替代 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;<br></code></pre></td></tr></table></figure><ul><li>我们通过条件判断触发pthread_cond_wait, 这个函数会将线程挂起, 并且释放当前持有的锁.</li><li>在我们认为可以满足条件的地方触发pthread_cond_signal, 这个函数会选择一个挂起的线程并唤醒他, 被唤醒的线程会重新持有互斥锁并且继续执行pthread_cond_wait后面的代码.</li></ul><h4 id="CS模型代码案例"><a href="#CS模型代码案例" class="headerlink" title="CS模型代码案例"></a>CS模型代码案例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<br><span class="hljs-type">pthread_cond_t</span> cond_var = PTHREAD_COND_INITIALIZER;<br><span class="hljs-type">int</span> shared_data = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 生产者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">while</span> (shared_data != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">// 条件判断</span><br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex);  <span class="hljs-comment">// 等待条件变量</span><br>    &#125;<br>    <br>    shared_data = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 生产数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;生产者生产数据: %d\n&quot;</span>, shared_data);<br>    <br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_var);  <span class="hljs-comment">// 唤醒消费者, 这时条件一定满足</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">// 释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 消费者线程函数</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);  <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-keyword">while</span> (shared_data == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond_var, &amp;mutex);  <span class="hljs-comment">// 等待条件变量</span><br>    &#125;<br>    <br>    shared_data = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 消费数据</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;消费者消费数据: %d\n&quot;</span>, shared_data);<br>    <br>    <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond_var);  <span class="hljs-comment">// 唤醒生产者, 这时条件一定满足</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);  <span class="hljs-comment">// 释放互斥锁</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">pthread_t</span> producer_thread, consumer_thread;<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;producer_thread, <span class="hljs-literal">NULL</span>, producer, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;consumer_thread, <span class="hljs-literal">NULL</span>, consumer, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_join</span>(producer_thread, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_join</span>(consumer_thread, <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutex);<br>    <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond_var);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程同步机制包装类"><a href="#线程同步机制包装类" class="headerlink" title="线程同步机制包装类"></a>线程同步机制包装类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> LOCKER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCKER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜exception＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜semaphore.h＞</span><br><br><span class="hljs-comment">/*封装信号量的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">sem</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化信号量*/</span><br>    <span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sem_init</span>(＆m_sem,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/*构造函数没有返回值，可以通过抛出异常来报告错误*/</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁信号量*/</span><br>    ～<span class="hljs-built_in">sem</span>()<br>    &#123;<br>        <span class="hljs-built_in">sem_destroy</span>(＆m_sem);<br>    &#125;<br><br>    <span class="hljs-comment">/*等待信号量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_wait</span>(＆m_sem)==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*增加信号量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">post</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sem_post</span>(＆m_sem)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">sem_t</span> m_sem;<br>&#125;;<br><br><span class="hljs-comment">/*封装互斥锁的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">locker</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化互斥锁*/</span><br>    <span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_mutex_init</span>(＆m_mutex,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁互斥锁*/</span><br>    ～<span class="hljs-built_in">locker</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>    &#125;<br><br>    <span class="hljs-comment">/*获取互斥锁*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_lock</span>(＆m_mutex)==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*释放互斥锁*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_unlock</span>(＆m_mutex)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>&#125;;<br><br><span class="hljs-comment">/*封装条件变量的类*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">cond</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/*创建并初始化条件变量*/</span><br>    <span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_mutex_init</span>(＆m_mutex,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">pthread_cond_init</span>(＆m_cond,<span class="hljs-literal">NULL</span>)!=<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/</span><br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*销毁条件变量*/</span><br>    ～<span class="hljs-built_in">cond</span>()<br>    &#123;<br>        <span class="hljs-built_in">pthread_mutex_destroy</span>(＆m_mutex);<br>        <span class="hljs-built_in">pthread_cond_destroy</span>(＆m_cond);<br>    &#125;<br><br>    <span class="hljs-comment">/*等待条件变量*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> ret=<span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(＆m_mutex);<br>        ret=<span class="hljs-built_in">pthread_cond_wait</span>(＆m_cond,＆m_mutex);<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(＆m_mutex);<br>        <span class="hljs-keyword">return</span> ret==<span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*唤醒等待条件变量的线程*/</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">signal</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(＆m_cond)==<span class="hljs-number">0</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> m_mutex;<br>    <span class="hljs-type">pthread_cond_t</span> m_cond;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h2 id="不可重入函数"><a href="#不可重入函数" class="headerlink" title="不可重入函数"></a>不可重入函数</h2><p>不可重入函数不能在多线程环境下使用, 因为其一般会使用到静态变量, 比如inet_ntoa等.</p><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>我们在上文已经知道线程之间信号处理共享并且信号掩码会继承但独立, 那么我们就可以设置一个单独的信号处理线程.</p><p>相关函数如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_sigmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>*newmask,<span class="hljs-type">sigset_t</span>*oldmask)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigwait</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span>*set,<span class="hljs-type">int</span>*sig)</span></span>;<br></code></pre></td></tr></table></figure><p>构建流程如下 : </p><ul><li>在主线程构建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码.</li><li>在信号处理线程中调用sigwait来等待信号并处理之.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜pthread.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdlib.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜errno.h＞</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> handle_error_en(en,msg) do&#123;errno=en;perror(msg);exit(EXIT_FAILURE);&#125;while(0)</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">sig_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">sigset_t</span>* set = (<span class="hljs-type">sigset_t</span>*)arg;<br>    <span class="hljs-type">int</span> s, sig;<br>    <span class="hljs-keyword">for</span>(;;)<br>    &#123;<br>        <span class="hljs-comment">/*第二个步骤，调用sigwait等待信号*/</span><br>        s = <span class="hljs-built_in">sigwait</span>(set, &amp;sig);<br>        <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;sigwait&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Signal handling thread got signal%d\n&quot;</span>, sig);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pthread_t</span> thread;<br>    <span class="hljs-type">sigset_t</span> set;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-comment">/*第一个步骤，在主线程中设置信号掩码*/</span><br>    <span class="hljs-built_in">sigemptyset</span>(&amp;set);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGQUIT);<br>    <span class="hljs-built_in">sigaddset</span>(&amp;set, SIGUSR1);<br>    s = <span class="hljs-built_in">pthread_sigmask</span>(SIG_BLOCK, &amp;set, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;pthread_sigmask&quot;</span>);<br>    s = <span class="hljs-built_in">pthread_create</span>(&amp;thread, <span class="hljs-literal">NULL</span>, &amp;sig_thread, (<span class="hljs-type">void</span>*)&amp;set);<br>    <span class="hljs-keyword">if</span>(s != <span class="hljs-number">0</span>)<br>        <span class="hljs-built_in">handle_error_en</span>(s, <span class="hljs-string">&quot;pthread_create&quot;</span>);<br>    <span class="hljs-built_in">pause</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程局部存储-TLS"><a href="#线程局部存储-TLS" class="headerlink" title="线程局部存储(TLS)"></a>线程局部存储(TLS)</h2><p>线程局部存储（TLS）是一种允许线程拥有独立数据的技术。这意味着每个线程都可以访问同名变量的不同实例，而这些变量在不同线程中不会互相干扰。TLS 在多线程环境中提供了一种为每个线程分配私有存储空间的机制。</p><p>简单来说可以理解为 : </p><ul><li><strong>TLS中的数据像线程的私有全局变量, 避免在各种函数间频繁传入常用的数据降低效率</strong>.</li></ul><p>在 POSIX 系统中，如果你使用 <code>pthread_key_create()</code> 来创建线程局部存储（TLS）键并且关联某些数据，那么你还需要提供一个销毁函数，这个销毁函数会在线程退出时自动调用，用来释放线程局部存储的数据。</p><p>销毁过程：</p><ul><li>在 <code>pthread_key_create()</code> 时，你可以指定一个销毁函数（destructor），这个函数会在线程退出时被调用。</li><li><code>pthread_key_delete()</code> 用于显式地删除一个 TLS 键，销毁相关的资源。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">pthread_key_t</span> t_key;  <span class="hljs-comment">// 定义 TLS 键</span><br><span class="hljs-comment">// 初始化（通常在程序启动时调用）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_tls</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">pthread_key_create</span>(&amp;t_key, [](<span class="hljs-type">void</span>* ptr) &#123;<br>        <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-comment">// 线程退出时自动释放资源</span><br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 设置线程局部值</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_tls_value</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    *ptr = value;<br>    <span class="hljs-built_in">pthread_setspecific</span>(t_key, ptr);<br>&#125;<br><span class="hljs-comment">// 获取线程局部值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_tls_value</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">pthread_getspecific</span>(t_key);<br>    <span class="hljs-keyword">return</span> ptr ? *ptr : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然以上是操作系统提供的TLS使用, 在实际使用中, GCC和C++11都有提供对应的TLS使用方式</p><ul><li>GCC : <strong><code>__thread</code></strong> 将该关键字置于变量前方, 就可以将该变量作为线程局部资源使用.</li><li>C++11 : <strong><code>thread_local</code></strong> 将该关键字置于变量前方, 也可以实现相同的效果.</li></ul><p>需要注意的一点是<code>__thread</code>只作用于POD类型变量, 而<code>thread_local</code>都可以, 因此更推荐使用<code>thread_local</code>.</p><p>在性能方面 : <code>__thread</code> &gt; <code>thread_local</code> &gt; <code>pthread_key_t</code>.</p><hr><h2 id="浅谈线程设计的初衷"><a href="#浅谈线程设计的初衷" class="headerlink" title="浅谈线程设计的初衷"></a>浅谈线程设计的初衷</h2><p>线程设计的初衷就是在于和多核CPU搭配实现同时并行处理多个任务, 我们可以简单理解线程的合理数量应当和CUP核数相当, 数量太少显示不出线程的优势, 数量太多其额外开销其实会非常多并且还吃力不讨好.</p>]]></content>
    
    
    
    <tags>
      
      <tag>多线程</tag>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被讨厌的勇气 读书摘录(2)</title>
    <link href="/2025/02/22/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/"/>
    <url>/2025/02/22/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/</url>
    
    <content type="html"><![CDATA[<ul><li>当人能够感觉到”与这个人在一切可以无拘无束”的时候, 才能体会到爱.</li><li>人究竟为什么要寻求别人的认可呢? 其实, 很多情况下都是因为赏罚教育的影响.</li><li>如果一味地寻求别人的认可, 在意别人的评价, 那最终就会活在别人的人生中.</li><li>我们必须从”这是谁的课题”这一观点出发, 把自己的课题和他人的课题分离开来.</li><li>基本上, 一切人际关系矛盾都起源于对别人的课题妄加干涉或自己的课题被别人妄加干涉.</li><li>可以把马带到水边, 但不能强迫其喝水, 能够改变自己的只有自己.</li><li>正因为是关系紧密的家人, 才更有必要有意识地去分离课题.</li><li>如果不分界限把自己的希望强加给他人, 那就变成粗暴的”干涉”了.</li><li>别人如何评价你的选择, 那是别人的课题, 你根本无法左右.</li><li>不干涉别人的课题, 也不让别人干涉自己的课题.</li><li>要想构筑良好的人际关系也需要保持一定的距离, 如果距离太近, 贴在一起, 那就无法与对方正面对话.</li><li>分离课题并不是以自我为中心, 相反, 干涉别人的课题才是以自我为中心的想法.</li><li>选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其享乐主义, 当然, 这其实是为了让自己接受不自由生活而捏造出的一种人生谎言.</li><li>把改变自己当成操纵他人的手段是一种极其错误的想法.</li><li>人际关系之卡总是掌握在自己手中, 如果执着于认可欲求, 那便是把人际关系之卡抛给了别人.</li><li>我们应该思考的不是他人为我做了什么, 而是我能为他人做什么, 并积极地加以实践.</li><li>对人而言, 最大的不幸就是不喜欢自己.</li><li>是否真正做出了贡献, 从原理上根本无从了解, 只要能够产生”我对他人有用”的主观感受就行.</li><li>所有的问题行为, 都是一种”廉价的优越性追求”.</li><li>普通不等于无能, 我们根本没必要特意炫耀自己的优越性.</li><li>如果感觉能够看得到过去也能预测未来, 那就证明你没有认真的活在此时此刻, 而是生活在模糊而微弱的灯光中.</li><li>聚焦此时此刻是认真而谨慎地做好现在能做的事情.</li><li>人生最大的谎言, 就是不活在此时此刻.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务编程 读书笔记(7)</title>
    <link href="/2025/02/22/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)/"/>
    <url>/2025/02/22/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(7)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第13章 多进程编程</p></blockquote><p>本章主要是讨论创建进程, 进程替换, 进程等待, 进程间通信, 最后一个占大头.</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>; <br></code></pre></td></tr></table></figure><p>这个只需要记住返回值的判断 : </p><ul><li><p><code>&lt; 0</code> : fork失败.</p></li><li><p><code>== 0 </code>: 属于子进程.</p></li><li><p><code>&gt; 0</code> : 属于父进程.</p></li></ul><p>子进程继承父进程的文件描述符表, 但是父进程设置的信号回调都回取消.</p><hr><h3 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>**environ;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*file,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">const</span> <span class="hljs-type">char</span>*arg,...,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*file,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path,<span class="hljs-type">char</span>*<span class="hljs-type">const</span> argv[],<span class="hljs-type">char</span>*<span class="hljs-type">const</span> envp[])</span></span>;<br></code></pre></td></tr></table></figure><hr><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><ul><li>子进程退出之后, 父进程读取其退出状态之前, 子进程都处于僵尸态, 这会占据内核资源, 需要调用wait释放子进程.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/types.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/wait.h＞</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span>*stat_loc)</span></span>;  <span class="hljs-comment">// 等待任一进程</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">int</span>*stat_loc,<span class="hljs-type">int</span> options)</span></span>;  <span class="hljs-comment">// 等待指定进程</span><br></code></pre></td></tr></table></figure><p>默认都是阻塞的, 但是waitpid如果options设置了WHOHANG, 就会变成非阻塞.</p><p>当一个进程结束时, 会向父进程发送SIGCHLD信号, 我们可以捕获这个信号, 在信号回调函数中使用非阻塞waitpid.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">handle_child</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">pid_t</span> pid;<br><span class="hljs-type">int</span> stat;<br><span class="hljs-keyword">while</span>((pid=<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,＆stat,WNOHANG))＞<span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">/*对结束的子进程进行善后处理*/</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>一种最经典的进程间通信就是管道, 这里不再详述.</p><p>接下来详述三种无关联进程间的通信方式, 这里需要注意虽然是无关进程, 但都是同一主机下的进程, 是依靠主机单独在内核中开辟出一些内容物实现的.</p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>我们首先要理解信号量是干什么的 : </p><p>它主要用来<strong>控制对共享资源的访问</strong>,  与其说它是进程间的一种通信方式, 不如说它<strong>可以管控进程间对共享内存的访问</strong>, 其有一个信号量资源, 进程可以调用函数将信号量进行加减操作, 当信号量归0时, 会限制之后需要访问共享内存的进程(挂起), 可以理解为这是<strong>一个有计数功能的专门针对共享资源的高级锁</strong>.</p><p>信号量的核心理念是对信号量进行处理, <strong>在设计共享资源的代码前后, 分别设置P操作和V操作</strong>,  P代表passeren(进入), 会减少信号量; V代表vrijgeven(退出), 会增加信号量. PV操作都有对应的函数可以触发. 你可以类比为P操作就是加锁, V操作就解锁.</p><p>关于信号量的系统函数有两套 : </p><ul><li>System V 信号量 : 早期信号量, 设置复杂, 但是老牌系统都在使用, 只适合多线程环境.</li><li>POSIX 信号量 : 比较简单易用, 适合多线程环境.</li></ul><p>我们先来学习System V信号量 : </p><h4 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sem.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key,<span class="hljs-type">int</span> num_sems,<span class="hljs-type">int</span> sem_flags)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来创建一个新的信号量集. </p><ul><li><p>key用来标识一个全局唯一的信号量集, 就是一个唯一关键字, 一般用ftok生成.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>num_sems是要设置的信号量的数目, 一般就一个. </p></li><li><p>最后一个一般0666, 设置访问权限.</p></li></ul><h4 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sem.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semctl</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id,<span class="hljs-type">int</span> sem_num,<span class="hljs-type">int</span> command,...)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数是用来对建立的信号量集进行设置的函数, </p><ul><li>sem_id : semget的返回值</li><li>sem_num : 信号量集中的索引, 设置为0代表选择信号集中的第一个.</li><li>command : 用来设置进行什么操作, SETVAL代表设置信号集, 后面加要设置的值.</li></ul><p>由于刚建立默认的信号量为0, 无法使用, 必须通过这个函数设置信号量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CONCURRENT 1   <span class="hljs-comment">// 同一时刻只允许一个进程访问共享内存</span></span><br><span class="hljs-built_in">semctl</span>(sem_id, <span class="hljs-number">0</span>, SETVAL, MAX_CONCURRENT);<br></code></pre></td></tr></table></figure><p>假如我们要共享的不是内存而是线程池, 那么这里就大有可为了, 可以根据当前线程池中线程的数量设置信号量, 可以对访问线程数进行限制.</p><h4 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">semop</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id,<span class="hljs-keyword">struct</span> sembuf*sem_ops,<span class="hljs-type">size_t</span> num_sem_ops)</span></span>;<br></code></pre></td></tr></table></figure><p>这函数用来进行实际的pv操作, sembuf的结构需要细致了解一下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_num;  <span class="hljs-comment">// 信号量的索引</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_op; <span class="hljs-comment">// 操作的数量</span><br><span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_flg;     <span class="hljs-comment">// 额外的属性</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个参数还是如果为0默认选第一个.</li><li>sem_op : p操作就是-1, v操作就是1.</li><li>sem_flg : 一般推荐加上SEM_UNDO, 这个参数的作用是设置回滚操作, 也就是说p操作完, 如果在触发v操作前进程崩溃了, 也会将p操作改变的值恢复回去.</li></ul><p>一般这样配置 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义信号量操作结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> p = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, SEM_UNDO&#125;;  <span class="hljs-comment">// wait 操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SEM_UNDO&#125;;   <span class="hljs-comment">// post 操作</span><br></code></pre></td></tr></table></figure><h4 id="示例：System-V-信号量控制并发数量"><a href="#示例：System-V-信号量控制并发数量" class="headerlink" title="示例：System V 信号量控制并发数量"></a>示例：System V 信号量控制并发数量</h4><p>假设我们有一个资源池，最多允许 3 个进程并发访问，我们会将信号量的初始值设置为 3。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_CONCURRENT 3</span><br><br><span class="hljs-comment">// 定义信号量操作结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> p = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, SEM_UNDO&#125;;  <span class="hljs-comment">// wait 操作</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> v = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SEM_UNDO&#125;;   <span class="hljs-comment">// post 操作</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">key_t</span> key = <span class="hljs-built_in">ftok</span>(<span class="hljs-string">&quot;semfile&quot;</span>, <span class="hljs-number">65</span>);   <span class="hljs-comment">// 创建 IPC 键</span><br>    <span class="hljs-type">int</span> sem_id = <span class="hljs-built_in">semget</span>(key, <span class="hljs-number">1</span>, IPC_CREAT | <span class="hljs-number">0666</span>);  <span class="hljs-comment">// 获取信号量</span><br><br>    <span class="hljs-comment">// 设置初始信号量值为 3，表示允许 3 个进程并发访问</span><br>    <span class="hljs-built_in">semctl</span>(sem_id, <span class="hljs-number">0</span>, SETVAL, MAX_CONCURRENT);<br><br>    <span class="hljs-comment">// 模拟进程访问资源</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;p, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) &#123;  <span class="hljs-comment">// 尝试获取信号量</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop p&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 访问共享资源</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process %d is accessing shared resource.\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 模拟工作</span><br><br>    <span class="hljs-comment">// 释放信号量</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;v, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) &#123;  <br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semop v&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Process %d finished accessing shared resource.\n&quot;</span>, <span class="hljs-built_in">getpid</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>共享内存也是SystemV和POSIX各有一套函数, 这里使用POSIX的. </p><p>简单来说就是向内核申请一块共享内存, 然后通过映射函数(mmap)将这块内存映射到进程的虚拟地址空间上, 使得进程操作这块内存可以像平常一样.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/stat.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜fcntl.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shm_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*name, <span class="hljs-type">int</span> oflag, <span class="hljs-type">mode_t</span> mode)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shm_unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span></span>;<br></code></pre></td></tr></table></figure><p>这个是用于申请创建共享内存的函数 : </p><ul><li>name : 名字自己起, 最好是”&#x2F;name”这种格式.</li><li>oflag : 用于指定创建方式, O_RDONLY &#x2F; O_RDWR &#x2F; O_CREAT </li><li>mode : 一般是0666</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ftruncate</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">off_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数通常要搭配shm_open使用, 它用于设定文件大小为length.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>start : 允许用户使用某个特定的地址作为这段内存的起始地址, 设置为NULL自动选择地址.</li><li>length : 内存段的长度.</li><li>port : 设置内存段的访问权限.</li><li>flags : 控制内存段内容被修改后程序的行为.</li><li>fd : 被映射文件对应的文件描述符, 这个通过shm_open生成.</li><li>offset : 设置从文件的何处开始映射.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(6)</title>
    <link href="/2025/02/19/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)/"/>
    <url>/2025/02/19/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(6)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第10章 信号</p><p>第11章 定时器</p><p>第12章 libevent</p></blockquote><p>网络服务器一般有三种事件需要处理 : IO事件, 信号事件, 定时器事件.</p><p>这三种事件都可以通过epoll函数来进行统一处理.</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h4 id="信号有什么作用"><a href="#信号有什么作用" class="headerlink" title="信号有什么作用?"></a>信号有什么作用?</h4><p>其实主要是为了处理一些特殊事件, 比如中断系统调用, 触发定时器信号, 管道读写失败发出的信号. 比如说中断进程, 在服务器上直接中断一般不是一个合理的做法, 一般会捕获中断信号, 在做出中断的准备后(如关闭连接, 释放内存, 记录日志)在进行中断进程.</p><h4 id="最重要的两个信号捕获函数"><a href="#最重要的两个信号捕获函数" class="headerlink" title="最重要的两个信号捕获函数"></a>最重要的两个信号捕获函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜signal.h＞</span><br><span class="hljs-function"><span class="hljs-type">_sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span>　sig, _sighandler_t_handler)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> sig, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction*act, <span class="hljs-keyword">struct</span> sigaction*oact)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="信号来源"><a href="#信号来源" class="headerlink" title="信号来源"></a>信号来源</h4><p>❑对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</p><p>❑系统异常。比如浮点异常和非法内存段访问。</p><p>❑系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</p><p>❑运行kill命令或调用kill函数。</p><p>服务器程序必须处理（或至少忽略）一些常见的信号，以免异常终止。</p><h4 id="统一事件源"><a href="#统一事件源" class="headerlink" title="统一事件源"></a>统一事件源</h4><p>听起来比较高端, 但其实就是把信号事件注册到epoll上, 让epoll可以通过if在处理IO事件的同时可以一并处理信号事件.</p><p>最基础的做法就是 : </p><ul><li>用signal或sigaction把需要捕获的信号获取</li><li>设置一个管道, 在信号回调函数中将信号转发给管道写端.</li><li>将管道的读端的读事件注册进内核事件表中.</li><li>在epoll_wait所在的循环中对管道的读端额外进行监视.</li></ul><p>你可以理解为对于IO事件, epoll通过将sockfd注册进事件表进行监视; 对于信号事件, epoll通过将管道读端注册进内核事件表进行监视.</p><p>以下是一个统一事件源的代码 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><br><span class="hljs-comment">/* 信号处理函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sig_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-type">int</span> save_errno = errno;<br>    <span class="hljs-type">int</span> msg = sig;<br>    <span class="hljs-built_in">send</span>(pipefd[<span class="hljs-number">1</span>], (<span class="hljs-type">char</span>*)&amp;msg, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-comment">/* 将信号值写入管道，以通知主循环 */</span><br>    errno = save_errno;<br>&#125;<br><br><span class="hljs-comment">/* 设置信号的处理函数 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addsig</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sigaction</span> sa;<br>    <span class="hljs-built_in">memset</span>(&amp;sa, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-built_in">sizeof</span>(sa));<br>    sa.sa_handler = sig_handler;<br>    sa.sa_flags |= SA_RESTART;<br>    <span class="hljs-built_in">sigfillset</span>(&amp;sa.sa_mask);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">sigaction</span>(sig, &amp;sa, <span class="hljs-literal">NULL</span>) != <span class="hljs-number">-1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is %d\n&quot;</span>, errno);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd);<br><br>    <span class="hljs-comment">/* 使用 socketpair 创建管道，注册 pipefd[0] 上的可读事件 */</span><br>    ret = <span class="hljs-built_in">socketpair</span>(PF_UNIX, SOCK_STREAM, <span class="hljs-number">0</span>, pipefd);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">setnonblocking</span>(pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">addfd</span>(epollfd, pipefd[<span class="hljs-number">0</span>]);  <br><br>    <span class="hljs-comment">/* 设置一些信号的处理函数 */</span><br>    <span class="hljs-built_in">addsig</span>(SIGHUP);<br>    <span class="hljs-built_in">addsig</span>(SIGCHLD);<br>    <span class="hljs-built_in">addsig</span>(SIGTERM);<br>    <span class="hljs-built_in">addsig</span>(SIGINT);<br><br>    <span class="hljs-type">bool</span> stop_server = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (!stop_server) &#123;<br>        <span class="hljs-type">int</span> number = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> ((number &lt; <span class="hljs-number">0</span>) &amp;&amp; (errno != EINTR)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++) &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br><br>            <span class="hljs-comment">/* 如果就绪的文件描述符是 listenfd，则处理新的连接 */</span><br>            <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);<br>                <span class="hljs-built_in">addfd</span>(epollfd, connfd);<br>            &#125;<br>            <span class="hljs-comment">/* 如果就绪的文件描述符是 pipefd[0]，则处理信号 */</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((sockfd == pipefd[<span class="hljs-number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;<br>                <span class="hljs-type">int</span> sig;<br>                <span class="hljs-type">char</span> signals[<span class="hljs-number">1024</span>];<br>                ret = <span class="hljs-built_in">recv</span>(pipefd[<span class="hljs-number">0</span>], signals, <span class="hljs-built_in">sizeof</span>(signals), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; ++i) &#123;<br>                        <span class="hljs-keyword">switch</span> (signals[i]) &#123;<br>                            <span class="hljs-keyword">case</span> SIGCHLD:<br>                            <span class="hljs-keyword">case</span> SIGHUP:<br>                                <span class="hljs-keyword">continue</span>;<br>                            <span class="hljs-keyword">case</span> SIGTERM:<br>                            <span class="hljs-keyword">case</span> SIGINT:<br>                                stop_server = <span class="hljs-literal">true</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close fds\n&quot;</span>);<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">close</span>(pipefd[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中比较重点的是 : </p><ul><li><code>ret = socketpair(PF_UNIX, SOCK_STREAM, 0, pipefd);</code> 通过socketpair激活pipefd对应的管道</li><li><code>addfd(epollfd, pipefd[0]);</code>  将管道读端注册进内核事件表</li><li><code>addsig</code>函数将需要捕获的信号进行捕获</li><li><code>else if ((sockfd == pipefd[0]) &amp;&amp; (events[i].events &amp; EPOLLIN))</code> 在循环中额外对信号事件做处理.</li></ul><hr><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>其实就是服务器有可能需要有定时触发的机制存在, 所以需要用到Linux中的定时机制.</p><p>Linux提供了三种定时方法，它们是：</p><p>❑socket选项SO_RCVTIMEO和SO_SNDTIMEO。</p><p>❑SIGALRM信号。</p><p>❑I&#x2F;O复用系统调用的超时参数。</p><p>这里比较重要的就是信号触发, SIGALRM是通过调用alarm函数传入触发时间来传出的, 很多定时器都基于这个实现.</p><p>定时器就是一个结构体, 里面一般包含了超时时间和回调函数, 我们在回调函数中处理定时任务.</p><p>最重要的如何实现定时触发, 一般是通过循环调用alarm实现每隔一段时间向系统发送一个SIGALRM信号, 通过统一事件源对SIGALRM信号做对应处理, 一般会调用一个心搏函数(tick), 对所有时间已经超时的定时器调用其回调函数执行定时任务.</p><p>这里还要思考的一个问题是, 定时任务有可能会很多, 我们需要一个容器来装载这些定时器, 考虑到一定是离超时时间越近的会越先被处理, 那么这个用来存储的容器就有一个需要排序的需求, 超时时间越小就越靠前.</p><p>这里有三种容器可供选择 : 链表, 时间轮, 时间堆.</p><ul><li><p>链表 : 从链表的性质判断, 如果要保持链表有序, 插入效率O(N), 删除和执行的效率都是O(1).</p><p>其实这个效率已经不错了, 虽然在理论上不一定比后两种强, 但是考虑到定时器事件在一般情况下需求量很小, 由于链表没有多余操作反而效率会高, 因此libevent也是依据情况在链表和时间堆直接进行选择的.</p></li><li><p>时间轮 : 你可以理解为这是一个环状的哈希表, 每收到一次定时信号就触发环上的一块, 轮转触发.</p></li><li><p>时间堆 : 这就是一个小根堆, 你甚至可以直接用C++的priority_queue来实现这个时间堆, 其插入效率O(lgn), 删除和执行都是O(1), 在理论上确实优于链表.</p></li></ul><hr><h2 id="Libevent-—-高性能I-O框架库"><a href="#Libevent-—-高性能I-O框架库" class="headerlink" title="Libevent — 高性能I&#x2F;O框架库"></a>Libevent — 高性能I&#x2F;O框架库</h2><p>其实就是一个对我们之前学的I&#x2F;O复用函数和信号和定时器进行分装的一个库.</p><p>它实现了 : 统一事件源 &#x2F; 可移植性 &#x2F; 对并发编程的支持.</p><p>使用方法和epoll有类似的地方, 但是简化了大量的步骤, 并且可以用非常接近的使用方法设置IO事件&#x2F;信号事件&#x2F;定时器事件的回调函数.</p><ul><li><p>event_base_new(); </p><p>用于创建一个event_base对象, 你可以理解为这就是一个Reactor实例(基于IO复用的事件处理器).</p></li><li><p>event_new(…) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">event</span>* <span class="hljs-built_in">event_new</span>(<span class="hljs-keyword">struct</span> event_base *base,<span class="hljs-comment">// 对应的Reactor实例</span><br>                        <span class="hljs-type">evutil_socket_t</span> fd,<span class="hljs-comment">// 对应事件的文件描述符</span><br>                        <span class="hljs-type">int</span> events,<span class="hljs-comment">// 要注册的事件</span><br>                        event_callback_fn callback,<span class="hljs-comment">// 事件回调函数</span><br>                        <span class="hljs-type">void</span> *arg);<span class="hljs-comment">// 事件回调函数需要的参数</span><br></code></pre></td></tr></table></figure><p>这个函数用于注册事件,  三种事件都可以在这个函数中处理 : </p><ul><li><p>fd : 文件描述符, IO事件就是对应socket, 信号事件是对应信号枚举, 定时器事件设置为-1.</p></li><li><p>events : 主要用于描述事件</p><p><code>EV_READ</code>：表示关注文件描述符上的读事件。</p><p><code>EV_WRITE</code>：表示关注文件描述符上的写事件。</p><p><code>EV_SIGNAL</code>：表示关注特定信号事件。</p><p><code>EV_TIMEOUT</code>：表示关注超时事件（定时器）。</p><p><code>EV_PERSIST</code>：表示该事件在触发后不会自动移除，必须手动移除事件。</p><p><code>EV_ET</code>：表示使用边缘触发模式（Edge Triggered）。</p></li><li><p>callback :  需要放入一个event_callback_fn类型的回调函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">void</span>(*回调函数名)(<span class="hljs-type">evutil_socket_t</span>,<span class="hljs-type">short</span>,<span class="hljs-type">void</span>*arg);  <span class="hljs-comment">// 所有回调函数形式必须是这样</span><br></code></pre></td></tr></table></figure></li><li><p>arg : 用于存放callback需要的参数, 你可以和线程创建相类比.</p></li></ul></li><li><p>event_add(…)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">event_add</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> event *ev, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *tv)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用于激活base中的这个事件, event_new负责注册事件, 这个负责激活事件.</p><ul><li>ev : 用event_new构建出来的事件处理器.</li><li>tv : 一个时间参数, IO和信号填NULL就行, 定时器事件需要在这里填入所确定的延时.</li></ul></li><li><p>event_base_dispatch(base); </p><p>这个函数就是触发事件处理器开始循环监视的参数, 进程将阻塞在这里.</p></li><li><p>event_free(struct event *ev);</p></li></ul><p>  释放事件结构体.</p><ul><li><p>event_base_free(struct event_base *base);</p><p>释放事件处理器结构体.</p></li></ul><p>还要注意的是这里的事件被event_new出来并没有被激活, 只有在event_add后才算被激活, 只有激活的事件才会在event_base_dispatch中被处理, 另外如果没有给事件设置<code>EV_PERSIST</code>属性, 事件在触发一次后就会自动被删除, 必须重新add, 但是如果有这个属性, 那么在触发后会依旧处于激活状态, 除非手动event_del.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(5)</title>
    <link href="/2025/02/16/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)/"/>
    <url>/2025/02/16/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(5)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>第九章 I&#x2F;O复用(1)</p></blockquote><p>本节主要描述三个IO复用函数, select &#x2F; poll &#x2F; epoll.</p><p>这里对select &#x2F; poll只做简要描述, 对epoll做详尽描述.</p><p>所谓I&#x2F;O复用, 就是使程序可通过一些函数<strong>同时监听多个文件描述符</strong>(如socket), 可以即使并发对这些文件描述符上的事件进行处理.</p><p>要注意的一点是I&#x2F;O复用函数本身是<strong>阻塞</strong>的, 它属于同步IO的范畴, 其被广泛使用是因为其同时监听的特性可以大幅提升处理效率.</p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/select.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">select</span><span class="hljs-params">(<span class="hljs-type">int</span> nfds,fd_set*readfds, fd_set*writefds, fd_set*exceptfds, <span class="hljs-keyword">struct</span> timeval*timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>nfds : 指定被监听的文件总数.</p></li><li><p>fd_set : 一个整型数组, 其实就是用来存储文件描述符的</p><ul><li>readfds &#x2F; writefds &#x2F; exceptfds 分别对应可读可写异常事件对应的文件描述符集合.</li></ul></li><li><p>timeout : 用来告诉程序select阻塞等待了多久, 是输出型参数.</p></li></ul><hr><h3 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h3><p>我们需要认识哪些情况下文件描述符可以被认为是可读、可写或者出现异常.</p><p>下列情况下socket可读：</p><p>❑socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</p><p>❑socket通信的对方关闭连接。此时对该socket的读操作将返回0。</p><p>❑监听socket上有新的连接请求。</p><p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p><p>下列情况下socket可写：</p><p>❑socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</p><p>❑socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</p><p>❑socket使用非阻塞connect连接成功或者失败（超时）之后。</p><p>❑socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</p><hr><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜poll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pollfd*fds, <span class="hljs-type">nfds_t</span> nfds,<span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>nfds其实就是一个整数, 用来记录fds的大小.</p></li><li><p>timeout记录了poll的阻塞超时值, 设置为-1则始终处于阻塞, 0则立即返回.</p></li><li><p>fds需要细讲, 它是一个pollfd类型的数组, pollfd的结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span><br>&#123;<br><span class="hljs-type">int</span> fd;<span class="hljs-comment">/*文件描述符*/</span><br><span class="hljs-type">short</span> events;<span class="hljs-comment">/*注册的事件*/</span><br><span class="hljs-type">short</span> revents;<span class="hljs-comment">/*实际发生的事件，由内核填充*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>fd : 就是要监视的文件描述符.</li><li>events : 这里由用户填入关心的事件.</li><li>revents : 这里会返回实际发生的事件, 由内核填充. 这里返回的事件只会和用户关心的事件有关. &lt;输出型参数&gt;</li></ul><p>在poll中事件用enum列举了出来 : </p><ul><li>POLLIN : 数据可读.</li><li>POLLOUT : 数据可写.</li><li>POLKLERR : 错误.</li><li>POLLHUP : 文件描述符被挂起.</li><li>POLLNVAL : 文件描述符没有被打开.</li><li>……</li></ul></li></ul><p>​和select相比, 可以理解为select只关心读写异常这三个事件, 而poll可通过在fds数组中设置实现对事件的关心和监视.</p><h4 id="poll使用方式"><a href="#poll使用方式" class="headerlink" title="poll使用方式"></a>poll使用方式</h4><p>我们首先要明确的就是这I&#x2F;O复用函数监视的是事件, 不是fd, <strong>是fd上发生的事件</strong>, 这个事件一般是就绪读和就绪写事件.</p><p>我们使用poll首先要设置fds数组 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化 pollfd 数组</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> fds[MAX_CLIENTS + <span class="hljs-number">1</span>]; <span class="hljs-comment">// +1 用于服务器 socket</span><br><span class="hljs-type">int</span> nfds = <span class="hljs-number">1</span>; <span class="hljs-comment">// 当前监视的文件描述符数量</span><br><br><span class="hljs-comment">// 将服务器 socket 添加到 pollfd 数组中</span><br>fds[<span class="hljs-number">0</span>].fd = server_fd;<br>fds[<span class="hljs-number">0</span>].events = POLLIN; <span class="hljs-comment">// 监视可读事件</span><br><br><span class="hljs-comment">// 初始化客户端文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= MAX_CLIENTS; i++) &#123;<br>    fds[i].fd = <span class="hljs-number">-1</span>; <span class="hljs-comment">// -1 表示未使用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后将其传入poll函数, 程序运行到这里就会阻塞监听设置fd上的事件了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds, nfds, <span class="hljs-number">-1</span>); <span class="hljs-comment">// -1 表示无限等待</span><br></code></pre></td></tr></table></figure><p>监听的事件发生后就会返回, 然后我们就需要遍历fds, 查看里面的revents, 如果什么都没有发生为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查所有文件描述符</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nfds; i++) &#123;<br>    <span class="hljs-keyword">if</span> (fds[i].revents == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 没有事件发生</span><br>    &#125;<br>    <span class="hljs-comment">// 不为0说明事件发生, 下面可以开始处理事件逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="epoll系列函数"><a href="#epoll系列函数" class="headerlink" title="epoll系列函数"></a>epoll系列函数</h3><p>没错, epoll不是一个函数, 而是一系列函数, 包括epoll_create &#x2F; epoll_ctl &#x2F; epoll_wait函数等.</p><p>你可以理解为其是poll函数的升级版, 它把类似设置fds的行为利用函数在内核中实现, 并且还增加了很多提升效率的功能, 可以说是前两个函数的上位替代, 唯一不足的就是这个函数是Linux专属, 存在跨平台的问题.</p><h4 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>size用于提示事件表具体有多大, 无需准确, 这只是一个提示.</li></ul><p>重要的是这个函数的返回值, 调用该函数会在内核创建一个事件表, 就类似于poll需要自己创建的fds, 函数返回值是<strong>这个事件表的文件描述符</strong>, 一般被叫做epid, 这个返回值会被用作下一个函数<strong>epoll_ctl的第一个参数</strong>.</p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd, <span class="hljs-type">int</span> op, <span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> epoll_event*event)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>epfd : 用于指定对哪个内核事件表进行操作, 由epoll_create生成.</p></li><li><p>op : 指定操作类型, 三种, EPOLL_CTL_ADD(注册事件) &#x2F; EPOLL_CTL_MOD(修改事件) &#x2F; EPOLL_CTL_DEL(删除事件).</p></li><li><p>fd : 指定fd;</p></li><li><p>event : 用于存放事件类型和事件发生后可能需要的数据.</p><p>epoll_event的结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span><br>&#123;<br><span class="hljs-type">__uint32_t</span> events;<span class="hljs-comment">/*epoll事件*/</span><br><span class="hljs-type">epoll_data_t</span> data;<span class="hljs-comment">/*用户数据*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>events : 和poll中使用方法一致, 事件类型还是那些, 只不过前面要加一个”E”, 另外还加入了两个特殊事件EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键，我们将在后面讨论它们.</li><li>data : 这是一个联合体, 这里其实就是ptr和fd二选一, 我们在poll的pollfd结构体中由一个fd, 这里的fd与之效用相同, 都是为了在事件发生时可以及时使用到事件发生对应socket的fd. 这里ptr其实就是给出一个选择可以自定义一个结构体, 可以不只存入fd, 还可以存入其他需要的信息(例如提前分配的缓冲区的指针, 缓冲区大小).</li></ul><p>epoll_data_t结构如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">epoll_data</span><br>&#123;<br><span class="hljs-type">void</span>*ptr;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">uint32_t</span> u32;<br><span class="hljs-type">uint64_t</span> u64;<br>&#125;<span class="hljs-type">epoll_data_t</span>;<br></code></pre></td></tr></table></figure></li></ul><p>epoll_ctl成功返回0, 失败返回-1并设置errno.</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><p>这个函数才是epoll真正的执行函数, 前面两个函数都是再进行前置条件的设置, 调用epoll_wait才会开始阻塞进行实际的监视.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/epoll.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> epfd,<span class="hljs-keyword">struct</span> epoll_event*events,<span class="hljs-type">int</span> maxevents,<span class="hljs-type">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>我们看它的参数其实和poll函数非常相似.</p><ul><li>epfd : 选择进行监视的内核事件表.</li><li>events : 这个参数和epoll_ctl中event类型一致, 但是<strong>用法不一样</strong>, 在epoll_ctl中的event是只是单独一个, 目的是为了注册一个fd对应的事件. 在这里events是一个数组, 这是一个<strong>输出型参数</strong>, 用于<strong>存储所有触发了的事件</strong>.</li><li>maxevents : 最多监听多少个事件.</li><li>timeout : 同poll.</li></ul><p>一旦内核事件表中的事件已就绪, epoll_wait将会退出阻塞, 返回就绪的事件个数, 我们便可以去循环遍历events, 对其中的fd进行对应的读写操作.</p><hr><h3 id="poll和epoll的对比"><a href="#poll和epoll的对比" class="headerlink" title="poll和epoll的对比"></a>poll和epoll的对比</h3><p>我们可以感觉到epoll其实是讲poll中许多设置的细节分配到函数中, 并且将这些操作在内核中执行, 使之更加高效.</p><p>另外poll中的fds参数其实兼顾了输入与输出, 这就导致在输出时需要循环判断之前设置的所有事件, 其时间复杂度为O(N). 但epoll中输入由epoll_ctl中的event完成, 输出由epoll_wait中的events完成, events中只包含已就绪的事件, 而不需要再像poll一样循环判断, 其时间复杂度为O(1), 我们可以从下面的代码中直观看出 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*如何索引poll返回的就绪文件描述符*/</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i)<br>&#123;<br><span class="hljs-keyword">if</span>(fds[i].revents &amp; POLLIN)<span class="hljs-comment">/*判断第i个文件描述符是否就绪*/</span><br>&#123;<br><span class="hljs-type">int</span> sockfd=fds[i].fd;<br><span class="hljs-comment">/*处理sockfd*/</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*如何索引epoll返回的就绪文件描述符*/</span><br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd,events,MAX_EVENT_NUMBER,<span class="hljs-number">-1</span>);<br><span class="hljs-comment">/*仅遍历就绪的ret个文件描述符*/</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++)<br>&#123;<br><span class="hljs-type">int</span> sockfd=events[i].data.fd;<br><span class="hljs-comment">/*sockfd肯定就绪，直接处理*/</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="LT-和-ET-模式"><a href="#LT-和-ET-模式" class="headerlink" title="LT 和 ET 模式"></a>LT 和 ET 模式</h3><p>根据名字来分析没什么意义, 这里大可以理解为普通模式和高效模式, select和poll都限定普通模式, epoll可以选择普通模式和高效模式, 高效(ET)模式优势在于<strong>减少epoll_wait触发事件的次数从而提高整体效率</strong>, 劣势在于编程难度提高并且兼容性下降(其实不太有).</p><p>认识LT和ET的差别之前, 我们需要认识到, 数据会被内核接收缓冲区接收, 用户要将其通过recv等操作读到用户自己定义的缓冲区中进行处理, 而用户缓冲区和内核接收缓冲区是有本质大小区别的, 用户自己定义的缓冲区不能太大, 因为太大会占用过多内存导致效率下降, 而内核接收缓冲区比较大, 也就是说接收到的数据量有可能很多, 一次读取(recv)可能根本无法读完, LT和ET模式便是在处这种情况的方式上有所差异.</p><p>LT和ET的差别在于 : </p><ul><li>LT模式下, 每次只读满用户缓冲区大小的数据就退出, 通过epoll_wait多次触发事件来读完.</li><li>ET模式下, 一个事件只能被epoll_wait触发一次, 也就是说每次要循环读取数据到用户缓冲区, 直到内核接收缓冲区读完.</li></ul><p>在实操中,  ET模式是对单个fd对应的监听事件设置的, 触发ET模式需要我们对epoll_wait的第四个参数<code>struct epoll_event*event</code>,  其中<code>epoll_event</code>中的events进行设置, 和添加监视读事件一样添加<code>EPOLLET</code>这个参数, 相当于把当前fd监听的事件附加一个ET属性. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> enable_et)</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<span class="hljs-comment">// 监视读就绪事件</span><br>    <span class="hljs-keyword">if</span> (enable_et)<br>    &#123;<br>        event.events |= EPOLLET;<span class="hljs-comment">// 开始ET模式</span><br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);  <span class="hljs-comment">// 将这个事件加进内核事件表中</span><br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数便是向内核事件表注册一个监听fd读事件并且依据enable_et来决定是否使用ET模式的函数, 在我们下面的例子中要用到.</p><p>接下来将展示书中的一份代码, 用于展示LT和ET模式的区别, 本质是一个TCP服务器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 10</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> enable_et)</span></span><br><span class="hljs-function"></span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN;<br>    <span class="hljs-keyword">if</span> (enable_et)<br>    &#123;<br>        event.events |= EPOLLET;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lt</span><span class="hljs-params">(epoll_event *events, <span class="hljs-type">int</span> number, <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> listenfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span> (sockfd == listenfd)<br>        &#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>            <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-built_in">close</span>(sockfd);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">et</span><span class="hljs-params">(epoll_event *events, <span class="hljs-type">int</span> number, <span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> listenfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; number; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>        <span class="hljs-keyword">if</span> (sockfd == listenfd)<br>        &#123;<br>            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>            <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>            <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>            <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;event trigger once\n&quot;</span>);<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>                <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK))<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-built_in">close</span>(sockfd);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-built_in">close</span>(sockfd);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-built_in">lt</span>(events, ret, epollfd, listenfd);       <span class="hljs-comment">// LT模式对应的处理方式</span><br>        <span class="hljs-comment">// et(events, ret, epollfd, listenfd);  // ET模式对应的处理方式</span><br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里建议好好分析以下代码再看下面每个函数的作用.</p><ul><li><p>int setnonblocking(int fd)</p><p>这个函数用途是将socket读写操作设置为非阻塞, LT设不设置都行, 因为只读一次并且调用时已经处于读就绪情况. 而ET必须要设置, 因为我们可以看到ET模式下要一直循环读取直到errno为<code>EAGAIN</code>或<code>EWOULDBLOCK</code>才会停止, 如果不是非阻塞读不到数据就卡住了.</p></li><li><p>void addfd(int epollfd, int fd, bool enable_et)</p><p>这个函数就是把注册一个和fd相关的事件到内核事件表上, 可以选择是否开启ET模式.</p></li><li><p>main函数</p><p>很简易地实现了实现了一个TCP连接的接收, 需要注意的是在实现listen操作后, 我们利用addfd把listenfd注册到了内核事件表中, 然后进入到epoll_wait的无限循环中, epoll_wait会对listenfd上的读就绪事件做出反应并触发下面的lt&#x2F;et函数.</p></li><li><p>lt &#x2F; et 函数</p><p>这个函数会接收epoll_wait输出的就绪事件数组, 并遍历进行事件处理.</p><p>通过分析每个事件对应的fd, 判断是listenfd中的建立连接请求事件(sockfd &#x3D;&#x3D; listenfd), 还是普通socket的读就绪事件(events[i].events &amp; EPOLLIN).</p><p>如果是建立连接的请求, 先通过accept得到普通的socketfd, 然后利用addfd将其加入内核事件表中, 根据调用的是lt还是et选择是否启用ET模式, 在这之后epoll_wait也会对这些普通socketfd的读就绪事件做出反应.</p><p>如果是普通读, 则调用recv进行数据读取与处理, 这里LT模式只读取一次就退出, ET模式要持续循环读取直到内核缓冲区被读完.</p></li></ul><p>这里用户缓冲区设置为10, 这里设置的偏小, 但是便于测试, 通过测试我们可以发现确实ET模式下事件的触发次数要少很多 : </p><p><img src="/../img/image/1.png"></p><h4 id="为什么-non-blocking-I-O-和-I-O复用-要同时使用"><a href="#为什么-non-blocking-I-O-和-I-O复用-要同时使用" class="headerlink" title="为什么 non-blocking I&#x2F;O 和 I&#x2F;O复用 要同时使用?"></a>为什么 non-blocking I&#x2F;O 和 I&#x2F;O复用 要同时使用?</h4><p>主要是因为如果输入输出函数是阻塞的话, 就有可能会触发阻塞, 一旦在一个socket事件上触发阻塞, 就无法再处理其他socket上的事件了.尤其是再epoll开ET模式的情况下, 需要利用循环反复读取做到一次性读出数据, 而退出循环的方式就是依靠非阻塞I&#x2F;O的返回值来实现的, 如果不使用非阻塞, 就一定会在读完后触发阻塞.</p><h4 id="选择ET一定好吗"><a href="#选择ET一定好吗" class="headerlink" title="选择ET一定好吗?"></a>选择ET一定好吗?</h4><p>这个并不一定, 因为其优势在于减少epoll_wait的触发频率, 如果数据收发量没有极端的高时, 其实和LT相差不大, 其适用的场景是连接数极大且为短连接的情况, 在此之外使用ET其实是给客户提供负担, 因为其要求必须进行循环一次性读完, 用户可能处理不好这种情况.</p><hr><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>这也是类似ET一样可以设置的一个事件属性, 原因是因为一个socket注册的事件可能被触发多次, 如果在<strong>多线程环境</strong>下, 就会出现<strong>两个线程同时操作一个socket</strong>的局面, 这是万万不可的, 一个socket的读事件就应当被一个线程包揽, 不然数据的连贯性就缺失了, 进而处理基本必定失败. </p><p>这一点可以使用epoll的EPOLLONESHOT事件避免.</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。这样，当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。但反过来思考，注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p><p>书中的示例代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EVENT_NUMBER 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">fds</span> &#123;<br>    <span class="hljs-type">int</span> epollfd;<br>    <span class="hljs-type">int</span> sockfd;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setnonblocking</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    <span class="hljs-type">int</span> old_option = <span class="hljs-built_in">fcntl</span>(fd, F_GETFL);<br>    <span class="hljs-type">int</span> new_option = old_option | O_NONBLOCK;<br>    <span class="hljs-built_in">fcntl</span>(fd, F_SETFL, new_option);<br>    <span class="hljs-keyword">return</span> old_option;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addfd</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd, <span class="hljs-type">bool</span> oneshot)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET;<br>    <span class="hljs-keyword">if</span> (oneshot) &#123;<br>        event.events |= EPOLLONESHOT;<br>    &#125;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, fd, &amp;event);<br>    <span class="hljs-built_in">setnonblocking</span>(fd);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset_oneshot</span><span class="hljs-params">(<span class="hljs-type">int</span> epollfd, <span class="hljs-type">int</span> fd)</span> </span>&#123;<br>    epoll_event event;<br>    event.data.fd = fd;<br>    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;<br>    <span class="hljs-built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_MOD, fd, &amp;event);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">worker</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sockfd = ((fds*)arg)-&gt;sockfd;<br>    <span class="hljs-type">int</span> epollfd = ((fds*)arg)-&gt;epollfd;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);<br>    <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(sockfd, buf, BUFFER_SIZE - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">close</span>(sockfd);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;foreiner closed the connection\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EAGAIN) &#123;<br>                <span class="hljs-built_in">reset_oneshot</span>(epollfd, sockfd);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read later\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get content:%s\n&quot;</span>, buf);<br>            <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br>    ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br>    epoll_event events[MAX_EVENT_NUMBER];<br>    <span class="hljs-type">int</span> epollfd = <span class="hljs-built_in">epoll_create</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(epollfd != <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">addfd</span>(epollfd, listenfd, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll failure\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ret; i++) &#123;<br>            <span class="hljs-type">int</span> sockfd = events[i].data.fd;<br>            <span class="hljs-keyword">if</span> (sockfd == listenfd) &#123;<br>                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>                <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>                <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_address, &amp;client_addrlength);<br>                <span class="hljs-built_in">addfd</span>(epollfd, connfd, <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;<br>                <span class="hljs-type">pthread_t</span> thread;<br>                fds fds_for_new_worker;<br>                fds_for_new_worker.epollfd = epollfd;<br>                fds_for_new_worker.sockfd = sockfd;<br>                <span class="hljs-built_in">pthread_create</span>(&amp;thread, <span class="hljs-literal">NULL</span>, worker, (<span class="hljs-type">void</span>*)&amp;fds_for_new_worker);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;something else happened\n&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实内容和上一个例子大差不差, 多的就是普通读改为使用多线程, 并且读完要调用reset_oneshot重新设置EPOLLONESHOT这一事件属性, 这样可以保证同一时间只有一个线程读取一个socket.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(4)</title>
    <link href="/2025/02/15/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/"/>
    <url>/2025/02/15/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(4)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第八章 高性能服务器程序框架</strong></p></blockquote><p>本章意在抛出一些核心的概念, 实操基本没有, 但是这些概念的理解我认为相对重要, 我会以口语化的形式简要描述.</p><h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><ul><li>C&#x2F;S模型 : 客户端&#x2F;服务端, 最基础的服务器模型, 资源集中在服务端, 主要是客户端向服务端申请资源.</li><li>p2p模型 : 每个主机都可以是客户端和服务端, 每个主机上都会存有一定的资源, 每个主机利用洪泛向每个点申请资源.</li></ul><hr><h2 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h2><p><img src="/../img/image/2.png"></p><ul><li>I&#x2F;O处理单元 : 用于处理客户连接, 实现负载均衡, 可以用主线程实现, 也可以直接用Nginx.</li><li>逻辑单元 : 一般是一个进程或线程, 一般用于处理核心逻辑, 也可进行数据的收发(依事件处理模式而定).</li><li>网络存储单元 : 就是数据库, 比如mysql.</li><li>请求队列 : 就是以上三者之间通信方式的抽象, 一般用池实现, 里面存放已经建立好的TCP连接.</li></ul><hr><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><p>其实就在确定数据在收发时是阻塞还是非阻塞, 是同步还是异步.</p><ul><li><p>阻塞和非阻塞属于<strong>数据准备</strong>阶段, 是系统IO操作的<strong>就绪状态</strong>.</p></li><li><p>同步和异步属于<strong>数据读写</strong>阶段, 是<strong>应用程序和内核的交互方式</strong>.</p></li><li><p>阻塞 : 在IO操作就绪时, 进程将被阻塞, 等待IO数据收发.</p></li><li><p>非阻塞 : 在IO操作就绪时, 会立即做出判断, 给出返回值, 退出函数, 通过返回值判断收发是否正常.</p></li><li><p>同步I&#x2F;O : 读写操作在IO事件发生之后, 由应用程序本身完成.</p><p>阻塞IO &#x2F; IO复用 &#x2F; SIGIO信号 都属于同步IO</p></li><li><p>异步I&#x2F;O : 读写操作由内核完成, 应用程序只是提前设置缓冲区位置和IO操作完成后的通知函数.</p></li></ul><hr><h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><p>服务器程序通常需要处理三类事件：I&#x2F;O事件、信号及定时事件。</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>这是一种同步IO模式, 其中线程分为主线程和工作线程, 主线程负责监视socket是否有信息发送过来, 工作线程负责读写以及核心逻辑.</p><p>简略步骤如下 : </p><ul><li>主线程通过epoll注册socket的读就绪事件. </li><li>主线程调用epoll_wait等待注册的socket发来消息.</li><li>某个socket可读时, 将其分发给工作线程.</li><li>工作线程进行读取并处理核心逻辑, 如果需要回复, 就用ekpoll注册写就绪事件.</li><li>主线程也会调用epoll_wait等待写事件.</li><li>当socket可写时, 主线程再将其分发给一个工作进程进行写操作.</li></ul><p><img src="/../img/3.png"></p><h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>一种异步IO模式, 基础思想与Reactor模式一直, 但是利用异步IO的机制减去了工作线程的读写工作, 读写工作由内核实现, 只需要设置通知函数唤醒工作线程.</p><p><img src="/../img/image/4.png"></p><hr><h2 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h2><p>这个名字真的很高端, 但实际有更简单的理解.</p><p>这是一个逻辑单元内部的高效编程手法, 可以简单理解为把一个事务分解成多个执行的阶段, 用enum把这些状态列举出来, 再用switch通过判断当前事务状态来分别调用对应的处理函数. </p><p>比如我们要对HTTP请求进行读取和分析, http报文有请求行&#x2F;请求报头&#x2F;请求正文三个部分, 由于TCP传输一次传输可能不完整, 我们可能读不完全, 我们可以把状态分为请求行读取, 报头读取, 正文读取, 在不同的状态执行不同的读写操作和处理操作. 并且我们也应当设置合理的状态转移, 比如当前状态为请求行读取, 在相关操作处理完后, 那么状态就应当被转化为报头读取.</p><p>下面是完整的代码, 确实非常冗长, 上面这一段算是我最精简的概括了, 其实经过求证其实也没有多大必要去详细记住, 因为现在有很多的http库可以解决这方面的问题, 我们主要是重在理解这个概念.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 4096 <span class="hljs-comment">/* 读缓冲区大小 */</span></span><br><br><span class="hljs-comment">/* 主状态机的两种可能状态，分别表示：当前正在分析请求行，当前正在分析头部字段 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">CHECK_STATE</span> &#123;<br>    CHECK_STATE_REQUESTLINE = <span class="hljs-number">0</span>,<br>    CHECK_STATE_HEADER<br>&#125;;<br><br><span class="hljs-comment">/* 从状态机的三种可能状态，即行的读取状态，分别表示：读取到一个完整的行、行出错和行数据尚且不完整 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">LINE_STATUS</span> &#123;<br>    LINE_OK = <span class="hljs-number">0</span>,<br>    LINE_BAD,<br>    LINE_OPEN<br>&#125;;<br><br><span class="hljs-comment">/* 服务器处理HTTP请求的结果：NO_REQUEST表示请求不完整，需要继续读取客户数据；GET_REQUEST表示获得了一个完整的客户请求；BAD_REQUEST表示客户请求有语法错误；FORBIDDEN_REQUEST表示客户对资源没有足够的访问权限；INTERNAL_ERROR表示服务器内部错误；CLOSED_CONNECTION表示客户端已经关闭连接了 */</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HTTP_CODE</span> &#123;<br>    NO_REQUEST,<br>    GET_REQUEST,<br>    BAD_REQUEST,<br>    FORBIDDEN_REQUEST,<br>    INTERNAL_ERROR,<br>    CLOSED_CONNECTION<br>&#125;;<br><br><span class="hljs-comment">/* 为了简化问题，我们没有给客户端发送一个完整的HTTP应答报文，而只是根据服务器的处理结果发送如下成功或失败信息 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *szret[] = &#123;<span class="hljs-string">&quot;I get a correct result\n&quot;</span>, <span class="hljs-string">&quot;Something wrong\n&quot;</span>&#125;;<br><br><span class="hljs-comment">/* 从状态机，用于解析出一行内容 */</span><br><span class="hljs-function">LINE_STATUS <span class="hljs-title">parse_line</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> &amp;checked_index, <span class="hljs-type">int</span> &amp;read_index)</span> </span>&#123;<br>    <span class="hljs-type">char</span> temp;<br>    <span class="hljs-comment">/* checked_index指向buffer（应用程序的读缓冲区）中当前正在分析的字节，read_index指向buffer中客户数据的尾部的下一字节。buffer中第0～checked_index字节都已分析完毕，第checked_index～(read_index-1)字节由下面的循环挨个分析 */</span><br>    <span class="hljs-keyword">for</span> (; checked_index &lt; read_index; ++checked_index) &#123;<br>        <span class="hljs-comment">/* 获得当前要分析的字节 */</span><br>        temp = buffer[checked_index];<br>        <span class="hljs-comment">/* 如果当前的字节是“\r”，即回车符，则说明可能读取到一个完整的行 */</span><br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-string">&#x27;\r&#x27;</span>) &#123;<br>            <span class="hljs-comment">/* 如果“\r”字符碰巧是目前buffer中的最后一个已经被读入的客户数据，那么这次分析没有读取到一个完整的行，返回LINE_OPEN以表示还需要继续读取客户数据才能进一步分析 */</span><br>            <span class="hljs-keyword">if</span> ((checked_index + <span class="hljs-number">1</span>) == read_index) &#123;<br>                <span class="hljs-keyword">return</span> LINE_OPEN;<br>            &#125;<br>            <span class="hljs-comment">/* 如果下一个字符是“\n”，则说明我们成功读取到一个完整的行 */</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (buffer[checked_index + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-comment">/* 否则的话，说明客户发送的HTTP请求存在语法问题 */</span><br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>        <span class="hljs-comment">/* 如果当前的字节是“\n”，即换行符，则也说明可能读取到一个完整的行 */</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> ((checked_index &gt; <span class="hljs-number">1</span>) &amp;&amp; buffer[checked_index - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\r&#x27;</span>) &#123;<br>                buffer[checked_index - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                buffer[checked_index++] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>                <span class="hljs-keyword">return</span> LINE_OK;<br>            &#125;<br>            <span class="hljs-keyword">return</span> LINE_BAD;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/* 如果所有内容都分析完毕也没遇到“\r”字符，则返回LINE_OPEN，表示还需要继续读取客户数据才能进一步分析 */</span><br>    <span class="hljs-keyword">return</span> LINE_OPEN;<br>&#125;<br><br><span class="hljs-comment">/* 分析请求行 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_requestline</span><span class="hljs-params">(<span class="hljs-type">char</span> *temp, CHECK_STATE &amp;checkstate)</span> </span>&#123;<br>    <span class="hljs-type">char</span> *url = <span class="hljs-built_in">strpbrk</span>(temp, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-comment">/* 如果请求行中没有空白字符或“\t”字符，则HTTP请求必有问题 */</span><br>    <span class="hljs-keyword">if</span> (!url) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *url++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-type">char</span> *method = temp;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(method, <span class="hljs-string">&quot;GET&quot;</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 仅支持GET方法 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The request method is GET\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    url += <span class="hljs-built_in">strspn</span>(url, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-type">char</span> *version = <span class="hljs-built_in">strpbrk</span>(url, <span class="hljs-string">&quot;\t&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!version) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    *version++ = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    version += <span class="hljs-built_in">strspn</span>(version, <span class="hljs-string">&quot;\t&quot;</span>);<br><br>    <span class="hljs-comment">/* 仅支持HTTP/1.1 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(version, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br><br>    <span class="hljs-comment">/* 检查URL是否合法 */</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(url, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) &#123;<br>        url += <span class="hljs-number">7</span>;<br>        url = <span class="hljs-built_in">strchr</span>(url, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!url || url[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The request URL is:%s\n&quot;</span>, url);<br><br>    <span class="hljs-comment">/* HTTP请求行处理完毕，状态转移到头部字段的分析 */</span><br>    checkstate = CHECK_STATE_HEADER;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><br><span class="hljs-comment">/* 分析头部字段 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_headers</span><span class="hljs-params">(<span class="hljs-type">char</span> *temp)</span> </span>&#123;<br>    <span class="hljs-comment">/* 遇到一个空行，说明我们得到了一个正确的HTTP请求 */</span><br>    <span class="hljs-keyword">if</span> (temp[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> GET_REQUEST;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(temp, <span class="hljs-string">&quot;Host:&quot;</span>, <span class="hljs-number">5</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">/* 处理“HOST”头部字段 */</span><br>        temp += <span class="hljs-number">5</span>;<br>        temp += <span class="hljs-built_in">strspn</span>(temp, <span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the request host is:%s\n&quot;</span>, temp);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 其他头部字段都不处理 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I can not handle this header\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO_REQUEST;<br>&#125;<br><br><span class="hljs-comment">/* 分析HTTP请求的入口函数 */</span><br><span class="hljs-function">HTTP_CODE <span class="hljs-title">parse_content</span><span class="hljs-params">(<span class="hljs-type">char</span> *buffer, <span class="hljs-type">int</span> &amp;checked_index, CHECK_STATE &amp;checkstate, <span class="hljs-type">int</span> &amp;read_index, <span class="hljs-type">int</span> &amp;start_line)</span> </span>&#123;<br>    LINE_STATUS linestatus = LINE_OK; <span class="hljs-comment">/* 记录当前行的读取状态 */</span><br>    HTTP_CODE retcode = NO_REQUEST; <span class="hljs-comment">/* 记录HTTP请求的处理结果 */</span><br><br>    <span class="hljs-comment">/* 主状态机，用于从buffer中取出所有完整的行 */</span><br>    <span class="hljs-keyword">while</span> ((linestatus = <span class="hljs-built_in">parse_line</span>(buffer, checked_index, read_index)) == LINE_OK) &#123;<br>        <span class="hljs-type">char</span> *temp = buffer + start_line; <span class="hljs-comment">/* start_line是行在buffer中的起始位置 */</span><br>        start_line = checked_index; <span class="hljs-comment">/* 记录下一行的起始位置 */</span><br><br>        <span class="hljs-comment">/* checkstate记录主状态机当前的状态 */</span><br>        <span class="hljs-keyword">switch</span> (checkstate) &#123;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_REQUESTLINE: &#123; <span class="hljs-comment">/* 第一个状态，分析请求行 */</span><br>                retcode = <span class="hljs-built_in">parse_requestline</span>(temp, checkstate);<br>                <span class="hljs-keyword">if</span> (retcode == BAD_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">case</span> CHECK_STATE_HEADER: &#123; <span class="hljs-comment">/* 第二个状态，分析头部字段 */</span><br>                retcode = <span class="hljs-built_in">parse_headers</span>(temp);<br>                <span class="hljs-keyword">if</span> (retcode == BAD_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> BAD_REQUEST;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retcode == GET_REQUEST) &#123;<br>                    <span class="hljs-keyword">return</span> GET_REQUEST;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">default</span>: &#123;<br>                <span class="hljs-keyword">return</span> INTERNAL_ERROR;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 若没有读取到一个完整的行，则表示还需要继续读取客户数据才能进一步分析 */</span><br>    <span class="hljs-keyword">if</span> (linestatus == LINE_OPEN) &#123;<br>        <span class="hljs-keyword">return</span> NO_REQUEST;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> BAD_REQUEST;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (argc &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage:%s ip_address port_number\n&quot;</span>, <span class="hljs-built_in">basename</span>(argv[<span class="hljs-number">0</span>]));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> address;<br>    <span class="hljs-built_in">bzero</span>(&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    address.sin_family = AF_INET;<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;address.sin_addr);<br>    address.sin_port = <span class="hljs-built_in">htons</span>(port);<br><br>    <span class="hljs-type">int</span> listenfd = <span class="hljs-built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">assert</span>(listenfd &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;address, <span class="hljs-built_in">sizeof</span>(address));<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    ret = <span class="hljs-built_in">listen</span>(listenfd, <span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">assert</span>(ret != <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_address;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client_address);<br>    <span class="hljs-type">int</span> fd = <span class="hljs-built_in">accept</span>(listenfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_address, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;errno is:%d\n&quot;</span>, errno);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">char</span> buffer[BUFFER_SIZE]; <span class="hljs-comment">/* 读缓冲区 */</span><br>        <span class="hljs-built_in">memset</span>(buffer, <span class="hljs-string">&#x27;\0&#x27;</span>, BUFFER_SIZE);<br>        <span class="hljs-type">int</span> data_read = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> read_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 当前已经读取了多少字节的客户数据 */</span><br>        <span class="hljs-type">int</span> checked_index = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 当前已经分析完了多少字节的客户数据 */</span><br>        <span class="hljs-type">int</span> start_line = <span class="hljs-number">0</span>; <span class="hljs-comment">/* 行在buffer中的起始位置 */</span><br><br>        <span class="hljs-comment">/* 设置主状态机的初始状态 */</span><br>        CHECK_STATE checkstate = CHECK_STATE_REQUESTLINE;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">/* 循环读取客户数据并分析之 */</span><br>            data_read = <span class="hljs-built_in">recv</span>(fd, buffer + read_index, BUFFER_SIZE - read_index, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span> (data_read == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;reading failed\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data_read == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;remote client has closed the connection\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            read_index += data_read;<br><br>            <span class="hljs-comment">/* 分析目前已经获得的所有客户数据 */</span><br>            HTTP_CODE result = <span class="hljs-built_in">parse_content</span>(buffer, checked_index, checkstate, read_index, start_line);<br>            <span class="hljs-keyword">if</span> (result == NO_REQUEST) &#123; <span class="hljs-comment">/* 尚未得到一个完整的请求 */</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (result == GET_REQUEST) &#123; <span class="hljs-comment">/* 得到一个完整的、正确的HTTP请求 */</span><br>                <span class="hljs-built_in">send</span>(fd, szret[<span class="hljs-number">0</span>], <span class="hljs-built_in">strlen</span>(szret[<span class="hljs-number">0</span>]), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 其他情况表示发生错误 */</span><br>                <span class="hljs-built_in">send</span>(fd, szret[<span class="hljs-number">1</span>], <span class="hljs-built_in">strlen</span>(szret[<span class="hljs-number">1</span>]), <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">close</span>(fd);<br>    &#125;<br>    <span class="hljs-built_in">close</span>(listenfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说这里有两个状态机, 分为主状态机和从状态机, 从状态机用于解析出一行的内容, 主状态机用于根据当前状态选择不同的处理函数.</p><hr><h2 id="提高服务器性能的其他建议"><a href="#提高服务器性能的其他建议" class="headerlink" title="提高服务器性能的其他建议"></a>提高服务器性能的其他建议</h2><h3 id="池"><a href="#池" class="headerlink" title="池"></a>池</h3><p>以空间换时间, 即“浪费”服务器的硬件资源, 以换取其运行效率, 这就是池（pool）的概念。</p><p>池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无须动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。当服务器处理完一个客户连接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。从最终的效果来看，池相当于服务器管理系统资源的应用层设施，它避免了服务器对内核的频繁访问。</p><p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。</p><ul><li><p>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</p></li><li><p>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程池或线程池中取得一个执行实体，而无须动态地调用fork或pthread_create等函数来创建进程和线程。</p></li><li><p>连接池通常用于服务器或服务器机群的内部永久连接。每个逻辑单元可能都需要频繁地访问本地的某个数据库。简单的做法是：逻辑单元每次需要访问数据库的时候，就向数据库程序发起连接，而访问完毕后释放连接。很显然，这种做法的效率太低。一种解决方案是使用连接池。连接池是服务器预先和数据库程序建立的一组连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑单元再将该连接返还给连接池。</p></li></ul><h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>应当避免不必要的数据复制, 这就在要求我们善用内核处理函数, 例如sendfile, splice, tee等, 这些函数都是在内核空间中直接进行, 避免了向用户空间的拷贝. 当然共享内存也是一个很有用的手段.</p><h3 id="上下文切换和锁"><a href="#上下文切换和锁" class="headerlink" title="上下文切换和锁"></a>上下文切换和锁</h3><p>我们知道进程切换和线程切换也是会导致系统开销的, 使工作线程的数量保持在一个合理的范围内也是一个必要的行为. </p><p>另外还有锁, 锁会带来大量的系统开销, 所以要善用读写锁等锁机制.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被讨厌的勇气 读书摘录(1)</title>
    <link href="/2025/02/15/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2025/02/15/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94%20%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li>如果一味地关注过去的原因, 企图仅仅靠原因去解释事务, 那就会陷入决定论.</li><li>事实上我们会从经历中发现符合自己目的的因素. 决定我们自身的不是过去的经历, 而是我们自己赋予经历的意义.</li><li>但关键是经历本身不会决定什么. 我们给过去的经历”赋予了什么样的意义”, 这直接决定了我们的生活. 人生不是别人赋予的, 而是由自己选择的, 是自己选择自己如何生活.</li><li>如果不能感到幸福的话, 就不可以一直这样, 不可以止步不前, 必须不断向前迈进.</li><li>之所以无法改变, 是因为自己下了”不改变的决心”. 即使有些人有各种不满, 但却拿不出改变生活方式的勇气, 反而拒绝去改变, 牺牲当下本可以享受的乐趣, 维持痛苦的现状.</li><li>应该去做–这一简单的课题摆在眼前, 但却不断扯出各种不能做的理由, 你难道不认为这是一种很痛苦的生活方式吗?</li><li>借助权势来抬高自己的人终究是活在他人的价值观和人生中, 这是必须重点强调的地方.</li><li>弱势具有特权, 有些人以自己的不幸作为武器来支配对方, 其实就是在借助不幸来显示自己的特别, 想要用不幸这一点来压住别人. 这种人是可悲且令人无语的, 因为他在”使用”不幸的同时, 就会永远需要不幸, 进而永远无法抛开不幸.</li><li>健全的自卑感不是来自与别人的比较, 而是来自与”理想的自己”.</li><li>我们应当积极看待自己与别人的差异, 但是, 我们虽然不同但是平等.</li><li>s那就是无论认为自己多么正确, 也不要以此为理由去责难对方.</li><li>“我是正确的”这种坚信意味着坚持”对方是错误的”, 最终会演变为权力之争.</li><li>追求优越性不是通过与他人的竞争来完成的.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(3)</title>
    <link href="/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第七章 Linux服务器程序规范</strong></p></blockquote><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="rsyslog"><a href="#rsyslog" class="headerlink" title="rsyslog"></a>rsyslog</h3><p>一个非常强大的日志管理工具，它是现代 Linux 和 Unix 系统中默认的日志守护进程之一.</p><p>它负责收集、存储和转发来自操作系统和应用程序的日志消息.</p><h3 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h3><p>一个用于向rsyslog系统发送日志进行存储的函数.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜syslog.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">syslog</span><span class="hljs-params">(<span class="hljs-type">int</span> priority, <span class="hljs-type">const</span> <span class="hljs-type">char</span>*message,...)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>priority用来描述这个日志消息的类别级别等信息.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 消息类别</span><br>LOG_USER（值 <span class="hljs-number">1</span>）: 用户应用程序消息<br>LOG_DAEMON（值 <span class="hljs-number">3</span>）: 守护进程消息<br>LOG_SYSLOG（值 <span class="hljs-number">4</span>）: 系统日志相关消息<br>LOG_LOCAL0 到 LOG_LOCAL7（值 <span class="hljs-number">16</span> 到 <span class="hljs-number">23</span>）: 用户定义的本地类别<br><span class="hljs-comment">// 消息级别</span><br>LOG_EMERG（<span class="hljs-number">0</span>）：紧急情况，系统无法使用<br>LOG_ALERT（<span class="hljs-number">1</span>）：需要立即采取行动<br>LOG_CRIT（<span class="hljs-number">2</span>）：临界情况<br>LOG_ERR（<span class="hljs-number">3</span>）：错误<br>LOG_WARNING（<span class="hljs-number">4</span>）：警告<br>LOG_NOTICE（<span class="hljs-number">5</span>）：普通但需要注意的消息<br>LOG_INFO（<span class="hljs-number">6</span>）：一般信息<br>LOG_DEBUG（<span class="hljs-number">7</span>）：调试信息<br></code></pre></td></tr></table></figure><p>这些信息用”|”运算符连接.</p><p>类别可以不填, 默认为LOG_USER, 也可以在openlog中设置.</p></li><li><p>后面用来填写要保存的日志信息, 是一个模板和可变参数, 可以这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;This is a simple log message.&quot;</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *username = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;User %s has logged in.&quot;</span>, username);<br></code></pre></td></tr></table></figure></li></ul><h3 id="openlog-closelog"><a href="#openlog-closelog" class="headerlink" title="openlog &#x2F; closelog"></a>openlog &#x2F; closelog</h3><p>其实就是使用syslog要用到的构造和析构函数. </p><p>openlog不写使用syslog会隐式调用该函数, closelog必须显式调用.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜syslog.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">openlog</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*ident,<span class="hljs-type">int</span> logopt,<span class="hljs-type">int</span> facility)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closelog</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后，它通常被设置为程序的名字。logopt参数对后续syslog调用的行为进行配置，它可取下列值的按位或：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_PID 0x01<span class="hljs-comment">/*在日志消息中包含程序PID*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_CONS 0x02<span class="hljs-comment">/*如果消息不能记录到日志文件，则打印至终端*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_ODELAY 0x04<span class="hljs-comment">/*延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOG_NDELAY 0x08<span class="hljs-comment">/*不延迟打开日志功能*/</span></span><br></code></pre></td></tr></table></figure><p>facility参数可用来修改syslog函数中的默认设施值, 可以提前设置日志类别 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">openlog</span>(<span class="hljs-string">&quot;MyApp&quot;</span>, LOG_PID | LOG_CONS, LOG_USER);<br><span class="hljs-built_in">syslog</span>(LOG_INFO, <span class="hljs-string">&quot;This is an info message.&quot;</span>);<br><span class="hljs-built_in">closelog</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="uid-euid"><a href="#uid-euid" class="headerlink" title="uid &#x2F; euid"></a>uid &#x2F; euid</h3><ul><li><p><strong><code>uid</code></strong> 是进程的真实用户 ID，标识启动进程的用户。</p></li><li><p><strong><code>euid</code></strong> 是进程的有效用户 ID，决定进程的权限级别。</p><p>euid存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</p></li><li><p><strong><code>getuid</code></strong> 和 <strong><code>geteuid</code></strong> 用于获取 <code>uid</code> 和 <code>euid</code>，常用于权限检查、权限切换和调试。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜stdio.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">uid_t</span> uid=<span class="hljs-built_in">getuid</span>();<br><span class="hljs-type">uid_t</span> euid=<span class="hljs-built_in">geteuid</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;userid is%d,effective userid is:%d\n&quot;</span>,uid,euid);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>作用 : 根据当前用户的权限执行不同的操作 &#x2F; 用于调试和日志记录.</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>将以root身份启动的进程切换为以一个普通用户身份运行:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">switch_to_user</span><span class="hljs-params">(<span class="hljs-type">uid_t</span> user_id,<span class="hljs-type">gid_t</span> gp_id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*先确保目标用户不是root*/</span><br><span class="hljs-keyword">if</span>((user_id==<span class="hljs-number">0</span>)＆＆(gp_id==<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">/*确保当前用户是合法用户：root或者目标用户*/</span><br><span class="hljs-type">gid_t</span> gid=<span class="hljs-built_in">getgid</span>();<br><span class="hljs-type">uid_t</span> uid=<span class="hljs-built_in">getuid</span>();<br><span class="hljs-keyword">if</span>(((gid!=<span class="hljs-number">0</span>)||(uid!=<span class="hljs-number">0</span>))＆＆((gid!=gp_id)||(uid!=user_id))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-comment">/*如果不是root，则已经是目标用户*/</span><br><span class="hljs-keyword">if</span>(uid!=<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <br><span class="hljs-comment">/*切换到目标用户*/</span><br><span class="hljs-keyword">if</span>((<span class="hljs-built_in">setgid</span>(gp_id)＜<span class="hljs-number">0</span>)||(<span class="hljs-built_in">setuid</span>(user_id)＜<span class="hljs-number">0</span>)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>每个进程都有自己的pid, 也会有自己的pgid, pgid是自己所在的进程组id.</p><p>每个进程组都有一个首领进程, 首领进程的pid将会被用作进程组的id, 作用仅限于此.</p><p>一个进程组中的进程有共同作用, 如果一个接收了SIGINT信号, 其他几个也会一并退出.</p><p>父子进程就默认属于同一个进程组, 但也可以通过setsid来改变.</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话（session）.</p><p>通过会话，操作系统可以更高效地管理进程组和终端交互，并为用户提供强大的作业控制功能。</p><h4 id="会话的作用"><a href="#会话的作用" class="headerlink" title="会话的作用"></a><strong>会话的作用</strong></h4><p>（1）<strong>终端管理</strong></p><ul><li>会话与终端关联，决定了哪些进程组可以访问终端。</li><li>每个会话有一个前台进程组（Foreground Process Group），只有前台进程组中的进程可以从终端读取输入、向终端输出，并接收终端的控制信号（如 <code>Ctrl+C</code> 发送的 <code>SIGINT</code>）。</li></ul><p>（2）<strong>作业控制</strong></p><ul><li>会话支持作业控制（Job Control），允许用户在前台和后台之间切换任务。</li><li>例如，Shell 可以将一个作业（如管道命令）放到前台或后台运行。</li></ul><p>（3）<strong>信号管理</strong></p><ul><li>会话可以统一管理信号。</li><li>例如，当终端断开连接时，会话首进程会收到 <code>SIGHUP</code> 信号，通常会导致会话中的所有进程终止。</li></ul><p>（4）<strong>资源管理</strong></p><ul><li>会话可以统一管理资源。</li><li>例如，当会话首进程终止时，操作系统会向会话中的所有进程发送 <code>SIGHUP</code> 信号，终止整个会话。</li></ul><h3 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">char</span>*<span class="hljs-title">getcwd</span><span class="hljs-params">(<span class="hljs-type">char</span>*buf,<span class="hljs-type">size_t</span> size)</span></span>;  <span class="hljs-comment">// 获取当前的工作目录</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chdir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path)</span></span>;<span class="hljs-comment">// 改变当前工作目录</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chroot</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*path)</span></span>;<span class="hljs-comment">// 改变根目录</span><br></code></pre></td></tr></table></figure><h3 id="服务器程序后台化-守护进程"><a href="#服务器程序后台化-守护进程" class="headerlink" title="服务器程序后台化(守护进程)"></a>服务器程序后台化(守护进程)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">daemonize</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid＜<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid＞<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777*/</span><br>    <span class="hljs-built_in">umask</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*创建新的会话，设置本进程为进程组的首领*/</span><br>    <span class="hljs-type">pid_t</span> sid = <span class="hljs-built_in">setsid</span>();<br>    <span class="hljs-keyword">if</span> (sid＜<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">/*切换工作目录*/</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">chdir</span>(<span class="hljs-string">&quot;/&quot;</span>))＜<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span><br>    <span class="hljs-built_in">close</span>(STDIN_FILENO);<br>    <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>    <span class="hljs-built_in">close</span>(STDERR_FILENO);<br>    <span class="hljs-comment">/*关闭其他已经打开的文件描述符，代码省略*/</span><br>    <br>    <span class="hljs-comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span><br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDONLY);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/null&quot;</span>, O_RDWR);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以使用daemon函数, 将该函数所在的进程变为守护进程 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜unistd.h＞</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> nochdir,<span class="hljs-type">int</span> noclose)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>nochdir用于指定是否改变当前目录, 0则设置”&#x2F;“为根目录.</li><li>noclose设置为0时, 三个标准都会被默认重定向到&#x2F;dev&#x2F;null文件.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(2)</title>
    <link href="/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/"/>
    <url>/2025/02/13/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(2)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第六章 高级IO函数</strong></p></blockquote><h3 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> fd[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>fd[0]对应读端, fd[1]对应写端</p></li><li><p>默认阻塞, 可设置为非阻塞</p></li><li><p>双端都存在引用计数功能, 写端引用计数为0读端read返回0, 读端引用计数为0写端write会失败并发出SIGPIPE信号</p></li><li><p>多用于父子进程间通信, 一边关闭读端, 一边关闭写端.</p></li></ul><hr><h3 id="dup-dup2"><a href="#dup-dup2" class="headerlink" title="dup &#x2F; dup2"></a>dup &#x2F; dup2</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd, <span class="hljs-type">int</span> newfd)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><ul><li>文件描述符 : 用来标定已打开文件的整数, 进程中默认打开的三个操作符是stdio(0), stiout(1), stderro(2).</li><li>文件描述符以进程为单位, 每个进程都有一套独立的文件描述符, 从0开始, 进程开始就会使用0,1,2三个文件描述符, 分别代表输入&#x2F;输出&#x2F;报错.</li><li>Linux下一切皆文件, 我们很多的行为都可以被解释为文件操作, 比如fork, socket, 只要有文件描述符, 我们就可以控制其读写.</li><li>可以创建文件描述符的操作 : open&#x2F;pipe&#x2F;socket&#x2F;accept&#x2F;fork等.</li><li>每次创建文件描述符时选择的值都是<strong>从0开始当前进程中最小的未使用值</strong>.</li></ul><p>dup&#x2F;dup2的作用主要就是<strong>重定向文件描述符的输入输出</strong>. </p><p>dup的主要操作为 : 将一个新的文件描述符(和创建逻辑一致)重定向到fd, 返回这个新文件描述符.</p><p>dup2就是在dup的基础上, 可以指定这个新的文件描述符, 如果这个新的文件描述符已被占用, 就先关闭该描述符再重定向.</p><p>其实在实际使用中”新的文件描述符”一般都是三种标准文件描述符, 即将标准输入输入重定向到fd.</p><p>dup的使用比较意识流, 我们先看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ip = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br>    <span class="hljs-built_in">bzero</span>(&amp;server, <span class="hljs-built_in">sizeof</span>(server));<br>    server.sin_family = AF_INET;<br>    server.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-built_in">inet_pton</span>(AF_INET, ip, &amp;server.sin_addr);<br><br>    <span class="hljs-type">int</span> sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-built_in">sizeof</span>(server));<br>    ret = <span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client;<br>    <span class="hljs-type">socklen_t</span> client_addrlength = <span class="hljs-built_in">sizeof</span>(client);<br><br>    <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">accept</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client, &amp;client_addrlength);<br>    <span class="hljs-keyword">if</span> (connfd &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: accept() failed.\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">close</span>(STDOUT_FILENO);<br>        <span class="hljs-built_in">dup</span>(connfd);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello World\n&quot;</span>);<br>        <span class="hljs-built_in">close</span>(connfd);<br>    &#125;<br><br>    <span class="hljs-built_in">close</span>(sock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个简易的TCP网络代码, dup在这里的作用是把标准输出重定向到网络套接字, 过程如下 : </p><ul><li><code>close(STDOUT_FILENO);</code>关闭标准输入</li><li><code>dup(connfd);</code>选取从0开始当前进程中最小的未使用值, 那就是刚刚关闭的标准输出(1), 因此标准输出被重定向到了connfd.</li><li><code>printf(&quot;Hello World\n&quot;);</code>中的输出将被改为输出到connfd中, 其实就类似于使用了send将”Hello World\n”发送了出去.</li></ul><p>加入换用dup2, 可以把close+dup替换为如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">dup2</span>(connfd, STDOUT_FILENO);<br></code></pre></td></tr></table></figure><p>dup2的使用一般比dup要方便直观不少, 所以日常中基本都是使用dup2.</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>将标准输入输出从重定向到打开的文件.</li><li>将标准输入输出从重定向到网络套接字. </li><li>将标准输入输出从重定向到管道.</li><li>利用子进程会继承父进程文件描述符的特性, 在fork前使用dup2可以使后续的子进程重定向到相同的位置而无需多余操作, 在fork后使用dup2可以使父子进程输入输出到不同的文件, 这里的可操作空间很大. 如果不使用dup2可能还要创建多余的文件句柄等.</li></ul><hr><h3 id="readv-writev"><a href="#readv-writev" class="headerlink" title="readv &#x2F; writev"></a>readv &#x2F; writev</h3><p>后面的v指代vector, 作用在于输入输出到多个缓冲区(这里的缓冲区可以理解为内存).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/uio.h＞</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">readv</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec*vector,<span class="hljs-type">int</span> count)</span>；</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">writev</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec*vector,<span class="hljs-type">int</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>相比于普通的read : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>read只能读入一个缓冲区的内容, count代表buf的size.</p><p>readv可以读入多个缓冲区的内容, 多个缓冲区都被存在struct iovec中, count代表缓冲区的个数.</p><p>write和writev同理.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">char</span> header_buf[BUFFER_SIZE];<br>...<br><span class="hljs-type">char</span>*file_buf;<br>...<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iovec</span> iv[<span class="hljs-number">2</span>];<br>iv[<span class="hljs-number">0</span>].iov_base = header_buf;            <span class="hljs-comment">// 指向缓冲区的指针</span><br>iv[<span class="hljs-number">0</span>].iov_len = <span class="hljs-built_in">strlen</span>(header_buf);<span class="hljs-comment">// 缓冲区的size</span><br>iv[<span class="hljs-number">1</span>].iov_base = file_buf;<br>iv[<span class="hljs-number">1</span>].iov_len = file_stat.st_size;<br>ret = <span class="hljs-built_in">writev</span>(connfd,iv,<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>在发送http回复时我们就可以将报头部分和文件部分存入iv中, 就可以实现将多个缓冲区中的内存发送, 而不必要将这两个部分合并再用write发送, 我们可以发现这可以避免不必要的拷贝和内存消耗.</p><hr><h3 id="内存的用户空间和内核空间"><a href="#内存的用户空间和内核空间" class="headerlink" title="内存的用户空间和内核空间"></a>内存的用户空间和内核空间</h3><ul><li>用户空间 : 用户程序运行的内存区域，包含应用程序的代码、数据和堆栈。用户程序在此空间运行，<strong>无法直接访问硬件或内核资源</strong>，必须通过系统调用请求内核协助.</li><li>内核空间 : 操作系统内核运行的内存区域，负责管理硬件、进程调度、内存分配等核心功能。只有内核代码能直接访问此区域，具有<strong>最高权限</strong>（如操作硬件、修改页表).</li><li>用户态和内核态的转换 : <ul><li>这两种状态是CPU的运行状态, 一般处于用户态, 可以通过一些方式进入内核态.</li><li>内核态拥有最高权限.</li><li>内核态可以访问所有内存空间, 包括磁盘, 网络设备等, 用户态只可访问内存空间. </li><li>进入内核态的方式 : 系统调用(fork, open, read等), 硬件中断, 异常.</li></ul></li></ul><hr><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>一种专用于文件网络传输的send.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/sendfile.h＞</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span>*offset, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>out_fd : 要输出到的socketfd, 这里必须是socket的fd.</li><li>in_fd : 要输入的文件fd, 这里必须是真正文件的fd.</li><li>offset : 要从in_fd偏移量为多少的位置开始读, 默认为0.</li><li>count : 要读取的大小.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">sendfile</span>(sockfd, filefd, <span class="hljs-literal">NULL</span>, stat_buf.st_size);<br></code></pre></td></tr></table></figure><p>该函数的优势在于传输文件时不需要将其从磁盘搬到用户空间再发送, 而是直接在内核空间中就将磁盘中的数据发送到网络套接字中, 实现了<strong>零拷贝</strong>.</p><hr><h3 id="mmap-munmap"><a href="#mmap-munmap" class="headerlink" title="mmap &#x2F; munmap"></a>mmap &#x2F; munmap</h3><p>一个用于申请一段内存空间将文件映射到该空间中的函数, 这个空间可以作为进程间通信的贡献内存. munmap用于释放该空间.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span>＜sys/mman.h＞</span><br><span class="hljs-function"><span class="hljs-type">void</span>*<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span>*start,<span class="hljs-type">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>start : 允许用户使用某个特定的地址作为这段内存的起始地址, 设置为NULL自动选择地址.</li><li>length : 内存段的长度.</li><li>port : 设置内存段的访问权限.</li><li>flags : 控制内存段内容被修改后程序的行为.</li><li>fd : 被映射文件对应的文件描述符.</li><li>offset : 设置从文件的何处开始映射.</li></ul><hr><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>用于两个文件描述符之间的数据移动, 所谓移动就是说读取完就没有了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">splice</span><span class="hljs-params">(<span class="hljs-type">int</span> fd_in, <span class="hljs-type">off_t</span> *off_in, <span class="hljs-type">int</span> fd_out, <span class="hljs-type">off_t</span> *off_out, <span class="hljs-type">size_t</span> len, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>fd_in : 执行输入的文件描述符.</li><li>off_in : 对应偏移量的指针, 一般设NULL.</li><li>fd_out : 接收输入的文件描述符.</li><li>off_out : 同上.</li><li>len : 输入数据的长度.</li><li>flags : 控制数据如何移动.</li></ul><p>splice可以在内核空间中实现不同文件描述符之间的信息传输, 而和管道结合可以将这种信息传输扩展到进程间通信, 而不只是在一个进程内传输, 由此可以实现<strong>高效的进程间通信</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/uio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> pipe_fds[<span class="hljs-number">2</span>]; <span class="hljs-comment">// 管道文件描述符</span><br>    <span class="hljs-type">pid_t</span> pid;<br>    <span class="hljs-type">char</span> *message = <span class="hljs-string">&quot;Hello from parent process to child process using splice!&quot;</span>;<br>    <span class="hljs-type">ssize_t</span> bytes_spliced;<br><br>    <span class="hljs-comment">// 创建管道</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe</span>(pipe_fds) == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;pipe failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    pid = fork();<br>    <span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;fork failed&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (pid &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 父进程：将数据写入管道</span><br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭管道的读端</span><br><br>        <span class="hljs-comment">// 将数据写入管道</span><br>        bytes_spliced = <span class="hljs-built_in">splice</span>(STDOUT_FILENO, <span class="hljs-literal">NULL</span>, pipe_fds[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, BUFFER_SIZE, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (bytes_spliced == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice to pipe failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Parent process wrote data to pipe: %zd bytes\n&quot;</span>, bytes_spliced);<br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭管道的写端</span><br><br>        <span class="hljs-comment">// 等待子进程结束</span><br>        <span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 子进程：从管道中读取数据</span><br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">1</span>]); <span class="hljs-comment">// 关闭管道的写端</span><br><br>        <span class="hljs-comment">// 通过管道读取数据并将其输出</span><br>        <span class="hljs-type">char</span> buf[BUFFER_SIZE];<br>        bytes_spliced = <span class="hljs-built_in">splice</span>(pipe_fds[<span class="hljs-number">0</span>], <span class="hljs-literal">NULL</span>, STDOUT_FILENO, <span class="hljs-literal">NULL</span>, BUFFER_SIZE, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (bytes_spliced == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;splice from pipe failed&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Child process received data from pipe: %zd bytes\n&quot;</span>, bytes_spliced);<br>        <span class="hljs-built_in">close</span>(pipe_fds[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 关闭管道的读端</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码中父进程向子进程发送消息, 子进程可以接收到父进程中的消息, 并且由于splice一切都在内核空间中进行, 非常高效.</p><hr><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>用于两个文件描述符之间的数据复制, 和splice用法一致, 但是数据读取后会留下了, 下次读取还在.</p><hr><h3 id="struct-stat"><a href="#struct-stat" class="headerlink" title="struct stat"></a>struct stat</h3><p>用于用于描述文件或文件系统对象的结构体. 使得进程可以通过stat, fstat, lstat获得文件的基本信息.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> &#123;<br>    <span class="hljs-type">dev_t</span>     st_dev;         <span class="hljs-comment">/* 文件所在设备的 ID */</span><br>    <span class="hljs-type">ino_t</span>     st_ino;         <span class="hljs-comment">/* Inode 号 */</span><br>    <span class="hljs-type">mode_t</span>    st_mode;        <span class="hljs-comment">/* 文件类型和权限 */</span><br>    <span class="hljs-type">nlink_t</span>   st_nlink;       <span class="hljs-comment">/* 硬链接数 */</span><br>    <span class="hljs-type">uid_t</span>     st_uid;         <span class="hljs-comment">/* 所有者的用户 ID */</span><br>    <span class="hljs-type">gid_t</span>     st_gid;         <span class="hljs-comment">/* 所有者的组 ID */</span><br>    <span class="hljs-type">dev_t</span>     st_rdev;        <span class="hljs-comment">/* 设备 ID（如果是设备文件） */</span><br>    <span class="hljs-type">off_t</span>     st_size;        <span class="hljs-comment">/* 文件大小（字节数） */</span><br>    <span class="hljs-type">blksize_t</span> st_blksize;     <span class="hljs-comment">/* 文件系统 I/O 的块大小 */</span><br>    <span class="hljs-type">blkcnt_t</span>  st_blocks;      <span class="hljs-comment">/* 文件占用的块数 */</span><br><br>    <span class="hljs-comment">/* 时间戳 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_atim;  <span class="hljs-comment">/* 最后访问时间 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_mtim;  <span class="hljs-comment">/* 最后修改时间 */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span> st_ctim;  <span class="hljs-comment">/* 最后状态变更时间 */</span><br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_atime st_atim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后访问时间（秒） */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_mtime st_mtim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后修改时间（秒） */</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> st_ctime st_ctim.tv_sec  <span class="hljs-comment">/* 向后兼容：最后状态变更时间（秒） */</span></span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;   <span class="hljs-comment">// 用路径寻找文件信息,  statbuf都是输出型参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-keyword">struct</span> stat *statbuf)</span></span>;<span class="hljs-comment">// 用文件fd寻找文件信息</span><br></code></pre></td></tr></table></figure><p>使用方法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_buf;<br><span class="hljs-built_in">fstat</span>(filefd, &amp;stat_buf);  <br>...<br><span class="hljs-built_in">sendfile</span>(connfd,filefd,<span class="hljs-literal">NULL</span>,stat_buf.st_size);  <span class="hljs-comment">// 这里sendfile的就会用到需要传输的文件大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux高性能服务器编程 读书笔记(1)</title>
    <link href="/2025/02/10/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/"/>
    <url>/2025/02/10/%5BLinux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%5D%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0(1)/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>第五章  Linux网络编程基础API</strong></p></blockquote><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><h3 id="什么是大小端字节序"><a href="#什么是大小端字节序" class="headerlink" title="什么是大小端字节序?"></a>什么是大小端字节序?</h3><p>这里以32位机举例, 32位机CPU一次可以装载4字节,  那么这4个字节不同的排序方式就对应了不同的字节序 : </p><ul><li>大端字节序 : 顺着排, 0x12345678 将被排序为 12  34  56  78.</li><li>小端字节序 : 逆着排, 0x12345678 将被排序为 78  56  34  12.</li></ul><h3 id="为什么要分大小端"><a href="#为什么要分大小端" class="headerlink" title="为什么要分大小端?"></a>为什么要分大小端?</h3><p>其实更多还是因为<strong>历史原因</strong>,  早期都是按照大端字节序来设计的, 因为顺着排更符合人类的阅读习惯, 早期网络协议设计都是按大端设计的, 并且网络协议一旦实施就不好改了, 所以直到现在网络传输的字节序都是大端字节序, 因此大端字节序又称为网络字节序.</p><p>后来人们发现小端字节序更符合CPU的运算逻辑, 使用小段字节序编码可以让CPU运行更加高效, 因此之后的主机大都采用小端字节序, 因此小段字节序又称为主机字节序.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">htonl</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> hostlong)</span>; <span class="hljs-comment">// host to network long </span><br></code></pre></td></tr></table></figure><p>以上为long类型端口从主机字节序转为网络字节序的函数.</p><hr><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="shutdown关闭socket"><a href="#shutdown关闭socket" class="headerlink" title="shutdown关闭socket"></a>shutdown关闭socket</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shutdown</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">int</span> howto)</span></span>;<br></code></pre></td></tr></table></figure><p>shoudown类似于进阶版的close, close是直接断开读写, shoudown可以分别关闭读端写端.</p><p>howto为选项 : </p><ul><li>SHUT_RD : 只关闭写端.</li><li>SHUT_WR : 只关闭读端.</li><li>SHUT_RDWR : 双端关闭.</li></ul><p>应用场景 : 半双工实现, 客户端收到EOF可以直接关闭读端, 写端不关闭可以继续处理没有处理完的事务.</p><p>其实就是读端和写端都会占用资源, close只能同时释放, showdown可以根据具体情况选择只读不写&#x2F;只写不读, 提前释放部分资源.</p><h3 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h3><ul><li><p>SO_REUSEADDR : 强制使用处于TIME_WAIT状态的连接占用的socket地址.</p><ul><li>TIME_WAIT作用 : TCP连接发送的数据可能滞后, 如果崩溃立即重启, 可能接收到旧数据包造成混乱.</li></ul><p>SO_REUSEADDR作用 : </p><ol><li>可以避免服务器崩溃后进入TIME_WAIT状态, 配合systemd可以实现快速重启服务.</li><li>支持多个进程同时绑定同一个端口(仅限UDP), 用于视频影音等高并发用多个进程同时处理发送到同一个端口上的信息.</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> reuse = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 表示启用设置</span><br>setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="hljs-keyword">sizeof</span>(reuse));<br></code></pre></td></tr></table></figure></li><li><p>SO_RCVBUF&#x2F;SO_SNDBUF : 用于修改TCP发送和接收缓冲区的大小.</p><p>缓冲区大小最小为256字节, 大小会按设置的大小的两倍计算.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> bufsize = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 标定新的缓冲区大小</span><br><span class="hljs-built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_RCV, &amp;bufsize, <span class="hljs-built_in">sizeof</span>(bufsize))<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>在现实生活中我们习惯<strong>用域名代替IP地址, 用服务名代替端口号</strong>, 使用网络信息API便可以<strong>实现&lt;域名+服务名&gt;到&lt;IP+port&gt;的双向转化</strong>, 便于我们socket等操作的进行. 主要是两大函数<code>getaddrinfo</code>和<code>getnameinfo</code>, 这两个函数<strong>线程安全并且支持各种地址族和协议类型</strong>, 可以使socket进行动态设置以实现<strong>动态实时处理与跨平台性</strong>.</p><h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>这个函数可以通过主机名获得IP地址, 通过服务名获得端口号.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *node,                   <span class="hljs-comment">// 主机名 / 字符串形式的IP地址</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-type">char</span> *service,<span class="hljs-comment">// 服务名</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> addrinfo *hints, <span class="hljs-comment">// 传入一些必要的信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">                <span class="hljs-keyword">struct</span> addrinfo **res<span class="hljs-comment">// 存储返回结果, 输出型参数</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> &#123;<br>    <span class="hljs-type">int</span>              ai_flags;        <span class="hljs-comment">// 地址信息标志</span><br>    <span class="hljs-type">int</span>              ai_family;       <span class="hljs-comment">// 地址族 (AF_INET, AF_INET6 等)</span><br>    <span class="hljs-type">int</span>              ai_socktype;     <span class="hljs-comment">// 套接字类型 (SOCK_STREAM, SOCK_DGRAM 等)</span><br>    <span class="hljs-type">int</span>              ai_protocol;     <span class="hljs-comment">// 协议类型 (IPPROTO_TCP, IPPROTO_UDP 等), 默认为0即可</span><br>    <span class="hljs-type">size_t</span>           ai_addrlen;      <span class="hljs-comment">// 地址长度</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span> *ai_addr;         <span class="hljs-comment">// 指向套接字地址的指针</span><br>    <span class="hljs-type">char</span>            *ai_canonname;    <span class="hljs-comment">// 完整主机名</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *ai_next;         <span class="hljs-comment">// 下一个地址信息链表</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以利用获取的信息直接建立socket : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints, *res;<br><span class="hljs-built_in">memset</span>(&amp;hints, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(hints));<br>hints.ai_family = AF_UNSPEC;   <span class="hljs-comment">// 支持 IPv4 和 IPv6</span><br>hints.ai_socktype = SOCK_STREAM; <span class="hljs-comment">// TCP</span><br><br><span class="hljs-comment">// 获取目标主机的地址信息</span><br><span class="hljs-type">int</span> status = <span class="hljs-built_in">getaddrinfo</span>(<span class="hljs-string">&quot;www.example.com&quot;</span>, <span class="hljs-string">&quot;http&quot;</span>, &amp;hints, &amp;res);<br><span class="hljs-keyword">if</span> (status != <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用返回的地址信息创建套接字并进行连接</span><br><span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(res-&gt;ai_family, res-&gt;ai_socktype, res-&gt;ai_protocol);<br><span class="hljs-keyword">if</span> (sockfd == <span class="hljs-number">-1</span>) &#123;<br>    <span class="hljs-comment">// 错误处理</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-built_in">freeaddrinfo</span>(res);<br><span class="hljs-built_in">freeaddrinfo</span>(hints);  <span class="hljs-comment">// addrinfo类型需要释放内存</span><br></code></pre></td></tr></table></figure><h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>通过socket地址返回主机名&#x2F;服务名, 和getaddrinfo是相反的作用.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa, <span class="hljs-type">socklen_t</span> salen, <span class="hljs-comment">// 目标网络地址结构体</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *host, <span class="hljs-type">size_t</span> hostlen,<span class="hljs-comment">// 返回的主机名, 输出型参数</span></span><br><span class="hljs-params">                <span class="hljs-type">char</span> *serv, <span class="hljs-type">size_t</span> servlen,<span class="hljs-comment">// 返回的服务名/端口号, 输出型参数</span></span><br><span class="hljs-params">                <span class="hljs-type">int</span> flags<span class="hljs-comment">// 确定函数行为</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> sa;<br>   <span class="hljs-type">char</span> host[NI_MAXHOST], service[NI_MAXSERV];<br>   <br>   <span class="hljs-comment">// 构造一个IPv4地址，假设是127.0.0.1，端口是80</span><br>   sa.sin_family = AF_INET;<br>   sa.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">80</span>);<br>   <span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;(sa.sin_addr));<br><br>   <span class="hljs-comment">// 获取主机名和服务名</span><br>   <span class="hljs-type">int</span> result = <span class="hljs-built_in">getnameinfo</span>((<span class="hljs-keyword">struct</span> sockaddr*)&amp;sa, <span class="hljs-built_in">sizeof</span>(sa),<br>                            host, NI_MAXHOST, service, NI_MAXSERV, <span class="hljs-number">0</span>);<br>   <span class="hljs-keyword">if</span> (result == <span class="hljs-number">0</span>) &#123;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Host: %s\n&quot;</span>, host);<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Service: %s\n&quot;</span>, service);<br>   &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>高性能服务器编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(4)</title>
    <link href="/2025/02/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(4)/"/>
    <url>/2025/02/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(4)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>我们对规律与和谐的了解, 往往局限于那些我们已经掌握的事例; 但许多貌似彼此冲突的因素也能导致和谐的结果, 但许多规律我们固然尚未认识可是确实存在且更加神奇美妙.</p></li><li><p>其实幸福的人应该永远生活在此刻, 好好利用每件落到我们身上的琐事, 就像青草坦然接受每颗落在它身上的最细小的露珠那样, 别把时间用于挽回从前失去的机会, 并美名其曰承担责任.</p></li><li><p>若是能在宁静而有益的清晨之气中, 回想每日所做善事, 培养对美德的热爱和对邪恶的憎恨, 那么人心里原始的兽性, 就会像森林里被砍掉的新芽那样, 不会茁壮成长.</p></li><li><p>在渴望探索和了解万物的同时, 我们要牢记万物均是神秘和未经探索的.</p></li><li><p>我们需要看见我们突破自己的局限, 在我们从未涉足的原野自由自在的生活.</p></li><li><p>然而我们总是以为, 若是将我们农场的篱笆拆掉, 垒上石墙, 我们的生活便自此有了边界, 我们的命运也已经注定.</p></li><li><p>每个人都是其心灵领地的主人, 然而有些人明明毫不尊重自己, 却表现得很爱国, 捡起芝麻丢了西瓜. 他们热爱可以供他们造坟的土地, 却对那使他们的泥身充满生气的灵魂毫不关心. 爱国主义是他们脑里的蛆虫.</p></li><li><p>但人生的目标并非让自己持有这种敌视社会的态度, 而是始终能够做他自己, 遵从自己的原则, 无论这种遵从会让他对社会产生什么样的态度, 如果有幸遇到一个正义的政府, 他是不会产生敌意的态度的.</p></li><li><p><strong>我们很容易不知不觉就习惯某条固定的路线, 为我们自己踏出一条路来.</strong></p></li><li><p>大地的表面是柔软的, 人类的脚能够踩得它陷进去, 精神的道路也是如此. 所以世上的道路一定是非常破烂和尘土飞扬的, 传统和习俗的车辙也肯定是很深的!</p></li><li><p>如果人自信地朝着梦想的方向前进, 努力去过上他事先设想的生活, 他将会取得普通人想象不到的成功. 他会把某些东西甩在身后, 将会跨越无形的界线; 他的周围和内心将会得到新的解释, 赋予他更大的自由, 他将会过上一种更为高尚的生活.</p></li><li><p>如果你在空中修建了几座楼阁, 你的心血未必会白费, 那就是它们应该在的地方, 现在请把基础摆到它们下面去.</p></li><li><p>好像只有愚蠢是最安全的, 我却独想逾规越矩!</p></li><li><p>**至于未来或者前景, 我们应该抱着开放的态度, 顺其自然, 别明确的限定我们将来应该是什么模样.**至于过去或者从前, 应该将其抛在身后.</p></li><li><p>人们热爱的纯洁就像笼罩大地的迷雾, 而不像超乎那迷雾之上的蓝天.</p></li><li><p>如果适合我们的环境尚未出现, 我们又能用什么来取代它呢? 我们可别在虚造的环境里翻了船.</p></li><li><p>与其用花言巧语去美化事物, 倒不如说出事物的真相. 对大多数人来说, 我们并没有处于正确的地方, 而是出现在错误的位置. 由于天性的缺点, 我们虚构了一种情况, 把自己放进那情况里, 于是同时存在着两种情况, 想要走出来就加倍地难.</p></li><li><p>大多数人以为他们不要靠镇上的接济, 但他们往往是靠虚伪狡诈的手段来生活, 这是更应该遭到鄙视的.</p></li><li><p>去找旧东西吧, 回去找它们, 事物不会改变, 变的是我们.</p></li><li><p>别如此迫切地谋求发展, 别让自己受到许多外界因素摆布, 那本来是供你玩弄的; 那完全是在浪掷光阴.</p></li><li><p>我喜欢去掂量, 去摸索, 去接近那些让我产生最强烈最正确兴趣的东西.</p></li><li><p>我只会踏上我有能力去走的道路, 在那条道路上, 没有任何力量可以阻止我前行. 尚未打好地基就去修建拱门这种事情, 并不能给我带来满足感. 社会的沼泽和流沙也是如此, 可是年纪很大的孩子才能明白这个道理.</p></li><li><p>我们为何要长久地坐在走廊里, 空谈着那些无聊而陈腐的道德观, 而不去从事实际而有用的工作?</p></li><li><p>大多数人既不曾深入得到低下六英尺之处, 也不曾跳得多高, 我们不知道我们身在何处. 此外, 我们有大半时间是昏睡着的, 然而我们却自以为很聪明, 在表面上建立起秩序.</p></li><li><p>当今世上新奇的东西层出不穷, 可是我们依然忍受着难以置信的愚钝.</p></li><li><p>我们内心的生活就像河水, 也许它今年会涨得前所未有的高, 漫上干燥的坡地; 甚至可能造成灾害, 淹死我们所有的麝鼠.</p></li><li><p>早晨只是时间的流逝, 而不是真正的破晓. 导致我们闭上双眼的阳光, 对我们来说就是黑暗, 只有在我们醒着时, 天才是真正的破晓. 日出未必意味着光明, 太阳也无非是一颗晨星而已.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款53-55 杂项讨论</title>
    <link href="/2025/01/31/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE53-55%20%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <url>/2025/01/31/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE53-55%20%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学到这里, Effective C++至此也算是告一段落了, 还剩下一些杂七杂八的讨论, 我们将在本文逐一列举.</p></blockquote><h2 id="条款53-不要忽视编译器的警告"><a href="#条款53-不要忽视编译器的警告" class="headerlink" title="条款53 : 不要忽视编译器的警告"></a>条款53 : 不要忽视编译器的警告</h2><ul><li>我们应严肃对待编译器发出的警告信息, 努力在你的编译器最高警告级别下争取无警告的荣誉.</li><li>同时也不要过度依赖编译器的报警能力, 有些可能导致运行崩溃的错误编译器无法准确检测.</li></ul><hr><h2 id="条款54-让自己熟悉包括Tr1在内的标准程序库"><a href="#条款54-让自己熟悉包括Tr1在内的标准程序库" class="headerlink" title="条款54 : 让自己熟悉包括Tr1在内的标准程序库"></a>条款54 : 让自己熟悉包括Tr1在内的标准程序库</h2><p>Tr1其实是早期的实验标准库, 如今已经废弃, 许多功能都已经正式并入标准库中, 例如 : </p><ul><li>智能指针</li><li>functional</li><li>bind</li><li>unordered_set &#x2F; unordered_map</li><li>type_traits</li></ul><p>这些技术其实在现在都已经成熟并且被广泛运用, 成为了我们必须学习的一部分.</p><hr><h2 id="条款55-让自己熟悉Boost"><a href="#条款55-让自己熟悉Boost" class="headerlink" title="条款55 : 让自己熟悉Boost"></a>条款55 : 让自己熟悉Boost</h2><p>Boost 是 C++ 社区广泛使用的<strong>高质量开源库集合</strong>，旨在扩展 C++ 标准库功能，并推动新特性进入 C++ 标准。其特点包括：</p><ol><li><strong>高质量代码</strong>：经过严格代码审查和跨平台测试。</li><li><strong>与标准兼容</strong>：多个 Boost 组件（如智能指针、正则表达式）已被纳入 C++11 及后续标准。</li><li><strong>模块化设计</strong>：可按需引入单个头文件或编译库，减少依赖。</li><li><strong>跨平台支持</strong>：兼容主流操作系统和编译器。</li></ol><p>Boost 是 C++ 开发者的重要工具库，提供丰富的扩展功能，涵盖系统编程、算法、并发等领域。对于需要高性能和现代编程范式的项目，Boost 能显著提升开发效率和代码健壮性。</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款49-52 内存分配</title>
    <link href="/2025/01/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE49-52%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <url>/2025/01/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE49-52%20%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="条款49-了解new-handler的行为"><a href="#条款49-了解new-handler的行为" class="headerlink" title="条款49 : 了解new-handler的行为"></a>条款49 : 了解new-handler的行为</h2><h2 id="条款50-了解new和delete的合理替换时机"><a href="#条款50-了解new和delete的合理替换时机" class="headerlink" title="条款50 : 了解new和delete的合理替换时机"></a>条款50 : 了解new和delete的合理替换时机</h2><h2 id="条款51-编写new和delete时需固守常规"><a href="#条款51-编写new和delete时需固守常规" class="headerlink" title="条款51 : 编写new和delete时需固守常规"></a>条款51 : 编写new和delete时需固守常规</h2><h2 id="条款52-：写了placement-new也要写placement-delete"><a href="#条款52-：写了placement-new也要写placement-delete" class="headerlink" title="条款52 ：写了placement new也要写placement delete"></a>条款52 ：写了placement new也要写placement delete</h2><blockquote><p>条款49-52中详细讲述了定制new和delete的实现, 加上前面所讲述的智能指针及资源管理类, 让我们对内存管理有了比较深刻的认知. 但是这部分有些内容经查证已经相对过时, 所以我将统合这四个条款, 先对内存分配有一个初步的认识, 然后再简单讲解一下定制new和delete的编写, 之后再讨论一下各种内存分配的方式.</p></blockquote><h3 id="内存分配的整体认知"><a href="#内存分配的整体认知" class="headerlink" title="内存分配的整体认知"></a>内存分配的整体认知</h3><p>相比于java等编程语言以垃圾回收功能津津乐道, 但其实际也会带来运行效率下降的弊端, C++因此并没有纳入垃圾回收的机制, 将内存分配的任务交给了程序员自己, 所以学习内存分配是成为一个优秀C++程序员的所必须的. 为了实现更好的内存分配, 诸如智能指针, allocator等的各种资源管理类如雨后春笋般产生, 当然在此之外C++本身就可以对new进行定制, 这种做法虽然原始, 但是也有一定的用武之地.</p><p>先让我们了解一下内存分配的流程 : </p><ul><li>C : 内存申请(malloc) -&gt; …(使用) -&gt; 释放内存(free)</li><li>C++ : 内存申请 -&gt; 构造 -&gt; …(使用) -&gt; 析构 -&gt; 释放内存</li></ul><p>上面展示了C&#x2F;C++内存分配的流程, 其实内存申请和释放在底层都是调用malloc和free, 但是在C++中对其进行了封装, 因为其OOP的特性, 在new中不仅申请了内存, 还进行了对应的构造, 简单来说就是先调用malloc申请了一块内存, 然后在这片内存上调用对应对象的构造函数, delete也是同理不再赘述.</p><hr><h3 id="定制new和delete"><a href="#定制new和delete" class="headerlink" title="定制new和delete"></a>定制new和delete</h3><ul><li><p>什么是定制new和delete?</p><p>即对new和delete运算符进行重载, 包括new和delete的使用以及运算符重载学到这里我们应当都已经非常熟悉.</p></li><li><p>为什么要定制new和delete?</p><p>根本原因就是标准版本的new和delete提供的服务太少, 只有申请和构造, 析构和销毁, 因此定制可以实现更多的操作.</p><p>书中这里用了一个条款来解释, 我这里简单提炼一下定制new和delete主要可以做到的提升 : </p><ul><li>提前检测运用new或delete上的错误.</li><li>强化分配的效能, 可以引入内存池提升分配和释放的效率.</li><li>收集统计数据, 加入日志功能, 记录内存分配情况, 便于信息分析.</li></ul></li><li><p>如何实现定制new和delete?</p><p>主要就是学会new和delete的运算符重载, 但是其中还是有一些门道, 我们不妨来回顾一下new是如何使用的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">MyClass* myclass = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br></code></pre></td></tr></table></figure><p>假设有一个MyClass类, 其构造需要传入一个int, 这段代码便可以实现申请内存 + 构造的全过程, 但是我们还可以通过下面的代码实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* ptr = ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));    <span class="hljs-comment">// ::operator new</span><br>MyClass* myclass = <span class="hljs-built_in">new</span>(ptr) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);    <span class="hljs-comment">// placement new</span><br></code></pre></td></tr></table></figure><p>这和上面代码实现的效果是一样的, 里面的两个语法::operator new(全局分配函数)和placement new(定位new), 都是C++基础中应该学到过的, 其实也就分别对应了申请内存和构造, 于是我们可以对内存分配流程做出如下的对应 : </p><ul><li>内存申请(::operator new) -&gt; 构造(placement new) -&gt; …(使用) -&gt; 析构(placement delete) -&gt; 释放内存(::operator delete)</li></ul><p>那么定制new和delete就变成了定制::operator new和placement new(及对应deltete版本)了, 定制方法也很简单 : </p><ul><li><p>重载operator new, <strong>不同的参数对应不用的功能</strong>, 只传入一个size对应::operator new, 不仅传入size还传入ptr对应placement new, 也许这样设定你会觉得很怪, 但是事实就是这样, 我们通过代码来认识 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定制 ::operator new</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-comment">// 进行参数检测, 日志记录, 调用内存池等</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">return</span> ::<span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(size);  <span class="hljs-comment">// 可以仍然使用标准的 ::operator new, 当然也可以自己malloc</span><br>&#125;<br><br><span class="hljs-comment">// 定制 placement new 操作符</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> size, <span class="hljs-type">void</span>* ptr)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-comment">// 进行日志记录等操作</span><br>    <span class="hljs-keyword">return</span> ptr;  <span class="hljs-comment">// 不进行内存分配，只是返回已分配的内存地址</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当然这种运算符重载如果放在类外就是作用于全局, 放在类内就是类专属, 我们应当有所认知.</p></li></ul></li></ul><hr><h3 id="申请内存失败的处理方式"><a href="#申请内存失败的处理方式" class="headerlink" title="申请内存失败的处理方式"></a>申请内存失败的处理方式</h3><p>我们知道malloc是可能出错的, 内存不足等问题都有可能发送, malloc出错会返回一个nullptr, 在标准库中new会抛出<code>std::bad_alloc</code>这个异常, 因此我们在自己的<code>operator new</code>中如果使用malloc, 当其返回一个nullptr时也应抛出一个<code>bad_alloc</code>.</p><p>当然书中也提出应该有更优秀的处理方式, 不应该只是抛出异常, 在条款49中便提出标准库内置了一个错误处理函数<code>new_handler</code>, 可以通过<code>set_new_handler(handler)</code>这个函数来设置, 参数是一个函数指针, 也就是我们可以自己写回调函数并将其设置为<code>new_handler</code>, 在发生内存失败时可以自动调用该函数. 我们可以在其中记录日志, 使用内存池机制(如果用了内存池的话), 决定是否抛出异常(如果申请失败无所谓的话可以不抛出异常).</p><p>但是真的有必要吗?</p><p>其实new_handler在实际运用中已经很少使用, 根本原因还是在现代内存大小已经不再是问题, 也就是说内存申请失败几乎不可能出现, 只在极少嵌入式设备中可能有需要了. 而且如果真的出现了申请内存失败那只能说明问题很大, 不是硬件有问题就是代码哪里出现了严重的内存泄露, 这不是写一个new_handler可以解决的了, 因此其实在现代背景下还是老实抛出异常就行了.</p><hr><h3 id="浅谈内存分配"><a href="#浅谈内存分配" class="headerlink" title="浅谈内存分配"></a>浅谈内存分配</h3><p>关于内存分配我认为学好智能指针的使用是最关键的, 因为其可以很大程度上保证我们的代码不会内存泄漏, 只要不发生内存泄漏, 内存大小一般不会是问题.</p><p>我们对于内存分配的关注点应该放在如何避免内存泄漏和提升效率上, 内存泄漏有智能指针避免, 提速可以通过<strong>引入内存池</strong>来缓解, 内存池这里不再详述, 简单来说就是申请和释放内存其实是有一定花销的, 不断的一小块一小块地申请内存然后构造其实是效率远低于直接申请一大块内存, 然后根据需求分配这块内存的, 而内存池就是做到了后者.</p><p>至于如何引入, 可以通过上文的定制new和delete的重载函数中引入, 也可以通过自定义的allocator(分配器)来引入, allocator也是一种相对有用的内存分配技术, 如果感兴趣可以自己搜索学习.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>内存分配在现代主要还是依赖智能指针, 可以有效避免内存泄露.</li><li>如果想对内存分配做更细致的处理, 例如提速或记录日志等, 可以尝试定制new和delete, 使用allocator, 引入内存池.</li><li>内存分配失败的情况在当下非常少见, 可以写简单的失败处理机制, 但没必要投入过多精力.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款48 模板元编程(TMP)</title>
    <link href="/2025/01/22/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE48%20%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B(TMP)/"/>
    <url>/2025/01/22/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE48%20%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B(TMP)/</url>
    
    <content type="html"><![CDATA[<h2 id="条款48-认识template元编程"><a href="#条款48-认识template元编程" class="headerlink" title="条款48 : 认识template元编程"></a>条款48 : 认识template元编程</h2><blockquote><p>在条款47我们主要了解了萃取器这种模板元编程, 也初步进入了模板元编程的世界. 在本条款中, 我们将继续认识模板元编程, 认识其必要性和应用场景, 相比于条款47讲的还算比较深入,本条款真的就只是简介, 因为其体量确实非常庞大, 甚至可以单独作为一个学科研究.</p></blockquote><p><code>Template metaprogramming</code>, 模板元编程, 简称TMP, 是<strong>编写template-based C++程序并执行于编译期的过程</strong>.</p><hr><h3 id="模板元编程的效用"><a href="#模板元编程的效用" class="headerlink" title="模板元编程的效用"></a>模板元编程的效用</h3><p>我们目前可以用在条款47中学到的萃取器的知识来理解模板元的效用 : </p><ul><li>它让某些事情更容易, 这些事情原本比较困难甚至不可能.(例如针对迭代器类型进行可靠的条件编译)</li><li>它将工作期从运行期移至编译期, 大大提高了运行效率, 有更小的可执行文件, 更短的运行期, 更少的内存消耗.</li></ul><p>假设我们使用萃取器时不采用重载或<code>if constexpr</code>这种模板元编程, 而是就是在运行期通过判断迭代器类型来条件判断, 我们看看最后的效果怎样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeid</span>(<span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category) ==<br>      <span class="hljs-built_in">typeid</span>(std::random_access_iterator_tag)) &#123;<br>     iter += d;                                     <br>  &#125;                                                 <br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">while</span> (d--) ++iter; &#125;             <br>    <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">while</span> (d++) --iter; &#125;                    <br>  &#125;                                                 <br>&#125;<br></code></pre></td></tr></table></figure><p>这里还是用萃取器提取出类型, 利用<code>typeid</code>在运行期进行条件判断, 但是这种方法不仅不高效(对应效用2), 而且不可行(对应效用1).</p><ul><li><p>不高效 : 这个很容易理解, 利用模板元编程在编译期即可实现的效果, 这样却要在运行期花时间判断.</p></li><li><p>不可行 : 这段代码在一些情况下甚至都无法通过编译, 如果我们像下面这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::list&lt;<span class="hljs-type">int</span>&gt;::iterator iter;<br><span class="hljs-built_in">advance</span>(iter, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>这样使用非常合理, 但是会运行崩溃, 因为list的迭代器是双向迭代器, 而非随机访问迭代器, 所以<code>iter += d;</code>这段代码根本无法通过编译! 也许你会认为因为条件判断, 如果是list的迭代器, 这句代码永远不会触发, 但是我们应当知道 : </p><ul><li><strong>编译器必须确保所有源码都有效, 纵使是不会执行起来的代码.</strong></li></ul></li></ul><p>至此我们应该已经可以理解到部分模板元编程可以达到的效用了.</p><hr><h3 id="模板元编程中的”hello-world-”"><a href="#模板元编程中的”hello-world-”" class="headerlink" title="模板元编程中的”hello world!”"></a>模板元编程中的”hello world!”</h3><p>我们可以了解模板元编程中的一个入门编程, 它相当于初入编程的”hello world”, 即<strong>在编译期计算阶乘</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;                 <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;                   <br>  <span class="hljs-keyword">enum</span> &#123; value = n * Factorial&lt;n<span class="hljs-number">-1</span>&gt;::value &#125;;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                          <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;            <span class="hljs-comment">// 全特化</span><br>  <span class="hljs-keyword">enum</span> &#123; value = <span class="hljs-number">1</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们通过代码应该可以推导出一个递归的过程, 并且这个过程是通过模板在编译期来实现的! 于是我们就可以这样使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">5</span>&gt;::value &lt;&lt; std::endl;   <span class="hljs-comment">// 直接打印出120</span><br>  std::cout &lt;&lt; Factorial&lt;<span class="hljs-number">10</span>&gt;::value;               <span class="hljs-comment">// 直接打印出3628800</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以和普通递归求阶乘进行对比 : </p><ul><li>普通递归 : 运行期实现, 可以通过用户输入动态计算任意数的阶乘.</li><li>模板元递归 : 编译期实现, 只可以得到预先设置的数的阶乘.</li></ul><p>简单来说就是前者耗费运行期时间但是灵活, 后者不费运行期时间但是不可变.</p><p>当然使用enum是一个比较原始且可读性较差的做法, 在C++11已经引入constexpr : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">unsigned</span> n&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span> &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> value = n * Factorial&lt;n - <span class="hljs-number">1</span>&gt;::value;  <span class="hljs-comment">// constexpr代替enum</span><br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Factorial</span>&lt;<span class="hljs-number">0</span>&gt; &#123;<br>  <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">unsigned</span> value = <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="三个应用场景案例"><a href="#三个应用场景案例" class="headerlink" title="三个应用场景案例"></a>三个应用场景案例</h3><ul><li><p>确保度量单位正确.</p><p>在科学工程中, 我们可以提前确定度量单位的结合正确, 可以进行早期的错误侦测.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-comment">// 定义不同的单位类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Time</span> &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Time&quot;</span>; &#125;;<span class="hljs-comment">// 时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Length</span> &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Length&quot;</span>; &#125;;<span class="hljs-comment">// 长度</span><br><br><span class="hljs-comment">// 计算单位的乘法</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Unit1, <span class="hljs-keyword">typename</span> Unit2&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>;<br><br><span class="hljs-comment">// 两个长度相乘得到面积</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>&lt;Length, Length&gt; &#123;   <span class="hljs-comment">// 全特化</span><br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">struct</span> Area &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Area&quot;</span>; &#125;; <span class="hljs-comment">// 定义面积类型</span><br>&#125;;<br><br><span class="hljs-comment">// 时间与长度相除，得到速度</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MultiplyUnits</span>&lt;Length, Time&gt; &#123;<br>    <span class="hljs-keyword">using</span> type = <span class="hljs-keyword">struct</span> Velocity &#123; <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = <span class="hljs-string">&quot;Velocity&quot;</span>; &#125;; <span class="hljs-comment">// 定义速度类型</span><br>&#125;;<br><br><span class="hljs-comment">// 打印单位名称</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Unit&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printType</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;TypeName: &quot;</span> &lt;&lt; Unit::name &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 计算长度与时间的组合，得到速度</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MultiplyUnits&lt;Length, Time&gt;::type unit1;<br><span class="hljs-built_in">printType</span>&lt;unit1&gt;();  <span class="hljs-comment">// 输出: Unit: Velocity</span><br><br><span class="hljs-comment">// 计算长度与长度的组合，得到面积</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> MultiplyUnits&lt;Length, Length&gt;::type unit2;<br><span class="hljs-built_in">printType</span>&lt;unit2&gt;();  <span class="hljs-comment">// 输出: Unit: Area</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本例中就可以根据向<code>MultiplyUnits</code>中传入的类型在编译期进行判断其结果的类型.</p></li><li><p>优化矩阵运算.</p><p>在条款44中我们编写过矩阵, 假如我们进行下面的运算 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10000</span>&gt; BigMatrix;<br>BigMatrix m1, m2, m3, m4, m5;              <br>BigMatrix result = m1 * m2 * m3 * m4 * m5; <br></code></pre></td></tr></table></figure><p>如果这些在运行期完成, 将会产生内存巨大的临时对象和不低的时间成本, 但假如用模板元编程就可能消除临时对象并合并循环, 大大降低成本, 具体细节书中没有给出, 这里就不再细讲.</p></li><li><p>可以生成客户定制之设计模式实现品.</p><p>这里的命题就更加广阔了, 简单理解就是许多设计模式都和类与模板有关, 可以利用模板元编程根据需求将一些设计模式的行为从运行期搬到编译期中, 不仅实现了定制, 还提高了运行效率.</p></li></ul><hr><h3 id="现代模板元编程"><a href="#现代模板元编程" class="headerlink" title="现代模板元编程"></a>现代模板元编程</h3><p>随C++11, C++14, C++17的引入, 模板元编程的语法日渐丰富, 这一领域虽然有些晦涩难懂, 但是其确实有其价值所在, 并且越来越被重视. 我们虽然不一定要完全掌握, 但是可以逐步了解一下模板元编程的语法, 例如constexpr, if constexpr, SFINAE技术, 模板元函数等等.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>模板元编程可将工作由运行期移往编译期, 因而得以实现早期错误侦测和更高的执行效率.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款47 萃取器</title>
    <link href="/2025/01/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE47%20%E8%90%83%E5%8F%96%E5%99%A8/"/>
    <url>/2025/01/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE47%20%E8%90%83%E5%8F%96%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="条款47-请使用traits-classes表现类型信息"><a href="#条款47-请使用traits-classes表现类型信息" class="headerlink" title="条款47 : 请使用traits classes表现类型信息"></a>条款47 : 请使用traits classes表现类型信息</h2><blockquote><p>traits classes(萃取器类), 如你所见萃取器其实是一个模板类, 在C++中萃取器是一个神奇且有趣的存在, 它被广泛引用于标准库STL的编写中, 我们将在本条款中了解萃取器的功能及实现, 初步踏入模板元编程的世界.</p></blockquote><h3 id="模板元编程的初步认知"><a href="#模板元编程的初步认知" class="headerlink" title="模板元编程的初步认知"></a>模板元编程的初步认知</h3><p>很多人在第一次听到”模板元编程”时一定觉得非常高大上, 但是实际上我们可以简单认知其为<strong>针对模板类型在编译期执行的代码</strong>, 目前我们写的代码大都是在运行期执行的, 但是由于模板的引入, 我们便可以针对模板类型(T)进行各种操作, 譬如根据不同的类型选择不同的执行代码和计算逻辑, 这些行为都会在编译期执行. 而我们本条款要学习的萃取器便属于模板元编程的一部分.</p><hr><h3 id="在-STL源码剖析-中学习"><a href="#在-STL源码剖析-中学习" class="headerlink" title="在 STL源码剖析 中学习"></a>在 <em>STL源码剖析</em> 中学习</h3><p>本条款其实只是对萃取器的简介, 让你认识萃取器这个存在, 想要真正掌握它, 还是建议阅读<em>STL源码剖析</em>, 其中第二章用了整整一章的内容来详述萃取器相关的内容, 我也是因为提前阅读过<em>STL源码剖析</em>, 才对本条款的阅读没有什么障碍的.</p><hr><h3 id="萃取器"><a href="#萃取器" class="headerlink" title="萃取器"></a>萃取器</h3><p>顾名思义, 萃取器是用来萃取的, 其作用是<strong>从模板类型中萃取出类型信息</strong>, 另外萃取器是一种<strong>技术</strong>, 是一个可以实现萃取功能的类, 并且同时也需要被萃取类的帮助才行. </p><p>我们先来介绍书中的典例 - 迭代器 :</p><p>迭代器大家都熟知, 并且迭代器有五种迭代器类别 : <strong>只读迭代器, 只写迭代器, 单向读写迭代器, 双向读写迭代器, 随机读写迭代器</strong>, 这五种迭代器类型有明确的继承关系, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_iterator_tag</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">output_iterator_tag</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">forward_iterator_tag</span>: <span class="hljs-keyword">public</span> input_iterator_tag &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">bidirectional_iterator_tag</span>: <span class="hljs-keyword">public</span> forward_iterator_tag &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">random_access_iterator_tag</span>: <span class="hljs-keyword">public</span> bidirectional_iterator_tag &#123;&#125;;<br></code></pre></td></tr></table></figure><p>另外STL库中还有许多模板函数, advance函数便是其中之一, 其声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;  </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span>;<br></code></pre></td></tr></table></figure><p>其接收一个迭代器类型参数和一个距离类型参数, 意在实现<code>iter += d</code>这种操作, 也就是让iter按d发生变化, 这是迭代器的基本功能. 但是不同的迭代器所能实现的操作有所差别 : </p><ul><li>只读只写迭代器和单向读写迭代器只能正向且一次一步读写(++). </li><li>双向读写迭代器可以双向一次一步读写(++, –).</li><li>随机读写迭代器可以跳跃读写(+&#x3D; x, -&#x3D; x).</li></ul><p>这就导致advance希望根据迭代器类别去实现不同的操作, 就像下面一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span>(判断iter是否是随机读写迭代器) &#123;<br>        iter += d;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断iter是否是双向读写迭代器) &#123;<br>        <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (d--) ++iter;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (d++) --iter;<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(判断iter是否是迭代器) &#123;<br>        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 反向是违规的</span><br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance not supported for input iterators.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (d--) ++iter;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>当然这只是我们的幻想, 直接判断迭代器类型这种技术在C++17才出现, 我们在后面也会讲解, 但是我们先看看前人是如何解决这个问题的.</p><p>解决方法自然就是用<strong>萃取器</strong>了, 我们先要知道萃取器要做到什么, 在本例中就是<strong>从迭代器类型IterT中得到迭代器的类别</strong>, 这里不要混淆了, 迭代器类型是专属于某些大类的迭代器(如vector, deque的iterator), 迭代器类别就是我们上面说的五种类别, 也就是我们要从迭代器类型中提取出的东西. </p><p>重点在于如何提取出来, 实际过程非常复杂, 但又缺一不可, 我在这里经过总结将其分为两个部分 : 准备阶段和使用阶段.</p><hr><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>在这一阶段, 我们需要做的工作有 : </p><ul><li><p><strong>为需要提取出相关信息的迭代器配置对应的标签</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; ... &gt;                  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">deque</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category;  <span class="hljs-comment">// 这里便配置了需要的标签</span><br>    ...<br>  &#125;:<br>&#125;;<br></code></pre></td></tr></table></figure><p>本例中我们对deque(双端队列)的迭代器进行操作, 使用typedef对其<code>iterator_category(迭代器类别)</code>进行了声明, 这其实就是在说明deque的迭代器是可以随机读写的.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt; ... &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">list</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">iterator</span> &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> bidirectional_iterator_tag iterator_category;<br>    ...<br>  &#125;:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>在list中也是如此, list不支持随机读写, 只能双向读写, 因此它声明的是<code>bidirectional_iterator_tag</code>.</p></li><li><p><strong>准备一个萃取器类, 使其可以提取出迭代器中的对应标签.</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span> &#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> IterT::iterator_category iterator_category;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>提取的原理其实很简单, 这里需要萃取器类和被萃取类有一个<strong>共识</strong>, <strong>代表迭代器类别的标签名为<code>iterator_category</code></strong>, 这样只要向萃取器类中传入一个迭代器类型, 就可以通过<code>typedef typename IterT::iterator_category iterator_category;</code>这段代码将原本迭代器类型中的<code>iterator_category</code>, 赋给自己的<code>iterator_category</code>, 这样就实现了迭代器类别的提取.</p><p>当然我们可以发现这种萃取器只对typedef了<code>iterator_category</code>的自定义类型生效, 但在实际使用中普通指针也是类似迭代器的形式, 例如普通数组<code>int* arr</code>, 这里int*就可以当作是一种指针迭代器类, 它也可以做到随机读写访问. 因此我们可以使用模板的偏特化, 使其兼容指针迭代器 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;  <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">iterator_traits</span>&lt;IterT*&gt;   <span class="hljs-comment">// 模板偏特化</span><br>&#123;<br>  <span class="hljs-keyword">typedef</span> random_access_iterator_tag iterator_category; <span class="hljs-comment">// 直接设置普通指针的迭代器类型为随机读写迭代器</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="使用阶段"><a href="#使用阶段" class="headerlink" title="使用阶段"></a>使用阶段</h3><p>在准备阶段做出了萃取器后, 我们将要通过在advance函数中使用萃取器来达到我们原先希望的效果, 使用方法如下 : </p><ul><li>建立一个控制函数, 依旧是接受迭代器和距离.</li><li>建立一组特化函数, 除了接收迭代器, 距离, 还有迭代器类型.</li><li>在控制函数中利用萃取器萃取出迭代器类别, 将迭代器类别传入特化函数.</li><li>依靠<strong>重载解析</strong>机制, 将调用对应迭代器类型的特化函数.</li></ul><p>光看比较难以理解, 我们通过代码来分析 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//-------------特化函数-------------//</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::random_access_iterator_tag)</span>    <span class="hljs-comment">// 针对:random_access_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  iter += d;   <span class="hljs-comment">// 直接+=</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::bidirectional_iterator_tag)</span>    <span class="hljs-comment">// 针对bidirectional_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">while</span> (d--) ++iter; &#125;     <br>  <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">while</span> (d++) --iter;&#125;       <span class="hljs-comment">// 可逐次++/--</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;              </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doAdvance</span><span class="hljs-params">(IterT&amp; iter, DistT d,                  </span></span><br><span class="hljs-params"><span class="hljs-function">               std::input_iterator_tag)</span>   <span class="hljs-comment">// 针对input_iterator的特化版本</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span> ) &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance&quot;</span>);    <br>  &#125;<br>  <span class="hljs-keyword">while</span> (d--) ++iter;   <span class="hljs-comment">// 只可逐次++</span><br>&#125;<br><br><span class="hljs-comment">//-------------控制函数-------------//</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT, <span class="hljs-keyword">typename</span> DistT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span>           <span class="hljs-comment">// 控制函数</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 调用特化函数  </span><br>  <span class="hljs-built_in">doAdvance</span>(iter, d,                                              <br>    <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::<span class="hljs-built_in">iterator_category</span>()); <span class="hljs-comment">// 这里是最重点的地方                       </span><br>&#125;   <br></code></pre></td></tr></table></figure><p>我们先聚焦于控制函数, 调用特化函数应该都能理解, 重点在于 : </p><ul><li><strong>typename std::iterator_traits<IterT>::iterator_category()</strong></li></ul><p>这是<strong>特化函数的第三个参数</strong>, 这段代码如何理解?</p><ul><li><p>其中<code>typename</code>是为了防止编译器混淆, 确定后面的是一个类型(见条款42).</p></li><li><p><code>typename std::iterator_traits&lt;IterT&gt;::iterator_category</code>是一个类型, <strong>代表<code>iterator_traits</code>从<code>IterT</code>中取出的迭代器类别的类型</strong>.</p></li><li><p>后面加上**()**, 代表这是一个匿名变量, 这个参数本身没有任何用处, 所以使用匿名变量完全可行, <strong>其作用只在于传递一个类型, 触发内部的重载机制, 选择到正确的特化版本</strong>.</p></li></ul><p>再去分析特化函数, 上面给出了三个版本, <strong>第三个参数的类型分别是对应的迭代器类别</strong>, 这里连参数都没写在语法上是可行的, 因为确实不会用到, 没有写的必要. 这里要强调的一点是虽然没有<code>forward_iterator</code>的版本, 但是因为其和<code>input_iterator</code>的操作实质上是一样的, 这里会直接通过<strong>继承</strong>调用到其基类<code>input_iterator</code>的代码, 因此不需要多写.</p><hr><h3 id="现代C-中萃取器的使用方式"><a href="#现代C-中萃取器的使用方式" class="headerlink" title="现代C++中萃取器的使用方式"></a>现代C++中萃取器的使用方式</h3><p>先前我们介绍的使用方式是<strong>基于重载机制</strong>, 实现在编译期即可通过不同的迭代器类别选取不同的特化版advance.</p><p>一切的根本目的就是为了<strong>在编译期实现条件选择</strong>, 现在C++17中引入了<code>if constexpr</code>语法, 使得我们可以用类似if的语句实现编译器的条件选择, 就不需要再使用重载了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">advance</span><span class="hljs-params">(IterT&amp; iter, DistT d)</span> </span>&#123;<br>    <span class="hljs-keyword">using</span> category = <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::iterator_category; <span class="hljs-comment">// 还是要先萃取出迭代器类别</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;category, std::random_access_iterator_tag&gt;)</span> </span>&#123;<br>        iter += d;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;category, std::bidirectional_iterator_tag&gt;) &#123;<br>        <span class="hljs-keyword">if</span> (d &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (d--) ++iter;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">while</span> (d++) --iter;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;category, std::input_iterator_tag&gt;) &#123;<br>        <span class="hljs-keyword">if</span> (d &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;Negative distance not supported for input iterators.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (d--) ++iter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过标准库内置的<code>is_same_v</code>来判断两个类别是否相等, 其他均和普通if语句的操作一致.</p><hr><h3 id="更多类型信息可供提取"><a href="#更多类型信息可供提取" class="headerlink" title="更多类型信息可供提取"></a>更多类型信息可供提取</h3><p>在本条款中只针对<code>iterator_category</code>进行了提取, 但是事实上萃取器可以提取出更多的类型信息, 在<em>STL源码剖析</em>中主要提出了五种信息, 分别是 : value_type(迭代器所指对象的类型), difference_type(两个迭代器之间的距离类型), reference_type(迭代器所指对象的类型的引用), pointer_type(迭代器所指对象的类型的指针), iterator_category(迭代器类别).</p><p>这里<code>value_type</code>尤为常用, 像上文一样既然可以通过<code>iterator_category</code>来选取不同版本的代码, 那么也可以根据<code>value_type</code>(对象类型)来选取不同版本的代码, 所以说萃取器提供了非常灵活多样的编译期条件选取方式.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>可以使用萃取器技术提取出模板类型中的类型信息, 利用重载或C++17中的<code>if constexpr</code>实现编译期的条件选择.</li><li>实现萃取需要双方约定相同的类型信息名称.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
      <tag>萃取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款46 友元非成员函数</title>
    <link href="/2025/01/14/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE46%20%E5%8F%8B%E5%85%83%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2025/01/14/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE46%20%E5%8F%8B%E5%85%83%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款46-需要类型转换时请为模板定义友元非成员函数"><a href="#条款46-需要类型转换时请为模板定义友元非成员函数" class="headerlink" title="条款46 : 需要类型转换时请为模板定义友元非成员函数"></a>条款46 : 需要类型转换时请为模板定义友元非成员函数</h2><blockquote><p>本条款是条款24的延申讨论, 在引入模板的前提下, 如果我们想实现某些隐式类型转换的操作, 会需要比以往多一些额外的操作, 让我们通过本条款来理解.</p></blockquote><h3 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h3><p>还记得条款24中的<code>Rational</code>吗, 这是一个有理数类, 内部包含分子和分母, 可以由int隐式转换而来, 当时条款24中讨论的核心是如何让<code>Rational</code>支持混合运算, 就像下面这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result;          <br>result = oneHalf * <span class="hljs-number">2</span>;                 <br>result = <span class="hljs-number">2</span> * oneHalf;   <span class="hljs-comment">// 混合类型的乘法运算                          </span><br></code></pre></td></tr></table></figure><p>没有了解的可以看我往期的博客, 总之讨论最后的结果就是<code>operator*重载</code>不可以是成员函数(因为有this指针干扰), 要使用非成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>那么如果我们想写一个泛型的<code>Rational</code>, 我们会很自然地写出下面的版本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">const</span> T&amp; numerator = <span class="hljs-number">0</span>,     <br>           <span class="hljs-type">const</span> T&amp; denominator = <span class="hljs-number">1</span>);  <span class="hljs-comment">// 这个构造函数允许隐式类型转换</span><br><br>  <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <br>  <span class="hljs-function"><span class="hljs-type">const</span> T <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;         <br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,<br>                            <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>但很可惜, 当我们写出<code>result = oneHalf * 2;</code>这样的语句时根本无法通过编译, 其本质问题在于<strong>template的实参推导出了问题</strong>, 因为<strong>template实参推导过程中不将隐式类型转换纳入考虑</strong>, 2不能再像条款24中一样从int隐式转换为<code>Rationa</code>, 编译器只能试图从int中提取出T, 但这显然是不行的, 所以只能编译失败.</p><hr><h3 id="类内定义友元函数"><a href="#类内定义友元函数" class="headerlink" title="类内定义友元函数"></a>类内定义友元函数</h3><p>书中指出了解决方法 : </p><ul><li><strong>将这个非成员函数声明为友元.</strong></li></ul><p>我们在这里声明友元不是为了访问<code>Rational</code>中的<code>non-public</code>成分, 仅仅只是为了<strong>在类内部声明一个非成员函数</strong>, 这样在编译时<strong>这个非成员函数就会提前知道T是什么类型</strong>, 而不需要再通过template实参推导出, 前面的问题就迎刃而解了, 下面是新一版代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 声明友元模板函数</span><br>    <span class="hljs-keyword">typename</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs); <br>    ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                <br><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)&#123; <br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码在部分情况下是可以运行的, 也就是参数类型都是<code>Rational&lt;T&gt;</code>的情况下, 形如 <code>result = oneHalf * 2;</code>这样的语句依旧无法通过编译, 因为<strong>还是无法进行隐式转换</strong>! 我们知道Rational的隐式转换是通过其构造函数实现的, 但是当前情况是<code>operator*重载</code>被定义在类外, 由于template的存在, <code>Rational</code>和该函数没有任何联系, 该函数自然不能知道<code>Rational</code>的构造函数, 因此无法进行隐式转换.</p><p>解决方法也很简单 : </p><ul><li><strong>在类内定义友元函数</strong>.</li></ul><p>这种做法的本质是<strong>通过友元把一个非成员函数搬到了类内, 在类内接触到构造函数使之可以隐式类型转换</strong>. 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs, <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),      <br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());  <br>&#125;    <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样代码就可以正常运行了, 混合类型的运算也可以应对!</p><p>另外, 书中提出 : </p><ul><li><strong>在一个class template内, template名称可被用来作为”template和其参数”的简写</strong>.</li></ul><p>简单来说就是<code>Rational&lt;T&gt;</code>可以之间被替换为<code>Rational</code>, 仅限模板类内 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),      <br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());  <br>&#125;   <br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这便是最简单可以达到目的的版本了!</p><hr><h3 id="令friend函数调用辅助函数"><a href="#令friend函数调用辅助函数" class="headerlink" title="令friend函数调用辅助函数"></a>令friend函数调用辅助函数</h3><p>在此基础上, 作者还提出了一点优化, 因为我们在条款30中说过, friend函数也会被在底层化为inline函数, 这在对于本例确实是优化, 因为这个函数只有一行, 但是假如这个函数很长就会带来代码膨胀的问题, 于是我们可以”<strong>令friend函数调用辅助函数</strong>“来避免这一问题.</p><p>在本例中确实没什么必要, 这里只是举个例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span>;                                                                         <br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                                      </span><br><span class="hljs-function"><span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-title">doMultiply</span><span class="hljs-params">(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,      <span class="hljs-comment">// 辅助函数, 代码可以非常长</span></span></span><br><span class="hljs-params"><span class="hljs-function">                             <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)</span>     </span><br><span class="hljs-function"></span>&#123;                                                         <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>&lt;T&gt;(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),   <br>                     lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">friend</span><br>  <span class="hljs-type">const</span> Rational&lt;T&gt; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&lt;T&gt;&amp; lhs,<br>                              <span class="hljs-type">const</span> Rational&lt;T&gt;&amp; rhs)   <br>  &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">doMultiply</span>(lhs, rhs); &#125;                      <span class="hljs-comment">// 这里直接在友元函数中调用辅助函数</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里的代码非常巧妙, 我们可以知道辅助函数也是一个模板函数, 在这个函数里是无法进行隐式转换的, 但是实际效果依然可以隐式转换, 它支持各种混合运算! 因为所有的隐式转换都在<code>友元operator*重载</code>中进行, 在传给辅助函数时类型已经转换完毕!</p><hr><h3 id="逻辑梳理"><a href="#逻辑梳理" class="headerlink" title="逻辑梳理"></a>逻辑梳理</h3><p>我们可以再理一遍逻辑, 在引入模板的前提下 : </p><ul><li>为了支持混合运算, 运算符重载必须是非成员模板函数(成员模板函数有this干扰).</li><li>非成员模板函数实参推导过程中不将隐式类型转换纳入考虑.</li><li>因此要将其声明定义在类内, 本质是非成员函数, 不使用模板但达到模板类似的效果.</li><li>声明友元可以实现上述的需求.</li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>当我们希望一个模板类的运算可以支持”<strong>所有参数之隐式类型转换</strong>“时, 将那些函数定义为”<strong>class template内部的friend函数</strong>“.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款45 运用成员函数模板接受所有兼容类型</title>
    <link href="/2025/01/13/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE45%20%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B/"/>
    <url>/2025/01/13/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE45%20%E8%BF%90%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A5%E5%8F%97%E6%89%80%E6%9C%89%E5%85%BC%E5%AE%B9%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="条款45-运用成员函数模板接受所有兼容类型"><a href="#条款45-运用成员函数模板接受所有兼容类型" class="headerlink" title="条款45 : 运用成员函数模板接受所有兼容类型"></a>条款45 : 运用成员函数模板接受所有兼容类型</h2><blockquote><p>本条款中我们将会以智能指针为例, 介绍如何通过成员函数模板使一个模板类可以接受所有兼容类型.</p></blockquote><p>我们先来构建一个简单的继承体系 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Top</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Middle</span>: <span class="hljs-keyword">public</span> Top &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span>: <span class="hljs-keyword">public</span> Middle &#123; ... &#125;;<br>Top *pt1 = <span class="hljs-keyword">new</span> Middle;                   <span class="hljs-comment">// Middle*隐式转换为Top*</span><br>Top *pt2 = <span class="hljs-keyword">new</span> Bottom;                   <span class="hljs-comment">// Bottom*隐式转换为Top*</span><br><span class="hljs-type">const</span> Top *pct2 = pt1;  <span class="hljs-comment">// Top*隐式转换为const Top*</span><br></code></pre></td></tr></table></figure><p>在本例中, <code>Top</code>是最初始的基类, 依次派生出<code>Middle</code>和<code>Bottom</code>, 通过隐式转换, 各种指针类型是可以合理地进行隐式转换的. 但当我们想用智能指针代行管理事务时, 再想这样的转换就比较麻烦了, 当然标准库中的智能指针已经解决了这种问题, 我们现在要讨论的就是标准库是如何实现智能指针之间的隐式转换的, 我们期待的效果如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:                             <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SmartPtr</span><span class="hljs-params">(T *realPtr)</span></span>;    <span class="hljs-comment">// 通过资源指针进行初始化</span><br>  ...<br>&#125;;<br><br>SmartPtr&lt;Top&gt; pt1 = <span class="hljs-built_in">SmartPtr</span>&lt;Middle&gt;(<span class="hljs-keyword">new</span> Middle);   <br>SmartPtr&lt;Top&gt; pt2 = <span class="hljs-built_in">SmartPtr</span>&lt;Bottom&gt;(<span class="hljs-keyword">new</span> Bottom); <br>SmartPtr&lt;<span class="hljs-type">const</span> Top&gt; pct2 = pt1; <br></code></pre></td></tr></table></figure><p>这段代码是无法通过编译的, 因为就算是<code>Top</code>和<code>Middle</code>有联系, <code>SmartPtr&lt;Top&gt;</code>和<code>SmartPtr&lt;Middle&gt;</code>也没有任何联系, 它们是无法隐式转换的, 但是我们可以通过成员函数模板, 具体说是写一个泛化copy构造函数来创造这种联系.</p><hr><h3 id="泛化copy构造函数"><a href="#泛化copy构造函数" class="headerlink" title="泛化copy构造函数"></a>泛化copy构造函数</h3><p>我们先来写一个成员函数模板中的<strong>泛化copy构造函数</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;                       <span class="hljs-comment">// 泛化copy构造函数</span><br>  <span class="hljs-built_in">SmartPtr</span>(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other);       <br>  ...                 <br>&#125;;<br></code></pre></td></tr></table></figure><p>这个模板函数接受用一个<code>SmartPtr&lt;U&gt;</code>类型的参数去构造一个<code>SmartPtr&lt;T&gt;</code>类型的对象, 现在还只是声明, 我们应该考虑如何定义内部逻辑, 正常逻辑应该是先看<code>U*</code>是否可以隐式转换为<code>T*</code>, 如果可以转换也就可以进行智能指针之间的转换, 我们来看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SmartPtr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> U&gt;</span><br><span class="hljs-function">  <span class="hljs-title">SmartPtr</span><span class="hljs-params">(<span class="hljs-type">const</span> SmartPtr&lt;U&gt;&amp; other)</span>         </span><br><span class="hljs-function">  : heldPtr(other.get()) &#123;</span>...&#125;            <span class="hljs-comment">// 关键代码</span><br>    <br>  <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> heldPtr; &#125;<br>  ...<br><span class="hljs-keyword">private</span>:                                     <br>  T *heldPtr;                                <br>&#125;;<br></code></pre></td></tr></table></figure><p>这里直接将参数other中的<code>heldPtr</code>取出, 赋值给当前对象的<code>heldPtr</code>. 其实在这里就进行了检查 : </p><ul><li><code>other.get()</code>取出的指针类型为<code>U*</code>, 如果<code>U*</code>可以隐式转换为<code>T*</code>, 那么可以进行智能指针之间的转换.</li><li>如果不可以隐式转换, 编译错误, 会被系统拦截.</li></ul><p>至此, 通过泛化copy构造函数这个成员函数模板, 只要<code>U*</code>可以隐式转换为<code>T*</code>, 那么<code>SmartPtr&lt;U&gt;</code>也可以隐式转换为<code>SmartPtr&lt;T&gt;</code>.</p><hr><h3 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h3><p>成员函数模板的效用不只局限于构造函数, 也可以支持赋值操作, 其不改变语言规则, 但是可以帮助你让class在构造和赋值操作上可以兼容更多类型, 让我们在使用模板类型时可以像使用非模板类型时一样自然流畅. 我们可以了解一下标准库中<code>shared_ptr</code>的简略版本, 看看其对成员函数模板的使用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(Y * p)</span></span>;                         <span class="hljs-comment">// 泛化构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;                 <span class="hljs-comment">// 泛化copy构造函数</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                     </span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(weak_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;          <span class="hljs-comment">// 通过weak_ptr构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">explicit</span> <span class="hljs-title">shared_ptr</span><span class="hljs-params">(unique_ptr&lt;Y&gt;&amp; r)</span></span>;<span class="hljs-comment">// 通过unique_ptr构造</span><br>  <span class="hljs-comment">// 赋值</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                                    <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r);      <span class="hljs-comment">// 泛化赋值重载</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                                     <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(unique_ptr&lt;Y&gt;&amp; r);            <span class="hljs-comment">// 用unique_ptr赋值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>在本例中,  构造函数中只有泛化copy构造函数没有explicit, 说明其他构造函数都不应当支持隐式类型转换, 也就是说T和Y的类型应当一致. 另外成员模板函数并<strong>不改变语言规则</strong>, 就算我们写了泛化的拷贝构造函数和赋值重载, 依旧不影响普通的拷贝构造和赋值重载, 如果我们没有写, 编译器还是会自动生成, 所以如果想要控制构造的方方面面, 我们应当<strong>同时声明普通版本和泛化版本</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">shared_ptr</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">shared_ptr</span>(shared_ptr <span class="hljs-type">const</span>&amp; r);                 <span class="hljs-comment">// 普通拷贝构造</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Y&gt;                                </span><br><span class="hljs-function">    <span class="hljs-title">shared_ptr</span><span class="hljs-params">(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r)</span></span>;            <span class="hljs-comment">// 泛化拷贝构造</span><br><br>  shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr <span class="hljs-type">const</span>&amp; r);      <span class="hljs-comment">// 普通赋值重载</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span>&gt;                               <br>    shared_ptr&amp; <span class="hljs-keyword">operator</span>=(shared_ptr&lt;Y&gt; <span class="hljs-type">const</span>&amp; r); <span class="hljs-comment">// 泛化赋值重载</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>使用成员函数模板可以生成”可接受所有兼容类型”的函数.</li><li>当我们声明泛化拷贝构造和赋值重载时, 也应该声明其普通版本.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款44 防止代码膨胀</title>
    <link href="/2025/01/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE44%20%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80/"/>
    <url>/2025/01/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE44%20%E9%98%B2%E6%AD%A2%E4%BB%A3%E7%A0%81%E8%86%A8%E8%83%80/</url>
    
    <content type="html"><![CDATA[<h2 id="条款44-将与参数无关的代码抽离templates"><a href="#条款44-将与参数无关的代码抽离templates" class="headerlink" title="条款44 : 将与参数无关的代码抽离templates"></a>条款44 : 将与参数无关的代码抽离templates</h2><blockquote><p>我们知道代码重复和过度的inline都可能导致代码膨胀, 而在模板中会发生比较隐晦的代码重复, 我们应当尽力去避免代码重复的情况发生, 而最核心的方法就是将与参数无关的代码抽离templates, 让我们通过本条款进行了解.</p></blockquote><p>在本条款中我们将会了解 : </p><ul><li>在模板中什么情况下会发生代码膨胀?</li><li>如何缓解这种代码膨胀?</li><li>在缓解代码膨胀后如何知道该操作什么数据?</li></ul><hr><h3 id="代码膨胀"><a href="#代码膨胀" class="headerlink" title="代码膨胀"></a>代码膨胀</h3><p>举个例子, 假设你想为固定尺寸的正方矩形编写一个template, 该矩形指出逆矩阵运算 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,           <span class="hljs-comment">// 矩阵的元素类型是T</span><br>         std::<span class="hljs-type">size_t</span> n&gt;        <span class="hljs-comment">// 矩阵的固定尺寸为n, 这是非类型模板参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> &#123;         <br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;              <span class="hljs-comment">// 求逆功能</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们在使用这个类型时 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">5</span>&gt; sm1;      <span class="hljs-comment">// SquareMatrix&lt;double, 5&gt;类型</span><br>...<br>sm<span class="hljs-number">1.</span><span class="hljs-built_in">invert</span>();                 <br><br>SquareMatrix&lt;<span class="hljs-type">double</span>, <span class="hljs-number">10</span>&gt; sm2;     <span class="hljs-comment">// SquareMatrix&lt;double, 10&gt;类型</span><br>...<br>sm<span class="hljs-number">2.</span><span class="hljs-built_in">invert</span>(); <br></code></pre></td></tr></table></figure><p>我们应该已经注意到, 只要T和n有不同, 在实际上编译器就会重新编译出一份代码. 在本例中, 仅仅只是在尺寸上有差别, 但还是在底层编译出了两份除了尺寸不一样但是其他都相近的代码, 这就造成了实际意义上的代码膨胀.</p><p>你也许会觉得这样无可厚非, 这就是模板机制导致的, 但是细想<code>invert()</code>这个函数, 对矩阵求逆的过程基本都是相同的, 只是矩阵的尺寸有差别罢了, 我们可以通过某些手法将<code>invert()</code>抽离出来, 使其不必频繁编译, 这便是我们接下来要介绍的解决方法.</p><hr><h3 id="将实现类和功能类分离"><a href="#将实现类和功能类分离" class="headerlink" title="将实现类和功能类分离"></a>将实现类和功能类分离</h3><p>我们可以把一个类拆分, 把功能函数拆分出来作为基类, 实现类作为子类.</p><p>让我们直接给出例子, 根据例子来介绍 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;                   <span class="hljs-comment">// 基类 - 功能类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> &#123;               <br><span class="hljs-keyword">protected</span>:   <span class="hljs-comment">// 这里是protected, 不对外公开, 只给派生类调用</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>; <span class="hljs-comment">// 这里实际是用函数参数替代掉了SquareMatrixBase的模板参数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;    <span class="hljs-comment">// 派生类 - 实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">using</span> SquareMatrixBase&lt;T&gt;::invert;   <span class="hljs-comment">// 见条款33, 避免遮掩</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;   <span class="hljs-comment">// 调用模板基类的成员函数, 见条款43</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里<code>SquareMatrix</code>是实现类, 也就是我们正常使用的类型, 它的情况还是和上面一致, 只要T和n有不同, 还是会生成一份额外的代码, 但是不同的是<strong>它把大量的实际代码移到了功能类中(这里只显示了invert, 实际可以有很多功能函数), 使本身的代码量骤减, 大大减少了额外代码的生成</strong>.</p><p>这里<code>SquareMatrixBase</code>是功能类, 他负责给派生类提供相应的功能, 我们从派生类<strong>private继承</strong>自它便可看出. 它只有一个T模板参数, 也就是说它<strong>只对”矩阵元素对象的类型”参数化, 不对”矩阵的尺寸”参数化</strong>, 也就是说只要T相同, 就算派生类的n是任何数字, 都将使用同一份代码 , 不会再编译出多份代码, 我们也可以认为<strong>实际上是用函数参数替代掉了SquareMatrixBase的模板参数</strong>. </p><hr><h3 id="数据操作问题"><a href="#数据操作问题" class="headerlink" title="数据操作问题"></a>数据操作问题</h3><p>在解释这个问题之前, 我们应该再引入一个前提, 就是<strong>SquareMatrix应该是有一个存储数据的成员变量的</strong>, 这应当很容易理解, 在最初版<code>SquareMatrix</code>中就可以是这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T,         <br>         std::<span class="hljs-type">size_t</span> n&gt;       <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span> &#123;         <br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span></span>;            <br>    <br><span class="hljs-keyword">private</span>:<br>  T data[n * n];              <span class="hljs-comment">// 存储矩阵数据的成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在最初版中, <code>invert()</code>可以直接对data进行操作, 但是当我们把实现类和功能类分离后, <strong>data肯定还是在实现类中</strong>, 因为控制数据应当是实现类的职责, 并且这样子便于动态内存的分配; <strong>但是invert()到了功能类, 无法直接对data进行修改</strong>, 功能类函数该如何实际修改data中的数据, 这便是我们要解决的问题.</p><p>其实解决方式也很简单, <strong>在SquareMatrixBase中存储一个指向data的指针</strong>就好了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrixBase</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>  <span class="hljs-built_in">SquareMatrixBase</span>(T *pMem)     <br>  :<span class="hljs-built_in">pData</span>(pMem) &#123;&#125;                    <span class="hljs-comment">// 在构造函数中接受传入的资源指针</span><br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setDataPtr</span><span class="hljs-params">(T *ptr)</span> </span>&#123; pData = ptr; &#125;     <span class="hljs-comment">// 重新设置资源指针</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">(std::<span class="hljs-type">size_t</span> matrixSize)</span></span>;       <span class="hljs-comment">// 内部直接用pData这个指针对资源进行调整</span><br><br><span class="hljs-keyword">private</span>:<br>  T *pData;                                    <span class="hljs-comment">// 指向资源</span><br>&#125;;<br><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SquareMatrix</span>()                             <br>  : <span class="hljs-built_in">SquareMatrixBase</span>&lt;T&gt;(data) &#123;&#125;          <span class="hljs-comment">// 向基类构造传入资源指针</span><br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">invert</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">invert</span>(n); &#125;<br><span class="hljs-keyword">private</span>:<br>  T data[n*n];<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以自行决定实现类中数据内存的分配方式, 在上文中<code>T data[n*n];</code>是将数据存储在了对象内部, 也就是栈上. 我们也可以通过动态分配内存的方式将数据存入堆上(通过new来分配内存) : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, std::<span class="hljs-type">size_t</span> n&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareMatrix</span>: <span class="hljs-keyword">private</span> SquareMatrixBase&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">SquareMatrix</span>()                          <br>  : <span class="hljs-built_in">SquareMatrixBase</span>&lt;T&gt;(n, <span class="hljs-number">0</span>),            <br>    <span class="hljs-built_in">pData</span>(<span class="hljs-keyword">new</span> T[n*n])                    <span class="hljs-comment">// 向基类构造传入new出来的指针</span><br>  &#123; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">setDataPtr</span>(pData.<span class="hljs-built_in">get</span>()); &#125;      <br>  ...                                     <br><br><span class="hljs-keyword">private</span>:<br>  std::unique_ptr&lt;T&gt; pData;           <span class="hljs-comment">// 使用智能指针管理内存</span><br>&#125;; <br></code></pre></td></tr></table></figure><hr><h3 id="类型参数导致的代码膨胀"><a href="#类型参数导致的代码膨胀" class="headerlink" title="类型参数导致的代码膨胀"></a>类型参数导致的代码膨胀</h3><p>我们可以发现上文都对非类型参数(n)导致的代码膨胀提供的解决方案, 但是类型参数(T)也同样会导致代码膨胀, 不同的T也会产生不同的编译版本, 有些类型在底层其实是非常相近甚至相同的, 例如int和long, 各种指针类型之间. </p><p>假设T是一个指针类型, 所有指针类型都有着相同的二进制表述, 其实编译出来的代码基本一致, 只是指针类型不一样而已. 那么我们就可以在模板函数中将这些指针转换为<code>void*</code>, 然后调用操作<code>void*</code>指针类型的函数, 由后者完成实际函数, 也可以达到类似防止代码膨胀的效果, 标准库中的vector, list等都用过这种方式, 以下是list在底层的类似实现 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListBase</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back_impl</span><span class="hljs-params">(<span class="hljs-type">void</span>* value)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用 `void*` 实现通用逻辑</span><br>        *(pdata + size) = value;<br>        size++;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span>* pData;<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">List</span> : <span class="hljs-keyword">private</span> ListBase &#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(T* value)</span> </span>&#123;<br>        <span class="hljs-comment">// 转换为 `void*`，调用底层通用逻辑</span><br>        <span class="hljs-built_in">push_back_impl</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(value));<br>    &#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">void</span>* data[<span class="hljs-number">100</span>]; <span class="hljs-comment">// 用 `void*` 存储所有指针类型</span><br>&#125;;<br><br><span class="hljs-comment">// `list&lt;int*&gt;` 和 `list&lt;const int*&gt;` 都调用相同的底层代码</span><br>List&lt;<span class="hljs-type">int</span>*&gt; list1;<br>List&lt;<span class="hljs-type">const</span> <span class="hljs-type">int</span>*&gt; list2;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>使用模板会有隐含的代码膨胀产生, 我们可以通过将一些功能函数抽离出来作为基类, private继承给派生类来避免代码膨胀.</p></li><li><p>因非类型模板参数(n)造成的代码膨胀, 往往可消除, 可以用<strong>函数参数或class成员变量</strong>替换掉非类型模板参数.</p></li><li><p>因类型模板参数(T)造成的代码膨胀, 往往可降低, 可以让<strong>底层二进制表述完全相同的类型(如指针)共享功能函数</strong>.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款43 模板基类的继承</title>
    <link href="/2025/01/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE43%20%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/01/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE43%20%E6%A8%A1%E6%9D%BF%E5%9F%BA%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款43-学习处理模板化基类内的名称"><a href="#条款43-学习处理模板化基类内的名称" class="headerlink" title="条款43 : 学习处理模板化基类内的名称"></a>条款43 : 学习处理模板化基类内的名称</h2><blockquote><p>在本条款中我们将探讨继承与模板共同使用时的注意事项, 有些我们通过学习继承得来的直觉在这里可能不再适用, 当我们从Object Oriented C++ 跨进 Template C++, 继承就不像以前那样畅行无阻了.</p></blockquote><h3 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h3><p>我们先引入一个例子, 假设我们要写一个程序, 他能够传送信息到若干不同公司去, 大部分公司传输的信息不需要加密, 少部分公司传输的信息需要加密. 那么在实际编写中就是写一个<code>MsgSender</code>模板类, 模板参数是公司类型, 针对需要加密信息的公司进行全特化. 我们通过代码来理解.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 两个公司类, 传递信息都不需要加密</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyA</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyB</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendCleartext</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgInfo</span> &#123; ... &#125;;                  <span class="hljs-comment">// 用来保存信息的类</span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt; <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClear</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span>  <span class="hljs-comment">// 发送不加密的信息</span></span><br><span class="hljs-function">  </span>&#123;<br>    std::string msg;<br>    create msg from info;<br><br>    Company c;<br>    c.<span class="hljs-built_in">sendCleartext</span>(msg);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>假设我们想要在<code>MsgSender</code>的前提下再加入日志志记的功能, 继承它可能是一个最高效的方式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>: <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  ...                                    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-comment">// 信息发送前进行记录日志</span><br><br>    <span class="hljs-built_in">sendClear</span>(info);           <span class="hljs-comment">// 错误! 这里根本无法通过编译 </span><br>      <br>    <span class="hljs-comment">// 信息发送后进行记录日志</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种继承方式在<code>Object Oriented C++</code>领域中是没有任何问题的, 但是一旦加上了模板, 在事实上你会发现这个代码根本无法通过编译, 这就是我们本条款需要解决的问题.</p><hr><h3 id="问题核心"><a href="#问题核心" class="headerlink" title="问题核心"></a>问题核心</h3><p>开门见山地指出问题核心 : <strong>模板类存在特化这种操作</strong>, 因此普通模板类有的函数, 特化版本却不一定有. </p><p>我们假设还有一个公司Z, 它要求自己传送的信息必须加密, 我们看看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CompanyZ</span> &#123;                             <span class="hljs-comment">// 要求发送加密信息</span><br><span class="hljs-keyword">public</span>:                                    <br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendEncrypted</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; msg)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;                          <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MsgSender</span>&lt;CompanyZ&gt; &#123;                <br><span class="hljs-keyword">public</span>:                                  <br>  ...                                     <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendSecret</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123; ... &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们发现, 当我们对MsgSender进行全特化后, 这个特化版本中并没有<code>sendClear</code>! 然而LoggingMsgSender中使用到了sendClear这个函数, 那么当LoggingMsgSender继承到的是这个特化版本时, 报错也就在所难免了.</p><hr><h3 id="深入探讨"><a href="#深入探讨" class="headerlink" title="深入探讨"></a>深入探讨</h3><p>这种现象出现的本质在于, 在派生类中使用到的基类的功能, 因为特化的存在, 在一些版本有这种功能, 另外一些版本就可能没有, 所以C++可以选择的方式解决方案有两种 : </p><ul><li>假定继承而来的基类<strong>没有</strong>这些功能, 除非程序员明确指出有, 会在编译期报错.</li><li>假定继承而来的基类<strong>有</strong>这些功能, 程序员自行承担继承错误基类的风险, 会在运行期报错.</li></ul><p>在事实上C++选择了前者, 因为这样更加规范, 起码不会在运行中产生错误.</p><p>而其对应做出的行为就是 : <strong>C++不进入templatized base classes(模板基类)观察</strong>, 也就是C++不会去模板基类中找用到的成员, 除非程序员指定, 我们接下来将会介绍指定方法.</p><hr><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>其实就是在程序员通过自己的分析后, 明确告诉它有对应的功能, 总共有三种方式 : </p><ul><li><p>在基类函数前加上<code>this-&gt;</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ...<br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">sendClear</span>(info);                <span class="hljs-comment">// 编译通过</span><br>    ...<br>  &#125;<br></code></pre></td></tr></table></figure></li><li><p>使用using声明式.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Company&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggingMsgSender</span>: <span class="hljs-keyword">public</span> MsgSender&lt;Company&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> MsgSender&lt;Company&gt;::sendClear;   <span class="hljs-comment">// 提前告诉编译器基类中存在sendClear</span><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ...<br>    <span class="hljs-built_in">sendClear</span>(info);    <span class="hljs-comment">// 编译通过               </span><br>    ...<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>明确指出函数位于基类内.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sendClearMsg</span><span class="hljs-params">(<span class="hljs-type">const</span> MsgInfo&amp; info)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br>    MsgSender&lt;Company&gt;::<span class="hljs-built_in">sendClear</span>(info);      <span class="hljs-comment">// 编译通过</span><br>    ...                                       <br>&#125;   <br></code></pre></td></tr></table></figure><p>这种方式并不推荐, 因为其会关闭虚函数的绑定行为, 如果sendClear是虚函数的话, 将会强制使用当前基类的版本.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>继承模板基类后, 想要使用继承而来的成员, 必须通过<code>this-&gt;</code>或<code>using声明式</code>指定.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款42 typename</title>
    <link href="/2025/01/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE42%20typename/"/>
    <url>/2025/01/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE42%20typename/</url>
    
    <content type="html"><![CDATA[<h2 id="条款42-了解typename的双重意义"><a href="#条款42-了解typename的双重意义" class="headerlink" title="条款42 : 了解typename的双重意义"></a>条款42 : 了解typename的双重意义</h2><blockquote><p>本条款中我们将了解typename的两种使用场景, 对typename的内涵及使用加深认知.</p></blockquote><h3 id="template声明式"><a href="#template声明式" class="headerlink" title="template声明式"></a>template声明式</h3><p>在template的声明中, <code>template&lt;class T&gt;</code>和<code>template&lt;typename T&gt;</code>都是被允许的, 这两种写法并没有任何差别, C++对这两种写法一视同仁, 但是在真正使用中, 作者还是建议在传入自定义类时用class, 在传入任意类型(包括int等)时用typename, 这样会增加代码的可读性.</p><hr><h3 id="针对嵌套从属类型名称的应用"><a href="#针对嵌套从属类型名称的应用" class="headerlink" title="针对嵌套从属类型名称的应用"></a>针对嵌套从属类型名称的应用</h3><p>先让我们认识<strong>嵌套从属类型名称</strong>的定义 : </p><ul><li>从属 : 依赖于某个template参数.</li><li>嵌套 : 在class内呈嵌套状.</li><li>从属嵌套类型名称 : 在class内呈嵌套状且依赖于某个template参数的类型名称.</li></ul><p>我们通过下面的代码来理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> C&gt;                           </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print2nd</span><span class="hljs-params">(<span class="hljs-type">const</span> C&amp; container)</span>              </span><br><span class="hljs-function"></span>&#123;                                               <br>  <span class="hljs-keyword">if</span> (container.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>     <span class="hljs-function">C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>;  <span class="hljs-comment">// 这里的C::const_iterator便是从属嵌套类型名称</span><br>     ++iter;                                    <br>     <span class="hljs-type">int</span> value = *iter;                        <br>     std::cout &lt;&lt; value;                        <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是无法通过编译的, 我们只有在前头加上typename才可以通过编译, 这是因为编译器起初并不确定<code>C::const_iterator</code>是一个类型名称, 所以当你明确指明其是一个类型名称之后, 编译器就可以正常运作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typename</span> C::const_iterator <span class="hljs-title">iter</span><span class="hljs-params">(container.begin())</span></span>; <span class="hljs-comment">// 这样就可以了</span><br></code></pre></td></tr></table></figure><ul><li><p>所以为什么编译器无法确定这是一个类型名称呢? </p><p>其实是为了代码的严谨性, 我们举一个极端一点的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">C::const_iterator* x;<br></code></pre></td></tr></table></figure><p>当我们写下这样的代码时, 编译器并不知道<code>const_iterator</code>是C中的类型还是成员变量, 如果它是成员变量的话, 那么这其实是一个乘法运算式, *是乘号; 如果他是类型, 那么这其实就是一个定义式, *代表着指针. 这两种情况都完全合法, 因此需要程序员明确指出其究竟是什么才行.</p></li></ul><hr><h3 id="两个例外"><a href="#两个例外" class="headerlink" title="两个例外"></a>两个例外</h3><p>在一般情况下, typename必须作为嵌套从属类型名称的前缀词, 这一规则的例外是, typename不可出现在<strong>继承语句和初始值列表</strong>中, 这是C++中定死的, 没有必要去了解为什么, 记住就行.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base&lt;T&gt;::Nested &#123; <span class="hljs-comment">// 继承语句不可加typename </span><br><span class="hljs-keyword">public</span>:                                 <br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Derived</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">  : Base&lt;T&gt;::Nested(x)                  // 初始值列表不可加typename</span><br><span class="hljs-function">  &#123;</span>                                    <br><br>    <span class="hljs-keyword">typename</span> Base&lt;T&gt;::Nested temp;      <span class="hljs-comment">// 这里可以加</span><br>    ...                               <br>  &#125;                                    <br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="typename和typedef的组合使用"><a href="#typename和typedef的组合使用" class="headerlink" title="typename和typedef的组合使用"></a>typename和typedef的组合使用</h3><p>我们知道了typename会与嵌套从属类型名称绑定, 并且其实在一些情况下嵌套从属类型名称是很长的, 我们会习惯把typedef与typename组合, 将一个类型的书写长度缩短, 我们通过下面的例子了解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> IterT&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">workWithIterator</span><span class="hljs-params">(IterT iter)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> std::iterator_traits&lt;IterT&gt;::value_type value_type;<br>  <span class="hljs-function">value_type <span class="hljs-title">temp</span><span class="hljs-params">(*iter)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这是这个组合的经典用法, 在STL标准库中就有大量的使用.</p><p>这里通过typedef将<code>typename std::iterator_traits&lt;IterT&gt;::value_type</code>这个如此长的类型缩短到<code>value_type</code>, 不用想也一定会减少大量的代码量. 至于为什么会有这么长的类型, 这与<code>iterator_traits</code>的萃取功能有关, 简单来说就是<code>IterT</code>是一个迭代器类型,而<code>iterator_traits</code>可以根据<code>iterT</code>通过<code>value_type</code>萃取出迭代器所指向资源的真实类型T. 我们将在条款47中再作讨论这部分内容, 如果想深入学习的话也可以去<code>STL源码剖析</code>中研读.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>typename作为template参数时, 和class意义完全相同.</li><li>typename必须作为嵌套从属类型名称的前缀词, 除非在继承语句和初始值列表中.</li><li>将typedef和typename组合可以减小代码复杂度.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款41 隐式接口和编译期多态</title>
    <link href="/2025/01/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE41%20%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/"/>
    <url>/2025/01/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE41%20%E9%9A%90%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="条款41-了解隐式接口和编译期多态"><a href="#条款41-了解隐式接口和编译期多态" class="headerlink" title="条款41 : 了解隐式接口和编译期多态"></a>条款41 : 了解隐式接口和编译期多态</h2><blockquote><p>从本条款开始, 我们将开始讨论模板与泛型编程, templates最初知识为了建立类型安全的泛用容器, 但在不断的发展中泛型编程的观念逐渐成型, 使得我们拥有了将写出的代码和其所处理的对象类型彼此独立的技术. 在本条款中我们将了解两个泛型编程中的核心概念–隐式接口和编译期多态.</p></blockquote><p>在面向对象编程中, <strong>显示接口和运行期多态</strong>是我们主要研究的对象 : </p><ul><li>显示接口 : 函数的签名式(函数名称, 参数类型, 返回类型).</li><li>运行期多态 : 在运行期通过对象的动态类型进行动态绑定, 可以使相同的代码展现出多态的效用.</li></ul><p>而在templates及泛型编程的世界, 底层逻辑和面向对象有根本的不同, 但也不是毫不相干, 在其中显示接口和运行期多态仍然存在, 但是重要性降低, <strong>隐式接口和编译期多态</strong>是其中的重中之重.</p><p>我们先来举一个例子, 帮助我们理解上面两个新概念 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Widget</span>();<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">normalize</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(Widget&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) &#123;<br>      <span class="hljs-function">Widget <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>      temp.<span class="hljs-built_in">normalize</span>();<br>      temp.<span class="hljs-built_in">swap</span>(w);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个没有实际意义的<code>Widget</code>类, 只是为了促进我们的理解, 接下来我们将会写一个<code>doProcessing</code>的模板版本 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doProcessing</span><span class="hljs-params">(T&amp; w)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (w.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">10</span> &amp;&amp; w != someNastyWidget) &#123;<br>     <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(w)</span></span>;<br>     temp.<span class="hljs-built_in">normalize</span>();<br>     temp.<span class="hljs-built_in">swap</span>(w);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与原版的实现相似, 但是在实际编译中会有很大的差别, 我们比较直观的一个感受就是<strong>类型T至少应该有operator&gt;重载, operator!&#x3D;重载, 拷贝构造函数, normalize成员函数, swap成员函数(由上至下)</strong>, 不然编译肯定会报错, 这便是<strong>隐式接口</strong>最简单的一个理解.</p><ul><li>隐式接口在定义上是模板函数中的部分<strong>有效表达式</strong>.</li></ul><p>简单来说就是<strong>类型T必须可以做到表达式中的行为</strong>, <strong>如果做不到那便是隐式接口不匹配</strong>, 编译便无法通过, 在本例中的有效表达式便是<code>w.size() &gt; 10 &amp;&amp; w != someNastyWidget</code>, <code>T temp(w)</code>等. </p><p>并且由于其是隐式接口, 也可以通过<strong>隐式转换</strong>来进行匹配, 这么说比较晦涩, 举个例子就是<code>w.size() &gt; 10</code>这个表达式是应当返回一个bool类型的参数的, 但如果你的operator&gt;重载返回的是int类型, 并且以1作为true, 0作为false, 那么在编译中完全可以将int隐式转换为bool类型, 进而继续接下来的判断.</p><ul><li>编译期多态 : “以不同的template参数(T)具现化出来的function templates”会导致调用不同的函数.</li></ul><p>用术语来讲, 编译期多态基于<strong>模板具现化和函数重载解析</strong>, 但其实很容易理解, 白话讲就是<strong>在编译期根据不同的类型可以调用不同且对应的成员函数</strong>, 其效果与运行时多态在运行期动态绑定的行为相似, 因此被称为编译期多态.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>classes 和 templates 都支持接口和多态, templates不只有classes拥有的显示接口和运行时多态, 也有自己独有的隐式接口和编译期多态.</li><li>隐式接口基于有效表达式, 编译器多态基于模板具现化和函数重载解析.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款40 多重继承</title>
    <link href="/2025/01/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE40%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/01/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE40%20%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款40-明智而审慎地使用多重继承"><a href="#条款40-明智而审慎地使用多重继承" class="headerlink" title="条款40 : 明智而审慎地使用多重继承"></a>条款40 : 明智而审慎地使用多重继承</h2><blockquote><p>相比于java选择单继承+接口类多继承的方式, C++选择了更加直接的方式, 其允许多重继承存在. 不可否认的是确实大多数情况下单继承都可以胜任, 但是同样不可否认的是多重继承也一定有其用武之地. 在本条款中, 我们将认识多重继承, 了解辅助其实现的虚继承机制, 并且知晓多重继承的主要应用场景.</p></blockquote><p>多重继承的意思是<strong>继承一个以上的基类</strong>, 一般来说<strong>我们不希望这些基类在继承体系中又有更高级的继承</strong>, 这样会带来菱形继承的问题, 并且为了解决这种问题, 我们还要祭出虚继承这一机制来克服, 接下来我们将会逐一简单介绍菱形继承和虚继承机制.</p><hr><h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>简而言之就是派生类继承的多个基类中, 含有共同的父类. 如下图所示 : </p><p><img src="/../img/image/001.png"></p><p>如此这般, 假设<code>IOFile</code>中有成员, 那么<code>InputFile</code>和<code>OutputFile</code>中也会继承相应的成员, 那么File就继承到了两份相同的成员. 那么如何处理这种情况就是C++要解决的问题, 如何解决有两派观点 : </p><ul><li><p>File中就是有两份成员, 这是最直观的逻辑, 所以调用时都必须指定明确的基类.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">File f;<br>cout &lt;&lt; f.InputFile.a &lt;&lt; endl;  <span class="hljs-comment">// 假设IOFile中有成员变量a</span><br>cout &lt;&lt; f.OutputFile.a &lt;&lt; endl;<br>cout &lt;&lt; f.a &lt;&lt; endl; <span class="hljs-comment">// 编译错误!</span><br></code></pre></td></tr></table></figure></li><li><p><code>IOFile</code>只有一个文件名称, 所以继承自<code>IOFile</code>的成员不应当重复.</p></li></ul><p><strong>C++默认使用第一种方案, 毕竟这是最直观的逻辑, 但同时也提供了虚继承机制以支持第二种方案.</strong></p><hr><h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>简而言之就是对存在菱形继承的基类们在继承时前加virtual, 那么以后就不会出现继承两份的情况了, C++在底层会解决所有问题.</p><p>图示如下 : </p><p><img src="/../img/image/002.png"></p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InputFile</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> File &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputFile</span>: <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> File &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IOFile</span>: <span class="hljs-keyword">public</span> InputFile,<br>              <span class="hljs-keyword">public</span> OutputFile<br>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>具体实现细节我们不再详述, 但是我们有必要再次明确虚继承的劣势 : </p><ul><li>使用虚继承产生的对象会<strong>体积更大, 访问速度更慢</strong>.</li><li>派生类必须为从虚继承而来的基类中的成员变量进行<strong>手动初始化</strong>.</li></ul><p>这对我们的代码编写和实际运行都有一定影响.</p><p>对于虚继承, 我们建议要<strong>尽量避免使用</strong>, 如果有必要也<strong>不要在虚基类中添置成员变量等数据</strong>.</p><hr><h3 id="多重继承的使用情景"><a href="#多重继承的使用情景" class="headerlink" title="多重继承的使用情景"></a>多重继承的使用情景</h3><p>上面的两个知识都运用在特殊情况下, 然而我们平时不会想也不建议出现菱形继承的情况. 熟练使用多重继承可以在一些情景下达到事半功倍的效果, 有一种情况最为常见, 如果我们<strong>希望某个类public继承自某个接口类, 并且private继承某个协助其实现的class</strong>, 我们接下来也会举出一个这样的例子 : </p><p>假设我们有一个塑模人的接口类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IPerson</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IPerson</span>();<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个对人塑模的抽象基类, 我们希望使用工厂函数创造出一些可以被当作<code>IPerson</code>来使用的对象, 这些对象的静态类型是<code>IPerson</code>, 动态类型是<code>IPerson的派生类</code>, 工厂函数通过各种需求和条件生成对应的对象, 另外附加一点, 这个工厂函数要生成一个Person需要一个存储在数据库中的唯一id, 需要从用户处获取, 然后便可通过id获取Person的基本信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;IPerson&gt; <span class="hljs-title">makePerson</span><span class="hljs-params">(DatabaseID personIdentifier)</span></span>;  <span class="hljs-comment">// 工厂函数, 需要一个数据库id</span><br><br><span class="hljs-function">DatabaseID <span class="hljs-title">askUserForDatabaseID</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 向用户获取id的功能函数</span><br><br><span class="hljs-function">DatabaseID <span class="hljs-title">id</span><span class="hljs-params">(askUserForDatabaseID())</span></span>;  <span class="hljs-comment">// 用获取到的id创建DatabaseID对象</span><br><span class="hljs-function">std::shared_ptr&lt;IPerson&gt; <span class="hljs-title">pp</span><span class="hljs-params">(makePerson(id))</span></span>;  <span class="hljs-comment">// 将该对象传入工厂函数生成需求对象</span><br></code></pre></td></tr></table></figure><p>有了这些前戏, 我们就需要提供<code>IPerson</code>的派生类了, 我们假设这个class名为<code>CPerson</code>, 其必须继承自<code>IPerson</code>, 当然我们自然可以从无到有从写所有<code>IPerson</code>传来的接口函数, 但是假如我们有现成的一个可以帮助我们实现的类, 继承它可能是最好的选择 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInfo</span> &#123;<span class="hljs-comment">// 这个类被用来协助以各种格式打印从数据库中调出的数据</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">PersonInfo</span><span class="hljs-params">(DatabaseID pid)</span></span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">PersonInfo</span>();<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">theName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">theBirthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 传出字符串的前缀</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// 传出字符串的后缀</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[&quot;</span>;                       <span class="hljs-comment">// 默认前缀, 可重写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;]&quot;</span>;                       <span class="hljs-comment">// 默认后缀, 可重写</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">PersonInfo::theName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>   <span class="hljs-comment">// 这个函数将会通过传入的数据库id调出且生成加工后的name</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">char</span> value[Max_Formatted_Field_Value_Length];  <span class="hljs-comment">// 缓存区</span><br>  std::<span class="hljs-built_in">strcpy</span>(value, <span class="hljs-built_in">valueDelimOpen</span>());  <span class="hljs-comment">// 写入前缀</span><br><br>  <span class="hljs-comment">// 中间可能会很长, 会实现利用id从数据库中调用name的操作</span><br> <br>  std::<span class="hljs-built_in">strcat</span>(value, <span class="hljs-built_in">valueDelimClose</span>());  <span class="hljs-comment">// 写入后缀</span><br><br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是我们便可写出一个public继承自<code>IPerson</code>, private继承自<code>PersonInfo</code>的<code>CPerson</code>派生类, 他<strong>通过PersonInfo提供的功能实现了IPerson继承来的接口</strong>, 这种多重继承确实是<strong>最合理最高效最简洁</strong>的做法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPerson</span>: <span class="hljs-keyword">public</span> IPerson, <span class="hljs-keyword">private</span> PersonInfo &#123;     <span class="hljs-comment">// 采用多重继承</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">CPerson</span><span class="hljs-params">(    DatabaseID pid)</span>: PersonInfo(pid) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                      </span><br><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> PersonInfo::<span class="hljs-built_in">theName</span>(); &#125;                     <span class="hljs-comment">// 直接取用PersonInfo的功能调出name字符串</span><br>                                                        <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span>                 </span><br><span class="hljs-function">  </span>&#123; <span class="hljs-keyword">return</span> PersonInfo::<span class="hljs-built_in">theBirthDate</span>(); &#125;<span class="hljs-comment">// 同理</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>当前name()传出的字符串是<code>[name]</code>这种风格, 当然你也可以根据需求改变信息的格式, 我们可以通过重写<code>PersonInfo</code>虚函数的方式改变格式 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPerson</span>: <span class="hljs-keyword">public</span> IPerson, <span class="hljs-keyword">private</span> PersonInfo &#123;   <br>    ...<br><span class="hljs-keyword">private</span>:                                                <br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimOpen</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&lt;&quot;</span>; &#125;    <span class="hljs-comment">// 这里重写虚函数</span><br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">valueDelimClose</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&gt;&quot;</span>; &#125;   <span class="hljs-comment">// 传出的格式改为 : &lt;name&gt;</span><br>&#125;; <br></code></pre></td></tr></table></figure><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>请把多重继承当作成一个工具, 它可以将不同的类以不同的方式结合到一起, public继承意味着”is-a”, private继承意味着”is-implemented-in-terms-of”, 当然如果你有一个单继承的设计方案可以达到相同的效果, 那么还是应当选用单继承. 多继承只是在一些情况下是最合理最高效最简洁的做法.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>多继承会比单继承复杂, 并且有可能会导致菱形继承, 引发对虚继承的需求.</li><li>虚继承会增加大小, 速度, 初始化等成本, 如果虚继承建议虚基类不要带任何数据.</li><li>多继承确实有其用武之地, 一种常见情况是”某个类public继承自某个接口类, 并且private继承某个协助其实现的class”.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>Effectiv C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款38-39 复合和private继承</title>
    <link href="/2024/12/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE38-39%20%E5%A4%8D%E5%90%88%E5%92%8Cprivate%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE38-39%20%E5%A4%8D%E5%90%88%E5%92%8Cprivate%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款38-通过复合塑膜出has-a或”根据某物实现出”"><a href="#条款38-通过复合塑膜出has-a或”根据某物实现出”" class="headerlink" title="条款38 : 通过复合塑膜出has-a或”根据某物实现出”"></a>条款38 : 通过复合塑膜出has-a或”根据某物实现出”</h2><blockquote><p>在条款32中我们认识了public继承意味着is-a, 本条款将会认识两个新的关系, 均可通过”复合”这一操作实现出来.</p></blockquote><hr><h3 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h3><p>所谓<strong>复合</strong>, 就是<strong>某种类型的对象内含其他类型的对象,</strong> 其实非常容易理解, 我们通过代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123; ... &#125;;           <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PhoneNumber</span> &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  std::string name;              <span class="hljs-comment">// 复合std::string</span><br>  Address address;               <span class="hljs-comment">// 复合Address</span><br>  PhoneNumber voiceNumber;       <span class="hljs-comment">// 复合PhoneNumber</span><br>  PhoneNumber faxNumber;          <br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Person</code>类便是复合了<code>Address</code>和<code>PhoneNumber</code>两个类.</p><hr><h3 id="两种意义"><a href="#两种意义" class="headerlink" title="两种意义"></a>两种意义</h3><p>使用复合手法在不同领域的对象上, 有不同的意义, 我们先来定义两个领域 : </p><ul><li>应用域 : 当一个内置对象的目的是”<strong>这个类能做到什么(what)</strong>“, 它属于应用域, 上面的地址和电话便是如此.</li><li>实现域 : 当一个内置对象的目的是”<strong>这个类如何做到(how)</strong>“, 它属于实现类.</li></ul><p>在设置不同域的对象其代表的意义也不同, 让我们看下面两种意义 : </p><ul><li><p><strong>has-a(有一个)</strong> </p><p>当对象属于应用域, 如果A复合了B, 则代表A有一个B, A可以做出B的所有行为, 但不强制, 例如人有一个家.</p></li><li><p><strong>is-implemented-in-terms-of(根据某物实现出)</strong> </p><p>当对象属于实现域, 如果A复合了B, 则代表A根据B实现出来, A想要实现自己的功能要借助B的功能, 例如标准库中的unordered_set根据HashTable实现出来.</p><p>我如果不想用HashTable实现set, 也可以用list来实现, 书中给出的例子是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;                 <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Set</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">member</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; item)</span></span>;<br>  <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  std::list&lt;T&gt; rep;                 <span class="hljs-comment">// 复用list实现另一个版本的set.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是Set就可以依靠list提供的机能来实现自己的功能 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">bool</span> Set&lt;T&gt;::<span class="hljs-built_in">member</span>(<span class="hljs-type">const</span> T&amp; item) <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">find</span>(rep.<span class="hljs-built_in">begin</span>(), rep.<span class="hljs-built_in">end</span>(), item) != rep.<span class="hljs-built_in">end</span>();<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Set&lt;T&gt;::<span class="hljs-built_in">insert</span>(<span class="hljs-type">const</span> T&amp; item)<br>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">member</span>(item)) rep.<span class="hljs-built_in">push_back</span>(item);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> Set&lt;T&gt;::<span class="hljs-built_in">remove</span>(<span class="hljs-type">const</span> T&amp; item)<br>&#123;<br>  <span class="hljs-keyword">typename</span> std::list&lt;T&gt;::iterator it =               <br>    std::<span class="hljs-built_in">find</span>(rep.<span class="hljs-built_in">begin</span>(), rep.<span class="hljs-built_in">end</span>(), item);        <br>  <span class="hljs-keyword">if</span> (it != rep.<span class="hljs-built_in">end</span>()) rep.<span class="hljs-built_in">erase</span>(it);<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br>std::<span class="hljs-type">size_t</span> Set&lt;T&gt;::<span class="hljs-built_in">size</span>() <span class="hljs-type">const</span><br>&#123;<br>  <span class="hljs-keyword">return</span> rep.<span class="hljs-built_in">size</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>public继承的意义完全不同.</li><li>在应用域中, 复合意味着<code>has-a</code>. 在实现域, 复合意味着<code>is-implemented-in-terms-of</code></li></ul><hr><h2 id="条款39-明智而审慎地使用private继承"><a href="#条款39-明智而审慎地使用private继承" class="headerlink" title="条款39 : 明智而审慎地使用private继承"></a>条款39 : 明智而审慎地使用private继承</h2><blockquote><p>通过本条款, 你将明晰private继承在继承体系中充当了什么样的角色, 其与public继承和复合又有怎样的区别.</p></blockquote><p>没错, private继承也有其所意味的东西, 但是这个意义我们已经了解过了, 那就是<strong>is-implemented-in-terms-of</strong>.</p><p>没错, private继承和复合除开在底层的实现细节不同, 它们可以实现相同的目的, 虽然有着不同的限制.</p><p>我们还是先回忆一下private继承会发生什么 : </p><ul><li>编译器<strong>不会自动将该派生类对象隐式转换为基类对象</strong>, 也就是说基类参数接口将无法接受该对象.</li><li>所有从基类继承而来的属性在派生类中<strong>都是private的</strong>, 纵使它们原来是public&#x2F;protect.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123; <br>...<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span>;    <br>    ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>: <span class="hljs-keyword">private</span> Person &#123; ... &#125;;     <span class="hljs-comment">// 如果是private继承Person</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(<span class="hljs-type">const</span> Person&amp; p)</span></span>;   <span class="hljs-comment">// 按常理所有人都可以吃</span><br><br>Person p;                                  <span class="hljs-comment">// p is a Person</span><br>Student s;                                 <span class="hljs-comment">// s is a Student</span><br><br><span class="hljs-built_in">eat</span>(p);                                    <span class="hljs-comment">// 正确</span><br><span class="hljs-built_in">eat</span>(s);   <span class="hljs-comment">// 错误! 无法隐式转换为基类</span><br>cout &lt;&lt; s.<span class="hljs-built_in">speak</span>() &lt;&lt; endl;   <span class="hljs-comment">// 错误! public已经转为private</span><br></code></pre></td></tr></table></figure><p>我们可以看出private继承和<code>is-a</code>的关系完全不沾边, 最终的实际效果其实就是<code>is-implemented-in-terms-of</code>(根据某物实现出).</p><p>若B private继承 自A, 说明A需要采用B中备妥的某些特性, A不需要传递B的什么接口, 而是希望使用B的一部分功能实现, 可以是直接使用, 也可以是有目的的重写, 我们可以肯定的是这样至少要比我们单独实现一份需求的功能来得方便.</p><hr><h3 id="什么时候使用private继承"><a href="#什么时候使用private继承" class="headerlink" title="什么时候使用private继承"></a>什么时候使用private继承</h3><p>既然我们知道private继承和复合都可以实现<code>is-implemented-in-terms-of</code>的效果, 那么应该选哪个呢? </p><p>答案是如果可以选复合, 最好优先选择复合, 毕竟private继承有时十分晦涩, 会大大降低代码的可读性, 我们对private继承的使用应当是<strong>明智而审慎</strong>的.</p><p>接下我们将说明什么情况下可以选用private继承 : </p><ul><li><p><strong>涉及protected成员&#x2F;virtual函数时</strong>. 当我们希望继承并重写一些virtual函数或是使用一些protected成员时, 如果我们<strong>不希望它们将基类接口或成员暴露出去</strong>, 就可以采用private继承, 因为其有天然转换为private的属性.</p><p>以下是书中的一个例子, <code>Widget</code>想利用<code>Timer</code>中的计时机制来实现一些定时触发的机制, 它希望重写其中的<code>onTick()</code> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Timer</span><span class="hljs-params">(<span class="hljs-type">int</span> tickFrequency)</span></span>;<br>   <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// Timer每过一段时间就会触发一次onTick()</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span>: <span class="hljs-keyword">private</span> Timer &#123;<span class="hljs-comment">// private继承</span><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;      <span class="hljs-comment">// 重写Timer中的onTick(), 使其可以定时查看Widget的数据...</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样用户就不可能在外部调用到任何的<code>onTick</code>函数(包括基类和派生类的), 毕竟这只是为了实现内部的功能.</p></li><li><p><strong>有极大的空间要求时</strong>. 我们有时会面对一些空间十分有限的情况, 我们会非常希望去节省空间, 那么有一项技术值得我们研究 : </p><p>先引入一些前提, 我们有些时候会有创建并使用一些<strong>空类</strong>的需求, 目的在于用作类型标识, 占位符, 空对象之类的需求, 这样的需求始终存在并且在现代C++的重要性逐步提升, 比如通过类型表示进行类型推导, 实现在编译期即可进行判断的技术.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 类型标识空类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeB</span> &#123;&#125;;<br><br><span class="hljs-comment">//通过 if constexpr 在编译时确定类型并执行不同的行为, 提高了运行期效率</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identifyType</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same_v&lt;T, TypeA&gt;)</span> </span>&#123;   <span class="hljs-comment">// is_same_v是C++17引入的判断类型是否相同的类型特征</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TypeA\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_same_v&lt;T, TypeB&gt;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;TypeB\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown type\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">identifyType</span>(TypeA&#123;&#125;);  <span class="hljs-comment">// 输出 &quot;TypeA&quot;</span><br>    <span class="hljs-built_in">identifyType</span>(TypeB&#123;&#125;);  <span class="hljs-comment">// 输出 &quot;TypeB&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而使用这些空类符合”is-implemented-in-terms-of”的意味, 假设我们就是为了做类型标识, 那么如果我们想赋予一个类对应的类型标识来达到分类的效果, 我们可以让这个类复合或private继承空类来实现, 在这种情况下我们建议优先选择private继承, 这样可以通过继承的类型在编译器做出更多的操作, 并且也减小了对象大小, 这就是所谓的<strong>EBO(空白基类最优化)</strong>.</p><p>简单来说就是复合会增加对象大小(就算是空类也会), 而private继承<strong>完全不会增加大小, 而且还给了我们在编译期的可操作空间</strong>, 我们可以做到以下编译期类型识别的效果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 空类型标识基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeA</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeB</span> &#123;&#125;;<br><br><span class="hljs-comment">// 派生类，通过private继承不同的空基类来在编译期区分类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">private</span> TypeA &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnotherClass</span> : <span class="hljs-keyword">private</span> TypeB &#123;&#125;;<br><br><span class="hljs-comment">//通过 if constexpr 在编译时确定类型并执行不同的行为</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">identifyType</span><span class="hljs-params">(T obj)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_base_of_v&lt;TypeA, T&gt;)</span> </span>&#123;   <span class="hljs-comment">// is_base_of_v是C++17引入的判断基类类型的类型特征</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is of TypeA\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::is_base_of_v&lt;TypeB, T&gt;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Object is of TypeB\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Unknown type\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass a;<br>    AnotherClass b;<br><br>    <span class="hljs-built_in">identifyType</span>(a);  <span class="hljs-comment">// 输出: Object is of TypeA</span><br>    <span class="hljs-built_in">identifyType</span>(b);  <span class="hljs-comment">// 输出: Object is of TypeB</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="复合的优势"><a href="#复合的优势" class="headerlink" title="复合的优势"></a>复合的优势</h3><p>在上文我们讲了两种建议使用private继承的情况, 那么除此之外我们还是推荐能使用复合就使用复合, 其优势在于 : </p><ul><li>可读性高.</li><li>使用复合对象可以<strong>防止派生类重写其virtual函数</strong>. (private继承不可, 因为就算是private继承也可以重写private的virtual函数, 然后通过基类指针调用, 见条款35)</li><li>使用复合就可以<strong>使编译依存性降至最低</strong>, 如果继承必须可见定义, 而复合只需声明即可. (详见条款31)</li></ul><hr><h3 id="“public继承-复合”替代private继承"><a href="#“public继承-复合”替代private继承" class="headerlink" title="“public继承 + 复合”替代private继承"></a>“public继承 + 复合”替代private继承</h3><p>我们还可以通过”public继承 + 复合”替代一些场景下private继承的作用, 虽然这样会麻烦一些, 但值得我们考量, 我们将上文的Timer案例重写一下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetTimer</span>: <span class="hljs-keyword">public</span> Timer &#123;<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onTick</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    ...<br>  &#125;;<br>   WidgetTimer timer;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个例子中我们创建一个WidgetTimer的内部类, 其public继承自Timer, 其重写了onTick(), 并且我们立马在下面创建一个对应的复用对象, 我们可以发现这个private继承的效果类似, 并且也可以体现上述复合的优势.</p><p>当然这只适用于部分情况, private继承肯定还是有用武之地的.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>private继承意味着<code>is-implemented-in-terms-of</code>. </li><li>任何时候都优先选择复合, 除非一些特殊情况下.</li><li>private继承可以支持<code>EBO</code>, 并且在C++17中可以继承类型标识空类来实现编译期逻辑判断.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款36-37 两个绝不</title>
    <link href="/2024/12/20/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE36-37%20%E4%B8%A4%E4%B8%AA%E7%BB%9D%E4%B8%8D/"/>
    <url>/2024/12/20/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE36-37%20%E4%B8%A4%E4%B8%AA%E7%BB%9D%E4%B8%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="条款36-绝不重新定义继承而来的non-virtual函数"><a href="#条款36-绝不重新定义继承而来的non-virtual函数" class="headerlink" title="条款36 : 绝不重新定义继承而来的non-virtual函数"></a>条款36 : 绝不重新定义继承而来的non-virtual函数</h2><p>本条款很容易理解, 援引以前的条款就可以说明为什么 : </p><ul><li><p>条款34中就提到过 : non-virtual函数意味着<strong>接口 + 强制性实现继承</strong>, 它不应当被改变. </p></li><li><p>重新定义继承而来的non-virtual函数会触发条款33中所说的<strong>遮掩</strong>机制.</p></li><li><p>触发遮掩机制其实是对条款32中”<strong>public意味着is-a</strong>“这个定理的破坏.</p></li></ul><p>如果你这么做了, 还可能会出现以下奇怪的效果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">D</span>: <span class="hljs-keyword">public</span> B &#123;  <span class="hljs-comment">// D派生自B</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 这个定义遮掩了B中的mf()</span><br>&#125;;  <br><br><span class="hljs-comment">//--------------------------------------------//</span><br><br>D x;                              <span class="hljs-comment">// 创建一个D对象</span><br><br>B *pB = &amp;x;                       <br>pB-&gt;<span class="hljs-built_in">mf</span>();                         <span class="hljs-comment">// 调用B::mf()</span><br><br>D *pD = &amp;x;                       <br>pD-&gt;<span class="hljs-built_in">mf</span>();    <span class="hljs-comment">// 调用D::mf()</span><br></code></pre></td></tr></table></figure><p>我们可以看到通过同一个对象D调用的<code>mf()</code>居然效果不同, 这也很容易理解, 毕竟non-virtual并没动态绑定, 只是依据当前对象的静态类型来调用的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>任何情况下都不应重新定义一个继承来的non-virtual函数.</li></ul><hr><h2 id="条款37-绝不重新定义继承而来的缺省参数值"><a href="#条款37-绝不重新定义继承而来的缺省参数值" class="headerlink" title="条款37 : 绝不重新定义继承而来的缺省参数值"></a>条款37 : 绝不重新定义继承而来的缺省参数值</h2><blockquote><p>先缩小本条款的范围, 通过条款36我们首先应该知道不应该修改继承来的non-virtual函数, 所以本条款的讨论范围将局限在”继承一个带有缺省参数的virtual函数”.</p></blockquote><p>首先明确本条款的核心知识 : </p><ul><li><strong>virtual函数本身是动态绑定的, 但是缺省参数值是静态绑定的.</strong></li></ul><p>简单理解就是virtual函数会根据对象的当前类型进行动态绑定, 而缺省值无法改变, 只和一开始定义的静态类型相关.</p><p>我们来看代码来理解 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;; <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// Shape默认缺省值为Red</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// 这是一个糟糕的写法!</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Green)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// Shape默认缺省值为Green, 但是有用吗?</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 无缺省值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里设计了一个Shape基类, 派生出三角和圆, 我们来看调用时会发生什么 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 以下的静态类型都是基类</span><br>Shape* ps;                       <br>Shape* pc = <span class="hljs-keyword">new</span> Circle;         <br>Shape* pr = <span class="hljs-keyword">new</span> Rectangle;      <br><br>pc-&gt;<span class="hljs-built_in">draw</span>();<br>pr-&gt;<span class="hljs-built_in">draw</span>();<br></code></pre></td></tr></table></figure><p>这样子调用看上去没有任何问题, 实际上也确实依靠动态绑定调用到了派生类对应的draw(), 但根据测试<code>pc-&gt;draw()</code>中color缺省值是Red而非Green, 这便是因为我们上述的理由, 缺省值看的是静态类型, 也就是Shape.</p><ul><li><p>为什么C++会设计成会这样?</p><p>其实是因为动态绑定缺省值的花销实在过大, C++为了效率做了这般取舍.</p></li></ul><hr><h3 id="由此引发出的另一个问题"><a href="#由此引发出的另一个问题" class="headerlink" title="由此引发出的另一个问题"></a>由此引发出的另一个问题</h3><ul><li><strong>当静态类型是派生类时, 将无法获取基类的缺省值!</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这样可以使用基类的缺省值</span><br>Shape* pc = <span class="hljs-keyword">new</span> Circle;            <br>pc-&gt;<span class="hljs-built_in">draw</span>();<br><br><span class="hljs-comment">// 这样不行!</span><br>Circle* cc = <span class="hljs-keyword">new</span> Circle;<br>cc.<span class="hljs-built_in">draw</span>();    <span class="hljs-comment">// 错误, 自己没有缺省值, 并且也调不到基类的缺省值</span><br></code></pre></td></tr></table></figure><p>于是这样的机制似乎在逼迫我们要把所有含缺省值的virtual函数都手动填上和基类一样的缺省值, 就像下面的代码一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;; <br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 都加上和基类相同的缺省值</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span></span>;  <span class="hljs-comment">// 都加上和基类相同的缺省值</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>只有这样你才可以确保在任何使用场景下你的缺省值都可以正常生效.</p><p>但是这样值得吗? 显然是不值得的, 这里包含了<strong>代码重复和代码相依性</strong>两大弊病, 只要你想修改基类中的缺省值, 那么其他所有的派生类就都要修改, 这是我们非常不希望看到的, 还好我们有一个现成的解决方法.</p><hr><h3 id="藉由NVI手法解决上述问题"><a href="#藉由NVI手法解决上述问题" class="headerlink" title="藉由NVI手法解决上述问题"></a>藉由NVI手法解决上述问题</h3><p>没错, 就是我们条款35详细介绍的NVI手法(没看过的可以看我往期博客的对应部分, 这将很影响下文的理解), 我们<strong>让非虚函数接口有缺省值, 如果有缺省情况, 把这个缺省值传入具体实现的虚函数</strong>就可以了! 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ShapeColor</span> &#123; Red, Green, Blue &#125;;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">(ShapeColor color = Red)</span> <span class="hljs-type">const</span>           <span class="hljs-comment">// 非虚函数接口(包含缺省值), 见条款35</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-built_in">doDraw</span>(color);                                  <span class="hljs-comment">// 具体实现的虚函数接受color</span><br>  &#125;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;  <span class="hljs-comment">// 见条款35</span><br>&#125;;                                                  <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">doDraw</span><span class="hljs-params">(ShapeColor color)</span> <span class="hljs-type">const</span></span>;     <span class="hljs-comment">// 这样就不必再加缺省值了!  </span><br>  ...                                                <br>&#125;;<br><br><span class="hljs-comment">//-----------------------//</span><br><br>Circle* cc = <span class="hljs-keyword">new</span> Circle;<br>cc.<span class="hljs-built_in">draw</span>();                 <span class="hljs-comment">// 这样的调用也被允许了!</span><br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝对不要重新定义一个继承而来的缺省参数值, 因为它是静态绑定的.</li><li>再想让virtual函数携带缺省值是, 不妨使用NVI手法, <strong>让非虚接口替虚函数携带缺省值</strong>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款34 接口继承和实现继承</title>
    <link href="/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/17/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE34%20%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款34-区分接口继承和实现继承"><a href="#条款34-区分接口继承和实现继承" class="headerlink" title="条款34 : 区分接口继承和实现继承"></a>条款34 : 区分接口继承和实现继承</h2><blockquote><p>作为class的设计者, 我们有时希望派生类只继承成员函数的接口, 有时又希望同时继承接口和实现, 有时又希望能够重写所继承的实现,  因此我们的选择是多样的, 这里大有可以探讨的地方, 本条款将带我们区分不同的继承方法, 并对其做出建议</p></blockquote><h3 id="三种继承方式"><a href="#三种继承方式" class="headerlink" title="三种继承方式"></a>三种继承方式</h3><p>首先让我们明晰各种继承方式的区别, 大体有三种继承方式 : </p><ul><li><p>接口继承 : <strong>pure virtual函数</strong>实现, 强制派生类<strong>继承接口</strong>.</p><p>这种方式的通过强制继承接口确保必需功能的实现.</p></li><li><p>接口 + 缺省实现继承 : <strong>virtual函数</strong>实现, 派生类可以选择重写, <strong>继承基类提供的接口和缺省实现</strong>.</p><p>这种方式可以灵活选择是继承缺省版本还是重写.</p></li><li><p>接口 + 强制实现继承 : <strong>non-virtual函数</strong>实现, 派生类<strong>继承接口和唯一实现</strong>.</p><p>这种方式就是给整个继承体系增加了一个固定的工具函数, 该函数不可重写.</p></li></ul><p>简单来说就是继承会继承接口, 但是否继承一份实现是看具体情况而定的.</p><hr><h3 id="纯虚函数也可以被定义"><a href="#纯虚函数也可以被定义" class="headerlink" title="纯虚函数也可以被定义"></a>纯虚函数也可以被定义</h3><p>在前面的条款中应该有提过纯虚函数定义的问题, 这里再着重研究一下 : </p><ul><li><strong>纯虚函数可以被定义</strong>, 但调用它的唯一途径是调用时<strong>明确指出其class名称</strong>.</li></ul><p>就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br>  <span class="hljs-keyword">public</span>:  <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;...&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shape::draw</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;draw&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Shape* ps = <span class="hljs-keyword">new</span> Rectangle;<br>ps-&gt;Shape::<span class="hljs-built_in">draw</span>(); <span class="hljs-comment">// 这样便可以调用纯虚函数</span><br></code></pre></td></tr></table></figure><p>有了该定义, 便可以为上述的第二种继承方式提供<strong>更平常更安全的缺省实现</strong>.</p><hr><h3 id="“使用纯虚函数并定义”来替换普通虚函数的使用"><a href="#“使用纯虚函数并定义”来替换普通虚函数的使用" class="headerlink" title="“使用纯虚函数并定义”来替换普通虚函数的使用"></a>“使用纯虚函数并定义”来替换普通虚函数的使用</h3><p>先来引入前提, <strong>普通虚函数的重写并没有强制性, 并且在没有重写的情况下会自动继承缺省版本</strong>, 这点在实际应用中被认为是有风险的. 因为自动使用某些功能总是有可能超出使用者的预期的, 有些时候往往可能只是我们忘记重写, 本身并不希望使用缺省, 但实际却还是调用到了缺省, 这很有可能<strong>和我们想要实现的目的不一致, 但是在语法上是正确的, 我们不一定会意识到我们的错误</strong>. 书中举出了一个飞机公司的例子, 一开始有两种型号的飞机A和B, 新加入一个型号的飞机C,  其默认的飞行方式和AB都不同, 如果我们忘记重写fly函数, 自动调用的缺省函数可能不会符合我们的预期 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airport</span> &#123; ... &#125;;                     <span class="hljs-comment">// represents airports</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-comment">// fly的缺省行为</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123; ... &#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br>  ...                                   <span class="hljs-comment">// 忘记重写C的fly, 调用的缺省行为也可能不符合我们的预期</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>理解起来并没有那么麻烦, 就是使用<code>virtual</code>函数并没有强制性检查, 程序员的疏忽可能导致错误.</p><p>于是我们提出了一个新的方式替代<code>virtual</code>函数(第二种继承方案) : </p><ul><li><strong>使用pure virtual函数并定义,  在想要使用缺省版本时显示指定缺省版本</strong>.</li></ul><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Airplane</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数声明fly</span><br>  ...<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Airplane::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span>     </span><br><span class="hljs-function"></span>&#123;                                                  <br>  <span class="hljs-comment">// 用纯虚函数的定义当作缺省版本</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelA</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;   <span class="hljs-comment">// 在想要调用缺省版本时显示调用</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelB</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function">  </span>&#123; Airplane::<span class="hljs-built_in">fly</span>(destination); &#125;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ModelC</span>: <span class="hljs-keyword">public</span> Airplane &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ModelC::fly</span><span class="hljs-params">(<span class="hljs-type">const</span> Airport&amp; destination)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// 这里强制我们重写fly, 不想调用缺省版本就只能老实重写</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们可以用更安全地方式实现普通<code>virtual</code>函数的作用, <strong>利用纯虚函数必须重写的机制来让我必须在缺省和重写中做出选择, 而没有”忘了”这种选项</strong>.</p><hr><h3 id="继承方式的选择"><a href="#继承方式的选择" class="headerlink" title="继承方式的选择"></a>继承方式的选择</h3><p>具体选择还是依靠我们的需求来决定, 每种继承方式应用的场景我们都应明晰, 最后做出明智的判断, 最后作者还给出了几点提醒: </p><ul><li>除非你的<code>class</code>没有多态用途, 不要将所有函数声明为<code>non-virtual</code>.</li><li>除非你要写接口类, 不要将所有函数声明为<code>virtual</code>, 这是不想思考的体现.</li><li><code>virtual</code>函数是有成本的, 但是考虑到80-20法则(程序有80%的时间花费在20%的代码身上), 有80%的<code>virtual</code>函数不会对效率产生冲击, 这需要我们合理考量.</li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p><code>pure virtual</code>函数只确保接口继承, 但是也可以进行定义.</p></li><li><p><code>virtual</code>函数在接口继承的同时可以选择是否继承实现, 可以用”使用纯虚函数并定义”的方式来替换以提高安全性.</p></li><li><p><code>non-virtual</code>函数在接口继承的同时继承一份强制性实现.</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款33 继承, 重载与作用域</title>
    <link href="/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2024/12/16/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE33%20%E7%BB%A7%E6%89%BF,%20%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="条款33-避免遮掩继承而来的名称"><a href="#条款33-避免遮掩继承而来的名称" class="headerlink" title="条款33 : 避免遮掩继承而来的名称"></a>条款33 : 避免遮掩继承而来的名称</h2><blockquote><p>本条款并非和继承有关, 而是在讨论由继承引发的作用域问题, 其有可能破坏条款32所确定的法则, 因此我们在其之后介绍本条款。</p></blockquote><p>我们知道在不同作用域下如果有相同名称的事物, 无论其功能或类型, 都是局部优先的. 继承的父子类也是类似, 不管是不是虚函数, 亦或是纯虚函数都完全没有关系, 都遵守相同名称局部优先的原则, 我们来看看一下的代码 :  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>分析代码我们可以发现, 派生类的函数都将覆盖基类相同名称的函数, 但没有什么原则上的问题.</p><p>但是如果加入重载, 事情就变得有些复杂了, 我们来看看接下来的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;  <span class="hljs-comment">// mf1的重载</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf2</span><span class="hljs-params">()</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span></span>;  <span class="hljs-comment">// mf3的重载</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们经过测试发现, 派生类调用<code>mf1</code>将只能调用到<code>Derived</code>中的<code>mf1()</code>, <code>mf3</code>也是如此, 而基类中的重载版本将无法再获取(除非用<code>Base::</code>). 以下我们将会介绍两种应用于不同情况下的解决办法.</p><hr><h3 id="using声明式"><a href="#using声明式" class="headerlink" title="using声明式"></a>using声明式</h3><p>让我们回顾条款32 : “<strong>public意味is-a</strong>“ , 也就是说派生类可以干出所有<code>Base</code>可以干的事, 但是在这种情况下, 基类可以使用<code>mf1(int)</code>, 而派生类却不可, 这便是打破了这个规则. 因此我们可以再在派生类重写对应的重载, 亦或是直接接受父类的重载版本, 就像如下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">using</span> Base::mf1;       <br>  <span class="hljs-keyword">using</span> Base::mf3;      <span class="hljs-comment">// 所有Base中的mf1和mf2在Derived中都可见</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf3</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mf4</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>如此便可<strong>避免遮掩继承而来的名称</strong>.</p><hr><h3 id="转交函数"><a href="#转交函数" class="headerlink" title="转交函数"></a>转交函数</h3><p><code>public</code>继承可以通过<code>using</code>暴露所有基类的名称及其对应的重载版本, 但当然也会有<code>private</code>继承(具体细节在条款39中讲解)有类似的需求, 但<code>private</code>继承不一定需要继承所有基类的重载版本, 可能只是某个被遮掩的版本, 于是我们可以通过<strong>转交函数</strong>, 来缩小获取的范围, 让我们看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br>  ...                                   <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span>: <span class="hljs-keyword">private</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">mf1</span><span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123; Base::<span class="hljs-built_in">mf1</span>(); &#125;                     <span class="hljs-comment">// 转交给基类, 选取其中的无参数版本</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样<code>mf1</code>就只会有基类无参数版本的<code>mf1</code>对应的功能, 而使用不到带<code>int</code>的重载版本.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>派生类中的名称会遮掩基类中的名称.</li><li><code>public</code>继承必须接受所有基类中所有被遮掩的名称, 故用<code>using</code>声明式.</li><li><code>private</code>继承中可能有需要基类中被遮掩物的需求, 可以用转交函数声明调用基类函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款32 public继承</title>
    <link href="/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/"/>
    <url>/2024/12/12/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE32%20public%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="条款32-确定你的public继承塑膜出-is-a-关系"><a href="#条款32-确定你的public继承塑膜出-is-a-关系" class="headerlink" title="条款32 : 确定你的public继承塑膜出 is-a 关系"></a>条款32 : 确定你的public继承塑膜出 is-a 关系</h2><blockquote><p>从本条款开始我们将步入面向对象编程这一重要领域进行讨论, 首先我们将会围绕public继承, 分析public继承的意义与目的, 再举出两个错误的public继承典例.</p></blockquote><h3 id="public继承意味”is-a”-是一种-的关系"><a href="#public继承意味”is-a”-是一种-的关系" class="headerlink" title="public继承意味”is-a”(是一种)的关系"></a>public继承意味”is-a”(是一种)的关系</h3><p>这便是C++面向对象编程的最重要的一个规则, 请把这个规则牢牢记在心中吧, 相信很多人以及对这种认知有所耳闻, 我甚至在学java的多态时都听到过这个概念, 可见此思想影响之深远.</p><p>如果你令B公开继承自A, 那么代表着<strong>B是一种A</strong>,  进而代表着<strong>所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生</strong>. 反之则不然, 需要B的场景并不能用A替代.</p><p>这种规则表面上很容易理解, 但是我们应当多去站在语法和程序本身的角度去理解, 因为我们在生活中的直觉可能会误导我们, 它并不一定是富有逻辑性而且缜密, 这会让我们想当然地去认为xxx是一种xxx.</p><p>让我们通过两个例子来揭露这种错误.</p><hr><h3 id="鸟会飞"><a href="#鸟会飞" class="headerlink" title="鸟会飞?"></a>鸟会飞?</h3><p>直觉来看, 鸟应该是会飞的, 但是当我们想到鸵鸟和企鹅, 事情就开始不对劲了, 我们先来看第一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;                  <span class="hljs-comment">// 鸟会飞</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>:<span class="hljs-keyword">public</span> Bird &#123;            <span class="hljs-comment">// 企鹅是鸟</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们可以看出, 企鹅确实是鸟, 但企鹅确实不会飞, 它本就不应该继承fly()函数, 于是我们就会有下一版 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br>  ...                                      <span class="hljs-comment">// 不在声明fly()函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyingBird</span>: <span class="hljs-keyword">public</span> Bird &#123;<span class="hljs-comment">// 一个新的派生类, 用来做所有飞鸟的基类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>: <span class="hljs-keyword">public</span> Bird &#123;<br>  ...                                       <span class="hljs-comment">// 这里就继承不到fly()了</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>至此逻辑就合理了,  这也在告诫我们应当仔细分析设置在类中的每个成员函数是否合理.</p><hr><h3 id="进一步梳理"><a href="#进一步梳理" class="headerlink" title="进一步梳理"></a>进一步梳理</h3><p>上一个例子因为鸟是否会飞的需求而产生了不同的设计, 但是书中想告诉我们, <strong>世界上并不存在一个”适用于所有软件”的完美设计</strong>, 因为时间在流逝, 需求在变化, 我们的设计一定要符合需求, 假如我们整个体系就是针对飞鸟来建立的, 完全不会与企鹅鸵鸟相关, 那么最开始的设计完全是可行的. 简单来说, <strong>我们要明确需求, 根据需求分析各种不同的情况, 做出符合当前需求的继承设计</strong>, 当然也可以有一定的前瞻性, 但不要与当下的需求相悖.</p><hr><h3 id="正方形是一种矩形"><a href="#正方形是一种矩形" class="headerlink" title="正方形是一种矩形?"></a>正方形是一种矩形?</h3><p>这相比于上一例中由于常识产生的错误不同, 这就是数理方面的真理, 但从最终结果上并不适合<code>public</code>继承, 我们来看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">(<span class="hljs-type">int</span> newHeight)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-type">int</span> newWidth)</span></span>;<br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">height</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;               <span class="hljs-comment">// return current values</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">width</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addWidth</span><span class="hljs-params">()</span>               <span class="hljs-comment">// 调用这个函数会使这个width增加10, 并且height不加</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> oldHeight = <span class="hljs-built_in">height</span>();<br>  <span class="hljs-built_in">setWidth</span>(<span class="hljs-built_in">width</span>() + <span class="hljs-number">10</span>);<br>  <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">height</span>() == oldHeight);          <span class="hljs-comment">// 检察height是否变化</span><br>&#125; <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-keyword">public</span> Rectangle &#123;...&#125;;<br></code></pre></td></tr></table></figure><p>当我们用<code>Square</code>写出如下代码就会发生问题 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Square s;<br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());           <span class="hljs-comment">// 看正方形的性质是否保持</span><br>s.<span class="hljs-built_in">addWidth</span>();   <span class="hljs-comment">// 调用addWidth</span><br><span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">width</span>() == s.<span class="hljs-built_in">height</span>());   <span class="hljs-comment">// 看正方形的性质是否保持</span><br></code></pre></td></tr></table></figure><p>最后一条<code>assert</code>将会触发, 原因很容易理解, <code>addWidth</code>只增加了宽度, 这打破的正方形的性质.</p><p>进一步分析, <code>addWidth()</code>这个函数本身是完全合理的, 因为一个矩形就是可以只增加宽度而不增加长度, 错的是自顾自<code>public</code>继承自它的<code>Square</code>, 因为它假定了正方形是一种矩形, 尽管这在公理上确实是成立的,  但是我们要求的是<strong>正方形可以做出所有矩形可以做出的行为</strong>, 这仿佛就不行了, 因为矩形可以只增加宽度而正方形不可以.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p><code>is-a(是一种)</code>并非是唯一存在于继承中关系, 我们还会再条款38和条款39讨论另外两个常见的关系, <code>has-a(有一个)</code>和<code>is-implemented-in-terms-of(根据某物实现出)</code>, 而我们上文正方形和矩形的关系便可以用<code>has-a</code>来解释. 在学完另外两种关系之后, 我们便应当好好了解这些关系之间的差异, 在继承中做到正确的选择.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>public</code>继承意味”<code>is-a</code>“(是一种)的关系, 若B继承自A, 所有可以使用A的场景都可以使用B, 所有A可以产生的行为B都可以产生.</li><li>不要太相信直觉, 当你认为某些事物有 “<code>is-a</code>“的关系, 不妨再看看是否符合上一条的后半句.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>继承</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(3)</title>
    <link href="/2024/12/11/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/"/>
    <url>/2024/12/11/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(3)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>只要紧紧跟随你的天赋, 它每时每刻都将让你看到全新的景色.</p></li><li><p>从事商业需要极具自信, 认真, 机警, 敢于冒险和不知疲倦的精神.</p></li><li><p>当了解某个人的真实性格以后, 我自认为是不可能去改变它的, 无论是让它变得更好还是更坏.</p></li><li><p>我既可以因为看戏而感动, 但我也可以对和我有重要关系的实际事件无动于衷.</p></li><li><p>我们活得太拥挤, 因袭彼此的生活方式, 相互之间磕磕绊绊, 我想我们因此失去了彼此之间的尊重. 对所有热忱的交往来说, 次数再少肯定也是足够的.</p></li><li><p>每个人清醒过来之后都应该了解自己所处的位置, 只有到了失去这个世界之后, 我们才能开始找到我们自己, 才能发现我们所处的位置, 以及我们与万事万物的联系是多么紧密.</p></li><li><p>别让谋生变成苦差事, 而是让它成为娱乐活动. 尽情地享受大地吧, 但别去占有它. 世人往往缺少冒险精神和信仰, 所以他们忙于买卖经营, 过着奴隶般的日子.</p></li><li><p>人们每天只去离家不远的田野和街道, 到了夜里就乖乖回去, 他们到底生命渐渐失去了活力, 因为缺乏新鲜的空气.</p></li><li><p>我既热爱善良的人性, 也热爱野蛮的兽性.</p></li><li><p>打猎是我受过最好的教育, 尽管起初他们只能是玩玩而已, 最后未必能够成为厉害的猎人, 这样他们将来反而不会在这片或其他旷野上滥杀无辜, 不会以同类为渔猎的对象.</p></li><li><p>几乎所有的成虫吃的东西都比幼虫少得多, 饕餮者都是处于幼虫时期的人, 有些民族整个都处在这种阶段, 那些民族的人没有理想和创造力, 有的是出卖了他们的便便大腹.</p></li><li><p>只要坚持茹素, 你将会欢快地迎接白天和黑夜的到来, 生活将如鲜花和芳草般散发着香气, 并且变得更加乐观和高尚, 而且更有仙气—那就是你的成功.</p></li><li><p>也许最让人震惊, 最为真切的事实从来不曾在人与人之间交流过.</p></li><li><p>我认为白水是唯一适合智者的饮料, 酒并非高贵的液体, 一杯咖啡能够冲走清晨的希望, 一杯热茶可以破坏夜晚的美梦.</p></li><li><p>能够污秽人的, 不是吃进嘴里的食物, 而是不知餍足的食欲. 应该受到谴责的不是食物的事务或品质, 而是对口腹之欲的痴迷; 加入你吃东西不是为了维持我们的生命, 也不是为了激发我们的灵感, 而是为了喂饱控制我们的馋虫, 那么你应该感到惭愧.</p></li><li><p>许多烦人的噪音传到远处之后, 人们居然将其当成音乐来倾听, 着对我们低贱的生活来说, 真实莫大的讽刺.</p></li><li><p>饕餮, 贪杯, 好色或嗜睡其实是一回事, 它们无非都是肉体的欲求, 只要看到有人犯了其中之一, 我们便知道他是耽于声色犬马之徒, 污秽与纯洁是不能并存的.</p></li><li><p>智慧和纯洁出自勤奋, 无知与堕落源于懒惰. 对学生来说, 堕落就是思考的懒惰.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款31 编译依存性</title>
    <link href="/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/"/>
    <url>/2024/12/11/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE31%20%E7%BC%96%E8%AF%91%E4%BE%9D%E5%AD%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款31-将文件间的编译依存关系降至最低"><a href="#条款31-将文件间的编译依存关系降至最低" class="headerlink" title="条款31 : 将文件间的编译依存关系降至最低"></a>条款31 : 将文件间的编译依存关系降至最低</h2><blockquote><p>本条款将带我们认识文件编译依存的问题, 以及解决问题的两个有效手段.</p></blockquote><h3 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h3><p>问题的根源来自C++并没有把**”将接口从实现中分离”**这事做得很好, 简单来说, 由于C++本身机制与定位的原因, 为了达到更大的效率和可扩展性, C++引入<code>inline</code>和<code>template</code>等特性, 这些特性无不需要在头文件中发挥作用, 也就代表原本只应该存放声明的头文件会加入太多的实现细目, 也就是所谓的”没有把将接口从实现中分离这事做得很好”.</p><p>这带来的问题是既然<strong>很多定义在头文件里</strong>, 一旦我们要修改这些定义, 那么所有使用了这个头文件的所有客户(头文件)就都需要重新编译, 一环嵌一环, 最后需要的<strong>编译成本就非常高</strong>了, 这在书中被称作**”连串编译依存关系”**.</p><hr><h3 id="进一步解析"><a href="#进一步解析" class="headerlink" title="进一步解析"></a>进一步解析</h3><p><code>inline</code>和<code>template</code>无可厚非, 这是为了效率我们必须要让步的地方, 但是许多<strong>成员变量</strong>也会定义在类的定义式中, 这就有我们处理的余地了, 看看以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;address.h&quot;</span> <span class="hljs-comment">// 必须包含下方相关类的头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>         <span class="hljs-type">const</span> Address&amp; addr);<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>      std::string theName;        <span class="hljs-comment">// 名称定义</span><br>      Date theBirthDate;          <span class="hljs-comment">// 生日定义</span><br>      Address theAddress;         <span class="hljs-comment">// 地址定义</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这是一个人的抽象类型, 里面有三种不同类型的成员变量, 我们可以设想到的是, 只要<code>Date</code>和<code>Address</code>的内部定义发生变化, 就一定会连串导致<code>Person</code>重新编译, 然后使用<code>Person</code>的客户也需要重新编译.</p><p>部分语言的解决方式是直接在底层处理成指针, 这样到哪里都是原生指针的大小, 就无需通过引入头文件知道其大小, 于是可能处理成如下定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string* theName;        <br>Date* theBirthDate;   <br>Address* theAddress;<br></code></pre></td></tr></table></figure><p>这样就不需要引入头文件了,  只需要声明有这么一个类就行了, 当然string还是声明头文件吧, 因为标准库的编译一般不会成为编译瓶颈.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>             </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                          <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;      <br></code></pre></td></tr></table></figure><p>但我们的C++并没有在底层实现这种机制, 也是因为效率和一些设计理念的问题, 但没关系, 我们可以自己仿照这种做法来实现, 这就请我们回忆起条款29中提到的<strong>pimpl idiom</strong>手法(指针指向实现), 我们将在本条款继续深入其使用, <strong>设置接口类和实现类, 做到接口和实现分离</strong>, 以下是接口类的代码, 实现类将在后文补充 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><p>我们会实现一个<code>PersonImpl</code>封装上文的三个定义, 并且实现对<code>Person</code>中成员函数的定义,  因此<code>Person</code>中就只有这三个类型的声明而无定义了, 就算这三个类发生修改, 也无需重新编译Person, 于此通过接口与实现分离, 降低了编译依存关系.</p><p>额外说一下, <code>shared_ptr</code>并不需要被管理类的头文件, 也是声明即可, 就像正常的指针一样.</p><hr><h3 id="思想内核"><a href="#思想内核" class="headerlink" title="思想内核"></a>思想内核</h3><p><strong>编译依存性最小化</strong>的本质在于<strong>以”声明的依存性”替换”定义的依存性”</strong>, 现实中让头文件<strong>尽可能自我满足</strong>, 万一做不到, 则让它与其它文件内<strong>声明式</strong>相依.</p><p>于是我们可以衍生出三个设计策略 : </p><ul><li>如果可以用<strong>指针或引用</strong>就不要直接用类定义. <strong>类定义需要引入头文件, 但是指针或引用不需要, 只要声明类型即可</strong>.</li><li>如果能够, 尽量<strong>以class声明式替换class定义式</strong>. <strong>当你声明一个函数而用到某个class时, 你并不需要改class的定义</strong>, 纵使函数以<code>by value</code>的方式传递该类型的参数, 就像上面的<code>Person</code>构造一样.</li><li><strong>为接口类和实现类(也就是声明和定义)提供不同的头文件</strong>, 原因很容易理解, 本来分开的目的就是为了在实现类修改时无需接口类再次编译进而扩散影响,  放在一个头文件中到最后还不是一块编译吗?</li></ul><p>这里还需要解释为什么上面的策略都是无需定义, 只要声明就可以了?</p><p>我们可以想开一点, 就是在接口类中真的有没有无所谓, 只要通过声明认为它有就行, 真正用它的是实现类, <strong>一旦任何人调用那些函数, 调用之前定义式一旦得先曝光才行</strong>(就是你调用函数前肯定会传入对应的参数嘛), 所以我们是<strong>将”提供定义式”的义务从接口类头文件转到了”内含该函数调用”的客户文件中</strong>, 这样就可以<strong>将”非必要类型定义”与客户端之间的编译依存性去掉</strong>.</p><p>接下来将会根据思想内核提供两种实现编译依存性最小化的最终方案 : </p><hr><h3 id="Handle-classes"><a href="#Handle-classes" class="headerlink" title="Handle classes"></a>Handle classes</h3><p>本方案以上文的<strong>pimpl idiom</strong>手法为核心, <code>Handle classes</code>意为使用句柄的类, 这个句柄就是<strong>pimpl idiom</strong>手法的指针, <code>Person</code>类还是和上文一致, <code>PersonImpl</code>类<strong>应当和Person有着完全相同的成员函数, 并且有原本Person预想拥有的成员变量</strong>,  可以理解为<code>PersonImpl</code>才是真正的<code>Person</code>类, 以后所有的修改将在<code>PersonImpl</code>中进行.</p><p>一般来说我们要实现三个文件, 一个<code>Person.h</code>存放供客户使用的接口类, 一个<code>PersonImpl.h</code>存放对应接口类的实现类, 一个<code>Person.cpp</code>实现<code>Person</code>中函数声明的对应定义.  有点麻烦, 可以看代码理解, 接下来将给出两个分别封装接口类和实现类的头文件 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h  存放接口类, 和上文一致</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span>;                      <span class="hljs-comment">// 同时也声明实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;                        <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;                         <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday,<br>        <span class="hljs-type">const</span> Address&amp; addr);<br><span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>...<br><br><span class="hljs-keyword">private</span>:                                   <br>  std::shared_ptr&lt;PersonImpl&gt; pImpl;  <span class="hljs-comment">// shared_ptr使用见条款13</span><br>&#125;; <br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// PersonImpl.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonImpl</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">PersonImpl</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n) ,_birthDate(b) ,_address(a)<br>    &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp  在该文件实现接口类和实现类的真正关联</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;PersonImpl.h&quot;</span></span><br><br><span class="hljs-comment">// 完成对接口类中声明函数的定义</span><br>Person::<span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)<br>    : <span class="hljs-built_in">pImpl</span>(std::<span class="hljs-built_in">make_shared</span>&lt;PersonImpl&gt;(name, birthday, addr)) &#123;&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">Person::name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">name</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">birthDate</span>(); &#125;<br><span class="hljs-function">std::string <span class="hljs-title">Person::address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pImpl-&gt;<span class="hljs-built_in">address</span>(); &#125;<br></code></pre></td></tr></table></figure><p>宏观来说<code>Person</code>更像是一个外壳, 和<code>PersonImpl</code>有藕断丝连的关系, 而<code>PersonImpl</code>才拥有我们的核心代码, 不过对<code>PersonImpl</code>的修改并不需要<code>Person</code>所在头文件重新编译, 因为它和<code>PersonImpl</code>的关系都是声明来的, 在定义上没有任何关联.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span>  <span class="hljs-comment">// 只需包含接口类即可</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, date, addr)</span></span>;<br>cout &lt;&lt; p.<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; p.<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="Interface-classes"><a href="#Interface-classes" class="headerlink" title="Interface classes"></a>Interface classes</h3><p>本方案核心在于<strong>继承</strong>, 像是<code>java</code>有专属的接口类, <code>C++</code>也可以模拟类似的<strong>抽象基类作为接口类, 而派生类作为实现类</strong>, 也可以达到和上个方案相似的效果, 但是唯一的问题是<strong>客户怎么使用接口类</strong>? 接口类既然是抽象基类, 就绝不可能生成对象, 但是<strong>抽象基类可以有指针和引用</strong>, 由此可以<strong>利用多态机制通过基类指针调用到派生的实现类</strong>, 所以我们虽然写不了构造函数, 但是可以写一个<strong>factory</strong>(工厂)函数来调用派生类的构造函数进而返回派生类的指针, 代码还是三个部分, 我们来逐一阅读 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span>                      </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span>                      <span class="hljs-comment">// shared_ptr所在</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Person</span>() = <span class="hljs-keyword">default</span>;    <span class="hljs-comment">// virtual析构函数见条款7</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 工厂函数为create, 通过提供的参数构造不同的派生类</span><br><span class="hljs-function"><span class="hljs-type">static</span> std::shared_ptr&lt;Person&gt;    </span><br><span class="hljs-function"><span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// RealPerson.h  存放实现类</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span>   <span class="hljs-comment">// 对实现所需的其他类进行包含</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><br><span class="hljs-comment">// 定义实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RealPerson</span> : <span class="hljs-keyword">public</span> Person &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">RealPerson</span>(<span class="hljs-type">const</span> std::string&amp; n, <span class="hljs-type">const</span> Date&amp; b, <span class="hljs-type">const</span> Address&amp; a)<br>        :_name(n), _birthDate(b), _address(a)<br>    &#123;&#125;<br>    <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">RealPerson</span>() &#123;&#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _name; &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">birthDate</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _birthDate.<span class="hljs-built_in">toString</span>(); &#125;<br>    <span class="hljs-function">std::string <span class="hljs-title">address</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> _address.<span class="hljs-built_in">toString</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    std::string _name;<br>    Date _birthDate;<br>    Address _address;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Person.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;RealPerson.h&quot;</span></span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-function">std::shared_ptr&lt;Person&gt;</span><br><span class="hljs-function"><span class="hljs-title">Person2::create</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name, <span class="hljs-type">const</span> Date&amp; birthday, <span class="hljs-type">const</span> Address&amp; addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> std::<span class="hljs-built_in">shared_ptr</span>&lt;RealPerson&gt;(std::<span class="hljs-built_in">make_shared</span>&lt;RealPerson&gt;(name, birthday, addr));<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里重点理解<code>create</code>工厂函数, 它的最终目的一定是传出一个派生类的智能指针, 尽管传出指针的静态类型是<code>std::shared_ptr&lt;Person&gt;</code>, 但也会依靠多态机制绑定到正确的派生类类型. 至于是什么派生类可以通过参数值, 读取数据库数据, 环境变量等各种因素影响, 这里是因为只写了<code>RealPerson</code>一个派生类所以就直接返回了, 实际情况可以写更多的判断类型返回不同的派生类指针, 比如男人女人伪人之类的.</p><p>于是客户就可以这样调用<code>Person</code>类 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Person.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Date.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Address.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Date <span class="hljs-title">date</span><span class="hljs-params">(<span class="hljs-number">2024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Address <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;NUC&quot;</span>)</span></span>;<br><span class="hljs-function">std::shared_ptr&lt;Person&gt; <span class="hljs-title">pp</span><span class="hljs-params">(Person::create(<span class="hljs-string">&quot;李四&quot;</span>, date, addr))</span></span>;<br><br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">name</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">birthDate</span>() &lt;&lt; endl;<br>cout &lt;&lt; pp-&gt;<span class="hljs-built_in">address</span>() &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="两种方案的异同"><a href="#两种方案的异同" class="headerlink" title="两种方案的异同"></a>两种方案的异同</h3><p><code>Handle classes</code>利用<strong>pimpl idiom</strong>手法, 构造出来的是一个实打实的对象, 因此可以通过各种方式调用内部功能, 使用较为简单.</p><p><code>Interface classes</code>利用<strong>继承和多态</strong>, 构造出来的只能说一个指向派生类对象的指针, 因此只可通过指针调用内部功能, 需要额外调用工厂函数, 但是吃到了多态的便利性, 可以有更大的可扩展性.</p><p>二者都实现了声明与定义的分离, 使头文件相依于声明式而非定义式, 解除了接口和实现之间的耦合关系, 从而降低了文件间的编译依存性.</p><hr><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>C++由于专注于运行时效率的提升, 引入<code>inline</code>等各种方式来促成该目的, 再加上<code>template</code>, 这其实给编译带来了过大的负担, 也就是说其实是牺牲了编译时而成全了运行时, 放在现实中其实就是牺牲了程序员的时间成本而成全了客户, 这无可厚非, 但若是因此影响了开发效率就顾此失彼了, 因此我们才要优化编译时间, 才要降低编译依存性, 尽管这可能增加些微的运行时成本, 但这仍是必要的.</p><p>另外我们也应权衡<code>inline</code>, <code>template</code>和以上两种方案的使用, 就让它们出现在最应该出现的地方吧.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>支持”编译依存性最小化”的一般构想是 : 相依于声明式, 不要相依于定义式. 基于此构想的两个手段是<code>Handle classes</code>和<code>Interface classes</code>.</li><li>头文件应该以”完全且仅有声明式”的形式存在, 除非要使用<code>inline</code>或<code>template</code>, 而且就算使用<code>template</code>, 也可以在头文件中实现<code>template</code>的声明, 将定义置入非头文件中,</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>编译依存性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款30 inline</title>
    <link href="/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/"/>
    <url>/2024/12/09/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE30%20inline/</url>
    
    <content type="html"><![CDATA[<h2 id="条款30-透彻了解inlining的里里外外"><a href="#条款30-透彻了解inlining的里里外外" class="headerlink" title="条款30 : 透彻了解inlining的里里外外"></a>条款30 : 透彻了解inlining的里里外外</h2><blockquote><p>inline 函数, 多么棒的点子! 本条款将带我们透彻了解inlining的里里外外, 与往常的形式不同, 我会以知识点集的形式把书中对inline的描述列举处理, 可更简单明了的认识inline.</p></blockquote><h2 id="inline的优劣"><a href="#inline的优劣" class="headerlink" title="inline的优劣"></a>inline的优劣</h2><ul><li><code>inline</code>函数, 看起来像函数, 动作像函数, 却比宏好得多, 调用它们<strong>不用蒙受函数调用所带来的额外开销</strong>.</li><li>编译器会对<code>inline</code>函数执行语境相关最优化, 会<strong>提升编译效率</strong>.</li><li>如果内存有限, 过度<code>inlining</code>会造成程序<strong>体积太大</strong>.</li><li><code>inline</code>会带来<strong>代码膨胀</strong>, 进而导致额外的<strong>换页</strong>行为, 降低高速缓存装置的<strong>击中率</strong>.</li><li><strong>如果inline函数的本体很小</strong>, 编译器针对”函数本体”产出的码可能比针对”函数调用”产出的码更小, 反而会促成与上一条相反的情况, 可以导致较小的目标码和较高的高速缓存装置击中率.</li><li><code>inline</code>函数无法随程序库的升级而升级, 简单说如果程序库中有一个<code>inline</code>函数, 如果决定改变该函数, 那么程序库中所有用到该函数的程序就必须重新编译. 如果是<code>non-inline</code>函数,客户端只需要重新连接就好了, 没有那么大的编译负担, 如果是动态库就更没有了.</li></ul><hr><h2 id="inline的特性"><a href="#inline的特性" class="headerlink" title="inline的特性"></a>inline的特性</h2><ul><li><p><strong>inline不是一个强制命令, 它只是对编译器的一个申请!</strong> 编译器可以加以忽略, 大部分编译器将拒绝太过复杂的函数(含循环, 递归, 长度过长)进行<code>inlining</code>. 简而言之, <strong>一个表面看似inline的函数是否真的是inline, 取决于你的建置环境, 主要取决于编译器</strong>.</p></li><li><p><code>inline</code>可以明确提出, 也可以<strong>隐喻提出</strong>.</p></li><li><p>隐喻提出的方式是<strong>将函数定义在class定义式中</strong>. 这便是为什么很多<code>class</code>会将实现简短的函数直接在<code>class</code>定义式中将声明定义一并给出, 其实就是在方便的前提下还隐喻地使用了<code>inline</code>函数, 以达到”没有声明任何<code>inline</code>却处处都是<code>inline</code>“的效果. </p></li><li><p>隐喻<code>inline</code>函数通常是<strong>成员函数</strong>, 也可以是<code>friend</code>函数.</p></li><li><p>所有<code>virtual</code>函数与调用<code>virtual</code>的函数都无法<code>inlining</code>. <code>virtual</code>代表着等待运行时判定, 而<code>inline</code>代表编译时提前替换, 这两种行为是绝对冲突的.</p></li></ul><hr><h2 id="inline的使用"><a href="#inline的使用" class="headerlink" title="inline的使用"></a>inline的使用</h2><ul><li><code>inline</code>函数通常<strong>一定被置于头文件内</strong>, 因为大多数建置环境都在编译过程中进行<code>inline</code>.</li><li><code>templates</code>(泛型类&#x2F;函数)通常也被置于头文件内, 很多程序员认为泛型函数一定都是<code>inline</code>, 但这是错误的, <strong>template的实例化与inline无关</strong>, 不应该这样考量, 还是应该依照代码长度,内容以及环境做具体考量.</li><li><strong>构造函数和析构函数往往是inlining的糟糕候选人</strong>, 因为就算它们是空白的, 也有可能在底层被编译器施加很多额外的代码, 例如基类的构造与析构, 这导致它们的实际代码量远比我们看见的要多得多, 令它们<code>inlining</code>很有可能会发生代码膨胀.</li><li>一开始先不要将任何函数声明成<code>inline</code>, 除非你非常笃定它就是<code>inline</code>的典型案例, 当你开始关心效率时, 再分析是否可以<code>inlining</code>.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h2><ul><li>请将大多数的<code>inlining</code>限制在<strong>小型, 被频繁调用</strong>的函数身上.</li><li>通过将函数定义在<code>class</code>定义式中实现隐喻<code>inline</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款29 异常安全性</title>
    <link href="/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/"/>
    <url>/2024/12/08/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE29-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="条款29-为”异常安全”而努力是值得的"><a href="#条款29-为”异常安全”而努力是值得的" class="headerlink" title="条款29 : 为”异常安全”而努力是值得的"></a>条款29 : 为”异常安全”而努力是值得的</h2><blockquote><p>异常安全性是我们每个程序员都要考量的内容, 我们有必要知道我们写出的每个函数保证了怎样的异常安全, 因为一个函数是否会抛出异常不仅会影响我们是否使用该函数的决策, 也会影响部分的编译器优化策略, 让我们通过本条款来充分认识异常安全性.</p></blockquote><p>先了解本条款的例子, 假设有个<code>class</code>用来表现夹带背景图案的GUI界面, 这个<code>class</code>用于多线程环境, 所以它有个互斥器作为并发控制之用 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span>;           <span class="hljs-comment">// 用来改变背景图片的成员函数</span><br><br><span class="hljs-keyword">private</span>:<br><br>  Mutex mutex;                    <span class="hljs-comment">// 互斥器</span><br><br>  Image *bgImage;                 <span class="hljs-comment">// 当前的背景图像</span><br>  <span class="hljs-type">int</span> imageChanges;               <span class="hljs-comment">// 背景图像被改变的次数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">lock</span>(&amp;mutex);                      <span class="hljs-comment">// 上锁</span><br><br>  <span class="hljs-keyword">delete</span> bgImage;                    <span class="hljs-comment">// 释放原背景</span><br>  ++imageChanges;                    <span class="hljs-comment">// 更新计数</span><br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);       <span class="hljs-comment">// 修改新背景</span><br><br>  <span class="hljs-built_in">unlock</span>(&amp;mutex);                    <span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从异常安全性的角度来看, <code>changeBackground</code>非常糟糕, 它并没有满足”异常安全”的两个必要条件 : </p><ul><li><p><strong>不泄漏任何资源</strong>. </p><p>资源泄漏包括内存&#x2F;文件句柄&#x2F;<code>socket</code>连接&#x2F;锁等泄漏, 这里我们知道<code>new Image(imgSrc)</code>是一定可能有<code>bad_alloc</code>的异常的, 当异常发生, <code>unlock(&amp;mutex)</code>语句将不会执行, 锁并没有得到释放, 也就是说发生了泄漏.</p></li><li><p><strong>不允许数据败坏</strong>.</p><p>数据败坏即数据与预期的有效状态不符, 比如野指针. 这里当<code>new Image(imgSrc)</code>处发生异常, <code>bgImage</code>的原资源已经释放却没有获得新资源, 它的行为是未定义的, 并且<code>imageChanges</code>也增加了一次本不存在的计数, 这都是数据败坏.</p></li></ul><hr><h3 id="利用资源管理类解决资源泄漏"><a href="#利用资源管理类解决资源泄漏" class="headerlink" title="利用资源管理类解决资源泄漏"></a>利用资源管理类解决资源泄漏</h3><p>当我们深谙条款13”<strong>以对象管理资源</strong>“的道理后, 资源泄漏将不再是问题! 资源管理类可以确保资源及时且自动地释放, 并且还减少了我们的代码量, 于是我们就可以用条款14中<code>RAII</code>风格的<code>Lock</code>类来解决本条款的锁泄漏 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                <span class="hljs-comment">// 自动管理锁的释放</span><br>  <span class="hljs-keyword">delete</span> bgImage;<br>  ++imageChanges;<br>  bgImage = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc);    <span class="hljs-comment">// 一旦触发异常离开函数作用域就会自动触发Lock的析构函数释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>绝大多数异常引发的资源泄漏都可以用资源管理类来解决.</p><hr><h3 id="三种异常安全保证"><a href="#三种异常安全保证" class="headerlink" title="三种异常安全保证"></a>三种异常安全保证</h3><p>这将是本条款的重点, 一个异常安全的函数在避免资源泄漏之后, 为了防止数据败坏, 我们还必须拥有下面三个保证之一, 越往后保证强度越大.</p><ul><li><p><strong>基本承诺</strong> : 异常抛出后, 没有数据泄漏, 没有数据败坏, 所有事物仍然保持有效, 但是不支持完全回滚, 我们不确定数据在该函数中修改成什么样了, 即使这种状态合法, 其实就是符合<strong>两个必要条件但是不做任何处理</strong>. 我们看以下的例子理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; data)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i = <span class="hljs-number">10</span>; i ++ )<br>        data.<span class="hljs-built_in">push_back</span>(i); <span class="hljs-comment">// 如果此处抛出异常，vector 自动管理内存，无泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该例子符合基本承诺, 这个函数向<code>data</code>中插入1到10, 插入动作会抛出异常, 但是<code>vector</code>会自动管理内存, 不会有泄漏与数据败坏, 但是加入我们在插入<code>i = 5</code>时出现异常, 那么异常抛出将不会执行之后的语句, 也就是说这次插入的结果是<code>data</code>尾插了1,2,3,4, 然而出现异常后客户并不会知道内部到底插入了多少, 虽然该状态合法.</p></li><li><p><strong>强烈保证</strong> : 如果异常被抛出, 对象状态不会改变, 与调用该函数前状态一致. 就是说, 没有异常就是完全成功, 抛出异常对象状态会发生<strong>回滚</strong>, 回滚至调用前状态. </p></li><li><p><strong>不抛掷保证</strong> : 承诺绝不抛出异常. 这种函数不可能涉及任何动态内存的分配, 一般只是对<strong>内置类型</strong>进行操作, 如算术类型, 指针, 引用等.并且这种函数我们一般会在其函数定义后添加<code>noexcept</code>关键字, 这代表你向编译器声明这个函数绝不会抛出异常, 编译器就会删去对这个函数的异常处理工作, 实现效率的提升.</p></li></ul><hr><h3 id="实现强烈保证"><a href="#实现强烈保证" class="headerlink" title="实现强烈保证"></a>实现强烈保证</h3><p>我们一般都是由下至上选择安全保证, 不抛掷保证只适用于对内置类型的操作, 比较典型的就是移动构造和移动赋值.</p><p>所以大多数情况下我们更愿意实现强烈保证, 我们来看看将<code>changeBackground</code>修改为强烈保证的步骤 : </p><ol><li>将<code>bgImage</code>这个成员变量用智能指针代替, 这个只是为了实现两个条件中的避免资源泄漏.</li><li>重新改变语句顺序, <strong>不要为了表示某事件的发生而改变对象状态, 除非那件事真的发生了</strong>.</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;<br>  ...<br>  std::shared_ptr&lt;Image&gt; bgImage; <span class="hljs-comment">// 改用智能指针</span><br>  ...<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;<br>  bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));  <span class="hljs-comment">// 以 new Image(imgSrc) 的结果设定为bfImage的内部指针</span><br>     <span class="hljs-comment">// 无需delete原资源, reset内部会帮我们自动调用delete</span><br>  ++imageChanges;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析上述代码, 我们可以很惊喜地发现, 如果<code>new Image(imgSrc)</code>失败, 对象状态将不发生任何改变, <code>reset</code>和<code>++imageChanges</code>都不会触发,  也就是说失败即回滚, 成功即完全, 再加上不会资源泄漏与数据败坏, 其符合强烈保证!</p><hr><h3 id="copy-and-swap"><a href="#copy-and-swap" class="headerlink" title="copy and swap"></a>copy and swap</h3><p>上文我们通过<strong>调整语序</strong>来实现了强烈保证, 这确实是最基础的一种解决方法, 其内核在于”<strong>在所有可能抛出异常的动作成功结束前不要改变对象状态</strong>“, 但是这种做法比较费脑, 并且不一定适合某些场景. 然而有一个<strong>一般化的设计</strong>很典型地会导致强烈保证, 这个策略被称为<code>copy and swap</code>.</p><p>使用方法很简单, <strong>为你打算修改的对象做出一个副本, 在那个副本上做任何的修改, 待所有改变成功后再交换原对象和副本</strong>(注意这个做法的前提建立在<code>swap</code>是<code>noexcept</code>的, 这也是为什么条款25一直强调<code>swap</code>不抛异常的重要性). 其内核在于”<strong>修改对象数据的副本, 然后在一个不抛异常的函数中将数据和原件置换</strong>“.</p><p>在看代码之前, 有一个手法很适合实现上述操作, 叫做<strong>pimpl idiom</strong>(pointer to implementation idiom)(指针指向实现), 这个手法在于将所有需要隐藏的成员变量和成员函数包入一个<strong>实现类</strong>, 外部构造一个<strong>接口类</strong>, 该接口类存放该实现类的指针(一般是智能指针)与外放接口. 条款31将详细描述该手法的优势, 在本条款就是将<strong>所有”隶属对象的数据”从原对象放进另一个对象内, 然后赋值原对象一个指针, 指向该对象</strong>, <strong>这样我们copy and swap的对象就仅限于存放数据的对象, 而一切操作都在原对象中进行</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PMImpl</span> &#123;                               <span class="hljs-comment">// 实现类</span><br>  std::shared_ptr&lt;Image&gt; bgImage;        <br>  <span class="hljs-type">int</span> imageChanges;                           <br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrettyMenu</span> &#123;  <span class="hljs-comment">// 接口类</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  Mutex mutex;<br>  std::shared_ptr&lt;PMImpl&gt; pImpl;  <span class="hljs-comment">// 一个智能指针指向实现类</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrettyMenu::changeBackground</span><span class="hljs-params">(std::istream&amp; imgSrc)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">using</span> std::swap;                            <span class="hljs-comment">// 见条款25</span><br>  <span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;mutex)</span></span>;                        <span class="hljs-comment">// 锁的copy and swap是没有意义的</span><br>  <span class="hljs-function">std::shared_ptr&lt;PMImpl&gt; <span class="hljs-title">pNew</span><span class="hljs-params">(<span class="hljs-keyword">new</span> PMImpl(*pImpl))</span></span>; <span class="hljs-comment">// 复制副本</span><br><br>  pNew-&gt;bgImage.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Image</span>(imgSrc));     <span class="hljs-comment">// 对副本进行所有修改</span><br>  ++pNew-&gt;imageChanges;<br><br>  <span class="hljs-built_in">swap</span>(pImpl, pNew);    <span class="hljs-comment">// 只有前面不抛异常才会到这里, 直接进行交换, 内置类型的交换一定不会有异常</span><br>&#125;                                     <br></code></pre></td></tr></table></figure><p>以上便通过<code>copy and swap</code>实现了强烈保证.</p><hr><h3 id="实现强烈保证的最终策略"><a href="#实现强烈保证的最终策略" class="headerlink" title="实现强烈保证的最终策略"></a>实现强烈保证的最终策略</h3><p><code>copy and swap</code>策略是<strong>对对象状态做出”全有或全无”改变</strong>的一个很好办法, 但是它<strong>不等于一个函数有强烈保证</strong>.</p><p>分析起来比较麻烦, 简单说就是<code>copy and swap</code><strong>只确定了内存相关操作的强烈保证, 使对象的局部状态有了一致性</strong>, 即”全有或全无”, 然而有时候对象其实是会对”<strong>非局部性数据</strong>“产生影响的, 例如数据库连接, 网络连接, 锁等, 这些东西不会只因为内存数据的有无而生效或失效, 连接还和连接的对象有关, 锁还和线程分配有关, 它们更偏向于全局状态, 这也是上面代码我没有将<code>Lock ml</code>存入<code>PMImpl</code>的原因.</p><p>再讲一个例子, 假设我在函数中创建的副本上对<strong>数据库</strong>进行了修改, 如果之后发生了异常, 如果我不做任何其他的操作, 那么这个数据库的修改是一直成立的, 并没有因为<code>copy and swap</code>而回滚, 这是完全可以理解的, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123; <span class="hljs-comment">// 修改局部数据与数据库</span><br>    <br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData; <span class="hljs-comment">// copy 创建局部状态的副本</span><br><br>    <span class="hljs-comment">// 修改数据库（非局部数据）</span><br>    db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>        localDataCopy.<span class="hljs-built_in">push_back</span>(i);   <span class="hljs-comment">// 如果此处发生异常, 前面的数据库修改无法恢复!</span><br>    &#125;<br>    <span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>&#125;<br></code></pre></td></tr></table></figure><p>因此, 我们可以总结出可以实现强烈保证的大体策略 :</p><ul><li><strong>如果函数有关内存数据的修改, 使用<code>copy and swap</code>策略.</strong></li><li><strong>如果函数有关非局部数据的修改, 自己根据非局部数据的性质进行对应的异常回滚操作.</strong></li></ul><p>例如上文的数据库, 我们就可以利用其<strong>事务</strong>的特性实现异常回滚 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyDataAndDatabase</span><span class="hljs-params">(std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; localData, Database&amp; db)</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; localDataCopy = localData;<br>    db.<span class="hljs-built_in">beginTransaction</span>(); <span class="hljs-comment">// 开启数据库事务</span><br><br>    <span class="hljs-keyword">try</span> &#123;<br>        db.<span class="hljs-built_in">updateRecord</span>(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// 修改数据库数据</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            localDataCopy.<span class="hljs-built_in">push_back</span>(i);  <span class="hljs-comment">// 此刻发生任何异常都会被捕获, 在catch语句中触发回滚</span><br>        &#125;<br><br>        db.<span class="hljs-built_in">commitTransaction</span>(); <span class="hljs-comment">// 所有修改成功后，提交事务</span><br>        std::<span class="hljs-built_in">swap</span>(localData, localDataCopy);<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        db.<span class="hljs-built_in">rollbackTransaction</span>();  <span class="hljs-comment">// 发生异常时，回滚事务</span><br>        <span class="hljs-keyword">throw</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是<code>modifyDataAndDatabase</code>函数也就拥有了强烈保证, 这部分的最终策略是我求证后自创的, 书中没有详细指出如有问题或补充欢迎指出.</p><hr><h3 id="关于嵌套函数的问题"><a href="#关于嵌套函数的问题" class="headerlink" title="关于嵌套函数的问题"></a>关于嵌套函数的问题</h3><p>书中指出, 嵌套函数会确实影响函数本身的异常安全性, 道理也很容易理解, 一个没有强烈保证的函数被嵌入一个函数, 那么这个函数也一定没有强烈保证. 然而<strong>所有嵌套函数都是强烈保证的就能使本函数有强烈保证了吗, 未必!</strong> 让我们看下面的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">someFunc</span><span class="hljs-params">()</span> </span>&#123;<br>    ...                <span class="hljs-comment">// 创建副本</span><br>    <span class="hljs-built_in">f1</span>();              <span class="hljs-comment">// 调用 f1 当成调用 modifyDataAndDatabase(localData);</span><br>    <span class="hljs-built_in">f2</span>();              <span class="hljs-comment">// 调用 f2</span><br>    ...                <span class="hljs-comment">// 将修改后的副本交换到原状态</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们把<code>f1</code>当成上文的<code>modifyDataAndDatabase</code>, 仔细想想有什么问题.</p><p>大佬可能一眼就看出来了, 虽然<code>f1</code>的本身有强烈保证, 但是如果<code>f2</code>抛出了异常, <code>f1</code>中对<code>localData</code>的修改固然可以因为<code>copy and swap</code>回滚, 但是数据库的修改不能呀, 我们在<code>f1</code>中的数据库回滚操作无法延申到<code>f2</code>中! 所以无法实现完全的回滚, 这个函数是没有强烈保证的!</p><p>这种问题书中叫做”<strong>连带影响</strong>“, 即当一个函数对”非局部性数据”有影响时, 其被嵌套在其他函数内部时, 就算本身有强烈保证, 也会因为外部可能的异常连带产生错误. </p><p>这个问题提醒我们一个函数如果想有强烈保证, 不要嵌套影响”非局部数据”的函数, 非要嵌套也要确定其后没有任何异常产生的可能性.</p><hr><h3 id="异常安全性就像怀孕"><a href="#异常安全性就像怀孕" class="headerlink" title="异常安全性就像怀孕 . . ."></a>异常安全性就像怀孕 . . .</h3><p>作者提出, 一位女士若非怀孕, 就是没怀孕, 不可能说她”部分怀孕”; 同理, 一个系统内如果有一个函数不具备异常安全性, 整个系统就不具备异常安全性, 很不幸, C++由于对C的继承, 其很多传统代码其实是不具备异常安全性的, 不过我们应当尽力让我们的代码具备异常安全性, 同时也<strong>应当将自己对函数的安全性定义写成文档, 为我们的客户和后期维护者使用</strong>.</p><hr><h3 id="书中作者难得发出感叹-由此摘录"><a href="#书中作者难得发出感叹-由此摘录" class="headerlink" title="书中作者难得发出感叹, 由此摘录:"></a>书中作者难得发出感叹, 由此摘录:</h3><p>四十年前, 满载goto的代码被视为一种美好实践, 而今我们却致力于写出结构化控制流.</p><p>二十年前, 全局数据被视为一种美好实践, 而今我们却致力于数据的封装.</p><p>十年前, 撰写”未将异常考虑在内”的函数被视为一种美好实践, 而今我们却致力于写出”异常安全码”.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>“以对象管理资源”可以阻止资源泄漏, 调整语序和三种异常保证可能可以阻止数据败坏.</li><li>“基本承诺”诚可贵, “强烈保证”价更高, 若为”不抛掷”, 二者皆可抛.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
      <tag>异常安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(2)</title>
    <link href="/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/"/>
    <url>/2024/12/07/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(2)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>假如我们醒来并没有过上比睡前更崇高的生活, 那么白天也就没什么好期待的了.</p></li><li><p>人要是不相信在喧嚣的白日之前, 有者更神圣,更绚丽的时刻, 那么他对生活肯定已经感到绝望, 而他所走的人生之路肯定是江河日下, 越来越黑暗的.</p></li><li><p>只要我清醒着, 心中有光明, 那就是早晨.</p></li><li><p>我们必须学会再次苏醒, 并保持着清醒的状态, 但要借助的不是某些生硬的措施, 而是对黎明的无限期待, 这是在我们睡得最熟时也会也会有的期待.</p></li><li><p>狗屁新闻!最重要的是去了解那些永不过时的东西!</p></li><li><p>大人没能过上有价值的生活, 却自认为更聪明, 因为他们更有经验, 可惜他们的经验其实就是失败.</p></li><li><p>只有持续不断地渗入和浸泡在周围的现实之中, 我们才能理解一切圣洁而高贵的东西.</p></li><li><p>让我们把自己安顿下来, 好好地工作, 用力去踩踏脚下的烂泥, 那由成见,偏见,传统,谎言和表象搅成的烂泥, 直到我们的脚触及更坚硬的底部和安稳的岩石, 也就是我们说的现实, 有了这个立足点, 我们得以在将来的世代能够知道, 谎言和表象的洪水曾经积聚得有多深.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款28 避免返回handles指向对象内部成分</title>
    <link href="/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/"/>
    <url>/2024/12/07/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE28%20%E9%81%BF%E5%85%8D%E8%BF%94%E5%9B%9Ehandles%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E5%86%85%E9%83%A8%E6%88%90%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款28-避免返回handles指向对象内部成分"><a href="#条款28-避免返回handles指向对象内部成分" class="headerlink" title="条款28 : 避免返回handles指向对象内部成分"></a>条款28 : 避免返回handles指向对象内部成分</h2><p>让我们先来明确本条款中的两个概念 : </p><ul><li>handle : 即句柄, 号码牌, 可以理解为各种<strong>指针, 引用, 迭代器</strong>.</li><li>内部成分 : <strong>private成员变量和成员函数</strong>.</li></ul><p>有了上面两个概念, 就可以比较直观地理解本条款了, 不过在通读完本条款后, 本条款虽说是<strong>避免返回handles指向对象内部成分</strong>, 但是其实内容着重在解释<strong>在必须返回handles指向对象内部成分的情况下, 会带来什么样的风险</strong>, 以此告诫我们注意. </p><hr><h3 id="降低对象封装性"><a href="#降低对象封装性" class="headerlink" title="降低对象封装性"></a>降低对象封装性</h3><p>书中指出, <strong>返回handles指向对象内部成分</strong>, 随之而来的便是**”降低对象封装性”的风险**, 如果不是有意设计, 我们<strong>不应令public成员函数返回一个handle指向private的成员变量</strong>, 这会使后者的<strong>实际访问级别变为public</strong>, 这是完全可以理解的.</p><p>书中描述了GUI中常有的矩形, 它一般会用左上点和右下点表示 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;                      <span class="hljs-comment">// 坐标点</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br>  ...<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-type">int</span> newVal)</span></span>;<br>  ...<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">RectData</span> &#123;                    <span class="hljs-comment">// 矩形资源类</span><br>  Point ulhc;                        <span class="hljs-comment">// 左上点</span><br>  Point lrhc;                        <span class="hljs-comment">// 右下点</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<span class="hljs-comment">// 资源管理类 见条款13</span><br>  ...<br><span class="hljs-keyword">private</span>:<br>  std::shared_ptr&lt;RectData&gt; pData;    <span class="hljs-comment">// 存入智能指针进行管理    </span><br>&#125;;<br></code></pre></td></tr></table></figure><p>客户一般会要求使用矩形的位置信息 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function">Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们用两个函数分别返回左上点和右下点, 这个操作很正常, 但是这给了客户捣乱的方式 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Point <span class="hljs-title">coord1</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-function">Point <span class="hljs-title">coord2</span><span class="hljs-params">(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(coord1, coord2)</span></span>;    <br><br>rec.<span class="hljs-built_in">upperLeft</span>().<span class="hljs-built_in">setX</span>(<span class="hljs-number">50</span>);  <span class="hljs-comment">// rec的左上点实际被修改为了(50, 0)!</span><br></code></pre></td></tr></table></figure><p>这种情况在条款3中也实际发生过, 就是<strong>通过const成员函数的返回值修改了类的内部数据</strong>, 原因条款3中已经解释过了, 解决方式也很简单, 给返回值也加一个<code>const</code>就好了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">upperLeft</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;ulhc; &#125;<br>  <span class="hljs-function"><span class="hljs-type">const</span> Point&amp; <span class="hljs-title">lowerRight</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> pData-&gt;lrhc; &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>重新整理思路, 封装性在于<strong>数据隐藏</strong>, 在于<strong>限制外部对内部的访问与修改</strong>. 以上函数做到了<strong>访问权的让渡与修改权的禁止</strong>, 访问权让渡是因为有必要的客户需求, 修改权禁止是应为客户没有权限修改内部, 以此在提供必要功能的前提下使对象达到了最好的封装性.</p><hr><h3 id="空悬句柄-dangling-handles"><a href="#空悬句柄-dangling-handles" class="headerlink" title="空悬句柄(dangling handles)"></a>空悬句柄(dangling handles)</h3><p>空悬句柄和C中的野指针很相似, 书中给出了某个函数返回GUI对象的外框(矩形)的例子 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GUIObject</span> &#123; ... &#125;; <br><span class="hljs-function"><span class="hljs-type">const</span> Rectangle <span class="hljs-title">boundingBox</span><span class="hljs-params">(<span class="hljs-type">const</span> GUIObject&amp; obj)</span></span>;  <span class="hljs-comment">// 返回一个矩形    </span><br><br>GUIObject *pgo;   <br>...                                  <br><span class="hljs-type">const</span> Point *pUpperLeft = &amp;(<span class="hljs-built_in">boundingBox</span>(*pgo).<span class="hljs-built_in">upperLeft</span>());  <span class="hljs-comment">// 这里pUpperLeft是一个空悬句柄                   </span><br></code></pre></td></tr></table></figure><p>我们来解释最后一句代码 : </p><ol><li><code>boundingBox(*pgo)</code> 利用<code>pgo</code>调用<code>boundingBox</code>函数</li><li><code>boundingBox</code>函数返回一个临时矩形对象(这是一个匿名对象, 以下简称<code>temp</code>)</li><li><code>temp</code>调用<code>upperLeft()</code>得到该临时对象的左上点</li><li>取出右上点的地址赋值给<code>pUpperLeft</code></li></ol><p>最后的结果就是<code>pUpperLeft</code>获得了一个来自临时对象的指针, 当控制域离开该行, 这个指针将成为一个野指针, 则称<code>pUpperLeft</code>是一个空悬句柄, 它指向了一个不存在的对象.</p><p>因此书中告诉我们, <strong>返回handles指向对象内部成分总是危险的</strong>, 不管这个<code>handle</code>是否为<code>const</code> 唯一造成危险的事实就是, <strong>有个handle被传出去了</strong>, 因此就有可能出现<strong>handle比其所指对象更长寿</strong>的风险, 这才是问题的核心.</p><p>然而指出这个风险不是说就不应该返回<code>handles</code>, 我们总会有许多需求需要访问内部成分, 这种风险避无可避, 而是在告诫我们时常注意空悬句柄问题, <strong>不要让我们的指针&#x2F;引用&#x2F;迭代器因为比其所指对象更长寿而失效</strong>.</p><p>我们可以再通过一个例子来加深理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) v.<span class="hljs-built_in">erase</span>(it);<br>    ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个就是非常经典<strong>迭代器失效</strong>问题, 这个例子在遍历<code>v</code>, 将<code>v</code>中等于3的元素删除, 这段代码看似合理, 但是结合我们上面的理解, 在触发<code>erase</code>后, <code>it</code>迭代器指向的对象其实已经被销毁了, 这时<code>++it</code>就变为了未定义的操作, 在<code>vs</code>中甚至会直接报错, 如果我们可以提前发现这个问题, 就可以做出以下改进 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;<span class="hljs-type">int</span>&gt; v = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator it = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">while</span> (it != v.<span class="hljs-built_in">end</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (*it == <span class="hljs-number">3</span>) it = v.<span class="hljs-built_in">erase</span>(it);<br>    <span class="hljs-keyword">else</span> ++it;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们利用<code>erase</code>的返回值对<code>it</code>重新赋值, 使其免于失效.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能避免返回<code>handles</code>指向对象内部成分, 这可以提升对象封装性, 避免<code>dangling handles</code>出现.</li><li>避无可避时谨慎释出内部成分的访问权与修改权, 修改权可用<code>const</code>禁止, 注意<code>dangling handles</code>问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款27 类型转换</title>
    <link href="/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/12/06/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE27%20%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="条款27-尽量少做转型动作"><a href="#条款27-尽量少做转型动作" class="headerlink" title="条款27 : 尽量少做转型动作"></a>条款27 : 尽量少做转型动作</h2><blockquote><p>优良的C++代码很少使用转型, 但是要完全摆脱它们又太过不切实际, 我们应当保证”类型错误”绝无可能发生. 本条款在了解各种转型动作的前提下, 指出了一些有风险的转型操作及其解决方法.</p></blockquote><p>我们先来回顾一下类型转换 : </p><h4 id="旧式C风格转型"><a href="#旧式C风格转型" class="headerlink" title="旧式C风格转型"></a>旧式C风格转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(T)expression;<br><span class="hljs-built_in">T</span>(experssion);<br></code></pre></td></tr></table></figure><h4 id="新式转型"><a href="#新式转型" class="headerlink" title="新式转型"></a>新式转型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">static_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">const_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">dynamic_cast</span>&lt;T&gt;(expression)<br><span class="hljs-built_in">reinterpret_cast</span>&lt;T&gt;(expression)<br></code></pre></td></tr></table></figure><ul><li>static_cast : 强制隐式转换, 适合除常量性移除之外的大部分转换场景.</li><li>const_cast : 唯一可以常量性移除的转换, 而且能且仅能移除常量性.</li><li>dynamic_cast : “安全向下转型”, 可以理解为一个有安全类型检查的可以将基类转为派生类的<code>static_cast</code>.</li><li>reinterpret_cast : 低级转型, 现在很少用了.</li></ul><hr><p>书中提出第一个观点 : 除非你确定转型没有任何风险, 并且旧式转型很方便, 应当<strong>始终理智使用新式转型</strong>, 以下为原因 : </p><ol><li>新式转型<strong>很容易在代码中被识别出来</strong>, 有助于编译器或其他工具识别.</li><li>新式转型<strong>细化了转型动作的目标</strong>, 使得编译器更容易诊断出错误的运用.</li></ol><hr><h4 id="避免做出”对象在C-中如何布局”的假设"><a href="#避免做出”对象在C-中如何布局”的假设" class="headerlink" title="避免做出”对象在C++中如何布局”的假设"></a>避免做出”对象在C++中如何布局”的假设</h4><p>书中提醒我们, <strong>类型转换并不仅仅是“告诉编译器类型的变化”</strong>, 它是会实际产生额外代码的, 而且有可能对当前对象布局做出调整, 例如将基类指针从原本的指向的基类, 改为指向派生类, 我们也许会认为前者和后者的指针地址是一样的, 实际也确实大多数情况都是一样的(包括我测试的), 但是书中说对象布局方式会依照编译器的不同而不同, 确实会发生前后者指针不一样的情况出现, 而且在出现多重继承是这种情况会更多. 所以作者告诫我们, <strong>“由于知道对象如何布局”而设计的转型, 在某些平台行得通, 在其他平台并不一定</strong>.</p><hr><h4 id="避免用类型转换写出似是而非的代码"><a href="#避免用类型转换写出似是而非的代码" class="headerlink" title="避免用类型转换写出似是而非的代码"></a>避免用类型转换写出似是而非的代码</h4><p>在写GUI时会有定义很多的窗口类, 这种应用框架一般会坚持派生类的重写会先调用父类版本, 于是就有了以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;                                <span class="hljs-comment">// base class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123; ... &#125;             <span class="hljs-comment">// 基类窗口重置尺寸</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;          <span class="hljs-comment">// derived class</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;                   <span class="hljs-comment">// 派生类重写</span><br>    <span class="hljs-built_in">static_cast</span>&lt;Window&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">onResize</span>();    <span class="hljs-comment">// 先调用父类版本的onResize()</span><br>    ...                                    <br>  &#125;                                          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们起初看可能还像一回事, 但是实际漏洞百出,  <code>static_cast&lt;Window&gt;(*this)</code>这个表达式返回的其实是一个**”<em>this对象值base class成分”的临时拷贝</em>*! <code>static_cast</code>在底层转换类型后进行切分, 然后把切分出来的部分拷贝返回. 也就是说真正调用基类<code>onResize()</code>的是这个临时对象, 而不是当前对象的基类部分, 想要真正使当前对象调用基类<code>onResize()</code>, 应以如下写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">onResize</span><span class="hljs-params">()</span> </span>&#123;<br>    Window::<span class="hljs-built_in">onResize</span>();                    <span class="hljs-comment">// 这样调用</span><br>    ...                                   <br>  &#125;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="谨慎使用dynamic-cast"><a href="#谨慎使用dynamic-cast" class="headerlink" title="谨慎使用dynamic_cast"></a>谨慎使用dynamic_cast</h4><p>我们之所以需要<code>dynamic_cast</code>, 通常是因为我们手持一个<strong>静态类型是base而动态类型是derived的指针或引用</strong>时, <strong>想要使用只有derived中有的一个普通函数</strong>, 因为其不是虚函数, 所以我们现在无权使用它, 只能依靠<code>dynamic_cast</code>来进行较为安全的转换.</p><p>假设我们的<code>SpecialWindow</code>有一个单独的闪烁功能, 有一个<code>vector</code>中存放了大量的<code>Window</code>, 我们希望遍历该<code>vector</code>, 如果其动态类型是<code>SpecialWindow</code>就调用其闪烁功能, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 特有的blink功能</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::shared_ptr&lt;Window&gt; &gt; VPW;  <span class="hljs-comment">// 存放Window智能指针的数组</span><br>VPW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>();  ++iter) &#123;<br>  <span class="hljs-comment">// dynamic_cast转换成功说明是SpecialWindow类型, psw不为空, 判true, 调用blink</span><br>  <span class="hljs-comment">// 转换失败说明不是, psw为nullptr, 判false</span><br>  <span class="hljs-keyword">if</span> (SpecialWindow *psw = <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow*&gt;(iter-&gt;<span class="hljs-built_in">get</span>()))<br>     psw-&gt;<span class="hljs-built_in">blink</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面算是对<code>dynamic_cast</code>的日常用法做了一个介绍, 但是作者告诉你使用<code>dynamic_cast</code>在很多情况并不必要, <strong>能不使用dynamic_cast就尽量不使用</strong>, 原因在于<code>dynamic_cast</code>为了实现安全性检测和其他一些目的, 效率十分低下, 相比于它的其他几个兄弟效率不只低了一点半点, 除非有<strong>必须是多态情况下用基类使用派生类普通函数的场景</strong>, 我们可以<strong>做出一些让步</strong>来提升我们的效率, 书中给出了两种方法 : </p><ol><li><p><strong>放弃多态需求</strong>, 确保容器内只有需求派生类的指针.具体来说就是<code>VPW</code>内只存<code>shared_ptr&lt;SpecialWindow&gt;</code>, 让<code>blink</code>的调用普遍化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;SpecialWindow&gt; &gt; VPSW; <span class="hljs-comment">// 只存派生类智能指针</span><br>VPSW winPtrs;<br>...<br><span class="hljs-keyword">for</span> (VPSW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>(); <span class="hljs-comment">// 直接调用</span><br></code></pre></td></tr></table></figure></li><li><p><strong>将普通函数转为virtual函数</strong>, <strong>略微增加写代码的成本</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123;&#125;  <span class="hljs-comment">// 这里什么都不做, 其目的只是为了让SpecialWindow通过多态调用有效果的blink()</span><br>  ...<br>&#125;;                                            <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow</span>: <span class="hljs-keyword">public</span> Window &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">blink</span><span class="hljs-params">()</span> </span>&#123; ... &#125;;                 <br>  ...                                          <br>&#125;;<br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;                                    <br>...<br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>();<br>     iter != winPtrs.<span class="hljs-built_in">end</span>();<br>     ++iter)                                  <br>  (*iter)-&gt;<span class="hljs-built_in">blink</span>();  <span class="hljs-comment">// 正常的多态用法</span><br></code></pre></td></tr></table></figure></li></ol><p>最后总结下来就是, <strong>在出现dynamic_cast需求场景时, 如果代码对效率没有太多需求, 直接使用dynamic_cast, 反之则思考是否能做出上面所说的两种让步, 如果前两种让步的代价实在太高再使用dynamic_cast</strong>.</p><p>书中还指出了一种应当杜绝的写法 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow1</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow2</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpecialWindow3</span> &#123; ... &#125;;<br>...                    <br><span class="hljs-keyword">typedef</span> std::vector&lt;std::tr1::shared_ptr&lt;Window&gt; &gt; VPW;<br>VPW winPtrs;<br>...<br><br><span class="hljs-keyword">for</span> (VPW::iterator iter = winPtrs.<span class="hljs-built_in">begin</span>(); iter != winPtrs.<span class="hljs-built_in">end</span>(); ++iter)<br>&#123;<br>  <span class="hljs-keyword">if</span> (SpecialWindow1 *psw1 =<br>       <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow1*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow2 *psw2 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow2*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (SpecialWindow3 *psw3 =<br>            <span class="hljs-built_in">dynamic_cast</span>&lt;SpecialWindow3*&gt;(iter-&gt;<span class="hljs-built_in">get</span>())) &#123; ... &#125;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样子的代码, 不仅效率低, 而且可维护性差, 最好将这种需求<strong>改写成某种virtual函数</strong>来实现, 不要去依赖<code>dynamic_cast</code>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>尽量避免转型</strong>, 尤其在注重效率的程序中避免<code>dynamic_cast</code>.</li><li>转型并非什么都没做, 会产生实际的花销.</li><li>如果转型是必要的, <strong>可以把转型过程放在一个函数中</strong>, 让客户调用该函数以实现转型, 而不需要将转型写入他们的代码.</li><li>最好使用<code>C++</code>风格的新式转型.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款26 尽可能延后变量定义式的出现时间</title>
    <link href="/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/"/>
    <url>/2024/12/05/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE26%20%E5%B0%BD%E5%8F%AF%E8%83%BD%E5%BB%B6%E5%90%8E%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%BC%8F%E7%9A%84%E5%87%BA%E7%8E%B0%E6%97%B6%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款26-尽可能延后变量定义式的出现时间"><a href="#条款26-尽可能延后变量定义式的出现时间" class="headerlink" title="条款26 : 尽可能延后变量定义式的出现时间"></a>条款26 : 尽可能延后变量定义式的出现时间</h2><p>只要你定义了一个变量, 并且其类型带有构造函数或析构函数, 那么当程序控制流到达变量定义式时, 你便得承担构造成本; 当变量离开作用域时, 你便得承担析构成本. 本条款希望我们避免<strong>定义变量但最终并未使用</strong>的情况, 不要白白浪费构造和析构的成本.</p><p>先来看看什么情况下会出现定义变量但最终并未使用 : </p><p>这是一个密码加密的函数, 由于密码本身不能修改, 所以要定义并返回一个<code>encryted</code>来表示<strong>加密后的密码</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  string encrypted;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  ...                        <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看到, 当密码的长度小于最小值时, 我们的函数无法提供对应的服务, 所以要抛出一个<code>logic_error</code>异常, 然后就离开该函数了, 也就是说先前构造的<code>encrypted</code>确实没有发挥任何作用.</p><p>没错, <code>encrypted</code>并非完全未被使用, 但是仍然会有未被使用的情况存在, 为了不无端付出构造和析构的成本, 我们应将其<strong>定义式往后移</strong>, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">if</span> (password.<span class="hljs-built_in">length</span>() &lt; MinimumPasswordLength) &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;Password is too short&quot;</span>);<br>  &#125;<br>  string encrypted;<br>  ...                     <br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们假设还有一个<code>encrypt</code>函数, 里面通过复杂的算法将<code>password</code>加密, 那么我们应当把<code>password</code>赋值给<code>encrypted</code>, 再把<code>encrypted</code>传进去, 进而使函数修改<code>encrypted</code>实现加密 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...<br>  string encrypted;         <br>  encrypted = password;  <span class="hljs-comment">// 赋值             </span><br><br>  <span class="hljs-built_in">encrypt</span>(encrypted);<span class="hljs-comment">// 传入</span><br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就又有可以提升效率的地方了, 这里的行为是<code>defalut</code>构造 + 赋值, 但是我们在条款4就讨论过 : “<strong>通过default构造函数构造出一个对象然后对它赋值比直接在构造是指定初值效率差</strong>“, 就和<code>vector</code>中<code>emplace_back</code>比<code>push_back</code>效率高一个道理, 于是我们可以有以下的改良操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">string <span class="hljs-title">encryptPassword</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; password)</span></span><br><span class="hljs-function"></span>&#123;<br>  ...                                   <br>  <span class="hljs-function">string <span class="hljs-title">encrypted</span><span class="hljs-params">(password)</span></span>;     <br>  <span class="hljs-built_in">encrypt</span>(encrypted);<br>  <span class="hljs-keyword">return</span> encrypted;<br>&#125;<br></code></pre></td></tr></table></figure><p>由此我们再回顾本条款的内容 : <strong>尽可能延后变量定义式的出现时间</strong>.</p><p>我们可以理解到”尽可能延后”的真正意义, 在于<strong>我们不应当只延后变量的定义, 直到非得使用该变量的前一刻为止, 甚至应该尝试延后这份定义直到能够给它初值实参为止</strong>. 这样不只能<strong>避免构造非必要对象</strong>, 还能<strong>避免无意义的defalut构造行为</strong>. 更深一层说, 以”具明显意义值初值”将变量初始化, 还可以附带说明变量的目的, <strong>提高代码的可读性</strong>.</p><hr><p>还有一个小问题, 循环怎么办? 我们在循环外定义只需要定义一次, 在循环内需要定义n次, 延后不是代价更大吗?</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget w;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;         <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>  w = 取决于某个i的值;       <span class="hljs-function">Widget <span class="hljs-title">w</span><span class="hljs-params">(取决于某个i的值)</span></span>;<br>  ...                                  ...<br>&#125;                                    &#125;<br></code></pre></td></tr></table></figure><p>我们分析两种写法的成本 : </p><ul><li>循环外 : 1构造 + 1析构 + n赋值</li><li>循环内 : n构造 + n析构</li></ul><p>确实就实际而言, 循环外的做法大体比较高效, 但这建立在: </p><ol><li>你知道赋值比”构造 + 析构”的成本低的情况下.</li><li>你的这部分代码对效率高度敏感.</li></ol><p>否则你应该使用循环内的做法.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽可能延后变量定义式的出现. 这样有助于<strong>避免浪费, 提升效率, 提高代码可读性</strong>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款25 考虑写出一个不抛异常的swap函数</title>
    <link href="/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/04/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE25%20%E8%80%83%E8%99%91%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E6%8A%9B%E5%BC%82%E5%B8%B8%E7%9A%84swap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款25-考虑写出一个不抛异常的swap函数"><a href="#条款25-考虑写出一个不抛异常的swap函数" class="headerlink" title="条款25 : 考虑写出一个不抛异常的swap函数"></a>条款25 : 考虑写出一个不抛异常的swap函数</h2><blockquote><p>swap 是一个有趣的函数, 原本它只是STL的一部分, 而后成为了异常安全性编程中的脊柱, 有关异常安全性我在条款11中介绍过, 在之后的条款29中也将着重着墨. 由于swap相当有用, 适当的实现非常重要, 好的swap设计可以带来非凡的效率提升.</p></blockquote><p>swap顾名思义, 意为将两对象的值彼此赋予对方, 在现代标准库中的实现是这样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> std &#123;<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>        T temp = std::<span class="hljs-built_in">move</span>(a);  <span class="hljs-comment">// 使用移动拷贝会大大提高效率且不抛出异常</span><br>        a = std::<span class="hljs-built_in">move</span>(b);<br>        b = std::<span class="hljs-built_in">move</span>(temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以看出这只是简单的移动拷贝而已, 而我们经常会使用一个手法叫做<code>pimpl idiom</code>, 其”<strong>以指针指向一个对象, 内涵真正的数据</strong>“, 这种手法意在将数据管理和操作管理解耦, 可以进行更有效的设计, 而这种类调用标准库的<code>std::swap</code>往往是效率低下的, 书中给出的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WidgetImpl</span> &#123;                          <span class="hljs-comment">// 保存Widget的数据</span><br><span class="hljs-keyword">public</span>:                                    <br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> a, b, c;                            <br>  std::vector&lt;<span class="hljs-type">double</span>&gt; v;                  <br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;                              <span class="hljs-comment">// 日常使用的Widget</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; rhs);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  WidgetImpl *pImpl;                         <span class="hljs-comment">// 一个指针指向数据</span><br>&#125;;           <br></code></pre></td></tr></table></figure><p>如果我们调用标准库中的<code>std::swap</code>, 其消耗是<strong>三次移动拷贝并且还有可能多余地拷贝双方的底层资源</strong>, 有可能产生更大的花销, 所以我们希望自定义的<code>swap</code>可以只交换<code>pImpl</code>的指针即可.</p><p>现在我们现在需要重新拟定一下我们的目标, 其一<strong>确保我们的swap函数不抛异常</strong>, 这是为了其在异常安全性上的功能得以实现; 其二<strong>让其他人调用swap时都能取得我们提供的高效的版本</strong>.</p><hr><p>前者只需我们记得不做有异常风险的举动就行了, 但是在<code>C++11</code>已经推行的当下, 我们还应<strong>必须</strong>给我们的函数贴心地加上<code>noexpect</code>标识符, 用来对编译器保证该函数绝不会抛出异常, <strong>编译器也会回应你的保证, 删去针对该函数的异常处理, 使效率提高</strong>. </p><hr><p>现在开始分析后者, 这里我们要知道一个前提, 大多数用户调用<code>swap</code>其实都是以标准库中的形式来调用的, 也就是说不会通过对象调用<code>swap</code>成员函数, 而是都是<code>swap(lhs, rhs)</code>这样的形式, 现在先研究在<code>C++98</code>版本下如何解决 :</p><p>书中给出的步骤如下:</p><ol><li>像我们先前一样写一个完美的不抛异常的<code>swap</code>成员函数.</li><li>在该<code>class</code>的命名空间下写一个<code>non-member swap</code>函数, 并使它调用该<code>class</code>的成员函数.</li><li>最后如果你的<code>class</code>不是<code>class template</code>(模板类), 为你的<code>class</code>全特化<code>std::swap</code>.</li></ol><p>我们来解释为什么要写三个函数, 即<strong>member + non-member + std全特化</strong> :</p><p>简单来说就是使在客户调用<code>swap(a, b)</code>时, 如果这个函数在<code>WidgetStuff</code>命名空间中, 就会直接匹配<code>non-member</code>版本, 进而调用相同命名空间下的<code>member</code>版本, 不会因为参数不匹配而没有调用到<code>member</code>版本. 而当客户调用标准库<code>swap</code>时, 由于模板全特化, 也会自动调用<code>member</code>版本.这样就极大程度上使得调用到的版本都是我们的特化版本.</p><p>由上面上述构成的最终方案如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span>  </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 下面解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-keyword">template</span>&lt;&gt;                       <span class="hljs-comment">// 对于swap针对Widget类型的全特化</span><br>  <span class="hljs-type">void</span> <span class="hljs-built_in">swap</span>&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)<br>  &#123;<br>    a.<span class="hljs-built_in">swap</span>(b);                 <br>  &#125;                                <br>&#125;<br></code></pre></td></tr></table></figure><p>这里要解释一下为什么<code>member</code>版本中要加<code>using std::swap;</code>而不是直接用<code>std::swap(pImpl, other.pImpl)</code>, 因为不必写死只用标准库, <code>pImpl</code>也有可能是有自定义<code>swap</code>函数的类对象, 这样子可以<strong>让编译器优先选择类的自定义swap</strong>, 并且通过<code>using std::swap;</code>暴露了标准库接口, <strong>在没有自定义的情况下最后也会选择标准库版本</strong>.</p><hr><p>以上是<code>C++98</code>版本的解决方法, 但在<code>C++11</code>已经引入的当下, 推出了一个新的机制<strong>参数依赖查找 (ADL, Argument-Dependent Lookup)</strong>, 这个机制简单来说就是在<code>C++98</code>时的函数查找机制都<strong>只是在当前作用域或using声明中查找</strong>,  <strong>而ADL可以通过参数的类型将该类型所在的命名空间纳入查找范围</strong>. 这对我们上述的解决办法有何助益? 答案是我们不需要执行第三步了, 也就是说可以放弃对<code>std::swap</code>的全特化了.</p><p>在C++98的情况下, 如果当前作用域中没有<code>non-member</code>版本, 就一定会回到使用标准库的情况, 所以对<code>std::swap</code>进行全特化是有必要的. 而<code>ADL</code>可以通过参数类型引入作用域, 只要<code>non-member</code>版本和<code>member</code>版本在同一命名空间下, 就一定可以调用成功, 就是说<strong>只要你认真实现了前两步, 就一定不会在发生调用标准库<code>swap</code>的情况</strong>, 我们对标准库swap的需求就已经降低到了只需要默认版本的程度, 不需要任何的特化, 所谓的特化已经成为”98往事”了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WidgetStuff &#123;  <span class="hljs-comment">// Widget所在的命名空间</span><br>  ...                                   <br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;      <br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123; <br>  <span class="hljs-keyword">public</span>:<br>    ...<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; other)</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <br>            <span class="hljs-keyword">using</span> std::swap;   <span class="hljs-comment">// 上面已经解释原因</span><br>        <span class="hljs-built_in">swap</span>(pImpl, other.pImpl); <br>    &#125;<br>    ...<br>  &#125;;  <br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;    </span><br><span class="hljs-function">  <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)</span> <span class="hljs-keyword">noexcept</span>   <span class="hljs-comment">// non-member                                      </span></span><br><span class="hljs-function">  </span>&#123;<br>    a.<span class="hljs-built_in">swap</span>(b);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意为了符合<code>C+11</code>版本, 我们新加了<code>noexcept</code>关键字, 添加的原因上文已经说明.</p><hr><p>这次我基于<code>C++11</code>的新增机制对书中条款的解读做出了比较大的变化, 让其更适应2024年的现在, 写了很多原本书中没有的内容, 可能会有自己考虑不周的地方, 欢迎评论指正!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>当std::swap对你的类型效率不高时, 提供swap的member版本和non-member版本, 确定这两个函数不抛出异常, 并且标明noexpect</strong>.</li><li>如果你的版本还在<code>C++98</code>, 可能还要考虑多提供对<code>std::swap</code>的全特化.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款24 类型转换与non-member函数</title>
    <link href="/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/"/>
    <url>/2024/12/03/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE24-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8Enon-member%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款24-若所有参数皆需类型转换-请为此采用non-member函数"><a href="#条款24-若所有参数皆需类型转换-请为此采用non-member函数" class="headerlink" title="条款24: 若所有参数皆需类型转换, 请为此采用non-member函数"></a>条款24: 若所有参数皆需类型转换, 请为此采用non-member函数</h2><blockquote><p>虽然令classes支持隐式类型转换是一个坏主意, 但常常有许多意外出现, 有些类型之间的关联实在太强, 我们经常想把它们放在一起用,       例如支持int类型隐式转换为Rational(有理数), 当对便利性的需求非常强烈之后, 也许支持隐式类型转换也未必是坏事.</p></blockquote><p>书中给出了一个<code>Rational</code>类, 它可以由<code>int</code>类型隐式转化而来 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,        <span class="hljs-comment">// 这里没有加explicit</span><br>           <span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);     <span class="hljs-comment">// 传入int类型可隐式转换为分母是1的Rational类型</span><br><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numerator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;             <span class="hljs-comment">// 获取分子</span><br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">denominator</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 获取分母  // 见条款22</span><br><br><span class="hljs-keyword">private</span>:<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们一定希望<code>Rational</code>类型可以和int类型相乘, 所以我们来写一个成员函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; rhs) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                       <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br>    ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了以上的函数, 我们看看能通过哪些代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Rational <span class="hljs-title">oneEighth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>)</span></span>;<br><span class="hljs-function">Rational <span class="hljs-title">oneHalf</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>Rational result = oneHalf * oneEighth;            <span class="hljs-comment">// fine</span><br>result = result * oneEighth;                      <span class="hljs-comment">// fine</span><br><br>result = oneHalf * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneHalf;                             <span class="hljs-comment">// error!</span><br></code></pre></td></tr></table></figure><p>我们发现最后一个例子无法通过编译, 原因很容易理解, 让我们重写一下上述两个式子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">result = oneHalf.<span class="hljs-keyword">operator</span>*(<span class="hljs-number">2</span>);                    <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2.</span><span class="hljs-keyword">operator</span>*(oneHalf);                    <span class="hljs-comment">// 2还没隐式转换, 怎么可能使用operator*</span><br></code></pre></td></tr></table></figure><p>因此我们有了这样的推论 : <strong>只有当参数被列于参数列内, 这个参数才是隐式转换的合格参与者</strong>.</p><p>至于”被调用之成员函数所隶属的哪个对象”, 即<strong>this对象</strong>, 绝不是隐式转换的合格参与者.</p><p>为了支持这样的混合算术运算, 可行之道拨云见日 : </p><p><strong>让operator*成为一个non-member成员函数</strong>, 即可让编译器在每一个实参上执行隐式类型转换. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br>  ... <br>&#125;;<br><br><span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,     <span class="hljs-comment">// non-member</span><br>                         <span class="hljs-type">const</span> Rational&amp; rhs) <br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.<span class="hljs-built_in">numerator</span>() * rhs.<span class="hljs-built_in">numerator</span>(),<br>                  lhs.<span class="hljs-built_in">denominator</span>() * rhs.<span class="hljs-built_in">denominator</span>());<br>&#125;<br><span class="hljs-comment">//-----------------------//</span><br><span class="hljs-function">Rational <span class="hljs-title">oneFourth</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)</span></span>;<br>Rational result;<br>result = oneFourth * <span class="hljs-number">2</span>;                           <span class="hljs-comment">// fine</span><br>result = <span class="hljs-number">2</span> * oneFourth;                           <span class="hljs-comment">// fine</span><br></code></pre></td></tr></table></figure><p>问题解决, 皆大欢喜. 有了以上的经验, 我们在看别人代码时, 就不会奇怪于为什么总是要把双目运算符的重载都放在类外作为<code>non-member</code>定义了, 说明他们也深谙上述的道理, 也许有时并没有隐式转换的需求大家还是这样写, 可能是因为习惯了.</p><hr><p>有人可能认为<code>operator*</code>可以作为友元与<code>Rational</code>类加强联系, 但完全没必要, 除非它要调用<code>Rational</code>的<code>private</code>数据, 不然这样只会降低其封装性(见条款23), 我们<strong>不应当只因函数不该成为member, 就自动让它成为friend</strong>.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>如果你需要为某个函数的所有参数进行类型转换, 那么这个函数必须是个<code>non-member</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>瓦尔登湖读书摘录(1)</title>
    <link href="/2024/12/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/"/>
    <url>/2024/12/02/%E7%93%A6%E5%B0%94%E7%99%BB%E6%B9%96%E8%AF%BB%E4%B9%A6%E6%91%98%E5%BD%95(1)/</url>
    
    <content type="html"><![CDATA[<ul><li><p>人只有想起自己的无知才能有长进, 但他如此忙碌于运用自己已有的知识, 又如何能想得起来呢?</p></li><li><p>受制于对自己的看法, 受制于他通过自己行动所赢得的名誉.</p></li><li><p>大家好像都选择了相同的生活模式, 好像这种模式是在他们清醒时做出的选择, 然而其实他们并不认为还有其他模式可选, 但聪敏而健康的人记得太阳每天都会升起.</p></li><li><p>所有的改变都是奇迹, 但这种奇迹时时刻刻都在发生.</p></li><li><p>在当前的境况中找到他们的勇气和灵感, 怀着恋人般的怜爱和热情, 珍惜着此时此刻的生活.</p></li><li><p>没有人会因为衣服上有补丁而显得卑贱.然而我敢说, 普遍而言, 人们追求衣服时髦或者至少干净并且没有补丁的心情, 远比追求良知完整无损的心情要迫切.</p></li><li><p>商品的价格就是你用来换它的那部分生命.</p></li><li><p>让群众热切地跟风的时尚其实都是奢靡浪费的人设定的.</p></li><li><p>最好的艺术作品应该表现人如何奋斗着将自己从这种境况中解放出来, 但我们的艺术却只致力于使某种境界变得舒适, 并让人忘记更高级的境界.</p></li><li><p>在用美丽的物品装饰房子之前, 我们必须清理墙壁, 清理我们的生活, 还必须有美丽的家务管理和美丽的生活方式做基础.</p></li><li><p>对于生活, 大学生不应抱着玩乐的态度, 也不应只是研究它, 而是自始至终真诚地去过好它.</p></li><li><p>我盼望每个人都能非常清醒地去发现和追求他自己的生活方式.</p></li><li><p>做好事, 做人们常说的好事, 绝不应成为我人生的主要目标, 而且基本上绝不应刻意为之.与其去做好事, 不如做个好人.</p></li><li><p>人世间最难闻的莫过于变了味的好事.</p></li><li><p>做好事几乎是人人都称赞的美德, 人们不仅称赞他, 还给予他过高的评价; 而高估他的, 正是我们的自私心.</p></li><li><p>我们应该散发出去的, 不是绝望, 而是勇气, 不是病态, 而是健全.</p></li><li><p>所有的健康和成功都对我有益处, 哪怕他可能显得遥不可及; 所有的疾病和失败只会让我感到悲伤和对我有坏处, 哪怕他能引起我的怜悯, 或者让我得到许多同情.</p></li><li><p>我们不要去做管理穷人的官员, 而是要努力成为对这个世界有贡献的人.</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>阅读</tag>
      
      <tag>瓦尔登湖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款22-23 封装性相关</title>
    <link href="/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/"/>
    <url>/2024/12/02/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE22-23%20%E5%B0%81%E8%A3%85%E6%80%A7%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款22-将成员变量声明为private"><a href="#条款22-将成员变量声明为private" class="headerlink" title="条款22 : 将成员变量声明为private"></a>条款22 : 将成员变量声明为private</h2><p>本条款中, 作者明确声明, 如果没有必要的原因, 务必将成员变量声明为<code>private</code>, 而非<code>public/protected</code>, 并苦口婆心地列举出了非常多使用<code>private</code>的优势, 让我们逐一阅览 : </p><ul><li><h4 id="保证了语法一致性"><a href="#保证了语法一致性" class="headerlink" title="保证了语法一致性"></a>保证了语法一致性</h4><p>当客户通过对象调用时, 如果将成员变量声明为<code>private</code>, 那么就省去了客户思考要不要加小括号的问题, 只要无脑加括号就行了.</p></li><li><h4 id="对成员变量的处理更加精确"><a href="#对成员变量的处理更加精确" class="headerlink" title="对成员变量的处理更加精确"></a>对成员变量的处理更加精确</h4><p>当你把成员变量声明为<code>public</code>时, 客户拥有对该变量的所有特权, 可读可写, 然而我们一定不希望这样, 如果我们把成员变量声明为<code>private</code>, 通过<code>public</code>函数, 我们希望客户读时就返回一个<code>const reference</code>, 希望写就让客户传入修改值, 在函数内部修改, 如果不希望读写就不暴露在外置接口中.</p></li><li><h4 id="保证了封装性"><a href="#保证了封装性" class="headerlink" title="保证了封装性"></a>保证了封装性</h4><p>书中提出 : <strong>Public意味不封装, 不封装意味不可改变</strong>, 因为成员变量很大程度上是会被广泛使用的, 会出现在无数客户代码中, 如此牵一发而动全身, 就算你以后想改, 可客户就不一定想改了. <code>protected</code>也是同理, <strong>protected成员变量就像public成员变量一样缺乏封装性</strong>, 虽然成员变量并不开放给客户, 但是如果你之下有无数的派生类, 带来的修改难度也是非同一般, 由此可以得出一个结论 : <strong>成员变量的封装性与”成员变量的内容改变所破坏的代码数量”成反比</strong>.</p><p>而当我们使用private成员变量, 我们的修改范围就仅仅只局限在类内, 非常易于事后的修改. <strong>就算外部可以通过函数访问该成员变量, 日后希望对这个变量进行替换或修改, 外部也全然不知. 也就是说, 把成员变量隐藏在函数接口背后, 可以为所有可能的实现提供弹性</strong>.</p><p>书中给出了一个速度收集器的类, 保存每次测量到的速度, 可以返回当前状态下的速度平均值, 雏型如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpeedDataCollection</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  vector&lt;<span class="hljs-type">int</span>&gt; data;<br>  ...<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addValue</span><span class="hljs-params">(<span class="hljs-type">int</span> speed)</span></span>;          <span class="hljs-comment">// 将收集到的速度存入data中</span><br>  <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">averageSoFar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 通过某些算法求得平均值并返回</span><br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们来假定一个情景, 这个类使用于一个嵌入式模板内, 一开始我们的可使用内存很少, 也不是很要求高效, 于是我们在<code>averageSoFar()</code>中的策略就是遍历<code>data</code>, 求出总和再求平均值. </p><p>当我们技术不断提高, 可使用内存变大了, 对计算效率有了需求, 我们就可以多加一个<code>private</code>成员变量<code>sum</code>额外记录<code>data</code>的总和, 然后修改<code>averageSoFar()</code>中的处理逻辑, 让其直接用<code>sum</code>求平均值, 效率可以从<code>O(N)</code>提到<code>O(1)</code>. </p><p>然而不管我们修改了什么, 外部<code>averageSoFar()</code>的使用者都不会知道.</p><p>这种<strong>把成员变量隐藏在函数接口背后</strong>的方式, 除了以上行为, <strong>还可以使得成员变量被读写时轻松同时其他对象, 验证class的约束条件以及函数的前提和事后条件, 实现在多线程环境中执行同步控制</strong>.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>切记将成员变量声明为<code>private</code>. 这有助于一致性, 访问控制, 允许约束条件获得保证, 提升类的实现弹性.</li><li><code>protected</code>并不比<code>public</code>更具封装性.</li></ul><hr><h2 id="条款23-宁以non-memeber-non-friend替换member函数"><a href="#条款23-宁以non-memeber-non-friend替换member函数" class="headerlink" title="条款23 : 宁以non-memeber non-friend替换member函数"></a>条款23 : 宁以non-memeber non-friend替换member函数</h2><p>本条款告诉我们, 如果一个成员函数没有直接访问成员变量的需求, 那么推荐将其替换为<code>non-memeber</code>且<code>non-friend</code>的函数.</p><p>想理解本条款可以先对封装性有进一步的认知 : </p><p>书中提出, 封装的本质在于<strong>隐藏内部实现和暴露有限接口</strong>, 至于我们为什么推崇封装, 是因为它<strong>使我们能改变的事务只影响有限客户</strong>, 就是说大大降低了我们后期做出改变时的维护成本. </p><p><strong>一个类的封装性和它的数据, 也就是成员变量息息相关</strong>, 愈少的代码可以看到数据, 愈多的数据就可以被封装, 封装性也就越强. </p><p>然而我们通常情况下认为数据以及操作数据的那些函数应该被捆绑在一起, 这样子是在实现所谓的封装, 然而正如我们前面所说, <strong>愈多成员函数可以访问数据, 数据的封装性就越低</strong>.</p><p>成员函数是实现封装的必要手段, 但并不代表我们可以毫无顾虑地增加成员变量, 每有一个函数可以访问到内部数据, 我们的维护成本就会提高一些, 因为你不一定会记得哪个函数有没有在什么不起眼的地方调用了我们的底层数据. 当然如果你预想的成员函数必须调用成员变量, 那完全没有问题. </p><p>书中给出了一个用于管理网络浏览器的类, 其中有一些用来清理的函数, 有的用来清理高速缓冲区, 有的用来清理历史记录, 有的用来移除<code>cookie</code>, 让我们看看书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearCache</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearHistory</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeCookies</span><span class="hljs-params">()</span></span>;<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们在大多数情况下是希望同时调用这三个函数的, 于是我们可以写一个统合函数<code>clearBrowser()</code>, 按照习惯我们可能就把它写为成员函数了, 但有了上面的认知, 我们可以直接把它写成一个<code>non-memeber non-friend</code>函数,  代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123;<br><span class="hljs-keyword">public</span>:<br>...<br>    <span class="hljs-comment">// void clearBrowser(WebBrowser&amp; wb); // 请放弃这种写法</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span><br><span class="hljs-function"></span>&#123;<br>  wb.<span class="hljs-built_in">clearCache</span>();<br>  wb.<span class="hljs-built_in">clearHistory</span>();<br>  wb.<span class="hljs-built_in">removeCookies</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们知道<code>clearBrowser</code>内部不会以任何形式直接调用数据,  所以干脆直接把<code>clearBrowser</code>排除在外, 这不只是告诉未来的自己, 也是在告诉将要维护这份代码的其他人, 这个函数从机理上就不可能触及底层数据, 是绝对安全的, 封装性因此得到提升.</p><p>当然还是要把他俩放在<strong>同一个命名空间</strong>内, 不然就真互相找不到了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>;<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><p>书中还提出 : 像是这种<code>clearBrowser</code>不触及底层数据的伪成员函数, 我们一般称其为便利函数, <strong>将所有的便利函数放在多个头文件内但隶属于同一个命名空间, 可以使编写者轻松找到并扩展某些方向的便利函数</strong>, 示例如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebBrowser</span> &#123; ... &#125;;<span class="hljs-comment">// 核心机能</span><br>     ...                                <br>&#125;<br><br><span class="hljs-comment">// header &quot;webbrowserclear.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clearBrowser</span><span class="hljs-params">(WebBrowser&amp; wb)</span></span>; <span class="hljs-comment">// 有关内存清理的便利函数</span><br>  ...                                   <br>&#125;   <br><br><span class="hljs-comment">// header &quot;webbrowserbookmarks.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关书签日志的便利函数</span><br>&#125;                                       <br><br><span class="hljs-comment">// header &quot;webbrowsercookies.h&quot;</span><br><span class="hljs-keyword">namespace</span> WebBrowserStuff &#123;<br>  ...                                   <span class="hljs-comment">// 有关cookie的便利函数</span><br>&#125;                                      <br>...<br></code></pre></td></tr></table></figure><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>宁以<code>non-memeber non-friend</code>替换<code>member</code>函数, 如果这个函数没有访问底层数据的必要的话. 这样子可以增加封装性, 包裹弹性和可扩展性.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款21 必须返回对象时, 别妄想返回其reference</title>
    <link href="/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/"/>
    <url>/2024/12/01/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE21%20%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6,%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6reference/</url>
    
    <content type="html"><![CDATA[<h2 id="条款21-必须返回对象时-别妄想返回其reference"><a href="#条款21-必须返回对象时-别妄想返回其reference" class="headerlink" title="条款21 : 必须返回对象时, 别妄想返回其reference"></a>条款21 : 必须返回对象时, 别妄想返回其reference</h2><blockquote><p>当程序员领悟了条款20所讲的pass-by-value的种种效率问题之后, 往往会变成十字军战士, 一心一意根除pass-by-value的存在, 然而这却会让他们犯下一些致命的错误, 通过本条款让我们来了解.</p></blockquote><p>阅读完本文章, 我更倾向于把本条款解释为 :</p><ul><li>必须返回<strong>新</strong>对象时, 别妄想返回其reference.</li></ul><p>这样子会更便于理解.</p><p>书中给出了一个有理数类, 用于计算一个有乘积的有理数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rational</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Rational</span>(<span class="hljs-type">int</span> numerator = <span class="hljs-number">0</span>,<span class="hljs-type">int</span> denominator = <span class="hljs-number">1</span>);<br>  ...<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> n, d;  <span class="hljs-comment">// 有理数的分子和分母</span><br><br><span class="hljs-keyword">friend</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是我们最初的设想, <code>operator*</code>是传值返回的, 这不由得引发我们顾虑, 我们确实是希望其返回一个新的代表<code>lhs</code>和<code>rhs</code>乘积的<code>Rational</code>对象, 但是传值返回的拷贝构造成本也许会很高, 因此有不同的程序员想出了三种不同返回策略, 但无一例外都是错误的, 让我们看书中逐一反驳.</p><hr><h4 id="返回一个pointer-reference指向一个-local-stack-对象"><a href="#返回一个pointer-reference指向一个-local-stack-对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个 local stack 对象"></a>返回一个pointer&#x2F;reference指向一个 local stack 对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-function">Rational <span class="hljs-title">result</span><span class="hljs-params">(lhs.n * rhs.n, lhs.d * rhs.d)</span></span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们的目的是避免调用构造函数, 这样不仅没有避免, 而且<code>result</code>还是一个<code>local</code>对象, 出了作用域就会被销毁, 返回的引用是一个悬挂引用! 我们首先应当知道的, 就是不要让函数返回一个函数内局部变量的<code>reference</code>, 也就是返回引用的生命周期一定要大.</p><hr><h4 id="返回一个reference指向一个heap-allocated对象"><a href="#返回一个reference指向一个heap-allocated对象" class="headerlink" title="返回一个reference指向一个heap-allocated对象"></a>返回一个reference指向一个heap-allocated对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,   <span class="hljs-comment">// 错误的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  Rational *result = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>  <span class="hljs-keyword">return</span> *result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其一还是会进行构造, 其二这会带来严重的内存泄露, 首先你必须记得在外部要执行delete, 其次当你进行连乘时, 例如<code>a * b * c</code> , 你永远无法获得<code>b*c</code>是new出来的指针, 也就是说必然内存泄露.</p><hr><h4 id="返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象"><a href="#返回一个pointer-reference指向一个local-static对象而有可能同时需要多个这样的对象" class="headerlink" title="返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象"></a>返回一个pointer&#x2F;reference指向一个local static对象而有可能同时需要多个这样的对象</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> Rational&amp; <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs,    <span class="hljs-comment">// 有风险的代码!</span><br>                          <span class="hljs-type">const</span> Rational&amp; rhs)    <br>&#123;<br>  <span class="hljs-type">static</span> Rational result; <br>  result = ...;            <br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个原理上看来没有问题, 但是只要使用<code>static</code>对象就一定会伴随着多线程情况下的风险, 这样就显得有弊端了, 除非你可以保证这个代码不会在多线程情况下出问题或是通过锁保证了线程安全, 就像我们条款4中提到的初始化策略一样 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>    <span class="hljs-keyword">return</span> timekeeper;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们会确保这个函数在多线程之前的单线程阶段就都调用过一次来实现初始化.</p><hr><p>看过以上的三种情况后, 最后还是直接返回对象吧!</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> <span class="hljs-type">const</span> Rational <span class="hljs-keyword">operator</span>*(<span class="hljs-type">const</span> Rational&amp; lhs, <span class="hljs-type">const</span> Rational&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d);<br>&#125;<br></code></pre></td></tr></table></figure><p>书中说即使要承担构造和析构的成本, 也还是推荐直接传值返回, 但是要知道Effective C++已经是十几年前的老书了, 现在伴随着C++11的引入, 带来了<strong>移动语义</strong>的新机制, 这种机制对传值返回带来了极大的优化, 简单来说就是不会有多余的构造和析构了, <strong>编译器会直接在原本要析构的临时对象上直接构建要传出的新对象</strong>, 也就是说传值返回的效率得到了极大的提升, 而这也与本条款的要求不谋而合, 可见Effective C++的条款还是禁得住时间历练的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><p>绝对不要返回一个<code>pointer/reference</code>指向一个<code>local stack</code>对象, 返回一个<code>reference</code>指向一个<code>heap-allocated</code>对象, 返回一个<code>pointer/reference</code>指向一个<code>local static</code>对象而有可能同时需要多个这样的对象. </p></li><li><p>请优先考虑传值返回吧, 在C++11引入移动语义后它如有神助!</p></li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款20 宁以pass-by-reference-to-const替换pass-by-value</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE20%20%E5%AE%81%E4%BB%A5pass-by-reference-to-const%E6%9B%BF%E6%8D%A2pass-by-value/</url>
    
    <content type="html"><![CDATA[<h2 id="条款20-宁以pass-by-reference-to-const替换pass-by-value"><a href="#条款20-宁以pass-by-reference-to-const替换pass-by-value" class="headerlink" title="条款20 : 宁以pass-by-reference-to-const替换pass-by-value"></a>条款20 : 宁以pass-by-reference-to-const替换pass-by-value</h2><blockquote><p>本条款将告诉我们函数传参时的最佳策略.</p></blockquote><p>我们都知道, <code>pass-by-value</code>(传值传参)是一个费时费力的过程, 它会直接复制一个原件的拷贝, 如果是自定义类就会调用一次拷贝构造来实现复制, 函数结束时还要额外调用一次析构函数, 我们会很有意愿去削减这方面的花销.</p><p>相信我们在别处的很多函数中都看见过<code>pass-by-reference-to-const</code>的存在, 在本书中也极力推荐这种写法, 足矣见得这种写法的高效与广泛, 就像下面这行函数定义 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStudent</span><span class="hljs-params">(<span class="hljs-type">const</span> Student&amp; s)</span></span>;<br></code></pre></td></tr></table></figure><p>reference的底层一般是个指针, 也就是说我们只是用了一个传递指针的花销就实现了参数的传递, 再加上const, 这对我们传入引用的安全性给予了保证,  使得这个写法<strong>兼具了效率与安全</strong>, 是不可多得的好事.</p><p>另外书中还给出了一个好处 : <strong>避免对象切割问题</strong>.</p><p>我们都知道多态中的动态类型是依靠指针和引用来触发的, 简单来说就是也许某个指针或引用的静态类型是基类, 但是动态类型可以通过实际的赋值来改变, 实现动态类型的绑定, 这点可是一个普通的类对象做不到的. 当我们使用<code>pass-by-reference-to-const</code>, 其实也就符合了这种性质, 我们来看代码理解 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<span class="hljs-comment">// 普通窗口</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function">std::string <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 返回窗口名</span><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;       <span class="hljs-comment">// 窗口显示函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowWithScrollBars</span>: <span class="hljs-keyword">public</span> Window &#123;<span class="hljs-comment">// 高级窗口! 它带滚动条!</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<span class="hljs-comment">// 对窗口重写</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面是一对父子类, 下面是分别用两种传值方法的函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(Window w)</span>         <span class="hljs-comment">// pass-by-value</span></span><br><span class="hljs-function"></span>&#123;                             <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printNameAndDisplay</span><span class="hljs-params">(<span class="hljs-type">const</span> Window&amp; w)</span>   <span class="hljs-comment">// pass-by-reference-to-const</span></span><br><span class="hljs-function"></span>&#123;                                           <br>  std::cout &lt;&lt; w.<span class="hljs-built_in">name</span>();<br>  w.<span class="hljs-built_in">display</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们使用以下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">WindowWithScrollBars wwsb;<br><span class="hljs-built_in">printNameAndDisplay</span>(wwsb);<br></code></pre></td></tr></table></figure><p>如果我们调用前者, 答案是只能调用基类的<code>display()</code>, 因为<strong>对象被切割了</strong>, <code>wwsb</code>被强行从派生类被切割成了基类, 这很正常, 传一个对象可没有什么多态的机制.</p><p>如果我们调用后者, 结果很成功, 调用的就是派生类的<code>display()</code>, 因为<code>w</code>虽然静态类型是<code>Window</code>, 但由于引用的对象<code>wwsb</code>类型是<code>WindowWithScrollBars</code>, 所以动态类型绑定为了派生类, 调用就正确了. 说的有些复杂了, 可以宏观理解为<code>pass-by-reference-to-const</code>是虚函数机制实现的必要手段.</p><hr><p>吹了那么久<code>pass-by-reference-to-const</code>, 那么就没有什么情况要用<code>pass-by-value</code>的吗?</p><p>答案是有的, 先看书中给出的最终结论 : <strong>内置类型, STL迭代器, 函数对象推荐用pass-by-value</strong>.</p><p>原因很简单, <code>pass-by-reference-to-const</code>说到底也就是一个指针的花销, <strong>一些内置类型的花销甚至比指针花销还小</strong>, 而<strong>STL迭代器和函数对象内部也就是一个或几个指针</strong>而已, 差不了多少, 当然也有一部分原因是习惯所致.</p><p>有人可能认为只包含小型对象的自定义类型也可以用<code>pass-by-value</code>, 这样的想法是有漏洞的.</p><p>书中给出了三个原因 : </p><ol><li>对象小不代表<strong>构造和析构函数的花销</strong>就不小, 如果你直接<code>pass-by-value</code>一个STL的<code>set</code>, 其内部对象也就是几个指针, 是所谓的”小对象”, 但是构造和析构的开销就不知道大多少倍了.</li><li><strong>某些编译器对待内置类型和自定义类型的态度截然不同</strong>, 编译器很乐意把内置类型对象放进缓存器, 但一个自定义类对象就不会有此般关怀.</li><li><strong>一个类创建完后是需要维护的</strong>, 你现在对象小, 不代表以后就不会根据客户需求加入额外的变量, 除非你在一开始就把框架定死了.</li></ol><p>因此书中才给出了我们上面的最终结论.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>尽量以pass-by-reference-to-const替换pass-by-value, 前者高效, 安全, 并且有效解决了切割问题.</li><li>以上规则不适用于内置类型, STL迭代器, 函数对象, 它们适合pass-by-value.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款19 设计class犹如设计type</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE19%20%E8%AE%BE%E8%AE%A1class%E7%8A%B9%E5%A6%82%E8%AE%BE%E8%AE%A1type/</url>
    
    <content type="html"><![CDATA[<h2 id="条款19-设计class犹如设计type"><a href="#条款19-设计class犹如设计type" class="headerlink" title="条款19 : 设计class犹如设计type"></a>条款19 : 设计class犹如设计type</h2><blockquote><p>C++ 是面向对象编程语言, 当你定义了一个新class, 也就定义了一个新type. 然而设计一个优秀的class是一项艰巨的任务, 正如设计一个好的type是一项艰巨的任务. 本条款将依照一个好的类型应有的行为来指导我们class的设计, 并一一列举出来.</p></blockquote><p>当我们要设计一个<code>class</code>时, 让我们对自己提出这些问题吧 : </p><ul><li><p><strong>新type的对象应该如何创建和销毁?</strong></p><p>想想<code>class</code>的构造和析构是否可以默认生成 不能的话该怎样编写.</p><p>想想是否要是设计内存的分配函数和释放函数.</p></li><li><p><strong>对象的初始化和对象的赋值该有什么样的差别?</strong></p><p>想想在<code>class</code>构造时需要有什么特殊的步骤, 以及是否需要设置一个<code>init</code>函数辅助构造.</p><p>想想<code>copying</code>时的策略是怎样的. (见条款14)</p></li><li><p><strong>新type的对象如果被 pass-by-value(以值传参) , 意味着什么?</strong></p><p>记住copy构造函数用来定义一个<code>type</code>被 <code>pass-by-value</code> 应当产生的行为.</p></li><li><p><strong>什么是新type的”合法值”?</strong></p><p>想想class的成员变量在你的预期中是否有一个合法的范围, 想想该怎样约束.</p><p>想想是否要设置超出合法范围时触发的检查机制.</p></li><li><p><strong>新type需要配合某个继承图系吗?</strong></p><p>如果其继承自某些既有的<code>class</code>, 你就应当受到那些<code>class</code>设计的束缚, 好好分析那些<code>virtual</code>函数是否要重写, 哪些不用.</p><p>尤其看看析构函数是否为<code>virtual</code>. (见条款7)</p></li><li><p><strong>新type需要什么样的转换?</strong></p><p>想想你的<code>class</code>可以和其他<code>class</code>产生什么可能且合理的转换, 如果有可以考虑实施.</p><p>如果有就写一个类型转换函数或接受其他类型的构造函数, 没有请声明<code>explicit</code>.</p></li><li><p><strong>什么样的操作符和函数对此新type而言是合理的?</strong></p><p>这个属于你的设计私事, 但也必须考虑清楚.</p></li><li><p><strong>什么样的默认成员函数应该驳回?</strong></p><p>将需要驳回的成员函数设置为<code>private</code>或者直接<code>delete</code>掉. (见条款6)</p></li><li><p><strong>谁该取用新type的成员?</strong></p><p>想想哪些成员应设为<code>public</code>, 哪些应设为<code>protected</code>, 哪些应设为<code>private</code>. </p><p>想想哪些<code>classes/functions</code>应是<code>friends</code>. </p></li><li><p><strong>什么是新type的”未声明接口”?</strong></p><p>想想你的<code>class</code>不对外的底层函数可以提供什么样的服务, 是否进行资源运用, 是否需要应对多线程情况, 以此在实现中加上相应的约束条件.</p></li><li><p><strong>新type有多么一般化?</strong></p><p>想想你的<code>class</code>是否要接受泛型编程, 有没有使用泛型编程的必要.</p></li><li><p><strong>真的需要一个新type吗?</strong></p><p>想想真的要定义一个新的class吗? 在你定义<code>derived class</code>时, 如果只是单纯地想添加一些机能, 而不是出于多态考虑, 那么说不定单纯定义一个或多个 <code>non-member</code> 函数或 <code>templates</code>, 更能够达到目标. 就像是<code>STL</code>源码中的<code>priority_queue</code>, 为了使用堆机制其实并没再建立一个专属的堆类, 而是写了几个用于调整堆结构的函数, 再套在<code>vector</code>上就实现了堆的功能.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>class</code>的设计就是<code>type</code>的设计, 在设计一个<code>class</code>之前请确定思考过本条款所提出的所有问题.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款18 设计正确易用的接口</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE18%20%20%E8%AE%BE%E8%AE%A1%E6%AD%A3%E7%A1%AE%E6%98%93%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款18-让接口容易被正确使用-不易被误用"><a href="#条款18-让接口容易被正确使用-不易被误用" class="headerlink" title="条款18 : 让接口容易被正确使用, 不易被误用."></a>条款18 : 让接口容易被正确使用, 不易被误用.</h2><blockquote><p>C++在接口之海漂浮, 一个好的接口很容易被正确使用, 不容易被误用.</p></blockquote><p>条款18其实是一个很宏观的条款, 让接口变得正确易用, 简单来说就是”<strong>促进正确使用</strong>“和”<strong>阻止误用</strong>“.</p><p>我们先从<strong>阻止误用</strong>的角度考虑, 对接口来说, 是否误用无非就是参数传递的类型对不对, 参数是否合法, 是否符合设计者的设想.</p><p>书中给出了一个日期类, 分别由年月日的成员变量, 我们先来看第一个给出的构造函数 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Date</span>(<span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> year);<br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样设计在设计者看来很合理, 但是没有任何合法性检查只会带来无穷的隐患, 我们可以从中看出以下问题 : </p><ul><li>客户不一定知道是按月日年的顺序来输入, 如果是我们的日常习惯, 可能会输入年月日.</li></ul><p>如何使用户在编写过程中就知道自己写错了呢? </p><p>书中告诉我们的方法是 : <strong>导入新类型</strong>, 因为问题的根源是年月日的变量类型都是相同的<code>int</code>, 如果设定为不同的类型, 就可以确保输入的正确性了, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Day</span> &#123;            <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Month</span> &#123;                <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Year</span> &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Day</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span>     <span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span>         <span class="hljs-keyword">explicit</span> <span class="hljs-title">Year</span><span class="hljs-params">(<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">  :val(d) &#123;</span>&#125;              :<span class="hljs-built_in">val</span>(m) &#123;&#125;                    :<span class="hljs-built_in">val</span>(y)&#123;&#125;<br><br>  <span class="hljs-type">int</span> val;                <span class="hljs-type">int</span> val;                      <span class="hljs-type">int</span> val;<br>&#125;;                      &#125;;                            &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Date</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Date</span>(<span class="hljs-type">const</span> Month&amp; m, <span class="hljs-type">const</span> Day&amp; d, <span class="hljs-type">const</span> Year&amp; y);<br>...<br>&#125;;<br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1995</span>)</span></span>;                      <span class="hljs-comment">// 错误, 不是int!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Day(<span class="hljs-number">30</span>), Month(<span class="hljs-number">3</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 错误, 顺序错了!</span><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month(<span class="hljs-number">3</span>), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;    <span class="hljs-comment">// 正确, 类型和顺序相对应</span><br></code></pre></td></tr></table></figure><p>当然还有一些数值我们可以提前限制, 比如一年肯定只有12个月, 我们就可以让用户不用直接通过构造传参, 而是用函数返回需求的<code>Month</code>对象, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Month</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Jan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">1</span>); &#125; <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Feb</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">2</span>); &#125;  <br>  ...                                       <br>  <span class="hljs-function"><span class="hljs-type">static</span> Month <span class="hljs-title">Dec</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Month</span>(<span class="hljs-number">12</span>); &#125; <br>  ...                                      <br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Month</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span></span>;  <span class="hljs-comment">// 不让用户显式使用构造, 只能通过成员函数内部调用</span><br>&#125;;<br><br><span class="hljs-function">Date <span class="hljs-title">d</span><span class="hljs-params">(Month::Mar(), Day(<span class="hljs-number">30</span>), Year(<span class="hljs-number">1995</span>))</span></span>;  <span class="hljs-comment">// 这样我们就可以这样调用了</span><br></code></pre></td></tr></table></figure><p> 书中提出<strong>以函数替换对象</strong>也是一种预防客户输入错误的方式.</p><p>当然通过<strong>const限制类型操作</strong>也是一种方式, 这里就不再举例.</p><hr><p>讲完了阻止误用, 那么如何<strong>促进正确使用</strong>呢? </p><p>正确使用, 简单来说就是<strong>符合使用者的习惯</strong>, 使用者的习惯是什么呢? 当然是<strong>使用内置类型</strong>呀, 使用者当然希望可以像使用<code>int</code>一样使用其他自定义的类型.</p><p>因此书中提出: <strong>除非有好理由, 否则应该尽量令你的自定义类型的行为与内置类型一致.</strong></p><p>实际来说就是<strong>用好运算符重载, 有必要时考虑迭代器的设计模式</strong>.</p><hr><p>书中还提出了一个重要观点 : </p><ul><li><strong>任何接口如果要求用户必须记得做某些事情, 就是有者”不正确使用”的倾向.</strong></li></ul><blockquote><p>接下来的内容有关条款13和14, 没有看过的可以看我往期的博客.</p></blockquote><p>让我们回到条款13中提出的<code>createInvestment()</code>工厂函数, 他会返回一个资源的原始指针, 而我们应当用<code>shared_ptr</code>去封装该指针, 这就成了用户必须记得做的事情, 那么为了让该函数返回的内容更易用, 我们可以在直接返回一个智能指针, 函数声明如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Investment* createInvestment();</span><br><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><hr><p>函数内部实现并非本条款的重点, 但是书中也花了部分篇幅去讲解, 我也会跟着解释清楚, 先看内部的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br>    <br>  ...                                <span class="hljs-comment">// 中间部分实现工厂函数的内存分配步骤</span><br>      <br>  <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到<code>shared_ptr</code>构造的两个参数我们可能会有点懵, 我们来一个个分析 : </p><p>首先我们明确<code>stl</code>中<code>shared_ptr</code>构造的第一个参数是<strong>原始资源类型的指针</strong>, 第二个参数是<strong>删除器函数</strong>.</p><p>先讲第二个参数, 看过条款14的都知道, <code>getRidOfInvestmen</code>t应当是我们提供给<code>shared_ptr</code>在析构时使用的函数, 它存在的意义在于某些类型没有传统的析构, 而是一些特殊的释放函数, 需要我们手动调用, 我们把这些函数放在删除器中, 就可以化手动为自动, 我们这里是假定<code>Investment</code>是有这种需求的类型, 如果不是当然可以不写. 这种由设计者自己定制删除器的行为其实也是在减少客户不必要的释放步骤, 与本条款的理念相符合.</p><p>接下来是第一个参数, 我们应当传入一个原始资源类型的指针, 按道理来说应该是通过<code>new Investment()</code> 返回一个指针直接存进去, 但这里选择先不进行动态分配, 直接存入一个<code>nullptr</code>, 而且由于<code>shared_ptr</code>构造不允许隐式类型转换, 所以要把<code>nullptr</code>强转成<code>Investment*</code>类型, 也就是<code>static_cast&lt;Investment*&gt;(nullptr)</code>了, 因此<code>retVal</code>刚生成时并没有分配到资源, 是在接下来中间部分实现内存分配.</p><p>这里深入一下, 为什么工厂函数中要先构造指针再分配内存, 而不是先分配内存再给指针构造? 这里有两点原因 : </p><ol><li><p>可能需要<strong>通过不同的条件以不同的方式分配内存</strong>, 这是也是工厂函数存在的意义所在.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">createInvestment</span><span class="hljs-params">(<span class="hljs-type">bool</span> isPremium)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">retVal</span><span class="hljs-params">(<span class="hljs-keyword">static_cast</span>&lt;Investment*&gt;(<span class="hljs-literal">nullptr</span>), getRidOfInvestment)</span></span>;<br><br>    <span class="hljs-comment">// 根据条件选择不同的分配方式</span><br>    <span class="hljs-keyword">if</span> (isPremium) &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;PremiumInvestment&gt;();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        retVal = std::<span class="hljs-built_in">make_shared</span>&lt;RegularInvestment&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> retVal;<br>&#125;<br></code></pre></td></tr></table></figure><p>分析以上代码, 我们可以知道<code>Investment*</code>的静态类型是一个基类指针, 但是通过<code>isPremium</code>和多态机制, 我们可以根据传入的<code>isPremium</code>来选择其动态类型是派生类的<code>PremiumInvestment</code>还是<code>RegularInvestment</code>进而产生不同的内存分配策略, 而这起码要我们先有一个指针对象才行.</p></li><li><p><strong>分配内存是有可能出现异常的</strong>, 如果出现异常先前分配的内存就泄露了, 但如果提前构造指针, 再用<code>make_shared</code>函数获取内存, 就算发生异常也一定是安全的, 因为<strong>指针会调用析构把先前的内存释放</strong>.</p></li></ol><p>也许略微有些跑题, 但是我觉得能看透问题的本质才是最重要的, 因此多下了一些功夫.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><strong>阻止误用的方法包括 : 导入新类型, 以函数替换对象, 利用const限制, 消除客户的资源管理责任, 不要让客户必须记得某些事情.</strong></li><li><strong>促进正确使用的方法包括 : 保证接口的一致性, 与内置类型行为兼容.</strong></li><li>可以通过设定定制的删除器减少客户手动调用释放函数的负担.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款16-17 new 和 delete</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE16-17%20new%20%E5%92%8C%20delete/</url>
    
    <content type="html"><![CDATA[<h2 id="条款16-成对使用new和delete时要采用相同形式"><a href="#条款16-成对使用new和delete时要采用相同形式" class="headerlink" title="条款16 : 成对使用new和delete时要采用相同形式"></a>条款16 : 成对使用new和delete时要采用相同形式</h2><p>直接看代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string *stringPtr1 = <span class="hljs-keyword">new</span> std::string;<br>std::string *stringPtr2 = <span class="hljs-keyword">new</span> std::string[<span class="hljs-number">100</span>];<br>...<br><span class="hljs-keyword">delete</span> stringPtr1;                     <br><span class="hljs-keyword">delete</span> [] stringPtr2;<br></code></pre></td></tr></table></figure><p>这个其实没什么好说的, 其实就是相对应就行.</p><hr><h2 id="条款17-以独立语句将newed对象置入智能指针"><a href="#条款17-以独立语句将newed对象置入智能指针" class="headerlink" title="条款17 : 以独立语句将newed对象置入智能指针"></a>条款17 : 以独立语句将newed对象置入智能指针</h2><p>在条款15我们知道C风格API喜欢直接调用原始资源, 那么我们来看一个不用直接调用原始资源的API : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processWidget</span><span class="hljs-params">(std::tr1::shared_ptr&lt;Widget&gt; pw, <span class="hljs-type">int</span> priority)</span></span>;<br></code></pre></td></tr></table></figure><p>这个函数用来在某动态分配的Widget上进行某些带有优先权的操作, 所以需要传入一个智能指针和一个优先度, 那么现在<strong>假定去求优先度其实是一个很复杂的过程</strong>, 我们需要额外封装一个函数来返回求得的优先度 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">priority</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>那么我们设想的调用<code>processWidget</code>的方法可能是这样的 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(<span class="hljs-keyword">new</span> Widget, <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>这里的<code>priority()</code>函数嵌套是没有问题的, 我们日常中也推荐多用这种手法, 但是前面的new就有问题了, 因为<code>shared_ptr</code>不支持隐式转换, 也就是无法通过<code>new</code>出一个<code>Widget*</code>再转换成<code>shared_ptr&lt;Widget&gt;</code>, 那么下面的修改是否合理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">processWidget</span>(std::tr1::<span class="hljs-built_in">shared_ptr</span>&lt;Widget&gt;(<span class="hljs-keyword">new</span> Widget), <span class="hljs-built_in">priority</span>());<br></code></pre></td></tr></table></figure><p>一眼看上去非常合理, 但是还是有一些隐患在其中, 我们知道<code>priority()</code>是一个很复杂的过程, 既然复杂就有可能会抛出异常, 抛出异常本身并不可怕, 我们可以设置对应的处理逻辑, 但是在这样的调用发生异常就有额外的问题了.</p><p>问题核心在于<strong>C++在函数参数的调用上弹性很大, 并不确定实际的调用步骤</strong> , 真正的调用步骤由编译器选择效率最高的步骤.</p><p>我们先来看看按顺序会发生什么 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>shared_ptr</code>构造函数</li><li>调用<code>priority()</code></li></ul><p>虽然我们确定执行 <code>&quot;new Widget&quot;</code> 表达式一定在调用<code>shared_ptr</code>构造函数之前, 但是我们确实不确定<code>priority()</code>的调用时机 : </p><ul><li>执行 <code>&quot;new Widget&quot;</code> 表达式</li><li>调用<code>priority()</code></li><li>调用<code>shared_ptr</code>构造函数</li></ul><p>如果是这样的话, 在priority()调用过程中发生了异常, 就算之后异常得到了处理,<code> &quot;new Widget&quot;</code>得到的资源也很大可能是被泄露了.</p><p>这一切的问题来源于<strong>在”资源被创建”和”资源被转换为资源管理对象”两个时间点之间有可能发生异常干扰</strong>.</p><p>解决方法很简单, 那就是标题 : <strong>坚持以独立语句将newed对象置入智能指针</strong>, 这样就可以杜绝一切异常干扰了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;Widget&gt; <span class="hljs-title">pw</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Widget)</span></span>;  <br><span class="hljs-built_in">processWidget</span>(pw, <span class="hljs-built_in">priority</span>()); <br></code></pre></td></tr></table></figure><p>于是以上操作就没有任何问题了!</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>成对使用<code>new</code>和<code>delete</code>时要采用相同形式.</li><li>以独立语句将<code>newed</code>对象置入智能指针.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款15 在资源管理类中提供对原始资源的访问</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE15%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E5%AF%B9%E5%8E%9F%E5%A7%8B%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="条款15-在资源管理类中提供对原始资源的访问"><a href="#条款15-在资源管理类中提供对原始资源的访问" class="headerlink" title="条款15 : 在资源管理类中提供对原始资源的访问"></a>条款15 : 在资源管理类中提供对原始资源的访问</h2><blockquote><p>我们将资源存入资源管理类, 为的是可以免去资源管理的麻烦, 但同时我们也希望<strong>可以正常合理地通过资源管理类来使用资源, 就像直接使用资源一样</strong>, 为此我们一定需要在资源管理类中提供对原始资源的访问;</p></blockquote><p>我们先来解答一些疑问 : </p><ul><li><h4 id="为什么要对原始资源进行访问-为什么要获取原始资源的指针"><a href="#为什么要对原始资源进行访问-为什么要获取原始资源的指针" class="headerlink" title="为什么要对原始资源进行访问(为什么要获取原始资源的指针)?"></a>为什么要对原始资源进行访问(为什么要获取原始资源的指针)?</h4><p>有时候需要我们传递原始资源的指针, 因为很多<code>C API</code>都是要求传递原始指针才能运作.</p></li><li><h4 id="如何进行资源访问呢"><a href="#如何进行资源访问呢" class="headerlink" title="如何进行资源访问呢?"></a>如何进行资源访问呢?</h4><p><strong>显式转换</strong> 或 <strong>隐式转换</strong> .</p></li></ul><hr><p><strong>显示转换</strong> : 资源管理类直接提供一个返回原始资源的<code>get()</code>函数, <code>C++</code>提供的智能指针也提供相应的功能.</p><p>书中举了一个有关字体资源管理的例子, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>假设有一个<code>C API</code>可以通过接受字体资源和字体大小来改变字体 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这是函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">changeFont</span><span class="hljs-params">(FontHandle f, <span class="hljs-type">int</span> newSize)</span></span>;     <span class="hljs-comment">// C风格的API函数</span><br><span class="hljs-comment">// 以下是用户具体使用例子</span><br><span class="hljs-function">Font <span class="hljs-title">f</span><span class="hljs-params">(getFont())</span></span>;<br><span class="hljs-type">int</span> newFontSize;<br>...<br><span class="hljs-built_in">changeFont</span>(f.<span class="hljs-built_in">get</span>(), newFontSize);<span class="hljs-comment">// 使用f.get()</span><br></code></pre></td></tr></table></figure><hr><p><strong>隐式转换</strong> : <strong>提供operator-&gt;和operator*的重载</strong> 或 <strong>直接提供隐式转换函数</strong></p><p>前者支持将资源管理类指针隐式转换为底部原始指针, 以此可以直接调用资源函数或取出资源成员变量 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function">FontHandle <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125; <span class="hljs-comment">// 直接显示调用该函数即可获得该资源</span><br>    <br>    <span class="hljs-comment">// 重载 operator-&gt;，返回原始的 FontHandle 指针</span><br>    FontHandle* <span class="hljs-keyword">operator</span>-&gt;() &#123;<br>        <span class="hljs-keyword">return</span> &amp;f;  <span class="hljs-comment">// 返回 FontHandle 的指针，允许访问 FontHandle 的成员</span><br>    &#125;<br><br>    <span class="hljs-comment">// 重载 operator*，返回对 FontHandle 的引用</span><br>    FontHandle&amp; <span class="hljs-keyword">operator</span>*() &#123;<br>        <span class="hljs-keyword">return</span> f;  <span class="hljs-comment">// 返回 FontHandle 的引用，允许访问 FontHandle 的成员</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样我们就可以完全将资源管理类当做一个指针看待, <strong>通过*取出原始资源, 通过-&gt;调用原始资源的成员</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(*f, newFontSize);  <span class="hljs-comment">// 假装f是一个指针, 通过解引用调出资源</span><br></code></pre></td></tr></table></figure><hr><p>后者在使用资源管理类时就会默认转换到底部原始指针 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Font</span> &#123;                           <span class="hljs-comment">// 对于FontHandle的资源管理类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Font</span><span class="hljs-params">(FontHandle fh)</span> :f(fh) &#123;</span>&#125;                                   <br>  ~<span class="hljs-built_in">Font</span>() &#123; <span class="hljs-built_in">releaseFont</span>(f); &#125;         <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">FontHandle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123; <span class="hljs-keyword">return</span> f; &#125;        <span class="hljs-comment">// 隐式转换函数</span><br><br><span class="hljs-keyword">private</span>:<br>  FontHandle f;                        <span class="hljs-comment">// 原始的字体资源指针</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这样直接写f就行了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">changeFont</span>(f, newFontSize);<br></code></pre></td></tr></table></figure><p>但是书中并不推荐这样使用, 因为这是一种<strong>完全把资源管理类作为原始资源</strong>的做法, 也就是说<strong>无法再使用有关任何资源管理类自己的操作</strong>, 当我们想进行资源管理类的拷贝赋值等操作时, 由于已经隐式转换为了资源, 这样做几乎不会有好下场, 当然你也可以保证完全不使用也不设计这类操作, 让它单独做好资源管理的本职工作, 也是完全可以使用这种方法的.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>API</code> 往往要求访问原始资源, 所以<strong>每个资源管理类都应提供一个取得其原始资源的方法</strong>.</li><li>对于原始资源的访问, 显示转换一般比较<strong>安全</strong>, 但隐式转换对客户比较<strong>方便</strong>, 自己斟酌利弊.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款14 在资源管理类中小心 copying 行为</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE14%20%E5%9C%A8%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%B1%BB%E4%B8%AD%E5%B0%8F%E5%BF%83%20copying%20%E8%A1%8C%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="条款14-在资源管理类中小心-copying-行为"><a href="#条款14-在资源管理类中小心-copying-行为" class="headerlink" title="条款14 : 在资源管理类中小心 copying 行为"></a>条款14 : 在资源管理类中小心 copying 行为</h2><blockquote><p>本条款是在我们自己建立资源管理类时要注意的行为, 但是归根结底, 我们为什么要自己建立资源管理类呢 ? 为什么不用 shared_ptr ? 这是我们在本条款中需要首先解决迭代问题.</p></blockquote><p>书中提出, C++提供的智能指针是适配于<code>heap-based</code>资源上的, 其要求不管是自动生成还是手动完成, 该资源<strong>必须要有析构函数</strong>, 然而并非所有的资源都是<code>heap-based</code>的, 简单来说就是有些资源<strong>没有对应的析构函数</strong>, 而是选择了别的方式进行资源的释放, 非常典型的就是<strong>文件句柄</strong>, 其必须要调用<code>close()</code>函数释放, 你如果直接把其交给<code>shared_ptr</code>而不做其他动作, 可以确定的是<code>shared_ptr</code>并不会智能到把<code>close()</code>加到智能函数中, 文件句柄不会被释放, 这样的资源还有很多, 而且大部分都很关键, 比如<strong>锁, 数据库连接, 网络socket</strong>等. 因此我们需要自己建立自己的资源管理类(当然也有些其他的方式).</p><hr><h3 id="怎么建立自己的资源管理类"><a href="#怎么建立自己的资源管理类" class="headerlink" title="怎么建立自己的资源管理类?"></a>怎么建立自己的资源管理类?</h3><p>简单来说还是<strong>遵循RAII原则</strong>, 构造即初始化, 析构即释放资源, 这里的释放资源具体到文件就是调用<code>close()</code>, 具体到锁就是调用<code>unlock()</code>, 我们自己应当考量, 而我们一般称其为 <strong>RAII风格的XXX</strong> .</p><p>书中给出了一段代码, 用于实现<strong>RAII风格的锁</strong> : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span></span><br><span class="hljs-function">  : mutexPtr(pm)</span><br><span class="hljs-function">  &#123;</span> <span class="hljs-built_in">lock</span>(mutexPtr); &#125;                          <span class="hljs-comment">// 获得资源</span><br><br>  ~<span class="hljs-built_in">Lock</span>() &#123; <span class="hljs-built_in">unlock</span>(mutexPtr); &#125;                <span class="hljs-comment">// 释放资源</span><br><br><span class="hljs-keyword">private</span>:<br>  Mutex *mutexPtr;<br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以实现以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Mutex m;                    <span class="hljs-comment">// 设置一个互斥器</span><br>...<br>&#123;                           <span class="hljs-comment">// 这是一块作用域, 可以是一个要求线程安全的函数内部</span><br><span class="hljs-function">Lock <span class="hljs-title">ml</span><span class="hljs-params">(&amp;m)</span></span>;            <span class="hljs-comment">// 直接用互斥器上锁</span><br>...                     <span class="hljs-comment">// 执行对锁有需求的行为</span><br>&#125;    <span class="hljs-comment">// 离开作用域自动调用析构, 析构中自动unlock</span><br></code></pre></td></tr></table></figure><hr><h3 id="言归正传-当一个RAII对象被复制-会发生什么事"><a href="#言归正传-当一个RAII对象被复制-会发生什么事" class="headerlink" title="言归正传, 当一个RAII对象被复制, 会发生什么事 ?"></a>言归正传, 当一个RAII对象被复制, 会发生什么事 ?</h3><p>以下是可能发生的复制策略 : </p><ul><li><p><strong>禁止复制</strong> : 很多时候我们并不希望资源管理类可以复制, 就像锁, 我们一定不希望多个锁对象控制同一个底层的互斥器, 这有违锁设计的初衷, 所以直接禁止就好了, 这时我们的<code>Uncopyable</code>类就有用了 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;        <span class="hljs-comment">// 直接private继承自Uncopyable</span><br><span class="hljs-keyword">public</span>:                                    <br>...                                     <span class="hljs-comment">// 同上   </span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>对底层资源祭出”引用计数法”</strong> : 这个其实就是利用<code>shared_ptr</code>实现资源共享就好了.</p><p>需要注意的就是, <code>shared_ptr</code>还有一个和共享内存无关的性质—<strong>删除器</strong>, 这是一个函数, 可以传入<code>shared_ptr</code>构造函数的第二参数, 如果没有删除器会默认调用析构, 有删除器就调用删除器, 这其实就在一定程度上解决了智能指针只能针对<code>heap-based</code>资源的问题, 让没有析构函数的资源也可以通过调用删除器实现释放, 以下是书中的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Lock</span><span class="hljs-params">(Mutex *pm)</span>       </span><br><span class="hljs-function">  : mutexPtr(pm, unlock)         // 初始化智能指针, 将unlock设置为删除器</span><br><span class="hljs-function">    lock(mutexPtr.get());</span><br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Mutex* mtx)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mtx) &#123;<br>        mtx-&gt;<span class="hljs-built_in">unlock</span>();<br>  &#125;<br>        <br>    <span class="hljs-comment">// 不需要写析构函数了, 它可以被删除器替代</span><br>&#125;<br>   <br><span class="hljs-keyword">private</span>:<br>  std::tr1::shared_ptr&lt;Mutex&gt; mutexPtr;    <span class="hljs-comment">// 使用 shared_ptr</span><br>&#125;;                     <br></code></pre></td></tr></table></figure><p>请注意如果我们写的资源管理类不希望共享资源, <code>shared_ptr</code>可以共享就带来了隐患, 像是上面的锁, 其实更推荐禁止拷贝的做法, 这种做法只是告诉我们一种其他的做法而已.</p></li><li><p><strong>复制底层资源</strong> : 这其实就是我们常说的深拷贝.</p></li><li><p><strong>转移底部资源的拥有权</strong> : 为了保证资源的独占性, 我们可以选择这种策略.</p></li></ul><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>复制<code>RAII对象</code>必须一并复制他所管理的资源, 资源的<code>copying</code>行为决定<code>RAII对象</code>的<code>copying</code>行为.</li><li>普遍的<code>copying</code>行为是禁止复制或施行引用计数法.</li><li>文件句柄和锁这类资源可以选择<strong>禁止复制, 支持移动</strong>的策略</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款13 以对象管理资源</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE13%20%E4%BB%A5%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="条款13-以对象管理资源"><a href="#条款13-以对象管理资源" class="headerlink" title="条款13 : 以对象管理资源"></a>条款13 : 以对象管理资源</h2><blockquote><p>所谓资源, 一旦用了它, 将来必须还给系统. 本条款及以后几项条款都致力于实现优秀的资源管理, 严守这些条款, 可以几乎消除资源管理问题.</p></blockquote><p>本条款主要提出<strong>以对象管理资源</strong>的思想, 以及对<code>std</code>内置的<code>auto_ptr</code>和<code>smart_prt</code>的使用策略做了分析.</p><p>书中塑模了一个投资行为, 让我们看看资源该如何处理 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Investment</span> &#123; ... &#125;;  <span class="hljs-comment">// 一个投资类</span><br><br><span class="hljs-function">Investment* <span class="hljs-title">createInvestment</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这是一个工厂函数, 返回一个动态分配的对象, 这里为了简化刻意不写参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  Investment *pInv = <span class="hljs-built_in">createInvestment</span>();         <br>  ...                                            <br>  <span class="hljs-keyword">delete</span> pInv;                                  <br>&#125;<br></code></pre></td></tr></table></figure><p>如果没有资源管理对象, 我们正常行为是请求指针使用后再<strong>手动删除</strong>.</p><p>书中提出了”以对象管理资源”的两个关键想法 : </p><ul><li><strong>获得资源后立即放进管理对象.</strong></li><li>**管理对象运用析构函数确保资源被释放, **这样便可倚赖 C++ 的”<strong>析构函数自动调用机制</strong>“确保资源被释放.</li></ul><p>这两个想法来源于一种资源管理观念 : </p><ul><li><strong>RAII (Resoure Acquisition Is Initialization)</strong> <strong>: 资源取得时机便是初始化时机 .</strong></li></ul><p>那么资源管理类该如何使用与实现呢 ? 不妨看看C++本身给我们提供的两个资源管理类(智能指针)吧. </p><hr><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::auto_ptr&lt;Investment&gt; <span class="hljs-title">pInv</span><span class="hljs-params">(createInvestment())</span></span>;  <span class="hljs-comment">// 请求对象的同时直接存入auto_ptr中 </span><br>  ...                                                 <br>&#125;         <br></code></pre></td></tr></table></figure><p>这样我们可以一如既往地使用<code>pInv</code>, 当其离开作用域时, 会经由<code>auto_ptr</code>的析构函数自动删除<code>pInv</code>.</p><p><code>auto_ptr</code>的特性 : 受<code>auto_ptr</code>管理的资源必须绝对没有一个以上的<code>auto_ptr</code>同时指向它.</p><p>也就是说<code>auto_ptr</code>保证独占指向的资源, 如果发生拷贝也会转交使用权, 这种特性使得其在需求共享内存的场面起不到作用, 于是也就有了我们接下来的<code>shared_ptr</code>.</p><hr><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::shared_ptr&lt;Investment&gt; <span class="hljs-title">pInv1</span><span class="hljs-params">(createInvestment())</span></span>;<br>  ...    <br>    std::<span class="hljs-function">tr1::shared_ptr&lt;Investment&gt;  <span class="hljs-title">pInv2</span><span class="hljs-params">(pInv1)</span></span>; <span class="hljs-comment">// 允许指向同一块内存</span><br>  pInv1 = pInv2; <span class="hljs-comment">// 允许赋值同时获得使用权</span><br>&#125;          <br></code></pre></td></tr></table></figure><p><code>share_ptr</code>是”<strong>引用计数型智能指针</strong>“, 其自己内部维护了一个计数器, 用于记录指向同一块资源的指针有多少, 当发生拷贝和赋值时都会使计数器 + 1, 当有指向其的指针离开作用域时都会使计数器 - 1, 当计数器为0时才自动触发真正的析构.</p><hr><p>请注意 : <code>auto_ptr</code>和<code>shared_ptr</code>的析构函数内部调用的都是 <code>delete</code>, 而非 <code>delete[]</code>, 虽然我们可以 <code>new []</code>, 但是这样new出来的指针就请不要存入智能指针了. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spi</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">100</span>])</span></span>; <span class="hljs-comment">// 这样是错误的!</span><br></code></pre></td></tr></table></figure><p>至于为什么没有<code>delete[]</code>版本的, 那是因为<code>vector</code>和<code>string</code>几乎总是可以取代动态分配而得的数组, 所以没必要.</p><hr><p>以上专门描述了<code>auto_ptr</code>和<code>shared_ptr</code>, 但是本条款并不专门针对它们, 而是在强调”<strong>以对象管理资源</strong>“的重要性, 有时候我们要使用的资源也许是这些<strong>预制式classes无法妥善管理</strong>的, 就需要我们有<strong>自己制作资源管理类</strong>的能力了, 至于其中要考虑的细节, 在接下来的条款14, 15中会提及.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>为防止资源泄露, 请使用<code>RAII</code>对象, 它们在构造函数中获得资源并在析构函数中释放资源. </li><li>优先使用<code>shared_ptr</code>, <code>auto_ptr</code>次之, 如果效果无法令你满意, 请自己制作资源管理类.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款10-12 拷贝与赋值</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE10-12%20%E6%8B%B7%E8%B4%9D%E4%B8%8E%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h2 id="条款10-令-operator-返回一个-reference-to-this"><a href="#条款10-令-operator-返回一个-reference-to-this" class="headerlink" title="条款10 : 令 operator&#x3D; 返回一个 reference to * this"></a>条款10 : 令 operator&#x3D; 返回一个 reference to * this</h2><blockquote><p>很多类都有重写operator&#x3D;函数的要求,  本质是 &#x3D; 左侧调用 operator&#x3D; 函数, 右侧作为参数传入, 将右侧参数赋值给左侧成员变量, 并且为了实现连锁赋值, 我们还应当使 operator&#x3D; 返回当前赋完值的对象.</p></blockquote><p>本条款的目的是<strong>实现连锁赋值</strong>, 接下来看看如何 令 operator&#x3D; 返回一个 reference to * this : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)     <span class="hljs-comment">// 返回一个引用, 符合右侧参数的类型</span><br>&#123;          <br>    <span class="hljs-comment">// 条款11, 12会告诉我们怎样实现中间的拷贝过程</span><br>    ...<br>    <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                        <span class="hljs-comment">// 返回=左侧的当前对象, 使其可以充当下一次operator=的右侧参数</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时这个协议不只适用于 &#x3D; , 也同样适用于 +&#x3D;, -&#x3D;, *&#x3D; 等运算符.</p><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>令赋值操作符重载返回一个 reference to * this</li></ul><hr><h2 id="条款11-在-operator-中处理”自我赋值”"><a href="#条款11-在-operator-中处理”自我赋值”" class="headerlink" title="条款11 : 在 operator&#x3D; 中处理”自我赋值”"></a>条款11 : 在 operator&#x3D; 中处理”自我赋值”</h2><blockquote><p>我们设置一个变量w, 令 w &#x3D; w , 这种自我赋值的做法虽然看上去很愚蠢, 但是合法, 这种程度的自由还是应该有的, 可是这在我们手动重载operator&#x3D; 时也会带来相应的麻烦, 有一些我们需要注意的点.</p></blockquote><p>正常来说, 如果我们的类中只有一些普通的本地变量, 其实不必考虑自我赋值的问题, 因为只要把正常情况下的 operator&#x3D; 函数写好(或者你也可以让编译器自动生成), 是没有什么问题的, 问题发生在<strong>需要动态管理内存</strong>时.</p><p>假如我们一个类中有一个成员变量是指针, 该指针指向一块动态分配的内存, 我们创建两个类对象 a 和 b , 其中的指针都指向不同的内存, 当使 a &#x3D; b, 从正常考量来说, b 赋值给 a 应当代表着 a 的指针将指向原先 b 所指向内存, 那么<strong>原先 a 所指向的内存就应当delete掉</strong>, 以完成最后的赋值操作. 书中举了一个指针指向bitmap的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bitmap</span> &#123; ... &#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br><span class="hljs-keyword">private</span>:<br>  Bitmap *pb; <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)              <span class="hljs-comment">// 这是一个有隐患的赋值重载</span><br>&#123;<br>  <span class="hljs-keyword">delete</span> pb;                                      <span class="hljs-comment">// delete掉原来指向的动态内存</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);                       <span class="hljs-comment">// 再new一块用来拷贝rhs副本的空间, pb重新接手这块空间 </span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                   <span class="hljs-comment">// 见条款10</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码看起来很合理, 但是带入自我赋值的情况, 你就会惊奇地发现, new Bitmap(*rhs.pb)用来拷贝的副本 rhs.pb 已经因为 delete pb 被释放了! 我们掉进了”<strong>在停止使用资源之前就意外释放了它</strong>“的陷阱! 虽然自我赋值是愚蠢的操作, 但我们程序员也不能让愚蠢的操作产生愚蠢的错误, 所以我们应当提前判断是否是自我赋值 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;   <span class="hljs-comment">// 判断是否是自我赋值, 是就直接返回</span><br>  <span class="hljs-keyword">delete</span> pb;<br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以对自我赋值的问题完全规避了! </p><hr><p>但是其实由于动态内存的存在, 还催生出了另一个问题, 就是其实new一个对象也会有产生异常的情况出现, 如果申请内存失败, pb就是折了孩子又赔兵, 原先的内存释放了, 新申请的还失败了, 这个问题就是<strong>异常安全性</strong>的问题了, 从原理上来说这和本条款重点针对的自我赋值毫无关联, 但是书中很高兴地告诉我们 : </p><ul><li><strong>让 operator&#x3D; 具备”异常安全性”往往会自动获得”自我赋值安全”的回报.</strong></li></ul><p>因此作者告诉我们可以把焦点放在实现异常安全性上, 对自我赋值问题倾向于不管理. 就是说虽然两个问题毫不相干, 但你解决一个问题却可以顺带解决另一个问题, 何乐而不为呢?</p><p>那么如何实现异常安全性呢? 异常安全性会在条款29着重讲解, 但不妨我们提前了解 : </p><p>简而言之就是 : <strong>不泄露任何资源, 不允许数据败坏, 强烈保证如果函数没有成功就回滚到函数被调用前的状态</strong>.</p><p>放在本例中, 就是<strong>如何确保new失败后pb可以依旧指向原先的内存, 而不是原先的内存被释放</strong>.</p><p>简单思考一下就可以写出如下的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs)<br>&#123;<br>  Bitmap *pOrig = pb;               <span class="hljs-comment">// 用一个备份指针记住原先的pb指向的空间先不释放</span><br>  pb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Bitmap</span>(*rhs.pb);         <span class="hljs-comment">// 令左边pb指向右边pb所指向内存的副本</span><br>  <span class="hljs-keyword">delete</span> pOrig;                     <span class="hljs-comment">// 如果new成功了再释放原先指向的空间</span><br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是异常安全性的问题就解决啦, 我们还可以发现, 确实自我复制安全的问题也被解决了, 因为pb不会被提前释放, 就算是对着自己再复制一遍也完全没有问题, 唯一的变化就是换了块内存而已.</p><p>书中还提出了一种理念相同, 但更推荐的编写方法 : <strong>copy and swap技术</strong>;</p><p>简而言之就是 : <strong>如果对某对象的操作有异常风险, 就直接先copy该对象的副本, 在该对象的副本上做出所有操作, 随后swap原件和副本</strong>.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Widget</span> &#123;<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Widget&amp; rhs)</span></span>; <br>  <span class="hljs-built_in">Widget</span>(<span class="hljs-type">const</span> Widget&amp; W);<br>  ...                       <br>&#125;;<br><br>Widget&amp; Widget::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Widget&amp; rhs) <span class="hljs-comment">// 大多数赋值重载最后用的都是这种方法</span><br>&#123;<br>  Widget <span class="hljs-built_in">temp</span>(rhs);             <span class="hljs-comment">// 使用重写的拷贝构造函数直接拷贝副本</span><br>  <span class="hljs-built_in">swap</span>(temp);                   <span class="hljs-comment">// 交换原件和副本</span><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里可能有些人似懂非懂, 前一个函数很明确要在拷贝目标内存成功后就释放原内存, 这个是怎么实现的呢?</p><p>这里的拷贝构造函数我们需要重写, 实现对 bitmap 的深拷贝, 拷贝完的对象就是 temp , 由于 temp 是一个临时对象, 离开这个函数的作用域就会析构掉, 此时我们交换原对象和目标对象, 那么最后析构掉的就是存在 temp 中的原对象, 而目标对象留在了我们的当前对象中.</p><hr><h3 id="请记住-1"><a href="#请记住-1" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>通过实现异常安全性顺便解决自我赋值的问题.</li><li>确保操作多个对象时, 其中多个对象实质上是同一个对象时, 其行为仍然正确.</li></ul><hr><h2 id="条款12-复制对象时勿忘其每一个成分"><a href="#条款12-复制对象时勿忘其每一个成分" class="headerlink" title="条款12 : 复制对象时勿忘其每一个成分"></a>条款12 : 复制对象时勿忘其每一个成分</h2><blockquote><p>copying函数 : 拷贝构造 和 赋值重载(operator&#x3D;) .</p><p>条款10&#x2F;11告诉了我们 operator&#x3D; 如何返回值 和 注意 operator&#x3D; 自我赋值, 本条款会告诉我们 copying函数 在赋值过程中应当注意些什么.</p></blockquote><p>书中提出, 如果我们决定自己实现 copying函数, 编译器会仿佛被冒犯似的, 以一种奇怪的方式回敬 : 当你的代码必然出错时也不会告诉你. </p><p>这也在警告我们, 复制对象时勿忘其每一个成分.</p><p>首先提出的观点是 : </p><ul><li><strong>如果你为class添加一个成员变量, 你必须同时修改copying函数</strong>.</li></ul><p>这点很好理解, 每个成员变量都必须和拷贝构造和赋值拷贝关联.</p><p>接下的观点就涉及继承层面了 : </p><ul><li><p><strong>只要为 derived class 撰写 copying函数, 必须很小心地复制其 base class 成分.</strong></p></li><li><p><strong>你应当让 derived class 的 copying函数 调用相应的 base class函数.</strong></p></li></ul><p>我们来看书中的代码来进一步了解这两句话 : </p><p>书中设定了一个<code>Customer顾客类</code>, 其派生类是<code>PriorityCustomer贵宾类</code>, 贵宾类中local int 变量 <code>priority</code>, 用来确定贵宾的优先度.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logCall</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; funcName)</span></span>;  <span class="hljs-comment">// 用来产生一个日志通告</span><br><br><span class="hljs-comment">// Customer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<span class="hljs-comment">// 普通客户</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  Customer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>  std::string name;<br>&#125;;<br><br>Customer::<span class="hljs-built_in">Customer</span>(<span class="hljs-type">const</span> Customer&amp; rhs)<br>: <span class="hljs-built_in">name</span>(rhs.name)                                 <br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>Customer&amp; Customer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Customer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;Customer 赋值重载被触发&quot;</span>);<br>  name = rhs.name;                             <br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;                                  <span class="hljs-comment">// 见条款10</span><br>&#125;<br><br><span class="hljs-comment">// PriorityCustomer 类</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityCustomer</span>: <span class="hljs-keyword">public</span> Customer &#123;                  <span class="hljs-comment">// 贵宾客户</span><br><span class="hljs-keyword">public</span>:<br>   ...<br>   <span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>   PriorityCustomer&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs);<br>  ...<br><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-type">int</span> priority;<br>&#125;;<br><br><span class="hljs-comment">// 重点看这个两个函数</span><br>PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br>  priority = rhs.priority;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>看似<code>PriorityCustomer</code>的构造函数好像复制了每一样东西, 但是其实它所<strong>继承的Customer部分并未进行复制</strong>, Customer部分中的name变量仍旧是未定义的, 当我们再仔细看看operator&#x3D;, 里面的问题是一样的.</p><p>接下来是改进后的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp">PriorityCustomer::<span class="hljs-built_in">PriorityCustomer</span>(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>: <span class="hljs-built_in">Customer</span>(rhs)                   <span class="hljs-comment">// 调用 base class 的 copy构造函数</span><br>  , <span class="hljs-built_in">priority</span>(rhs.priority)<br>&#123;<br>  <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 拷贝构造被触发&quot;</span>);<br>&#125;<br><br>PriorityCustomer&amp;<br>PriorityCustomer::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> PriorityCustomer&amp; rhs)<br>&#123;<br>    <span class="hljs-built_in">logCall</span>(<span class="hljs-string">&quot;PriorityCustomer 赋值重载被触发&quot;</span>);<br><br>  Customer::<span class="hljs-keyword">operator</span>=(rhs);           <span class="hljs-comment">// 对 base class 成分进行赋值动作</span><br>  priority = rhs.priority;<br><br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样代码就完美了! 再去回味前面提出的两句话, 其实就是在告诉我们<strong>显式且正确处理基类部分的拷贝和赋值</strong>的重要性.</p><p>我们要确保 : </p><ol><li>复制所有的 local 变量.</li><li>调用所有 <code>base classes</code> 内适当的 <code>copying函数</code>.</li></ol><hr><p>很多时候这两个<code>copying函数</code>往往有着近似的实现本体, 这可能会诱使我们用其中一个调用另外一个以实现代码复用的效果, 但是书中告诉我们这样做风险很大, 因为拷贝构造用来初始化新对象, 而赋值重载只能施行于已初始化的对象上, 二者的应用场景就不同, 不然也就不会分成两个默认成员函数了, 所以书中告诉我们 : </p><ul><li><p><strong>你不该令 copy assignment 操作符调用 copy构造函数 .</strong></p></li><li><p><strong>令 copy构造函数 调用 copy assignment 操作符同样无意义.</strong></p></li><li><p><strong>真正明智的做法是将相近代码封装进 init() 函数, 给二者调用.</strong></p></li></ul><hr><h3 id="请记住-2"><a href="#请记住-2" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li><code>copying函数</code>应当确保复制 “对象内的所有成员变量” 及 “所有<code>base class</code>成分”.</li><li>不要尝试<code>copying函数</code>相互调用, 应当封装一个共用函数实现代码复用.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款9 绝不在构造和析构函数过程中调用</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE9%20%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8virtual%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款09-绝不在构造和析构函数过程中调用virtual函数"><a href="#条款09-绝不在构造和析构函数过程中调用virtual函数" class="headerlink" title="条款09 : 绝不在构造和析构函数过程中调用virtual函数"></a>条款09 : 绝不在构造和析构函数过程中调用virtual函数</h2><p>开门见山阐释本条款的重点 : <strong>你不该在构造函数和析构函数中调用virtual函数</strong>.</p><p>书中给出了一个例子 : 假如我们要塑膜股市交易订单模型, 订单可以分成买入, 卖出等不同类型的订单, 当我们产生不同类型的订单, 也就是构造不同类型订单对象时, 我们也许会有记录订单日志的需求, 并我们希望订单根据不同的订单类型产生不同的订单日志.</p><p>于是我们可以抽象出以上需求的类构建过程, 一个订单基类, 派生出不同的订单派生类(如买入类, 卖出类), 基类的构造函数调用一个虚函数<code>logTransaction()</code>, 派生类重写出不同的<code>logTransaction()</code>, 就可以实现我们以上的需求.</p><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;                               <span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span>:                                           <br>  <span class="hljs-built_in">Transaction</span>()<br>  &#123;                                                 <br>  ...<br>  <span class="hljs-built_in">logTransaction</span>();                        <span class="hljs-comment">// 订单构建时依据订单动态类型构建对应日志       </span><br>&#125;     <br><br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;     <span class="hljs-comment">// 要求派生类重写</span><br>  ...<br>&#125;;                       <br>                                            <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;       <span class="hljs-comment">// 买入类</span><br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;           <span class="hljs-comment">// 提供重写版本日志</span><br>  ...<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SellTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;      <span class="hljs-comment">// 卖出类</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;          <br>  ...<br>&#125;;<br></code></pre></td></tr></table></figure><p>这段代码看似很完美, 但是真正运行起来是无法实现的!</p><p>当我们创建一个<code>BuyTransaction</code>类对象<code>b</code>时, 并不会调用<code>BuyTransaction</code>重写的<code>logTransaction()</code>, 而是会调用基类<code>Transaction</code>的<code>logTransaction()</code>, 然而我们基类的<code>logTransaction()</code>设置为纯虚函数甚至都没有写, 就更别谈运行了. </p><p>为什么? 书中告诉我们, <strong>在base class构造期间, virtual函数不是virtual函数</strong>, 更细致的说就是<strong>base class构造期间virtual函数绝不会下降到derived class阶层</strong>. 原因很直观, <strong>base class 构造函数执行期间derived class的成员变量一定还未初始化</strong>, 如果此刻就可以通过virtual下降到派生类, 我们怎么确保这个虚函数不会调用派生类的成员变量呢? 太危险了, 所以C++不会让你走这条路.</p><p>而且不止是不能在构造析构函数内调用虚函数, 当然也不能调用包含了虚函数的普通函数, 这是显而易见的, 这就又回到了我们开头说的那句话 : <strong>绝不在构造和析构函数过程中调用virtual函数</strong>, 只要还在过程中, 就不要调用.</p><hr><p>那么我们最开始的需求还有其他实现的方式吗?</p><p>书中提出一种解决办法 : 将<code>logTransaction()</code>改为普通函数, 要求派生类构造函数传递必要的日志信息给基类的构造函数, 基类的构造函数再把接收到的日志信息传入<code>logTransaction()</code>, 这样就可以了!</p><p>我们可以宏观地理解一下, 有助于我们的思维进步. 其实派生类的构造函数是一个<code>自底向上</code>的过程, 一直递归调用到最顶层的基类, 当调用到最顶层后, 我们不好奢求基类再自顶向下调用派生类的重写函数, 不如在一开始自底向上时就把必要的信息传递至基类构造函数, 这样想就非常通顺了.</p><p>代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Transaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span>  <span class="hljs-comment">// 接收下层的日志信息</span></span><br><span class="hljs-function">  </span>&#123;<br>  ...<br>  <span class="hljs-built_in">logTransaction</span>(logInfo);<br>&#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logTransaction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; logInfo)</span> <span class="hljs-type">const</span></span>;   <span class="hljs-comment">// 此时是普通函数</span><br>  ...<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyTransaction</span>: <span class="hljs-keyword">public</span> Transaction &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">BuyTransaction</span>(<span class="hljs-type">const</span> std::string&amp; parameters)<br>: <span class="hljs-built_in">Transaction</span>(<span class="hljs-built_in">createLogString</span>(parameters))             <span class="hljs-comment">// 将log信息传递给上层</span><br>  &#123; ... &#125;                                                 <br>   ...                                                  <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// 这里利用一个辅助函数创建一个值传给base class构造函数往往比较方便美观可读</span><br>  <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">createLogString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; parameterss)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>绝不在构造和析构函数过程中调用<code>virtual</code>函数.</li><li>对象在<code>derived class构造函数</code>开始执行前不会成为一个<code>derived class对象</code>.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款8 析构函数的异常管理</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE8%20%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="条款08-别让异常逃离析构函数"><a href="#条款08-别让异常逃离析构函数" class="headerlink" title="条款08 : 别让异常逃离析构函数"></a>条款08 : 别让异常逃离析构函数</h2><blockquote><p>日常编程中，常见异常通常由以下原因引发：</p><ol><li><strong>资源管理不当</strong>（如内存泄漏, 文件操作, 连接或断开连接失败）。</li><li><strong>边界和合法性检查不足</strong>（如数组越界、除以零）。</li><li><strong>并发编程问题</strong>（如死锁、数据竞争）。</li><li><strong>类型不匹配或错误的操作</strong>。</li></ol></blockquote><p>本条款主要讨论的是析构函数的异常管理, 为什么会不希望异常逃离析构函数, 因为<strong>析构函数是一个必须执行且有可能失败的函数</strong>, 因为内存泄漏, 文件操作, 连接或断开连接失败等资源管理行为的错误都是很难避免的, 而且由于<strong>析构函数是递归式调用并且可能一次性销毁大量结构</strong>, 同时产生大量异常的概率就提高了, 书中指出, <strong>如果同时存在多个异常, 程序不是结束执行就是导致不明确行为</strong>, 因此对于析构函数的异常管理在所难免.</p><hr><p>书中举出了一个数据库连接的例子 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConnection</span> &#123;  <span class="hljs-comment">// 数据库连接类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">static</span> DBConnection <span class="hljs-title">create</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">// 这个函数返回创建出来的静态数据库连接.                                     </span><br>  ...                                      <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;   <span class="hljs-comment">// 调用此函数关闭与数据库的连接, 这里有抛出异常的隐患         </span><br>&#125;;         <br></code></pre></td></tr></table></figure><p>我们经常会设计一个资源管理类来控制数据库的连接 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;                          <span class="hljs-comment">// 数据库连接管理类</span><br><span class="hljs-keyword">public</span>:<br>  ...<br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>   db.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 调用析构函数时断开数据库连接</span><br>  &#125;<br><span class="hljs-keyword">private</span>:<br>  DBConnection db;   <span class="hljs-comment">// RAII风格, 由DBConn管理DBConnection, 离开作用域自动触发DBConn的析构函数断开连接</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是我们就可以写出以下代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>    ...<br><span class="hljs-function">DBConn <span class="hljs-title">dbc</span><span class="hljs-params">(DBConnection::create())</span></span>; <span class="hljs-comment">// 直接建立DBConnection对象并交由DBConn对象dbc管理</span><br>    ... <span class="hljs-comment">// 进行数据库的CURD, 离开作用域自动断开连接</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>有了上面例子的基础, 我们来思考一下如何避免异常抛出吧.</p><p>站在<code>DBConn析构函数</code>的角度, 书中给出了两个一般的方法 : </p><ol><li><p>如果close()抛出异常就利用abort()结束程序.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>        <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>   std::<span class="hljs-built_in">abort</span>(); <span class="hljs-comment">// 直接结束程序</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>直接吞下该异常.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DBConn::~<span class="hljs-built_in">DBConn</span>()<br>&#123;<br><span class="hljs-keyword">try</span> &#123; db.<span class="hljs-built_in">close</span>(); &#125;<br><span class="hljs-built_in">catch</span> (...) &#123;<br>      <span class="hljs-comment">// 记录日志, 记录对close的调用失败</span><br>      <span class="hljs-comment">// 不做处理, 直接吞下</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>这两个方法其实都是保底方法, 一个是草率结束进程, 一个是吞掉异常防止扩散, 但其实<code>DBConn析构函数</code>也就能做这么多了.</p><hr><p>现在的问题是<strong>没有办法对”导致close抛出异常”的情况做出反应</strong>, 问题核心在<code>close()</code>函数被<code>DBConn析构函数</code>掌握, 只能其自己管理, 上一层无法干预. 那么由此我们可以将close()函数的使用权上交, 也就是让上一层用户有权决定处理<code>close()</code>报错的方式. </p><p>较佳策略是<strong>重新设计DBConn接口, 使客户有机会对可能出现的问题作出反应</strong>. </p><p>具体做法如下 : </p><ol><li><code>DBConn</code>自己也提供一个close接口, 内部封装上<code>DBConnection</code>的<code>close()</code>.</li><li><code>DBConn</code>自己对<code>DBConnection</code>的<code>close()</code>是否已经触发进行追踪管理, 如果到最后客户都没有自行close成功, 由<code>DBConn析构函数</code>自行完成close的任务.</li></ol><p>我们来看书中给出的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DBConn</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  ...<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span>                                     <span class="hljs-comment">// 提供给上层用户的close函数</span></span><br><span class="hljs-function">  </span>&#123;                                       <br>    db.<span class="hljs-built_in">close</span>();<br>    closed = <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  ~<span class="hljs-built_in">DBConn</span>()<br>  &#123;<br>      <span class="hljs-comment">// 如果到最后都没有触发close, 就会回到析构函数调用close的老路</span><br>      <span class="hljs-keyword">if</span> (!closed) &#123;<br>   <span class="hljs-keyword">try</span> &#123;                                           <br>     db.<span class="hljs-built_in">close</span>();                           <br>   &#125;<br>   <span class="hljs-built_in">catch</span> (...) &#123;                                    <br>     <span class="hljs-comment">// 记录日志, 记录对close的调用失败  </span><br>     ...                                   <span class="hljs-comment">// 直接结束 或 吞下异常</span><br>   &#125;<br>      &#125;<br>  &#125;<br><br><span class="hljs-keyword">private</span>:<br>  DBConnection db;<br>  <span class="hljs-type">bool</span> closed;<span class="hljs-comment">// 用布尔变量closed来对close()进行追踪管理</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>于是客户便可做出如下操作 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-comment">// 客户自己在认为合适的地方调用close()结束连接, 并用try-catch语句尝试捕获异常</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 这可能会抛出异常，如果关闭失败</span><br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        <span class="hljs-comment">// 客户端捕获从 close() 抛出的异常</span><br>        <span class="hljs-comment">// ... 出现异常时的操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只考虑数据库断开连接的场景, 我们可行的具体操作可以是重试关闭或执行数据库回滚, 代码如下 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UsingDB</span><span class="hljs-params">()</span> </span>&#123;<br>    DBConn dbConn;  <span class="hljs-comment">// 创建 DBConn 对象</span><br>    <br>    ...<br>    <br>    <span class="hljs-type">bool</span> success = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> attempts = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (!success &amp;&amp; attempts &lt; <span class="hljs-number">3</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        dbConn.<span class="hljs-built_in">close</span>();<br>        success = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;正在尝试断开数据库连接, 次数 :  &quot;</span> &lt;&lt; ++attempts &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    std::cerr &lt;&lt; <span class="hljs-string">&quot;已经尝试三次断开数据库连接, 但都出现异常, 断开失败&quot;</span> &lt;&lt; std::endl;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;进行补偿操作, 回滚数据库&quot;</span> &lt;&lt; std::endl;<br>        dbConn.<span class="hljs-built_in">rollback</span>(); <span class="hljs-comment">// 内部调用数据库的回滚函数</span><br>&#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再来捋一下流程, 先是客户需要考虑何时调用<code>close()</code>并写出应对异常的代码, 实际运行时如果没有异常就万事大吉, 有异常就触发客户的处理逻辑, 最后析构函数检查客户是否真的成功调用了<code>close()</code>, 如果还是没有调用, 就自己调用, 自己调用如果还出错, 就直接结束程序或吞掉异常.</p><p>至此我们将调用<code>close()</code>的责任从<code>DBConn析构函数</code>的手上移交到了使用<code>DBConn对象</code>的客户手上, 可以更好地避免异常逃离析构函数. 有人可能这样会加大客户的操作负担, 但是根据我们先前的分析, 只有客户才能有办法对”导致close抛出异常”的情况做出反应, 这样做是给客户提供一个根据实际情况回避异常的机会, 至于是否需要就看客户自己了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>析构函数绝对不要吐出异常. 如果分析出一个析构函数有抛出异常的风险, 应当先把异常捕捉下来, 看是否结束程序或吞下异常.</li><li>给客户提供自己处理异常的机会, 让客户可以根据实际情况对异常做出反应.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款7 virtual析构函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE7%20virtual%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款07-为多态基类声明virtual析构函数"><a href="#条款07-为多态基类声明virtual析构函数" class="headerlink" title="条款07 : 为多态基类声明virtual析构函数"></a>条款07 : 为多态基类声明virtual析构函数</h2><blockquote><p>说到多态, 我们应当非常了解其运行时绑定的机制, 简单来说就是我们可以在任何时候根据用户的需求将基类绑定为不同的派生类, 用相同的操作实现不同的效果, 这其中virtual函数起到了至关重要的作用, 每一个含有虚函数的类都会维护一个虚表, 以此实现基类到派生类的动态绑定. </p></blockquote><p>这里书中提到了一个重要又经常发生的问题 : <strong>如果<code>drived class(派生类)</code>对象经由一个<code>base class(基类)</code>指针被删除, 而该base class带着一个non-virtual析构函数, 那么结果是未定义的</strong>.</p><p>这里的结果未定义, 一般情况下是只会调用<code>base class</code>自己的析构函数, 销毁的是该对象的<code>base class</code>部分, 而<code>drived class</code>部分却没有被销毁, 就造成了诡异的”局部销毁”现象.</p><p>而解决这个问题的方法就是 : <strong>给 base class 一个 virtual析构函数</strong>.</p><p>先回忆一下有关派生类析构函数的知识 : <strong>派生类的析构函数会默认先调用上一层的析构函数</strong>. 也就是说是从当前派生类的析构函数开始, 递归式调用上一层的析构函数, 直到到达最深层的基类. </p><p>再思考上面的话, 当<code>base class</code>指针动态绑定<code>drived class</code>对象时, 如果我们想删除这个对象时, 正确的结果应该是调用动态绑定的<code>drived class</code>的析构函数, 这样才能正确地全部销毁, 而想这样调用就只能依赖于虚函数来实现, 也就是我们需要把base class的析构函数设置为virtual, 删除时就会根据虚表找到当前动态类型绑定的析构函数.</p><p>以下是书中的给出的样例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">TimeKeeper</span>();<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">TimeKeeper</span>();<br>  ...<br>&#125;;<br>TimeKeeper *ptk = <span class="hljs-built_in">getTimeKeeper</span>();<br>...<br><span class="hljs-keyword">delete</span> ptk;                         <span class="hljs-comment">// 现在, 行为正确</span><br></code></pre></td></tr></table></figure><p>书中告诉我们 : </p><ul><li><strong>virtual 函数的目的是允许 derived class 的实现得以客制化</strong>.</li><li><strong>任何 class 只要带有 virtual 函数都几乎确定应该也有一个 virtual 析构函数</strong>.</li></ul><hr><p>当然, 无端地将所有的 classes 的析构函数声明为 virtual, 就像从未声明他们为 virtual 一样, 都是错误的.</p><p>如果 class 不含 virtual 函数, 通常表示它并不意图被用作一个 base class, 也就完全不需要声明virtual析构函数.</p><p>我们知道使用虚函数是要带来额外的花销的, 包括维护虚表, 虚指针表等一系列繁杂的动作, 会带来时间成本和空间成本, 而且书中还提到由于对象大小的增加会影响其可移植性.</p><p>所以请记住一个心得 : <strong>只有当 class 内含至少一个 virtual 函数, 才为他声明 virtual析构函数</strong>.</p><hr><p><strong>请不要企图继承我们神圣的STL容器</strong>, 正因为考虑到上面虚函数有关时间, 空间, 可移植性的问题, STL容器并没有考虑被继承的情况, 它们的析构函数都是 non-virtual 的!</p><hr><p>这里书中提到了一个构建抽象类的小窍门 : </p><p>我们一般不希望抽象类被实体化, 它只提供一些接口 : </p><ol><li>被声明为<code>纯虚函数</code>的接口所有派生类必须重写.</li><li>被声明为<code>虚函数</code>的接口提供默认行为同时也允许派生类重写.</li><li>被声明为<code>普通函数</code>的接口可以被所有派生类继承, 使用.</li></ol><p>我们在设计一个抽象类时, 也许并不希望有什么类是必须重写的, 就是不希望有纯虚函数, 只需要提供虚函数和普通函数即可, 然而一个类想要不被实体化, <strong>必须存在一个纯虚函数</strong>, 那么哪里找一个纯虚函数呢? </p><p><strong>如果你拿不定主意, 选析构函数就好了!</strong> 毕竟抽象类一定有多态的需求, 只要有多态的需求, 析构函数就必须是 virtual 的, 已经是虚函数了, 变成纯虚函数也没什么问题, 而且当我们的派生类没有新增动态资源时, 就算我们不手动重写析构函数也没关系! 因为编译器会自动帮我们生成! 这样既满足了必须有一个纯虚函数的要求, 又不需要我们顾及纯虚函数必须重写的问题, 多么完美 !</p><p>不过有一个小细节必须要注意, 所有派生类析构函数最后都会调用到最底层基类的析构函数, 所以我们<strong>需要对纯虚析构函数进行定义</strong>!</p><p>纯虚析构函数真的能定义吗? 答案是能的, 虽然大多数情况下纯虚函数都不用定义, 但是真要定义还是可以的.</p><p>以下是书中的示例 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AWOV</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AWOV</span>() = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 纯虚函数</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br>AWOV::~<span class="hljs-built_in">AWOV</span>()  <span class="hljs-comment">// 纯虚函数的定义</span><br>&#123;<br>    <span class="hljs-comment">// delete ...</span><br>&#125;                    <br></code></pre></td></tr></table></figure><hr><p>再次重申, 本章的主要观点  <strong>给 base class 一个 virtual析构函数</strong> 只适用于多态用途, 这种<code>base class</code>的设计目的就是为了<strong>用来通过 <code>base class</code> 接口处理 <code>drived class</code> 对象</strong>.</p><p>我们也应当知道很多 class 的设计就不是为了作为 base class 来使用, 也并非所有的 base class 的设计目的是为了多态用途, 就像我们上一个条款的<code>Uncopyable</code>类, 它被作为基类就不是为了多态, 而是为了赋予派生类不可拷贝的属性, 就不需要使用基类接口, 使用也只是使用派生类, 使用 virtual析构函数就没必要了.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>请为多态性质的<code>base class</code>设置 virtual析构函数, 反之请不要.</li><li>不要试图继承<code>STL</code>容器.</li><li>想设计抽象类又不知道纯虚函数选谁时, 选析构函数当纯虚函数.</li></ul><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款5-6 默认成员函数</title>
    <link href="/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <url>/2024/11/30/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE5%20-%206%20%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="条款05-了解C-默默编写并调用哪些函数"><a href="#条款05-了解C-默默编写并调用哪些函数" class="headerlink" title="条款05 了解C++默默编写并调用哪些函数"></a>条款05 了解C++默默编写并调用哪些函数</h2><blockquote><p>编译器会默认为class创建default构造函数, 析构函数, copy构造函数, 赋值操作符重载, 这算是我们C++语言基础学习中的重中之重, 这里就不再过多阐释.</p></blockquote><p>书中提出一点 : 如果我们在实际使用中确实没有使用到某些默认成员函数, 编译器很大可能也不会自动创建对应的默认函数(例如copy构造函数, 赋值操作符重载).</p><hr><p>书中还提出了三种编译器拒绝自动生成赋值操作符重载的情景 : </p><ol><li>内含<code>reference(引用)</code>成员变量的类.</li><li>内含<code>const</code>成员变量的类</li><li>基类将赋值操作符重载声明为private的派生类</li></ol><p>原因都是显而易见的, <code>reference</code>不可改指不同对象, <code>const</code>不可被更改, 派生类基于基类.</p><hr><p>这里额外提一个小点, 就是默认生成的拷贝函数和辅助操作符重载默认都是浅拷贝, 就是只把类类对象的所有值进行复制, 如果有指针, 不会深入拷贝指针指向的内容, 只是单纯把指针本身拷贝.</p><h2 id="条款6-若不想使用编译器自动生成的函数-就该明确拒绝"><a href="#条款6-若不想使用编译器自动生成的函数-就该明确拒绝" class="headerlink" title="条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝"></a>条款6 : 若不想使用编译器自动生成的函数, 就该明确拒绝</h2><blockquote><p>虽然大多情况下一个类对象应当有外置的构造&#x2F;析构&#x2F;拷贝接口, 但是总会有一些独一无二的东西应当是不可复制的, 就想天下没有第二个你一样, 如果为你自己设计一个类, 你肯定也不希望有一个自动生成的拷贝函数可以拷贝出无数个你吧.</p></blockquote><p>因此, 若不想使用编译器自动生成的函数, 就该明确拒绝.</p><p>所以怎么拒绝呢?</p><ol><li>将该函数写入private中, 并且故意不实现它.</li><li>将该函数后加上<code>= delete</code>.</li></ol><p>假定我们要写一个房产买卖的类<code>HomeForSale</code>, 众所周知每一套房产都是独一无二的.</p><p>我们来看看怎么实现 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ...<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员函数</span><br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;); <br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;); <span class="hljs-comment">// 这样拷贝函数无法在外部使用就相当于禁用</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// private成员变量</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">HomeForSale</span>(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>; <span class="hljs-comment">// 直接声明禁用, 其实在哪声明都可以</span><br>    HomeForSale&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> HomeForSale&amp;) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-keyword">private</span>:<br>   ...<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h4 id="设计一个专门为了阻止copying动作的base-class"><a href="#设计一个专门为了阻止copying动作的base-class" class="headerlink" title="设计一个专门为了阻止copying动作的base class"></a>设计一个专门为了阻止copying动作的base class</h4><p>针对某些对象独一无二的情况, 我们可以设计一个专门为了阻止copying动作的base class, 让所有有此需求的类继承自该类, 就可以完全不用在专门处理阻止copying动作了.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Uncopyable</span> &#123;<br><span class="hljs-keyword">protected</span>:              <span class="hljs-comment">// 允许构造和析构</span><br>  <span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                            <br>  ~<span class="hljs-built_in">Uncopyable</span>() &#123;&#125;                           <br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-built_in">Uncopyable</span>(<span class="hljs-type">const</span> Uncopyable&amp;);   <span class="hljs-comment">// 阻止copying</span><br>  Uncopyable&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Uncopyable&amp;);<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeForSale</span>: <span class="hljs-keyword">private</span> Uncopyable &#123;     <br>  ...    <span class="hljs-comment">// 自此HomeForSale不需要再进行任何动作就可以实现阻止copying</span><br>&#125;;  <br></code></pre></td></tr></table></figure><p>ed : 也许有人觉得这样子反而多写的, 但在日常情况下<code>Uncopyable</code>完全可以是我们提前备好的, ctrl + v当然方便很多. 再说到为什么是<code>private继承</code>, 在后面的条款中我们会明白, <code>private继承</code>意味着<code>has-a(有一个)</code>的关系, 就是说, 派生类有着基类的部分性质, 而不等于基类, 符合此处<code>HomeForSale</code>和<code>Uncopyable</code>的关系.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住:"></a>请记住:</h3><ul><li>编译器会默认为class创建<code>default构造函数</code>, <code>析构函数</code>, <code>copy构造函数</code>, <code>赋值操作符重载</code>.</li><li>拒绝编译器自动生成的函数, 可以将其写在将该函数写入private中, 并且故意不实现它, 或者直接加上<code>= delete</code></li><li>可以写一些通用类如<code>Uncopyable</code>, 将功能和实现解耦.</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款4 初始化</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE4/</url>
    
    <content type="html"><![CDATA[<h2 id="条款04-确定对象被使用前已先被初始化"><a href="#条款04-确定对象被使用前已先被初始化" class="headerlink" title="条款04 确定对象被使用前已先被初始化"></a>条款04 确定对象被使用前已先被初始化</h2><blockquote><p>本条讨论如何安全高效地实现初始化, 当然也有一些条件奇葩的初始化值得我们去讨论</p></blockquote><h3 id="普通变量初始化"><a href="#普通变量初始化" class="headerlink" title="普通变量初始化"></a>普通变量初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br>cont <span class="hljs-type">char</span> text[] = <span class="hljs-string">&quot;hello&quot;</span>;<br><br><span class="hljs-type">double</span> d;<br>cin &gt;&gt; d;    <span class="hljs-comment">// 这种也叫初始化</span><br></code></pre></td></tr></table></figure><h3 id="类内变量初始化"><a href="#类内变量初始化" class="headerlink" title="类内变量初始化"></a>类内变量初始化</h3><p>类内变量的初始化一般就是三种, <code>类内设置初始值</code>, <code>缺省值</code> , <code>初始值列表</code>. </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stu</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name = <span class="hljs-string">&quot;小红&quot;</span>, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age = <span class="hljs-string">&quot;17&quot;</span>, <span class="hljs-type">const</span> string&amp; sex = <span class="hljs-string">&quot;女&quot;</span>) <span class="hljs-comment">// 设置缺省值 (次之)</span><br>    :_name(name.<span class="hljs-built_in">c_str</span>())<br>        ,_age(age)<br>        ,_sex(sex.<span class="hljs-built_in">c_str</span>())<span class="hljs-comment">// 初始化列表 (优先)</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span> : <br><span class="hljs-type">char</span> _name[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;小明&quot;</span>;<br>    <span class="hljs-type">int</span> _age = <span class="hljs-number">18</span>;<br>    <span class="hljs-type">char</span> _sex[<span class="hljs-number">5</span>] = <span class="hljs-string">&quot;男&quot;</span>;  <span class="hljs-comment">// 类内设置初始值 (最次)</span><br>&#125;<br><br>Stu s1;  <span class="hljs-comment">// 小红 17 女</span><br><span class="hljs-function">Stu <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">35</span>, <span class="hljs-string">&quot;男&quot;</span>)</span></span>;    <span class="hljs-comment">// 张三 35 男 </span><br></code></pre></td></tr></table></figure><p>这里虽然看起来三种方式都可以, 但是只推荐全部使用初始值列表, 当有特别想要设置的默认值时设置缺省值.</p><h3 id="初始值列表"><a href="#初始值列表" class="headerlink" title="初始值列表"></a>初始值列表</h3><h4 id="优势描述"><a href="#优势描述" class="headerlink" title="优势描述 :"></a>优势描述 :</h4><p>为了描述初始值列表的优势, 请先阅读以下另一版本的构造函数:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Stu</span>(<span class="hljs-type">const</span> string&amp; name, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; age, <span class="hljs-type">const</span> string&amp; sex)<br>&#123;<br>_name = name.<span class="hljs-built_in">c_str</span>();<br>    _age = age;<br>    _sex = sex.<span class="hljs-built_in">c_str</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这样子写构造函数其实和我们写初始值列表的最终结果是一样的, 而且相对直观.</p><p><strong>但是</strong>, 该版本在底层每个变量其实是先进行了一次default的构造, 再进行了一次copy操作, 其本质是<code>初始化 + 赋值</code>.</p><p>而<code>初始值列表</code>在底层只进行了一次copy构造, 比前者高效得多, 本质就是<code>初始化</code>.</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项 :"></a>注意事项 :</h4><ul><li>最好在初始值列表中初始化所有的成员变量, 这样起码不会忘记没有初始化的变量.</li><li>C++中成员变量的初始化顺序是按照类中声明的次序, 而非初始值列表中的顺序! (如果有继承关系, 基类一定早于派生类初始化)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Example</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : _b(b), _a(a) <span class="hljs-comment">// 尽管在初始化列表中是_b在前, 但是依旧是先初始化_a</span><br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> _a; <span class="hljs-comment">// _a 在 _b 之前声明</span><br>    <span class="hljs-type">int</span> _b; <span class="hljs-comment">// _b 在 _a 之后声明</span><br>&#125;;<br><span class="hljs-comment">// ----------------------------------------------------------//</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Red</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Blue</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Purple</span>&#123; <span class="hljs-comment">// 紫色需要类型为红色和蓝色的变量</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Purple</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red) ,<span class="hljs-built_in">b</span>(blue)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;<br>    Blue b;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> <span class="hljs-comment">// Color类存储三种颜色, 并且可以用红蓝配出紫</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Color</span>(<span class="hljs-type">const</span> Red&amp; red, <span class="hljs-type">const</span> Blue&amp; blue)<br>        :<span class="hljs-built_in">r</span>(red)<br>        :<span class="hljs-built_in">b</span>(blue)<br>        :<span class="hljs-built_in">purper</span>(r, b)<br>    &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    Red r;           <span class="hljs-comment">//purple p;</span><br>    Blue b; <span class="hljs-comment">//Red r;</span><br>    Purple p; <span class="hljs-comment">//Blue b; 假如是注释中的情况, 将无法编译通过, 因为p需要r,b都初始化完才能初始化</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="不同编译单元内定义non-local-static对象-的初始化次序"><a href="#不同编译单元内定义non-local-static对象-的初始化次序" class="headerlink" title="[ 不同编译单元内定义non-local static对象 ] 的初始化次序"></a>[ 不同编译单元内定义non-local static对象 ] 的初始化次序</h3><p>初看第一眼根本就不知道是什么东西(再看也不知道), 所以先介绍一下定义:</p><ul><li><p>编译单元 : 可以简单理解为一个单独的<code>.cpp</code>文件或<code>.h</code>文件等, 就是有一定的隔离性.</p></li><li><p><code>local static</code>(局部静态变量) : 生命周期为整个程序, <strong>在局部第一次调用时初始化</strong>, 之后都是用这个.</p></li><li><p><code>non-local static</code>(全局静态变量) : 生命周期也为整个程序, <strong>程序启动时初始化</strong>, 之后都是用这个.(例如全局变量)</p></li></ul><p><code>local static</code>和<code>non-local static</code>的区别简单来看就在于初始化的时机.</p><hr><p>再举一个例子, 如果我在<code>a.h</code>中定义了<code>class A</code>, 在<code>b.h</code>中定义了<code>class B</code>, 又在<code>c.cpp</code>中要求使用类型为A和类型为B的<code>non-local static</code>变量, 那么这两个变量的初始化次序是怎样的?</p><p>答案是<strong>无法判断</strong>, 你看上面的定义, <code>non-local static</code>对象都是在程序启动时初始化, C++根本没有手段判断应该先初始化哪个,所以这就是没有定义的行为!</p><hr><p>说了这么多, 那这样会带来什么隐患呢? </p><p>如果两个编译单元中的类有依赖关系的话, 初始化次序的不确定性就会导致问题!</p><p>假如说B类static变量中使用到了A类static变量的话, 如果在<code>c.cpp</code>中先初始化了B类static变量, 可是A类static变量还没初始化, 那么就只有报错一条路了. </p><hr><p>可能看到这里有人不太理解这种情况有什么应用场景, 那么我在这里引入一个定义 :</p><ul><li>内置型对象 : 这个对象本身并没有太大意义, 目的是为了引出类中的各种功能性函数, 一般是non-local static的.</li></ul><p><strong>进一步解释</strong> : 有些类中会有许多应用实际场景的方法函数, 如果需要使用这些函数, 就需要客户构造一个类对象,再用这个对象使用函数, 那么我们就干脆在类的头文件中声明一个类对象, 要求使用这个头文件的客户必须记得生成一个对应对象, 而这个对象一般是non-local static的. </p><p>假如有一个钟表类, 内部需要用到一个计时器的类, 于是使用了计时器类的内置对象, 当用户创建一个non-local static类型的钟表类对象时, 你无法确定计时器类的内置对象和钟表类对象哪个先初始化.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    ....<br>&#125;;<br><span class="hljs-keyword">extern</span> TimeKeeper tk;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(tk.<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里用tk获取当前时间来初始化time</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <span class="hljs-comment">// 如果用户设置一个全局变量的Clock类对象clock, 此时无法确定clock和tk的初始化次序!</span><br>...<br></code></pre></td></tr></table></figure><h4 id="解决方法-以local-static对象替换non-local-static对象"><a href="#解决方法-以local-static对象替换non-local-static对象" class="headerlink" title="解决方法 : 以local static对象替换non-local static对象"></a>解决方法 : 以local static对象替换non-local static对象</h4><p>这个解决方法用到了设计模式中最经典的<code>单例模式</code>的设计思想 : 延迟初始化.</p><p>思路简单来说就是, 既然给出一个non-local static对象有风险的话, 我就不给这个non-local static对象了, 我直接使用一个函数, 当客户有使用内置型对象相应需求的时候, 当真正客户调用这个函数时, 才会使用函数内部的代码自己生成一个local static对象供自己使用, 这样初始化次序就有了保障.</p><p>更通俗易懂地描述一下, 就是虽然不好直接使用内置型对象, 但是可以把函数返回值当成内置型对象来使用,  因为在函数内生成的对象时是local static对象, 没有初始化次序的问题.</p><p>看一看接下来的代码吧 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// TimeKeeper.h   这是一个计时器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeKeeper</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    ....<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetTime</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">TimeKeeper&amp; <span class="hljs-title">tk</span><span class="hljs-params">()</span> <span class="hljs-comment">// 这里用tk函数替代内置型对象tk</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">static</span> TimeKeeper timekeeper;  <span class="hljs-comment">// 当用户真正调用tk()时, 才会在函数内部生成一个局部静态变量(local static)</span><br>        <span class="hljs-keyword">return</span> timekeeper;<br>    &#125;<br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Clock.h这是一个钟表类</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;TimeKeeper&quot;</span></span><br>......<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br>    <span class="hljs-built_in">Clock</span>()<br>        :<span class="hljs-built_in">time</span>(<span class="hljs-built_in">tk</span>().<span class="hljs-built_in">GetTime</span>()) <span class="hljs-comment">// 这里只是简单地将tk换成了tk(), 从调用对象改为调用函数而已</span><br>    &#123;&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> time;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// user.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Clock.h&quot;</span></span><br>...<br>Clock clock; <br><span class="hljs-comment">// 设置一个全局变量的Clock类对象clock, 此时一定是clock开始初始化, 当初始化时调用到tk()再进行timekeeper的初始化</span><br>...<br></code></pre></td></tr></table></figure><h4 id="多线程情况下的安全性"><a href="#多线程情况下的安全性" class="headerlink" title="多线程情况下的安全性 :"></a>多线程情况下的安全性 :</h4><p>书中指明, <code>内涵static对象</code>在多线程情况下会带有线程安全的问题, 等待某事发生都会有麻烦.</p><p>如果同时调用tk(), 没办法保证只有一个timekeeper生成, 除非用锁, 但那样花销太大得不偿失.</p><p>所以我们可以在线程的单线程启动阶段<code>手工调用</code>所有的初始化函数(例如tk()), 这样在多线程来临前就可以确保初始化完毕.</p><hr><h3 id="请记住"><a href="#请记住" class="headerlink" title="请记住 :"></a>请记住 :</h3><ul><li>对内置型对象进行手工初始化, C++本身并不会保证正确初始化他们.</li><li>最好使用初始化列表, 并且排序要和类内的声明顺序一致.</li><li>如果有跨编译单元的初始化次序问题, 请以local static对象替换non-local static对象.</li></ul><p>刚开始写博客, 如有错误感谢指正!</p><p>by 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款3 const</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE3/</url>
    
    <content type="html"><![CDATA[<h2 id="条款03-尽可能使用const"><a href="#条款03-尽可能使用const" class="headerlink" title="条款03 : 尽可能使用const"></a>条款03 : 尽可能使用const</h2><blockquote><p><code>const</code>(不可被改动), 是一种非常有效且多样的语义约束, 有了这项约束, 我们可以借用编译器之手规范我们的代码, 以免带来意想不到的错误, 毕竟任何的改动都会伴随着一定的风险, 如果可以提前规避, 我们何乐而不为呢? </p></blockquote><p><code>const</code>在实际表现上是多才多艺的, 他可以修饰对象, 对象指针, 甚至成员函数, 接下来逐一介绍 :</p><h3 id="const-修饰变量"><a href="#const-修饰变量" class="headerlink" title="const 修饰变量"></a>const 修饰变量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">200010</span>; <span class="hljs-comment">// 这样子定义的N又被称为常变量, 其实也就是常量了(因为不可被改动)</span><br></code></pre></td></tr></table></figure><h3 id="const-修饰指针"><a href="#const-修饰指针" class="headerlink" title="const 修饰指针"></a>const 修饰指针</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// 众所周知, arr数组名是一个指针</span><br><span class="hljs-type">char</span>* a = arr;<span class="hljs-comment">// a指针可修改, 指针指向的内容可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* b = arr;<span class="hljs-comment">// b指针不可修改, 指针指向的内容可修改</span><br><span class="hljs-type">char</span>* <span class="hljs-type">const</span> c = arr;<span class="hljs-comment">// c指针可修改, 指针指向的内容不可修改</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-type">const</span> d = arr;<span class="hljs-comment">// d指针不可修改, 指针指向的内容不可修改</span><br></code></pre></td></tr></table></figure><p>谈到指针就不可避免的就会想到<code> 迭代器</code>, 毕竟<code>迭代器</code>就是指针的封装嘛.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//看看下面两种迭代器的定义, 就可以对应上面指针的情况</span><br><span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;::iterator iter = v.<span class="hljs-built_in">begin</span>(); <br><span class="hljs-comment">// 迭代器本身是const的, 也就是说本身不可修改, 相当于指针在*前加const</span><br><span class="hljs-comment">// 此时无法进行 ++iter 等操作</span><br><br>vector&lt;<span class="hljs-type">int</span>&gt;::const_iterator citer = v.<span class="hljs-built_in">begin</span>();<br><span class="hljs-comment">// 语言自带的const_iterator本身就是为了对迭代器指向的内容设置只读, 本身可以进行运算操作, 相当于在*后加const </span><br></code></pre></td></tr></table></figure><h3 id="const-修饰成员函数"><a href="#const-修饰成员函数" class="headerlink" title="const 修饰成员函数"></a>const 修饰成员函数</h3><blockquote><p>先明确<code>const</code>成员函数的意义 : 告知编译器这个函数内部的对象不应被改动.</p><p>不是说明函数本身不可改动!!!</p></blockquote><ul><li>那么对成员函数声明<code>const</code>的意义何在?</li></ul><ol><li><strong>使这个函数接口更容易被理解</strong>, 一个函数是否可以改变类内变量的具体数值会很大程度上影响我们对这个函数的定位判断.</li><li><strong>使操作<code>const</code>对象成为可能</strong>, 首先我们要明晰<code>const</code>对象是什么, 就是类定义出的<code>const</code>对象(例如 const Stu stu(小明, 18);), 当我们声明一个类对象为<code>const</code>时, 这个对象对象只能调用<code>const</code>成员函数, 调用的任何<code>non-const</code>成员函数都无法通过编译的, 因此如果你所设计的类有需求<code>const</code>的情景时, 请设计<code>const</code>成员函数.</li></ol><hr><ul><li>这里书中给出了一个事实 : <strong>两个成员函数如果只是常量性不同(const &#x2F; non-const), 也可以被重载.</strong></li></ul><p>​这其实就告诉我们如果想要适配<code>const</code>版本的话, <strong>non-const版本和const版本各写一个就好了</strong>, 编译器会根据对象是否为<code>const</code>来选择使用哪个函数, 样例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <span class="hljs-comment">// 1</span><br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <span class="hljs-comment">// 2</span><br> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;<br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function">TextBlock <span class="hljs-title">tb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br>cout &lt;&lt; tb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数2</span><br>cout &lt;&lt; ctb[<span class="hljs-number">0</span>];<span class="hljs-comment">// 调用函数1</span><br></code></pre></td></tr></table></figure><hr><ul><li>接下来需要介绍两种对<code> 成员函数为const</code>时应有行为的流派概念:</li></ul><h4 id="bitwise-const"><a href="#bitwise-const" class="headerlink" title="bitwise const :"></a>bitwise const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, 应当<strong>不改变对象中的任何变量</strong>, 也就是物理上没有1bit被改变.</p><h4 id="logical-const"><a href="#logical-const" class="headerlink" title="logical const :"></a>logical const :</h4><p>​这个流派认为如果一个成员函数为<code>const</code>, <strong>可以改变对象中的某些变量</strong>, <strong>但是不能对对象的主要逻辑产生影响</strong>, 也就是说对象在逻辑上没有被改变, 改变的部分只是起辅助优化作用, 例如修改日志, 对计算结果进行缓存, 记录当前容器大小等, 这些工作对主逻辑并没有任何影响, 却可以大大提高主逻辑的工作效率.</p><hr><ul><li>那么C++实际上是怎么定义<code>const</code>成员函数的行为的呢?</li></ul><p>​C++在<strong>一般情况下的定义按照<code>bitwise const</code>的规则进行</strong>, 也就是说一个<code>const</code>成员函数无法改变对象中任何变量.</p><p>​但是这其中有一个C++本身不好决断的情况需要了解 :</p><p>​还记得上面代码中定义的[]重载函数吗 ? const char&amp; operator[](const std::size_t position) const </p><p>​假如我把返回值改为char&amp; : char&amp; operator[](const std::size_t position) const</p><p>​那么这样就会产生一个奇怪的情况 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBlock</span> &#123;<br><span class="hljs-keyword">public</span>:<br> ...<br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br> &#123; <span class="hljs-keyword">return</span> text[position]; &#125;   <br><span class="hljs-keyword">private</span>:<br>   std::string text;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> TextBlock <span class="hljs-title">ctb</span><span class="hljs-params">(<span class="hljs-string">&quot;hello&quot;</span>)</span></span>;<br><span class="hljs-type">char</span>* pc = &amp;<span class="hljs-built_in">cbt</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">// 返回的指针没有const</span><br>*pc = <span class="hljs-string">&#x27;j&#x27;</span>;<span class="hljs-comment">// &quot;hello&quot;被变成了&quot;jello&quot;!!!</span><br></code></pre></td></tr></table></figure><p>​通过以上的情况我们可以发现, C++虽然确保在<code>const</code>成员函数内部不会改变任何对象, 但是并不会检查返回对象所指向的内容是否是不可改变的, C++可能认为在函数外的行为是程序员的自由吧, 所以我们应当注意这一点.</p><hr><ul><li>那么问题又来了, 既然<code>logical const</code>也有其道理所在, C++是如何解决的呢?</li></ul><p>​C++引入了一个与<code>const</code>相关的摆动场 : <strong>mutable(可变的).</strong></p><p>​<code>mutable</code> 的主要用途是在 <code>const</code> 成员函数中允许对特定成员变量的修改, 这样<code>logical const</code>的诉求就可以满足了。</p><p>​请阅读以下代码 : </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">text</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//...</span><br>        <br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">updateLength</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (!lengthIsValid)<br>&#123;<br><span class="hljs-comment">// 以下两句就是因为mutable得以通过</span><br>length = pText.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 重新更新text的长度</span><br>lengthIsValid = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 定义当前length可用</span><br>&#125;<br><span class="hljs-keyword">return</span> length;<br>&#125;<br>    <br><span class="hljs-keyword">private</span>:<br>string pText;<br><br><span class="hljs-comment">// mutable 关键字可以使某个成员变量在const成员函数被修改</span><br><span class="hljs-comment">// 作用是在不改变内部变量的基础逻辑的情况下, 可以引入少量变量可以被改变, 丰富逻辑</span><br><span class="hljs-comment">// 保证函数的安全, 使用mutable意味着在const成员函数中只能改变mutable变量, 其他变量不会被改变</span><br><span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> length;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">bool</span> lengthIsValid;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>​以上代码将<code>lenth</code>和<code>lengthIsValid</code>赋予<code>mutable</code>特性, 使其在<code>const</code>成员函数中可以改变, 从而可以用非常小的代价更新<code>text</code>的长度, 方便其他需要使用text长度的函数, 这两个变量均对<code>text</code>存储字符串的主逻辑没有影响.</p><hr><p>​最后还有一个比较有价值的观点 : 我们知道要适配<code>const</code>版本需要写两个类似的函数, 一个处理<code>const</code>对象, 一个处理<code>non-const</code>对象, 但是我们也应当发现这两个函数其实非常相似, 那么这就带来了一些问题:</p><ol><li><strong>代码重复</strong>, 这会带来阅读性降低, 维护成本提高的负面作用.</li><li>我们在以后的条款学习中会知道, 编译器一般会把成员函数替换为<code>inline</code>函数, 这在一般情况下肯定是更高效的, 但是<code>inline</code>函数中的代码越多, 会带来一系列如代码膨胀之类的问题, 这点我们应当避免.</li></ol><ul><li>书中提出了这样的解决方案 : <strong>令<code>non-const</code>版本调用<code>const</code>版本</strong>.</li></ul><p>​这样子做的前提是两个版本的内容一定相等, 或者说<code>non-const</code>版本不能修改对象内的变量, 毕竟如果修改了那和<code>const</code>版本就一定不一样了, 我们来改写上面[]重载的两个版本.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position) <span class="hljs-type">const</span>  <br>&#123; <br>    <span class="hljs-comment">//我们假定[]重载在返回下标引用之前还要做许多工作, 代码量巨大</span><br>    <span class="hljs-comment">// ...边界检验</span><br>    <span class="hljs-comment">// ...将数据访问的行为加入日志</span><br>    <span class="hljs-comment">// ...检验指向内容数据的完整性</span><br>    <span class="hljs-keyword">return</span> text[position]; <br>&#125;<br><br><span class="hljs-type">char</span>&amp; <span class="hljs-keyword">operator</span>[](<span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> position)<br>&#123; <br>    <span class="hljs-comment">// 这段代码实现了两次类型转换, 目的是调用const版本的operator[]函数并返回non-const的char&amp;</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">char</span>&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> text&amp;&gt;(*<span class="hljs-keyword">this</span>)[pos]);<br>    <span class="hljs-comment">/* 我们把这段代码拆分开来解读</span><br><span class="hljs-comment">    return const_cast&lt;char&amp;&gt;(    // 3. 将[]返回结果由const版本通过const_cast转换为non-const版本</span><br><span class="hljs-comment">        static_cast&lt;const text&amp;&gt;(*this)  // 1. 先将this指针通过static_cast转换为const text&amp;</span><br><span class="hljs-comment">        [pos] // 2. const text&amp;类型调用[]重载, 自然使用的是const版本的[]重载</span><br><span class="hljs-comment">    );</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​经过以上的操作, 无论<code>const</code>版本需要多少行代码, <code>non-const</code>版本都只需要一行代码即可, 相当实用.</p><p>​另外如果在<code>non-const</code>版本虽然和<code>const</code>版本十分相似, 但是还是想要修改一部分的数据, 也可以在调用完重载版本后不返回, 再进行一些修改操作再返回.</p><ul><li>小问题 : 为什么不用<code>const</code>版本调用<code>non-const</code>版本?  因为<code>non-const</code>版本不会限制修改行为, 无法监督<code>const</code>实现.</li></ul><hr><h2 id="请记住"><a href="#请记住" class="headerlink" title="请记住"></a>请记住</h2><ul><li>将某些东西声明为<code>const</code>可以帮助编译器检查出错误语法, <code>const</code>可被施加于任何对象, 函数参数, 函数返回值, 成员函数</li><li>C++在<code>const</code>成员函数定义上默认支持<code>bitwise const</code>流派, 但是也通过关键字<code>mutable</code>变相支持了<code>logical const</code>流派</li><li>当<code>non-const</code>版本和<code>const</code>版本等价实质时, 可以用<code>non-const</code>版本调用<code>const</code>版本</li></ul><p>作者 : 天目中云</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Effective C++ 条款1-2</title>
    <link href="/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/"/>
    <url>/2024/11/29/%5BEffective%20C++%5D%E6%9D%A1%E6%AC%BE1-2/</url>
    
    <content type="html"><![CDATA[<h3 id="条款01-视C-为一个语言联邦"><a href="#条款01-视C-为一个语言联邦" class="headerlink" title="条款01 : 视C++为一个语言联邦"></a>条款01 : 视C++为一个语言联邦</h3><blockquote><p>不像Java对各种资源都进行了整合内聚, C++更像是由四种次语言组合而成的语言联邦, 每种次语言都有自己的规约, 也都有不同的用武之地, 每个都可以给C++这门语言带来独特的优势.</p><ul><li><h4 id="C-C-的基础-包含指针-内置数据类型等基础思想"><a href="#C-C-的基础-包含指针-内置数据类型等基础思想" class="headerlink" title="C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想."></a>C  :  C++的基础, 包含指针&#x2F;内置数据类型等基础思想.</h4></li></ul></blockquote><ul><li><h4 id="Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态"><a href="#Object-Oriented-C-面向对象编程的核心-实现封装-继承-多态" class="headerlink" title="Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态."></a>Object-Oriented C++  :  面向对象编程的核心, 实现封装&#x2F;继承&#x2F;多态.</h4></li><li><h4 id="Template-C-泛型编程"><a href="#Template-C-泛型编程" class="headerlink" title="Template C++  :  泛型编程."></a>Template C++  :  泛型编程.</h4></li><li><h4 id="STL-一套template的程序库-包含各种数据结构与算法"><a href="#STL-一套template的程序库-包含各种数据结构与算法" class="headerlink" title="STL  :  一套template的程序库, 包含各种数据结构与算法."></a>STL  :  一套template的程序库, 包含各种数据结构与算法.</h4><p>  这四个方向我们都应熟识掌握, 但是可以给自己这样一个印象 : C++并不是一个一体的语言, 编程时的思想规范应当随你使用C++的对应部分而改变.</p></li></ul><hr><h3 id="条款02-尽量以cnost-enum-inline-替换-define"><a href="#条款02-尽量以cnost-enum-inline-替换-define" class="headerlink" title="条款02 : 尽量以cnost, enum, inline 替换 #define"></a>条款02 : 尽量以cnost, enum, inline 替换 #define</h3><blockquote><p>由 ‘#’ 引出的语句一般与C的预处理机制相关, 我们很需要预处理机制中的 #include 和 #ifdef, 前者保证库的引入, 后者可以针对不同的环境进行条件编译, 而 #define 却在语言的发展下显得有些与时代脱节了, 现在我们应当有心减少 #define 的使用.</p></blockquote><p>以下列举 #define 所带来的一些问题:</p><ol><li>书写代码时很难自动显示错误</li><li>编译错误时显示的信息并不直观</li><li>#define并不重视作用域, 面向全局生效, 这与我们应当坚持的封装思想相悖</li></ol><p>简而言之, 就是#define可能带来一些不可预料的行为并且无法保证类型安全, 而如今我们由足够多的方法可以安全有效地替代#define的功能, 比如const和enum可以替代#define在常量定义上功能, inline又可以替代#define在宏函数上的功能.</p><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100 <span class="hljs-comment">// 这个步骤在预处理阶段实现</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100</span>;<span class="hljs-comment">// 这个步骤在编译阶段实现</span><br></code></pre></td></tr></table></figure><h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 这里我们想定义三元色的对应数值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> RED = 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GREEN = 2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BLUE = 3</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>&#123;<br>    RED = <span class="hljs-number">1</span>, <br>    GREEN = <span class="hljs-number">2</span>,<br>    BLUE = <span class="hljs-number">3</span><br>&#125;<span class="hljs-comment">// 使用enum枚举类型在增强代码的可读性的同时也提升了可维护性</span><br><br><span class="hljs-comment">//-----------------------------------------------------//</span><br><span class="hljs-keyword">enum</span> Action&#123;<br>    RUN = <span class="hljs-number">0x0001</span>,    <span class="hljs-comment">// 第一位</span><br>    JUMP = <span class="hljs-number">0x0002</span>, <span class="hljs-comment">// 第二位</span><br>    SAY = <span class="hljs-number">0x0004</span>, <span class="hljs-comment">// 第三位</span><br>    SLEEP = <span class="hljs-number">0x0008</span> <span class="hljs-comment">// 第四位</span><br>&#125;<span class="hljs-comment">// 使用enum还可以实现比特级别的状态判断</span><br><br><span class="hljs-type">void</span> <span class="hljs-built_in">CheckAction</span>(<span class="hljs-type">int</span> action);   <span class="hljs-comment">// 假设我们有这样一个检查运动状态的函数, 那么我们就可以只接受一个int就可以判断复数的状态</span><br><span class="hljs-built_in">CheckAction</span>(RUN | JUMP | SAY);<span class="hljs-comment">// 这里的状态就 跑 + 跳 + 说话</span><br></code></pre></td></tr></table></figure><h4 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 加入我们想实现的MAX(a, b), 我们可以通过以下实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a, b)  (a) &gt; (b) ? (a) : (b)</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">MAX</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; a, <span class="hljs-type">const</span> T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们用模板 + inline就可以完全代替宏函数的作用, 首先inline的书写模式更加自然, 另外还保证了类型安全, 规避了#define的危险性.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Effective C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows API 学习笔记(3) 文件, 设备IO, 系统信息</title>
    <link href="/2015/09/08/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/"/>
    <url>/2015/09/08/Windows%20API%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文件, 设备IO, 系统信息</p></blockquote><blockquote><p>运行环境为vs2022</p></blockquote><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><h3 id="CreateFile"><a href="#CreateFile" class="headerlink" title="CreateFile"></a>CreateFile</h3><p>打开&#x2F;创建文件, 返回文件句柄, 可设置访问权限, 是否共享, 覆盖还是追加.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">HANDLE <span class="hljs-title">CreateFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR                lpFileName,      <span class="hljs-comment">// 文件名/设备名</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwDesiredAccess, <span class="hljs-comment">// 访问权限（读/写）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwShareMode,     <span class="hljs-comment">// 共享模式</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes, <span class="hljs-comment">// 安全属性（通常为NULL）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwCreationDisposition, <span class="hljs-comment">// 创建方式（新建/打开等）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD                 dwFlagsAndAttributes,  <span class="hljs-comment">// 文件属性（如缓存策略）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE                hTemplateFile           <span class="hljs-comment">// 模板文件（通常为NULL）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong><code>dwDesiredAccess</code></strong></p><p>访问权限：</p><ul><li><code>GENERIC_READ</code>：只读</li><li><code>GENERIC_WRITE</code>：只写</li><li><code>GENERIC_READ | GENERIC_WRITE</code>：读写</li></ul></li><li><p><strong><code>dwCreationDisposition</code></strong></p><p>文件存在&#x2F;不存在时的行为：</p><ul><li><code>CREATE_NEW</code>：新建（若存在则失败）</li><li><code>CREATE_ALWAYS</code>：覆盖已有文件</li><li><code>OPEN_EXISTING</code>：打开已有文件（不存在则失败）</li><li><code>OPEN_ALWAYS</code>：打开或创建</li><li><code>TRUNCATE_EXISTING</code>：清空已有文件</li></ul></li></ul><h3 id="ReadFile-WriteFile"><a href="#ReadFile-WriteFile" class="headerlink" title="ReadFile &#x2F; WriteFile"></a>ReadFile &#x2F; WriteFile</h3><p>读写文件, 都会移动文件指针.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">ReadFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE       hFile,          <span class="hljs-comment">// CreateFile返回的句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID       lpBuffer,       <span class="hljs-comment">// 接收数据的缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD        nNumberOfBytesToRead, <span class="hljs-comment">// 要读取的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD      lpNumberOfBytesRead,  <span class="hljs-comment">// 实际读取的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPOVERLAPPED lpOverlapped          <span class="hljs-comment">// 异步I/O结构（同步时为NULL）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function">BOOL <span class="hljs-title">WriteFile</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE       hFile,          <span class="hljs-comment">// 文件句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPCVOID      lpBuffer,       <span class="hljs-comment">// 待写入的数据缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD        nNumberOfBytesToWrite, <span class="hljs-comment">// 要写入的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD      lpNumberOfBytesWritten, <span class="hljs-comment">// 实际写入的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPOVERLAPPED lpOverlapped           <span class="hljs-comment">// 异步I/O结构</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="文件读写实操"><a href="#文件读写实操" class="headerlink" title="文件读写实操"></a>文件读写实操</h3><p>向文件追加”hello world!”, 并读出.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;locale&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br><br>HANDLE ret = <span class="hljs-built_in">CreateFile</span>(<br><span class="hljs-string">L&quot;test.txt&quot;</span>,<br>GENERIC_READ | GENERIC_WRITE, <span class="hljs-comment">// 读写</span><br>FILE_SHARE_READ,<span class="hljs-comment">// 可共享读</span><br><span class="hljs-literal">nullptr</span>,<br>OPEN_ALWAYS,<span class="hljs-comment">// 优先打开, 没有再创建</span><br>FILE_ATTRIBUTE_NORMAL, <br><span class="hljs-literal">nullptr</span><br>);<br><span class="hljs-built_in">SetFilePointer</span>(ret, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, FILE_END); <span class="hljs-comment">// 移动文件指针到末尾</span><br><span class="hljs-type">wchar_t</span> buf[] = <span class="hljs-string">L&quot;hello world!&quot;</span>;<br>DWORD realsize;<br><span class="hljs-built_in">WriteFile</span>(ret, buf, <span class="hljs-built_in">sizeof</span>(buf), &amp;realsize, <span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-built_in">SetFilePointer</span>(ret, <span class="hljs-number">0</span>, <span class="hljs-literal">NULL</span>, FILE_BEGIN); <span class="hljs-comment">// 移动文件指针到开头</span><br><br><span class="hljs-type">wchar_t</span> rec[<span class="hljs-number">40</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">ReadFile</span>(ret, rec, <span class="hljs-number">26</span>, &amp;realsize, <span class="hljs-literal">nullptr</span>);<br><br>std::wcout &lt;&lt; rec &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="存储设备相关"><a href="#存储设备相关" class="headerlink" title="存储设备相关"></a>存储设备相关</h2><h3 id="Windows文件系统"><a href="#Windows文件系统" class="headerlink" title="Windows文件系统"></a>Windows文件系统</h3><ul><li><p>物理磁盘 : 最基础的物理结构, 存在分区用来管理.</p></li><li><p>卷 : 逻辑概念, 操作系统和用户直接交互的“存储容器”.</p><ul><li>就是常见的C盘, D盘, E盘.</li><li>一个卷可以由一个或多个物理磁盘构成.</li></ul></li><li><p>文件系统 : 软件概念, 对卷的上层构造, 用文件系统去描述卷, 进而去操作其底层的物理磁盘.</p></li><li><p>在Windows操作系统中, 物理磁盘和卷都是可以做为文件被打开的, 进而用来查询一些具体参数.</p></li></ul><h3 id="DeviceIoControl"><a href="#DeviceIoControl" class="headerlink" title="DeviceIoControl"></a>DeviceIoControl</h3><p><strong>可以用来访问打开的各种硬件, 获取各种参数与实际状态, 及用来和驱动（设备对象）通信.</strong> (物理磁盘和卷便可访问)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">DeviceIoControl</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HANDLE       hDevice,           <span class="hljs-comment">// 设备句柄</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD        dwIoControlCode,   <span class="hljs-comment">// 控制代码</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID       lpInBuffer,        <span class="hljs-comment">// 输入缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD        nInBufferSize,     <span class="hljs-comment">// 输入缓冲区大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPVOID       lpOutBuffer,       <span class="hljs-comment">// 输出缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD        nOutBufferSize,    <span class="hljs-comment">// 输出缓冲区大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD      lpBytesReturned,   <span class="hljs-comment">// 返回的字节数</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPOVERLAPPED lpOverlapped       <span class="hljs-comment">// 用于异步操作</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>看起来很复杂, 但核心都在<strong>控制代码</strong>处, 你在这里传入的参数用于表明你<strong>想获取什么样的设备数据</strong>, 在后面填入接收的缓冲区即可.</p><ul><li><p><code>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX</code> 获取磁盘的几何信息</p><p>下面是向<code>DeviceIoControl</code>传入<code>IOCTL_DISK_GET_DRIVE_GEOMETRY_EX</code>来获取对应磁盘的几何信息的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;locale&gt;</span></span><br><br><span class="hljs-comment">// 打印磁盘几何结构信息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDiskGeometry</span><span class="hljs-params">(DISK_GEOMETRY_EX* diskGeometry)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=== 磁盘物理几何结构 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;柱面数(Cylinders): %I64d\n&quot;</span>, diskGeometry-&gt;Geometry.Cylinders.QuadPart);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;磁头数(TracksPerCylinder): %lu\n&quot;</span>, diskGeometry-&gt;Geometry.TracksPerCylinder);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;每磁道扇区数(SectorsPerTrack): %lu\n&quot;</span>, diskGeometry-&gt;Geometry.SectorsPerTrack);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;每扇区字节数(BytesPerSector): %lu\n&quot;</span>, diskGeometry-&gt;Geometry.BytesPerSector);<br><br>    <span class="hljs-comment">// 计算并显示磁盘总大小</span><br>    ULONGLONG totalSize = diskGeometry-&gt;Geometry.Cylinders.QuadPart *<br>        diskGeometry-&gt;Geometry.TracksPerCylinder *<br>        diskGeometry-&gt;Geometry.SectorsPerTrack *<br>        diskGeometry-&gt;Geometry.BytesPerSector;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n=== 磁盘容量计算 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;计算总容量: %I64u 字节\n&quot;</span>, totalSize);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;计算总容量: %.2f GB\n&quot;</span>, (<span class="hljs-type">double</span>)totalSize / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br><br>    <span class="hljs-comment">// 显示DISK_GEOMETRY_EX中提供的磁盘大小</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n=== 实际磁盘大小 ===\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;实际磁盘大小: %I64u 字节\n&quot;</span>, diskGeometry-&gt;DiskSize.QuadPart);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;实际磁盘大小: %.2f GB\n&quot;</span>, (<span class="hljs-type">double</span>)diskGeometry-&gt;DiskSize.QuadPart / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 默认查询PhysicalDrive0，或使用命令行参数</span><br>    <span class="hljs-type">wchar_t</span> devicePath[<span class="hljs-number">32</span>] = <span class="hljs-string">L&quot;\\\\.\\PhysicalDrive0&quot;</span>;<br>    <span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">wprintf</span>(<span class="hljs-string">L&quot;正在查询磁盘: %ls\n&quot;</span>, devicePath);<br><br>    <span class="hljs-comment">// 打开物理磁盘</span><br>    HANDLE hDevice = <span class="hljs-built_in">CreateFile</span>(<br>        devicePath,<br>        GENERIC_READ,<br>        FILE_SHARE_READ | FILE_SHARE_WRITE,<br>        <span class="hljs-literal">NULL</span>,<br>        OPEN_EXISTING,<br>        <span class="hljs-number">0</span>,<br>        <span class="hljs-literal">NULL</span><br>    );<br><br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;<br>        DWORD err = <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法打开磁盘设备，错误代码: %lu\n&quot;</span>, err);<br><br>        <span class="hljs-comment">// 获取错误描述</span><br>        LPVOID errMsg;<br>        <span class="hljs-built_in">FormatMessage</span>(<br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,<br>            <span class="hljs-literal">NULL</span>,<br>            err,<br>            <span class="hljs-number">0</span>,<br>            (LPTSTR)&amp;errMsg,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-literal">NULL</span><br>        );<br><br>        std::wcout &lt;&lt; <span class="hljs-string">L&quot;错误描述: &quot;</span> &lt;&lt; (<span class="hljs-type">wchar_t</span>*)errMsg &lt;&lt; std::endl;<br>        <span class="hljs-built_in">LocalFree</span>(errMsg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 准备获取磁盘几何结构</span><br>    DISK_GEOMETRY_EX diskGeometry = &#123; <span class="hljs-number">0</span> &#125;;<br>    DWORD bytesReturned = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 发送IOCTL请求</span><br>    BOOL result = <span class="hljs-built_in">DeviceIoControl</span>(<br>        hDevice,<br>        IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,<br>        <span class="hljs-literal">NULL</span>,<br>        <span class="hljs-number">0</span>,<br>        &amp;diskGeometry,<br>        <span class="hljs-built_in">sizeof</span>(diskGeometry),<br>        &amp;bytesReturned,<br>        <span class="hljs-literal">NULL</span><br>    );<br><br>    <span class="hljs-keyword">if</span> (!result) &#123;<br>        DWORD err = <span class="hljs-built_in">GetLastError</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;获取磁盘几何信息失败，错误代码: %lu\n&quot;</span>, err);<br><br>        LPVOID errMsg;<br>        <span class="hljs-built_in">FormatMessage</span>(<br>            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,<br>            <span class="hljs-literal">NULL</span>,<br>            err,<br>            <span class="hljs-number">0</span>,<br>            (LPTSTR)&amp;errMsg,<br>            <span class="hljs-number">0</span>,<br>            <span class="hljs-literal">NULL</span><br>        );<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;错误描述: %s\n&quot;</span>, (<span class="hljs-type">char</span>*)errMsg);<br>        <span class="hljs-built_in">LocalFree</span>(errMsg);<br>        <span class="hljs-built_in">CloseHandle</span>(hDevice);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印获取到的信息</span><br>    <span class="hljs-built_in">PrintDiskGeometry</span>(&amp;diskGeometry);<br><br>    <span class="hljs-comment">// 关闭设备句柄</span><br>    <span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">正在查询磁盘: \\.\PhysicalDrive0<br>=== 磁盘物理几何结构 ===<br>柱面数(Cylinders): <span class="hljs-number">62260</span><br>磁头数(TracksPerCylinder): <span class="hljs-number">255</span><br>每磁道扇区数(SectorsPerTrack): <span class="hljs-number">63</span><br>每扇区字节数(BytesPerSector): <span class="hljs-number">512</span><br><br>=== 磁盘容量计算 ===<br>计算总容量: <span class="hljs-number">512105932800</span> 字节<br>计算总容量: <span class="hljs-number">476.94</span> GB<br><br>=== 实际磁盘大小 ===<br>实际磁盘大小: <span class="hljs-number">512110190592</span> 字节<br>实际磁盘大小: <span class="hljs-number">476.94</span> GB<br></code></pre></td></tr></table></figure></li><li><p><code>IOCTL_STORAGE_QUERY_PROPERTY</code>  查询物理磁盘的属性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;winioctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;setupapi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initguid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;devguid.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStorageProperty</span><span class="hljs-params">(HANDLE hDevice)</span> </span>&#123;<br>    STORAGE_PROPERTY_QUERY query&#123;&#125;;<br>    query.PropertyId = StorageDeviceProperty;<br>    query.QueryType = PropertyStandardQuery;<br><br>    <span class="hljs-comment">// 第一次调用获取所需缓冲区大小</span><br>    STORAGE_DESCRIPTOR_HEADER header&#123;&#125;;<br>    DWORD bytesReturned = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DeviceIoControl</span>(<br>        hDevice,<br>        IOCTL_STORAGE_QUERY_PROPERTY,<br>        &amp;query,<br>        <span class="hljs-built_in">sizeof</span>(query),<br>        &amp;header,<br>        <span class="hljs-built_in">sizeof</span>(header),<br>        &amp;bytesReturned,<br>        <span class="hljs-literal">nullptr</span>)) &#123;<br>        wcerr &lt;&lt; <span class="hljs-string">L&quot;获取存储属性头信息失败，错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 分配缓冲区</span><br>    <span class="hljs-function">vector&lt;BYTE&gt; <span class="hljs-title">buffer</span><span class="hljs-params">(header.Size)</span></span>;<br>    <span class="hljs-keyword">auto</span> descriptor = <span class="hljs-built_in">reinterpret_cast</span>&lt;STORAGE_DEVICE_DESCRIPTOR*&gt;(buffer.<span class="hljs-built_in">data</span>());<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">DeviceIoControl</span>(hDevice, IOCTL_STORAGE_QUERY_PROPERTY,<br>        &amp;query, <span class="hljs-built_in">sizeof</span>(query), buffer.<span class="hljs-built_in">data</span>(), header.Size, &amp;bytesReturned, <span class="hljs-literal">nullptr</span>)) &#123;<br>        wcerr &lt;&lt; <span class="hljs-string">L&quot;错误: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 安全地获取字符串信息</span><br>    <span class="hljs-keyword">auto</span> GetStringFromOffset = [&amp;](DWORD offset) -&gt; <span class="hljs-type">const</span> <span class="hljs-type">char</span>* &#123;<br>        <span class="hljs-built_in">return</span> (offset &gt; <span class="hljs-number">0</span> &amp;&amp; offset &lt; header.Size) ?<br>            <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(buffer.<span class="hljs-built_in">data</span>() + offset) : <span class="hljs-string">&quot;N/A&quot;</span>;<br>        &#125;;<br><br>    wcout &lt;&lt; <span class="hljs-string">L&quot;=== 磁盘设备信息 ===&quot;</span> &lt;&lt; endl;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot;制造商: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetStringFromOffset</span>(descriptor-&gt;VendorIdOffset) &lt;&lt; endl;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot;型号: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetStringFromOffset</span>(descriptor-&gt;ProductIdOffset) &lt;&lt; endl;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot;固件版本: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetStringFromOffset</span>(descriptor-&gt;ProductRevisionOffset) &lt;&lt; endl;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot;序列号: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetStringFromOffset</span>(descriptor-&gt;SerialNumberOffset) &lt;&lt; endl;<br><br>    wcout &lt;&lt; <span class="hljs-string">L&quot;总线类型: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (descriptor-&gt;BusType) &#123;<br>    <span class="hljs-keyword">case</span> BusTypeUnknown: wcout &lt;&lt; <span class="hljs-string">L&quot;未知&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeScsi: wcout &lt;&lt; <span class="hljs-string">L&quot;SCSI&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeAtapi: wcout &lt;&lt; <span class="hljs-string">L&quot;ATAPI&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeAta: wcout &lt;&lt; <span class="hljs-string">L&quot;ATA&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusType1394: wcout &lt;&lt; <span class="hljs-string">L&quot;IEEE 1394&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSsa: wcout &lt;&lt; <span class="hljs-string">L&quot;SSA&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeFibre: wcout &lt;&lt; <span class="hljs-string">L&quot;光纤通道&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeUsb: wcout &lt;&lt; <span class="hljs-string">L&quot;USB&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeRAID: wcout &lt;&lt; <span class="hljs-string">L&quot;RAID&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeiScsi: wcout &lt;&lt; <span class="hljs-string">L&quot;iSCSI&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSas: wcout &lt;&lt; <span class="hljs-string">L&quot;SAS&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSata: wcout &lt;&lt; <span class="hljs-string">L&quot;SATA&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSd: wcout &lt;&lt; <span class="hljs-string">L&quot;SD&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeMmc: wcout &lt;&lt; <span class="hljs-string">L&quot;MMC&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeVirtual: wcout &lt;&lt; <span class="hljs-string">L&quot;虚拟&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeFileBackedVirtual: wcout &lt;&lt; <span class="hljs-string">L&quot;文件虚拟&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSpaces: wcout &lt;&lt; <span class="hljs-string">L&quot;存储空间&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeNvme: wcout &lt;&lt; <span class="hljs-string">L&quot;NVMe&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeSCM: wcout &lt;&lt; <span class="hljs-string">L&quot;SCM&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeUfs: wcout &lt;&lt; <span class="hljs-string">L&quot;UFS&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> BusTypeMax: wcout &lt;&lt; <span class="hljs-string">L&quot;最大&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: wcout &lt;&lt; <span class="hljs-string">L&quot;未知 (&quot;</span> &lt;&lt; descriptor-&gt;BusType &lt;&lt; <span class="hljs-string">L&quot;)&quot;</span>;<br>    &#125;<br>    wcout &lt;&lt; endl;<br><br>    wcout &lt;&lt; <span class="hljs-string">L&quot;命令队列支持: &quot;</span> &lt;&lt; (descriptor-&gt;CommandQueueing ? <span class="hljs-string">L&quot;是&quot;</span> : <span class="hljs-string">L&quot;否&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 打开磁盘0</span><br>    HANDLE hDevice = <span class="hljs-built_in">CreateFileW</span>(<br>        <span class="hljs-string">L&quot;\\\\.\\PhysicalDrive0&quot;</span>,<br>        GENERIC_READ,<br>        FILE_SHARE_READ | FILE_SHARE_WRITE,<br>        <span class="hljs-literal">nullptr</span>,<br>        OPEN_EXISTING,<br>        <span class="hljs-number">0</span>,<br>        <span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) &#123;<br>        wcerr &lt;&lt; <span class="hljs-string">L&quot;无法打开磁盘设备，错误码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询并打印磁盘信息</span><br>    <span class="hljs-built_in">PrintStorageProperty</span>(hDevice);<br><br>    <span class="hljs-built_in">CloseHandle</span>(hDevice);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">=== 磁盘设备信息 ===<br>制造商: NVMe<br>型号: WD PC SN740 SDDPNQD<span class="hljs-number">-512</span>G<span class="hljs-number">-1002</span><br>固件版本: <span class="hljs-number">73101000</span><br>序列号: E823_8FA6_BF53_0001_001B_448B_4A8D_25AA.<br>总线类型: NVMe<br>命令队列支持: 是<br></code></pre></td></tr></table></figure></li></ul><p>这里只是介绍了获取设备信息的用途, 但实际其可以与各种设备进行交互, 设置与输出.</p><h3 id="GetDiskFreeSpace-GetDiskFreeSpaceEx"><a href="#GetDiskFreeSpace-GetDiskFreeSpaceEx" class="headerlink" title="GetDiskFreeSpace &#x2F; GetDiskFreeSpaceEx"></a>GetDiskFreeSpace &#x2F; GetDiskFreeSpaceEx</h3><p>获取<strong>卷(盘)的空间信息</strong>, 包括总容量, 可用空间等. 前者为旧版, 后者为新版常用.</p><p>一般用来在备份或云空间存储时根据空间信息进行灵活判断.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetDiskFreeSpace</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpRootPathName,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpSectorsPerCluster,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpBytesPerSector,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpNumberOfFreeClusters,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpTotalNumberOfClusters</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br><br><span class="hljs-function">BOOL <span class="hljs-title">GetDiskFreeSpaceEx</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpDirectoryName,               <span class="hljs-comment">// [输入] 要查询的路径</span></span></span><br><span class="hljs-params"><span class="hljs-function">  PULARGE_INTEGER lpFreeBytesAvailable,  <span class="hljs-comment">// [输出] 当前用户可用空间（考虑配额）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  PULARGE_INTEGER lpTotalNumberOfBytes,  <span class="hljs-comment">// [输出] 卷总容量</span></span></span><br><span class="hljs-params"><span class="hljs-function">  PULARGE_INTEGER lpTotalNumberOfFreeBytes <span class="hljs-comment">// [输出] 物理剩余空间（忽略配额）</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>下面是获取C盘信息的代码 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><br><span class="hljs-comment">// 将字节数转换为易读格式 (GB/MB/KB)</span><br><span class="hljs-function">std::wstring <span class="hljs-title">FormatBytes</span><span class="hljs-params">(ULONGLONG bytes)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> KB = <span class="hljs-number">1024.0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> MB = KB * <span class="hljs-number">1024</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> GB = MB * <span class="hljs-number">1024</span>;<br><br>    <span class="hljs-keyword">if</span> (bytes &gt;= GB) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_wstring</span>(bytes / GB) + <span class="hljs-string">L&quot; GB&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes &gt;= MB) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_wstring</span>(bytes / MB) + <span class="hljs-string">L&quot; MB&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bytes &gt;= KB) &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_wstring</span>(bytes / KB) + <span class="hljs-string">L&quot; KB&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_wstring</span>(bytes) + <span class="hljs-string">L&quot; Bytes&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintDiskSpaceInfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* drivePath)</span> </span>&#123;<br>    ULARGE_INTEGER freeBytesAvailable;<br>    ULARGE_INTEGER totalBytes;<br>    ULARGE_INTEGER totalFreeBytes;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetDiskFreeSpaceEx</span>(drivePath, &amp;freeBytesAvailable, &amp;totalBytes, &amp;totalFreeBytes)) &#123;<br><br>        std::wcout &lt;&lt; <span class="hljs-string">L&quot;=== 磁盘空间信息 (&quot;</span> &lt;&lt; drivePath &lt;&lt; <span class="hljs-string">L&quot;) ===&quot;</span> &lt;&lt; std::endl;<br>        std::wcout &lt;&lt; <span class="hljs-string">L&quot;总容量: &quot;</span> &lt;&lt; <span class="hljs-built_in">FormatBytes</span>(totalBytes.QuadPart) &lt;&lt; std::endl;<br>        std::wcout &lt;&lt; <span class="hljs-string">L&quot;可用空间: &quot;</span> &lt;&lt; <span class="hljs-built_in">FormatBytes</span>(freeBytesAvailable.QuadPart) &lt;&lt; std::endl;<br>        std::wcout &lt;&lt; <span class="hljs-string">L&quot;实际空闲: &quot;</span> &lt;&lt; <span class="hljs-built_in">FormatBytes</span>(totalFreeBytes.QuadPart) &lt;&lt; std::endl;<br><br>        <span class="hljs-comment">// 计算已用空间百分比</span><br>        <span class="hljs-keyword">if</span> (totalBytes.QuadPart &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">double</span> usedPercent = <span class="hljs-number">100.0</span> - (<span class="hljs-number">100.0</span> * freeBytesAvailable.QuadPart / totalBytes.QuadPart);<br>            std::wcout &lt;&lt; <span class="hljs-string">L&quot;已用空间: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; usedPercent &lt;&lt; <span class="hljs-string">L&quot;%&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::wcerr &lt;&lt; <span class="hljs-string">L&quot;获取磁盘信息失败! 错误代码: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 查询C盘信息</span><br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* cDrive = <span class="hljs-string">L&quot;C:\\&quot;</span>;<br>    <span class="hljs-built_in">PrintDiskSpaceInfo</span>(cDrive);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">=== 磁盘空间信息 (C:\) ===<br>总容量: <span class="hljs-number">148.380192</span> GB<br>可用空间: <span class="hljs-number">2.701382</span> GB<br>实际空闲: <span class="hljs-number">2.701382</span> GB<br>已用空间: <span class="hljs-number">98.18</span>%<br></code></pre></td></tr></table></figure><p>肉眼可见的已经爆红了qwq.</p><h3 id="GetVolumeInformation"><a href="#GetVolumeInformation" class="headerlink" title="GetVolumeInformation"></a>GetVolumeInformation</h3><p>获取<strong>卷的基础信息</strong>, 比如卷名称, 序列号, 最大文件名长, 文件系统等.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GetVolumeInformation</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCTSTR lpRootPathName,          <span class="hljs-comment">// 根路径（如 &quot;C:\\&quot;）</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPTSTR lpVolumeNameBuffer,        <span class="hljs-comment">// 接收卷标名称的缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD nVolumeNameSize,           <span class="hljs-comment">// 卷标缓冲区大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpVolumeSerialNumber,     <span class="hljs-comment">// 接收卷序列号</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpMaximumComponentLength, <span class="hljs-comment">// 最大文件名长度</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPDWORD lpFileSystemFlags,       <span class="hljs-comment">// 文件系统特性标志</span></span></span><br><span class="hljs-params"><span class="hljs-function">  LPTSTR lpFileSystemNameBuffer,   <span class="hljs-comment">// 接收文件系统名称的缓冲区</span></span></span><br><span class="hljs-params"><span class="hljs-function">  DWORD nFileSystemNameSize        <span class="hljs-comment">// 文件系统名称缓冲区大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p>下面检查各种可能的卷, 然后输出对应卷的基础属性 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;locale&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CheckVolumeType</span><span class="hljs-params">(<span class="hljs-type">const</span> wstring&amp; path)</span> </span>&#123;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot;检查卷: &quot;</span> &lt;&lt; path;<br><br>    <span class="hljs-comment">// 1. 先检查是否是有效卷</span><br>    UINT driveType = <span class="hljs-built_in">GetDriveType</span>(path.<span class="hljs-built_in">c_str</span>());<br>    <span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* typeName;<br>    <span class="hljs-keyword">switch</span> (driveType) &#123;<br>    <span class="hljs-keyword">case</span> DRIVE_FIXED:      typeName = <span class="hljs-string">L&quot;本地硬盘&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DRIVE_REMOVABLE: typeName = <span class="hljs-string">L&quot;可移动设备(U盘等)&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DRIVE_CDROM:      typeName = <span class="hljs-string">L&quot;光盘驱动器&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DRIVE_REMOTE:    typeName = <span class="hljs-string">L&quot;网络驱动器&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DRIVE_RAMDISK:   typeName = <span class="hljs-string">L&quot;RAM磁盘&quot;</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:              typeName = <span class="hljs-string">L&quot;未知/无效&quot;</span>; <span class="hljs-keyword">break</span>;<br>    &#125;<br>    wcout &lt;&lt; <span class="hljs-string">L&quot; ← &quot;</span> &lt;&lt; typeName &lt;&lt; endl;<br><br>    <span class="hljs-comment">// 2. 获取卷详细信息</span><br>    WCHAR volName[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    WCHAR fsName[MAX_PATH] = &#123; <span class="hljs-number">0</span> &#125;;<br>    DWORD serial, maxLen, flags;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetVolumeInformation</span>(path.<span class="hljs-built_in">c_str</span>(), volName, MAX_PATH, &amp;serial,<br>        &amp;maxLen, &amp;flags, fsName, MAX_PATH)) &#123;<br>        wcout &lt;&lt; <span class="hljs-string">L&quot;  卷标: &quot;</span> &lt;&lt; volName &lt;&lt; endl;<br>        wcout &lt;&lt; <span class="hljs-string">L&quot;  文件系统: &quot;</span> &lt;&lt; fsName &lt;&lt; endl;<br>        wcout &lt;&lt; <span class="hljs-string">L&quot;  序列号: &quot;</span> &lt;&lt; hex &lt;&lt; serial &lt;&lt; dec &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        wcout &lt;&lt; <span class="hljs-string">L&quot;  无法获取信息 (错误: &quot;</span> &lt;&lt; <span class="hljs-built_in">GetLastError</span>() &lt;&lt; <span class="hljs-string">L&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    wcout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">setlocale</span>(LC_ALL, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">// 测试各种可能的Volume</span><br>    vector&lt;wstring&gt; testPaths = &#123;<br>        <span class="hljs-string">L&quot;C:\\&quot;</span>,    <span class="hljs-comment">// 系统盘</span><br>        <span class="hljs-string">L&quot;D:\\&quot;</span>,    <span class="hljs-comment">// 其他硬盘分区</span><br>        <span class="hljs-string">L&quot;E:\\&quot;</span>,    <span class="hljs-comment">// U盘/移动硬盘</span><br>        <span class="hljs-string">L&quot;F:\\&quot;</span>,    <span class="hljs-comment">// 光盘驱动器</span><br>        <span class="hljs-string">L&quot;Z:\\&quot;</span>,    <span class="hljs-comment">// 网络映射驱动器</span><br>        <span class="hljs-string">L&quot;X:\\&quot;</span>     <span class="hljs-comment">// 可能不存在的驱动器</span><br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; path : testPaths) &#123;<br>        <span class="hljs-built_in">CheckVolumeType</span>(path);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp">检查卷: C:\ ← 本地硬盘<br>  卷标: OS<br>  文件系统: NTFS<br>  序列号: c22b1551<br><br>检查卷: D:\ ← 本地硬盘<br>  卷标:<br>  文件系统: NTFS<br>  序列号: <span class="hljs-number">3</span>a<span class="hljs-number">7e1748</span><br><br>检查卷: E:\ ← 本地硬盘<br>  卷标:<br>  文件系统: NTFS<br>  序列号: <span class="hljs-number">60</span>a00693<br><br>检查卷: F:\ ← 未知/无效<br>  无法获取信息 (错误: <span class="hljs-number">3</span>)<br><br>检查卷: Z:\ ← 未知/无效<br>  无法获取信息 (错误: <span class="hljs-number">3</span>)<br><br>检查卷: X:\ ← 未知/无效<br>  无法获取信息 (错误: <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="系统信息相关"><a href="#系统信息相关" class="headerlink" title="系统信息相关"></a>系统信息相关</h2><h3 id="GetSystemInfo"><a href="#GetSystemInfo" class="headerlink" title="GetSystemInfo"></a>GetSystemInfo</h3><p>获取操作系统硬件相关的信息. 如CPU数, 处理器类型, 内存页大小.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetSystemInfo</span><span class="hljs-params">(LPSYSTEM_INFO lpSystemInfo)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="GlobalMemoryStatusEx"><a href="#GlobalMemoryStatusEx" class="headerlink" title="GlobalMemoryStatusEx"></a>GlobalMemoryStatusEx</h3><p>获取当前内存使用情况, 包括物理内存, 虚拟内存的总量和可用量.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">BOOL <span class="hljs-title">GlobalMemoryStatusEx</span><span class="hljs-params">(LPMEMORYSTATUSEX lpBuffer)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="GetSystemTime"><a href="#GetSystemTime" class="headerlink" title="GetSystemTime"></a>GetSystemTime</h3><p>获取系统当前的UTC(协调世界时, 北京时区需要 + 8时).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">GetSystemTime</span><span class="hljs-params">(LPSYSTEMTIME lpSystemTime)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="GetTickCount"><a href="#GetTickCount" class="headerlink" title="GetTickCount"></a>GetTickCount</h3><p>获取自系统启动以来的毫秒数(32 位整数).</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DWORD <span class="hljs-title">GetTickCount</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintSystemInfo</span><span class="hljs-params">()</span> </span>&#123;<br>    SYSTEM_INFO si;<br>    <span class="hljs-built_in">GetSystemInfo</span>(&amp;si);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;=== 系统信息 ===&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;CPU 核心数: &quot;</span> &lt;&lt; si.dwNumberOfProcessors &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;页面大小: &quot;</span> &lt;&lt; si.dwPageSize &lt;&lt; <span class="hljs-string">&quot; 字节&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;处理器架构: &quot;</span>;<br>    <span class="hljs-keyword">switch</span> (si.wProcessorArchitecture) &#123;<br>    <span class="hljs-keyword">case</span> PROCESSOR_ARCHITECTURE_AMD64: cout &lt;&lt; <span class="hljs-string">&quot;x64 (AMD or Intel)&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PROCESSOR_ARCHITECTURE_INTEL: cout &lt;&lt; <span class="hljs-string">&quot;x86&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> PROCESSOR_ARCHITECTURE_ARM:   cout &lt;&lt; <span class="hljs-string">&quot;ARM&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>: cout &lt;&lt; <span class="hljs-string">&quot;未知&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">break</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintMemoryStatus</span><span class="hljs-params">()</span> </span>&#123;<br>    MEMORYSTATUSEX ms;<br>    ms.dwLength = <span class="hljs-built_in">sizeof</span>(ms);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">GlobalMemoryStatusEx</span>(&amp;ms)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;=== 内存信息 ===&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;物理内存总量: &quot;</span> &lt;&lt; (ms.ullTotalPhys / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)) &lt;&lt; <span class="hljs-string">&quot; MB&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;可用物理内存: &quot;</span> &lt;&lt; (ms.ullAvailPhys / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)) &lt;&lt; <span class="hljs-string">&quot; MB&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;内存使用率: &quot;</span> &lt;&lt; ms.dwMemoryLoad &lt;&lt; <span class="hljs-string">&quot; %&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintSystemTime</span><span class="hljs-params">()</span> </span>&#123;<br>    SYSTEMTIME st;<br>    <span class="hljs-built_in">GetSystemTime</span>(&amp;st);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;=== 系统时间 (UTC) ===&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; st.wYear &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; st.wMonth &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; st.wDay &lt;&lt; <span class="hljs-string">&quot; &quot;</span><br>        &lt;&lt; st.wHour &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; st.wMinute &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; st.wSecond<br>        &lt;&lt; <span class="hljs-string">&quot;.&quot;</span> &lt;&lt; st.wMilliseconds &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintUptime</span><span class="hljs-params">()</span> </span>&#123;<br>    ULONGLONG ms = <span class="hljs-built_in">GetTickCount64</span>();<br>    ULONGLONG sec = ms / <span class="hljs-number">1000</span>;<br>    ULONGLONG min = sec / <span class="hljs-number">60</span>;<br>    ULONGLONG hr = min / <span class="hljs-number">60</span>;<br>    ULONGLONG day = hr / <span class="hljs-number">24</span>;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;=== 系统运行时长 ===&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;已运行: &quot;</span> &lt;&lt; day &lt;&lt; <span class="hljs-string">&quot; 天 &quot;</span><br>        &lt;&lt; (hr % <span class="hljs-number">24</span>) &lt;&lt; <span class="hljs-string">&quot; 小时 &quot;</span><br>        &lt;&lt; (min % <span class="hljs-number">60</span>) &lt;&lt; <span class="hljs-string">&quot; 分钟 &quot;</span><br>        &lt;&lt; (sec % <span class="hljs-number">60</span>) &lt;&lt; <span class="hljs-string">&quot; 秒&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">PrintSystemInfo</span>();<br>    <span class="hljs-built_in">PrintMemoryStatus</span>();<br>    <span class="hljs-built_in">PrintSystemTime</span>();<br>    <span class="hljs-built_in">PrintUptime</span>();<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果 : </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">=== 系统信息 ===<br>CPU 核心数: <span class="hljs-number">20</span><br>页面大小: <span class="hljs-number">4096</span> 字节<br>处理器架构: <span class="hljs-built_in">x64</span> (AMD <span class="hljs-keyword">or</span> Intel)<br><br>=== 内存信息 ===<br>物理内存总量: <span class="hljs-number">16010</span> MB<br>可用物理内存: <span class="hljs-number">3569</span> MB<br>内存使用率: <span class="hljs-number">77</span> %<br><br>=== 系统时间 (UTC) ===<br><span class="hljs-number">2025</span><span class="hljs-number">-9</span><span class="hljs-number">-8</span> <span class="hljs-number">11</span>:<span class="hljs-number">42</span>:<span class="hljs-number">5.720</span><br><br>=== 系统运行时长 ===<br>已运行: <span class="hljs-number">4</span> 天 <span class="hljs-number">5</span> 小时 <span class="hljs-number">16</span> 分钟 <span class="hljs-number">53</span> 秒<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>WindowsAPI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
